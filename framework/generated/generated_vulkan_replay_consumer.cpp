/*
** Copyright (c) 2018-2023 Valve Corporation
** Copyright (c) 2018-2023 LunarG, Inc.
** Copyright (c) 2023 Advanced Micro Devices, Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following conditions:
**
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
** FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
*/

/*
** This file is generated from the Khronos Vulkan XML API Registry.
**
*/

#include "generated/generated_vulkan_replay_consumer.h"

#include "decode/custom_vulkan_struct_handle_mappers.h"
#include "decode/vulkan_handle_mapping_util.h"
#include "generated/generated_vulkan_dispatch_table.h"
#include "generated/generated_vulkan_struct_handle_mappers.h"
#include "generated/generated_vulkan_dr_command_buffer_util.h"
#include "util/defines.h"

GFXRECON_BEGIN_NAMESPACE(gfxrecon)
GFXRECON_BEGIN_NAMESPACE(decode) //@@@HYH

#define TESTCODE 1

template <typename T>
void InitializeOutputStructPNext(StructPointerDecoder<T> *decoder);//@@@EZA

class CmdBuffApiCall //@@@WPK    This could be struct instead and then could omit public: below
{
public:
    gfxrecon::format::ApiCallId apiCall;
    format::ThreadId            thread_id;
    std::vector<uint8_t>        parameter_buffer_data;
    size_t                      parameter_buffer_size;
    ApiDecoder                  *decoder;
};

std::list<CmdBuffApiCall> savedDRCmdBuff; //@@@DSX

// Initialization of these should be done at replay startup during first pass through capture file.
// For now we hard code these for turning on command buffer saving code
uint64_t g_saveCmdBuf_BeginCommandBuffer_Index = 105;   //@@@ Index of vkBeginCommandBuffer command which will trigger saving of command buffer commands
uint64_t g_dumpResourses_CmdDraw_Index = 111;           //@@@ Index of vkCmdDraw which will trigger dump resources
uint64_t g_dumpResourses_QueueSubmit_Index = 154;       //@@@ Index of vkQueueSubmit in which we dump resources

static format::HandleId  g_savingCommandBuffer = 0;                     //@@@ commandBuffer we are current saving

void VulkanReplayConsumer::Process_vkCreateInstance(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    StructPointerDecoder<Decoded_VkInstanceCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkInstance>*           pInstance)
{
    if (!pInstance->IsNull()) { pInstance->SetHandleLength(1); }//@@@HET
    InstanceInfo handle_info;
    pInstance->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateInstance(returnValue, pCreateInfo, pAllocator, pInstance)/*@@@ADH*/;
    CheckResult("vkCreateInstance", returnValue, replay_result, call_info);
    AddHandle<InstanceInfo>(format::kNullHandleId, pInstance->GetPointer(), pInstance->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddInstanceInfo);
}

void VulkanReplayConsumer::Process_vkDestroyInstance(
    const ApiCallInfo&                          call_info,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkInstance in_instance = /*@@@QKJ*/MapHandle<InstanceInfo>(instance, &VulkanObjectInfoTable::GetInstanceInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetInstanceTable(in_instance)->DestroyInstance(in_instance, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(instance, &VulkanObjectInfoTable::RemoveInstanceInfo);
}

void VulkanReplayConsumer::Process_vkEnumeratePhysicalDevices(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    PointerDecoder<uint32_t>*                   pPhysicalDeviceCount,
    HandlePointerDecoder<VkPhysicalDevice>*     pPhysicalDevices)
{
    auto in_instance = GetObjectInfoTable().GetInstanceInfo(instance);
    pPhysicalDeviceCount->IsNull() ? nullptr : pPhysicalDeviceCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, InstanceInfo>("vkEnumeratePhysicalDevices", returnValue, instance, kInstanceArrayEnumeratePhysicalDevices, pPhysicalDeviceCount, pPhysicalDevices, &VulkanObjectInfoTable::GetInstanceInfo));
    if (!pPhysicalDevices->IsNull()) { pPhysicalDevices->SetHandleLength(*pPhysicalDeviceCount->GetOutputPointer()); }//@@@UAZ
    std::vector<PhysicalDeviceInfo> handle_info(*pPhysicalDeviceCount->GetOutputPointer());
    for (size_t i = 0; i < *pPhysicalDeviceCount->GetOutputPointer(); ++i) { pPhysicalDevices->SetConsumerData(i, &handle_info[i]); }//@@@DFK
    VkResult replay_result = OverrideEnumeratePhysicalDevices(GetInstanceTable(in_instance->handle)->EnumeratePhysicalDevices, returnValue, in_instance, pPhysicalDeviceCount, pPhysicalDevices)/*@@@HNM*/;
    CheckResult("vkEnumeratePhysicalDevices", returnValue, replay_result, call_info);
    if (pPhysicalDevices->IsNull()) { SetOutputArrayCount<InstanceInfo>(instance, kInstanceArrayEnumeratePhysicalDevices, *pPhysicalDeviceCount->GetOutputPointer(), &VulkanObjectInfoTable::GetInstanceInfo); }
    AddHandles<PhysicalDeviceInfo>(instance, pPhysicalDevices->GetPointer(), pPhysicalDevices->GetLength(), pPhysicalDevices->GetHandlePointer(), *pPhysicalDeviceCount->GetOutputPointer(), std::move(handle_info), &VulkanObjectInfoTable::AddPhysicalDeviceInfo);//@@@ZZA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceFeatures(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceFeatures>/*@@@PLQ*/* pFeatures)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/VkPhysicalDeviceFeatures* /*@@@USD*/out_pFeatures = pFeatures->IsNull() ? nullptr : pFeatures->AllocateOutputData(1);//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceFeatures(in_physicalDevice, /*@@@USD*/out_pFeatures)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceFormatProperties(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    StructPointerDecoder<Decoded_VkFormatProperties>/*@@@PLQ*/* pFormatProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/VkFormatProperties* /*@@@USD*/out_pFormatProperties = pFormatProperties->IsNull() ? nullptr : pFormatProperties->AllocateOutputData(1);//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceFormatProperties(in_physicalDevice, format, /*@@@USD*/out_pFormatProperties)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceImageFormatProperties(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    StructPointerDecoder<Decoded_VkImageFormatProperties>/*@@@PLQ*/* pImageFormatProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/VkImageFormatProperties* /*@@@USD*/out_pImageFormatProperties = pImageFormatProperties->IsNull() ? nullptr : pImageFormatProperties->AllocateOutputData(1);//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceImageFormatProperties(in_physicalDevice, format, type, tiling, usage, flags, /*@@@USD*/out_pImageFormatProperties)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceImageFormatProperties", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceProperties(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceProperties>/*@@@PLQ*/* pProperties)
{
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);
    pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(1);//@@@DFK
    OverrideGetPhysicalDeviceProperties(GetInstanceTable(in_physicalDevice->handle)->GetPhysicalDeviceProperties, in_physicalDevice, pProperties)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceQueueFamilyProperties(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pQueueFamilyPropertyCount,
    StructPointerDecoder<Decoded_VkQueueFamilyProperties>/*@@@PLQ*/* pQueueFamilyProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pQueueFamilyPropertyCount = pQueueFamilyPropertyCount->IsNull() ? nullptr : pQueueFamilyPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceQueueFamilyProperties", VK_SUCCESS, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceQueueFamilyProperties, pQueueFamilyPropertyCount, pQueueFamilyProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkQueueFamilyProperties* /*@@@USD*/out_pQueueFamilyProperties = pQueueFamilyProperties->IsNull() ? nullptr : pQueueFamilyProperties->AllocateOutputData(*/*@@@USD*/out_pQueueFamilyPropertyCount); /*@@@DRW*///@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceQueueFamilyProperties(in_physicalDevice, /*@@@USD*/out_pQueueFamilyPropertyCount, /*@@@USD*/out_pQueueFamilyProperties)/*@@@ABC*/;//@@@HQA
    if (pQueueFamilyProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceQueueFamilyProperties, */*@@@USD*/out_pQueueFamilyPropertyCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceMemoryProperties(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceMemoryProperties>/*@@@PLQ*/* pMemoryProperties)
{
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);
    pMemoryProperties->IsNull() ? nullptr : pMemoryProperties->AllocateOutputData(1);//@@@DFK
    OverrideGetPhysicalDeviceMemoryProperties(GetInstanceTable(in_physicalDevice->handle)->GetPhysicalDeviceMemoryProperties, in_physicalDevice, pMemoryProperties)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCreateDevice(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkDeviceCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkDevice>*             pDevice)
{
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);

    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    if (!pDevice->IsNull()) { pDevice->SetHandleLength(1); }//@@@HET
    DeviceInfo handle_info;
    pDevice->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateDevice(returnValue, in_physicalDevice, pCreateInfo, pAllocator, pDevice)/*@@@ADH*/;
    CheckResult("vkCreateDevice", returnValue, replay_result, call_info);
    AddHandle<DeviceInfo>(physicalDevice, pDevice->GetPointer(), pDevice->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddDeviceInfo);
}

void VulkanReplayConsumer::Process_vkDestroyDevice(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);//@@@DFK
    OverrideDestroyDevice(GetDeviceTable(in_device->handle)->DestroyDevice, in_device, pAllocator)/*@@@PKQ*/;//@@@HQA
    RemoveHandle(device, &VulkanObjectInfoTable::RemoveDeviceInfo);
}

void VulkanReplayConsumer::Process_vkGetDeviceQueue(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    uint32_t                                    queueFamilyIndex,
    uint32_t                                    queueIndex,
    HandlePointerDecoder<VkQueue>*              pQueue)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    if (!pQueue->IsNull()) { pQueue->SetHandleLength(1); }//@@@HET
    QueueInfo handle_info;
    pQueue->SetConsumerData(0, &handle_info);//@@@DFK
    OverrideGetDeviceQueue(GetDeviceTable(in_device->handle)->GetDeviceQueue, in_device, queueFamilyIndex, queueIndex, pQueue)/*@@@PKQ*/;//@@@HQA
    AddHandle<QueueInfo>(device, pQueue->GetPointer(), pQueue->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddQueueInfo);
}

void VulkanReplayConsumer::Process_vkQueueSubmit(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            queue,
    uint32_t                                    submitCount,
    StructPointerDecoder<Decoded_VkSubmitInfo>/*@@@PLQ*/* pSubmits,
    format::HandleId                            fence)
{
    auto in_queue = GetObjectInfoTable().GetQueueInfo(queue);

    /*@@@HWC*/MapStructArrayHandles(pSubmits->GetMetaStructPointer(), pSubmits->GetLength(), GetObjectInfoTable());
    auto in_fence = GetObjectInfoTable().GetFenceInfo(fence);//@@@DFK
    VkResult replay_result = OverrideQueueSubmit(GetDeviceTable(in_queue->handle)->QueueSubmit, returnValue, in_queue, submitCount, pSubmits, in_fence)/*@@@HNM*/;
    CheckResult("vkQueueSubmit", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkQueueWaitIdle(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            queue)
{
    VkQueue in_queue = /*@@@QKJ*/MapHandle<QueueInfo>(queue, &VulkanObjectInfoTable::GetQueueInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_queue)->QueueWaitIdle(in_queue)/*@@@ABC*/;
    CheckResult("vkQueueWaitIdle", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkDeviceWaitIdle(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->DeviceWaitIdle(in_device)/*@@@ABC*/;
    CheckResult("vkDeviceWaitIdle", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkAllocateMemory(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkMemoryAllocateInfo>/*@@@PLQ*/* pAllocateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkDeviceMemory>*       pMemory)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pAllocateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    if (!pMemory->IsNull()) { pMemory->SetHandleLength(1); }//@@@HET
    DeviceMemoryInfo handle_info;
    pMemory->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideAllocateMemory(GetDeviceTable(in_device->handle)->AllocateMemory, returnValue, in_device, pAllocateInfo, pAllocator, pMemory)/*@@@HNM*/;
    CheckResult("vkAllocateMemory", returnValue, replay_result, call_info);
    AddHandle<DeviceMemoryInfo>(device, pMemory->GetPointer(), pMemory->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddDeviceMemoryInfo);
}

void VulkanReplayConsumer::Process_vkFreeMemory(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            memory,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_memory = GetObjectInfoTable().GetDeviceMemoryInfo(memory);//@@@DFK
    OverrideFreeMemory(GetDeviceTable(in_device->handle)->FreeMemory, in_device, in_memory, pAllocator)/*@@@PKQ*/;//@@@HQA
    RemoveHandle(memory, &VulkanObjectInfoTable::RemoveDeviceMemoryInfo);
}

void VulkanReplayConsumer::Process_vkMapMemory(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            memory,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkMemoryMapFlags                            flags,
    PointerDecoder<uint64_t, void*>*            ppData)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_memory = GetObjectInfoTable().GetDeviceMemoryInfo(memory);
    /*@@@HPA*/void** /*@@@USD*/out_ppData = ppData->IsNull() ? nullptr : ppData->AllocateOutputData(1);//@@@PEA//@@@DFK
    VkResult replay_result = OverrideMapMemory(GetDeviceTable(in_device->handle)->MapMemory, returnValue, in_device, in_memory, offset, size, flags, /*@@@USD*/out_ppData)/*@@@HNM*/;
    CheckResult("vkMapMemory", returnValue, replay_result, call_info);
    PostProcessExternalObject(replay_result, (*ppData->GetPointer()), *ppData->GetOutputPointer(), format::ApiCallId::ApiCall_vkMapMemory, "vkMapMemory");//@@EDS
}

void VulkanReplayConsumer::Process_vkUnmapMemory(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            memory)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_memory = GetObjectInfoTable().GetDeviceMemoryInfo(memory);//@@@DFK
    OverrideUnmapMemory(GetDeviceTable(in_device->handle)->UnmapMemory, in_device, in_memory)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkFlushMappedMemoryRanges(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    memoryRangeCount,
    StructPointerDecoder<Decoded_VkMappedMemoryRange>/*@@@PLQ*/* pMemoryRanges)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    /*@@@HWC*/MapStructArrayHandles(pMemoryRanges->GetMetaStructPointer(), pMemoryRanges->GetLength(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = OverrideFlushMappedMemoryRanges(GetDeviceTable(in_device->handle)->FlushMappedMemoryRanges, returnValue, in_device, memoryRangeCount, pMemoryRanges)/*@@@HNM*/;
    CheckResult("vkFlushMappedMemoryRanges", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkInvalidateMappedMemoryRanges(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    memoryRangeCount,
    StructPointerDecoder<Decoded_VkMappedMemoryRange>/*@@@PLQ*/* pMemoryRanges)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    /*@@@HWC*/MapStructArrayHandles(pMemoryRanges->GetMetaStructPointer(), pMemoryRanges->GetLength(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = OverrideInvalidateMappedMemoryRanges(GetDeviceTable(in_device->handle)->InvalidateMappedMemoryRanges, returnValue, in_device, memoryRangeCount, pMemoryRanges)/*@@@HNM*/;
    CheckResult("vkInvalidateMappedMemoryRanges", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetDeviceMemoryCommitment(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            memory,
    PointerDecoder<VkDeviceSize>*               pCommittedMemoryInBytes)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDeviceMemory in_memory = /*@@@QKJ*/MapHandle<DeviceMemoryInfo>(memory, &VulkanObjectInfoTable::GetDeviceMemoryInfo);
    /*@@@HPA*/VkDeviceSize* /*@@@USD*/out_pCommittedMemoryInBytes = pCommittedMemoryInBytes->IsNull() ? nullptr : pCommittedMemoryInBytes->AllocateOutputData(1, static_cast<VkDeviceSize>(0));//@@@DFK
    GetDeviceTable(in_device)->GetDeviceMemoryCommitment(in_device, in_memory, /*@@@USD*/out_pCommittedMemoryInBytes)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkBindBufferMemory(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            buffer,
    format::HandleId                            memory,
    VkDeviceSize                                memoryOffset)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_buffer = GetObjectInfoTable().GetBufferInfo(buffer);
    auto in_memory = GetObjectInfoTable().GetDeviceMemoryInfo(memory);//@@@DFK
    VkResult replay_result = OverrideBindBufferMemory(GetDeviceTable(in_device->handle)->BindBufferMemory, returnValue, in_device, in_buffer, in_memory, memoryOffset)/*@@@HNM*/;
    CheckResult("vkBindBufferMemory", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkBindImageMemory(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            image,
    format::HandleId                            memory,
    VkDeviceSize                                memoryOffset)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_image = GetObjectInfoTable().GetImageInfo(image);
    auto in_memory = GetObjectInfoTable().GetDeviceMemoryInfo(memory);//@@@DFK
    VkResult replay_result = OverrideBindImageMemory(GetDeviceTable(in_device->handle)->BindImageMemory, returnValue, in_device, in_image, in_memory, memoryOffset)/*@@@HNM*/;
    CheckResult("vkBindImageMemory", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetBufferMemoryRequirements(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            buffer,
    StructPointerDecoder<Decoded_VkMemoryRequirements>/*@@@PLQ*/* pMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);
    /*@@@HPA*/VkMemoryRequirements* /*@@@USD*/out_pMemoryRequirements = pMemoryRequirements->IsNull() ? nullptr : pMemoryRequirements->AllocateOutputData(1);//@@@DFK
    GetDeviceTable(in_device)->GetBufferMemoryRequirements(in_device, in_buffer, /*@@@USD*/out_pMemoryRequirements)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetImageMemoryRequirements(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            image,
    StructPointerDecoder<Decoded_VkMemoryRequirements>/*@@@PLQ*/* pMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkImage in_image = /*@@@QKJ*/MapHandle<ImageInfo>(image, &VulkanObjectInfoTable::GetImageInfo);
    /*@@@HPA*/VkMemoryRequirements* /*@@@USD*/out_pMemoryRequirements = pMemoryRequirements->IsNull() ? nullptr : pMemoryRequirements->AllocateOutputData(1);//@@@DFK
    GetDeviceTable(in_device)->GetImageMemoryRequirements(in_device, in_image, /*@@@USD*/out_pMemoryRequirements)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetImageSparseMemoryRequirements(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            image,
    PointerDecoder<uint32_t>*                   pSparseMemoryRequirementCount,
    StructPointerDecoder<Decoded_VkSparseImageMemoryRequirements>/*@@@PLQ*/* pSparseMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkImage in_image = /*@@@QKJ*/MapHandle<ImageInfo>(image, &VulkanObjectInfoTable::GetImageInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pSparseMemoryRequirementCount = pSparseMemoryRequirementCount->IsNull() ? nullptr : pSparseMemoryRequirementCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, ImageInfo>("vkGetImageSparseMemoryRequirements", VK_SUCCESS, image, kImageArrayGetImageSparseMemoryRequirements, pSparseMemoryRequirementCount, pSparseMemoryRequirements, &VulkanObjectInfoTable::GetImageInfo));
    /*@@@HPA*/VkSparseImageMemoryRequirements* /*@@@USD*/out_pSparseMemoryRequirements = pSparseMemoryRequirements->IsNull() ? nullptr : pSparseMemoryRequirements->AllocateOutputData(*/*@@@USD*/out_pSparseMemoryRequirementCount); /*@@@DRW*///@@@DFK
    GetDeviceTable(in_device)->GetImageSparseMemoryRequirements(in_device, in_image, /*@@@USD*/out_pSparseMemoryRequirementCount, /*@@@USD*/out_pSparseMemoryRequirements)/*@@@ABC*/;//@@@HQA
    if (pSparseMemoryRequirements->IsNull()) { SetOutputArrayCount<ImageInfo>(image, kImageArrayGetImageSparseMemoryRequirements, */*@@@USD*/out_pSparseMemoryRequirementCount, &VulkanObjectInfoTable::GetImageInfo); }
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceSparseImageFormatProperties(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkSampleCountFlagBits                       samples,
    VkImageUsageFlags                           usage,
    VkImageTiling                               tiling,
    PointerDecoder<uint32_t>*                   pPropertyCount,
    StructPointerDecoder<Decoded_VkSparseImageFormatProperties>/*@@@PLQ*/* pProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPropertyCount = pPropertyCount->IsNull() ? nullptr : pPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceSparseImageFormatProperties", VK_SUCCESS, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceSparseImageFormatProperties, pPropertyCount, pProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkSparseImageFormatProperties* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(*/*@@@USD*/out_pPropertyCount); /*@@@DRW*///@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceSparseImageFormatProperties(in_physicalDevice, format, type, samples, usage, tiling, /*@@@USD*/out_pPropertyCount, /*@@@USD*/out_pProperties)/*@@@ABC*/;//@@@HQA
    if (pProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceSparseImageFormatProperties, */*@@@USD*/out_pPropertyCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkQueueBindSparse(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            queue,
    uint32_t                                    bindInfoCount,
    StructPointerDecoder<Decoded_VkBindSparseInfo>/*@@@PLQ*/* pBindInfo,
    format::HandleId                            fence)
{
    auto in_queue = GetObjectInfoTable().GetQueueInfo(queue);

    /*@@@HWC*/MapStructArrayHandles(pBindInfo->GetMetaStructPointer(), pBindInfo->GetLength(), GetObjectInfoTable());
    auto in_fence = GetObjectInfoTable().GetFenceInfo(fence);//@@@DFK
    VkResult replay_result = OverrideQueueBindSparse(GetDeviceTable(in_queue->handle)->QueueBindSparse, returnValue, in_queue, bindInfoCount, pBindInfo, in_fence)/*@@@HNM*/;
    CheckResult("vkQueueBindSparse", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCreateFence(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkFenceCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkFence>*              pFence)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkFenceCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pFence->IsNull()) { pFence->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkFence* /*@@@USD*/out_pFence = pFence->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateFence(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pFence)/*@@@ABC*/;
    CheckResult("vkCreateFence", returnValue, replay_result, call_info);
    AddHandle<FenceInfo>(device, pFence->GetPointer(), /*@@@USD*/out_pFence, &VulkanObjectInfoTable::AddFenceInfo);
}

void VulkanReplayConsumer::Process_vkDestroyFence(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            fence,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkFence in_fence = /*@@@QKJ*/MapHandle<FenceInfo>(fence, &VulkanObjectInfoTable::GetFenceInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyFence(in_device, in_fence, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(fence, &VulkanObjectInfoTable::RemoveFenceInfo);
}

void VulkanReplayConsumer::Process_vkResetFences(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    fenceCount,
    HandlePointerDecoder<VkFence>*              pFences)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkFence* /*@@@AZI*/in_pFences = /*@@@EDO*/MapHandles<FenceInfo>(pFences, fenceCount, &VulkanObjectInfoTable::GetFenceInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->ResetFences(in_device, fenceCount, /*@@@AZI*/in_pFences)/*@@@ABC*/;
    CheckResult("vkResetFences", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetFenceStatus(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            fence)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_fence = GetObjectInfoTable().GetFenceInfo(fence);//@@@DFK
    VkResult replay_result = OverrideGetFenceStatus(GetDeviceTable(in_device->handle)->GetFenceStatus, returnValue, in_device, in_fence)/*@@@HNM*/;
    CheckResult("vkGetFenceStatus", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkWaitForFences(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    fenceCount,
    HandlePointerDecoder<VkFence>*              pFences,
    VkBool32                                    waitAll,
    uint64_t                                    timeout)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    /*@@@EDO*/MapHandles<FenceInfo>(pFences, fenceCount, &VulkanObjectInfoTable::GetFenceInfo);//@@@DFK
    VkResult replay_result = OverrideWaitForFences(GetDeviceTable(in_device->handle)->WaitForFences, returnValue, in_device, fenceCount, pFences, waitAll, timeout)/*@@@HNM*/;
    CheckResult("vkWaitForFences", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCreateSemaphore(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkSemaphoreCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSemaphore>*          pSemaphore)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkSemaphoreCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pSemaphore->IsNull()) { pSemaphore->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkSemaphore* /*@@@USD*/out_pSemaphore = pSemaphore->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateSemaphore(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pSemaphore)/*@@@ABC*/;
    CheckResult("vkCreateSemaphore", returnValue, replay_result, call_info);
    AddHandle<SemaphoreInfo>(device, pSemaphore->GetPointer(), /*@@@USD*/out_pSemaphore, &VulkanObjectInfoTable::AddSemaphoreInfo);
}

void VulkanReplayConsumer::Process_vkDestroySemaphore(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            semaphore,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSemaphore in_semaphore = /*@@@QKJ*/MapHandle<SemaphoreInfo>(semaphore, &VulkanObjectInfoTable::GetSemaphoreInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroySemaphore(in_device, in_semaphore, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(semaphore, &VulkanObjectInfoTable::RemoveSemaphoreInfo);
}

void VulkanReplayConsumer::Process_vkCreateEvent(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkEventCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkEvent>*              pEvent)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkEventCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pEvent->IsNull()) { pEvent->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkEvent* /*@@@USD*/out_pEvent = pEvent->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateEvent(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pEvent)/*@@@ABC*/;
    CheckResult("vkCreateEvent", returnValue, replay_result, call_info);
    AddHandle<EventInfo>(device, pEvent->GetPointer(), /*@@@USD*/out_pEvent, &VulkanObjectInfoTable::AddEventInfo);
}

void VulkanReplayConsumer::Process_vkDestroyEvent(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            event,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkEvent in_event = /*@@@QKJ*/MapHandle<EventInfo>(event, &VulkanObjectInfoTable::GetEventInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyEvent(in_device, in_event, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(event, &VulkanObjectInfoTable::RemoveEventInfo);
}

void VulkanReplayConsumer::Process_vkGetEventStatus(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            event)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_event = GetObjectInfoTable().GetEventInfo(event);//@@@DFK
    VkResult replay_result = OverrideGetEventStatus(GetDeviceTable(in_device->handle)->GetEventStatus, returnValue, in_device, in_event)/*@@@HNM*/;
    CheckResult("vkGetEventStatus", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkSetEvent(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            event)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkEvent in_event = /*@@@QKJ*/MapHandle<EventInfo>(event, &VulkanObjectInfoTable::GetEventInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->SetEvent(in_device, in_event)/*@@@ABC*/;
    CheckResult("vkSetEvent", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkResetEvent(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            event)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkEvent in_event = /*@@@QKJ*/MapHandle<EventInfo>(event, &VulkanObjectInfoTable::GetEventInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->ResetEvent(in_device, in_event)/*@@@ABC*/;
    CheckResult("vkResetEvent", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCreateQueryPool(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkQueryPoolCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkQueryPool>*          pQueryPool)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkQueryPoolCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pQueryPool->IsNull()) { pQueryPool->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkQueryPool* /*@@@USD*/out_pQueryPool = pQueryPool->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateQueryPool(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pQueryPool)/*@@@ABC*/;
    CheckResult("vkCreateQueryPool", returnValue, replay_result, call_info);
    AddHandle<QueryPoolInfo>(device, pQueryPool->GetPointer(), /*@@@USD*/out_pQueryPool, &VulkanObjectInfoTable::AddQueryPoolInfo);
}

void VulkanReplayConsumer::Process_vkDestroyQueryPool(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            queryPool,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyQueryPool(in_device, in_queryPool, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(queryPool, &VulkanObjectInfoTable::RemoveQueryPoolInfo);
}

void VulkanReplayConsumer::Process_vkGetQueryPoolResults(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    size_t                                      dataSize,
    PointerDecoder<uint8_t>*                    pData,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_queryPool = GetObjectInfoTable().GetQueryPoolInfo(queryPool);
    if (!pData->IsNull()) { pData->AllocateOutputData(dataSize); }//@@@ENH//@@@DFK
    VkResult replay_result = OverrideGetQueryPoolResults(GetDeviceTable(in_device->handle)->GetQueryPoolResults, returnValue, in_device, in_queryPool, firstQuery, queryCount, dataSize, pData, stride, flags)/*@@@HNM*/;
    CheckResult("vkGetQueryPoolResults", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCreateBuffer(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkBufferCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkBuffer>*             pBuffer)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    if (!pBuffer->IsNull()) { pBuffer->SetHandleLength(1); }//@@@HET
    BufferInfo handle_info;
    pBuffer->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateBuffer(GetDeviceTable(in_device->handle)->CreateBuffer, returnValue, in_device, pCreateInfo, pAllocator, pBuffer)/*@@@HNM*/;
    CheckResult("vkCreateBuffer", returnValue, replay_result, call_info);
    AddHandle<BufferInfo>(device, pBuffer->GetPointer(), pBuffer->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddBufferInfo);
}

void VulkanReplayConsumer::Process_vkDestroyBuffer(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            buffer,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_buffer = GetObjectInfoTable().GetBufferInfo(buffer);//@@@DFK
    OverrideDestroyBuffer(GetDeviceTable(in_device->handle)->DestroyBuffer, in_device, in_buffer, pAllocator)/*@@@PKQ*/;//@@@HQA
    RemoveHandle(buffer, &VulkanObjectInfoTable::RemoveBufferInfo);
}

void VulkanReplayConsumer::Process_vkCreateBufferView(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkBufferViewCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkBufferView>*         pView)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkBufferViewCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pView->IsNull()) { pView->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkBufferView* /*@@@USD*/out_pView = pView->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateBufferView(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pView)/*@@@ABC*/;
    CheckResult("vkCreateBufferView", returnValue, replay_result, call_info);
    AddHandle<BufferViewInfo>(device, pView->GetPointer(), /*@@@USD*/out_pView, &VulkanObjectInfoTable::AddBufferViewInfo);
}

void VulkanReplayConsumer::Process_vkDestroyBufferView(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            bufferView,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkBufferView in_bufferView = /*@@@QKJ*/MapHandle<BufferViewInfo>(bufferView, &VulkanObjectInfoTable::GetBufferViewInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyBufferView(in_device, in_bufferView, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(bufferView, &VulkanObjectInfoTable::RemoveBufferViewInfo);
}

void VulkanReplayConsumer::Process_vkCreateImage(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkImageCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkImage>*              pImage)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    if (!pImage->IsNull()) { pImage->SetHandleLength(1); }//@@@HET
    ImageInfo handle_info;
    pImage->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateImage(GetDeviceTable(in_device->handle)->CreateImage, returnValue, in_device, pCreateInfo, pAllocator, pImage)/*@@@HNM*/;
    CheckResult("vkCreateImage", returnValue, replay_result, call_info);
    AddHandle<ImageInfo>(device, pImage->GetPointer(), pImage->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddImageInfo);
}

void VulkanReplayConsumer::Process_vkDestroyImage(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            image,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_image = GetObjectInfoTable().GetImageInfo(image);//@@@DFK
    OverrideDestroyImage(GetDeviceTable(in_device->handle)->DestroyImage, in_device, in_image, pAllocator)/*@@@PKQ*/;//@@@HQA
    RemoveHandle(image, &VulkanObjectInfoTable::RemoveImageInfo);
}

void VulkanReplayConsumer::Process_vkGetImageSubresourceLayout(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            image,
    StructPointerDecoder<Decoded_VkImageSubresource>/*@@@PLQ*/* pSubresource,
    StructPointerDecoder<Decoded_VkSubresourceLayout>/*@@@PLQ*/* pLayout)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_image = GetObjectInfoTable().GetImageInfo(image);
    pLayout->IsNull() ? nullptr : pLayout->AllocateOutputData(1);//@@@DFK
    OverrideGetImageSubresourceLayout(GetDeviceTable(in_device->handle)->GetImageSubresourceLayout, in_device, in_image, pSubresource, pLayout)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCreateImageView(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkImageViewCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkImageView>*          pView)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    if (!pView->IsNull()) { pView->SetHandleLength(1); }//@@@HET
    ImageViewInfo handle_info;
    pView->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateImageView(GetDeviceTable(in_device->handle)->CreateImageView, returnValue, in_device, pCreateInfo, pAllocator, pView)/*@@@HNM*/;
    CheckResult("vkCreateImageView", returnValue, replay_result, call_info);
    AddHandle<ImageViewInfo>(device, pView->GetPointer(), pView->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddImageViewInfo);
}

void VulkanReplayConsumer::Process_vkDestroyImageView(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            imageView,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkImageView in_imageView = /*@@@QKJ*/MapHandle<ImageViewInfo>(imageView, &VulkanObjectInfoTable::GetImageViewInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyImageView(in_device, in_imageView, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(imageView, &VulkanObjectInfoTable::RemoveImageViewInfo);
}

void VulkanReplayConsumer::Process_vkCreateShaderModule(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkShaderModuleCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkShaderModule>*       pShaderModule)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    if (!pShaderModule->IsNull()) { pShaderModule->SetHandleLength(1); }//@@@HET
    ShaderModuleInfo handle_info;
    pShaderModule->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateShaderModule(GetDeviceTable(in_device->handle)->CreateShaderModule, returnValue, in_device, pCreateInfo, pAllocator, pShaderModule)/*@@@HNM*/;
    CheckResult("vkCreateShaderModule", returnValue, replay_result, call_info);
    AddHandle<ShaderModuleInfo>(device, pShaderModule->GetPointer(), pShaderModule->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddShaderModuleInfo);
}

void VulkanReplayConsumer::Process_vkDestroyShaderModule(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            shaderModule,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkShaderModule in_shaderModule = /*@@@QKJ*/MapHandle<ShaderModuleInfo>(shaderModule, &VulkanObjectInfoTable::GetShaderModuleInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyShaderModule(in_device, in_shaderModule, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(shaderModule, &VulkanObjectInfoTable::RemoveShaderModuleInfo);
}

void VulkanReplayConsumer::Process_vkCreatePipelineCache(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkPipelineCacheCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkPipelineCache>*      pPipelineCache)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    if (!pPipelineCache->IsNull()) { pPipelineCache->SetHandleLength(1); }//@@@HET
    PipelineCacheInfo handle_info;
    pPipelineCache->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreatePipelineCache(GetDeviceTable(in_device->handle)->CreatePipelineCache, returnValue, in_device, pCreateInfo, pAllocator, pPipelineCache)/*@@@HNM*/;
    CheckResult("vkCreatePipelineCache", returnValue, replay_result, call_info);
    AddHandle<PipelineCacheInfo>(device, pPipelineCache->GetPointer(), pPipelineCache->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddPipelineCacheInfo);
}

void VulkanReplayConsumer::Process_vkDestroyPipelineCache(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPipelineCache in_pipelineCache = /*@@@QKJ*/MapHandle<PipelineCacheInfo>(pipelineCache, &VulkanObjectInfoTable::GetPipelineCacheInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyPipelineCache(in_device, in_pipelineCache, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(pipelineCache, &VulkanObjectInfoTable::RemovePipelineCacheInfo);
}

void VulkanReplayConsumer::Process_vkGetPipelineCacheData(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    PointerDecoder<size_t>*                     pDataSize,
    PointerDecoder<uint8_t>*                    pData)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_pipelineCache = GetObjectInfoTable().GetPipelineCacheInfo(pipelineCache);
    pDataSize->IsNull() ? nullptr : pDataSize->AllocateOutputData(1, GetOutputArrayCount<size_t, PipelineCacheInfo>("vkGetPipelineCacheData", returnValue, pipelineCache, kPipelineCacheArrayGetPipelineCacheData, pDataSize, pData, &VulkanObjectInfoTable::GetPipelineCacheInfo));
    if (!pData->IsNull()) { pData->AllocateOutputData(*pDataSize->GetOutputPointer()); }//@@@ENH//@@@DFK
    VkResult replay_result = OverrideGetPipelineCacheData(GetDeviceTable(in_device->handle)->GetPipelineCacheData, returnValue, in_device, in_pipelineCache, pDataSize, pData)/*@@@HNM*/;
    CheckResult("vkGetPipelineCacheData", returnValue, replay_result, call_info);
    if (pData->IsNull()) { SetOutputArrayCount<PipelineCacheInfo>(pipelineCache, kPipelineCacheArrayGetPipelineCacheData, *pDataSize->GetOutputPointer(), &VulkanObjectInfoTable::GetPipelineCacheInfo); }
}

void VulkanReplayConsumer::Process_vkMergePipelineCaches(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            dstCache,
    uint32_t                                    srcCacheCount,
    HandlePointerDecoder<VkPipelineCache>*      pSrcCaches)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPipelineCache in_dstCache = /*@@@QKJ*/MapHandle<PipelineCacheInfo>(dstCache, &VulkanObjectInfoTable::GetPipelineCacheInfo);
    /*@@@HPA*/const VkPipelineCache* /*@@@AZI*/in_pSrcCaches = /*@@@EDO*/MapHandles<PipelineCacheInfo>(pSrcCaches, srcCacheCount, &VulkanObjectInfoTable::GetPipelineCacheInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->MergePipelineCaches(in_device, in_dstCache, srcCacheCount, /*@@@AZI*/in_pSrcCaches)/*@@@ABC*/;
    CheckResult("vkMergePipelineCaches", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCreateGraphicsPipelines(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    uint32_t                                    createInfoCount,
    StructPointerDecoder<Decoded_VkGraphicsPipelineCreateInfo>/*@@@PLQ*/* pCreateInfos,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkPipeline>*           pPipelines)
{/*@@@GBN*/
//@@@START
    VkDevice in_device = MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPipelineCache in_pipelineCache = MapHandle<PipelineCacheInfo>(pipelineCache, &VulkanObjectInfoTable::GetPipelineCacheInfo);
    const VkGraphicsPipelineCreateInfo* in_pCreateInfos = pCreateInfos->GetPointer();
    MapStructArrayHandles(pCreateInfos->GetMetaStructPointer(), pCreateInfos->GetLength(), GetObjectInfoTable());
    const VkAllocationCallbacks* in_pAllocator = GetAllocationCallbacks(pAllocator);
    if (!pPipelines->IsNull()) { pPipelines->SetHandleLength(createInfoCount); }
    if (omitted_pipeline_cache_data_) {AllowCompileDuringPipelineCreation(createInfoCount, in_pCreateInfos);}
    VkPipeline* out_pPipelines = pPipelines->GetHandlePointer();
    VkResult replay_result = GetDeviceTable(in_device)->CreateGraphicsPipelines(in_device, in_pipelineCache, createInfoCount, in_pCreateInfos, in_pAllocator, out_pPipelines);
    CheckResult("vkCreateGraphicsPipelines", returnValue, replay_result, call_info);
    AddHandles<PipelineInfo>(device, pPipelines->GetPointer(), pPipelines->GetLength(), out_pPipelines, createInfoCount, &VulkanObjectInfoTable::AddPipelineInfo);
}

void VulkanReplayConsumer::Process_vkCreateComputePipelines(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    uint32_t                                    createInfoCount,
    StructPointerDecoder<Decoded_VkComputePipelineCreateInfo>/*@@@PLQ*/* pCreateInfos,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkPipeline>*           pPipelines)
{/*@@@GBN*/
//@@@START
    VkDevice in_device = MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPipelineCache in_pipelineCache = MapHandle<PipelineCacheInfo>(pipelineCache, &VulkanObjectInfoTable::GetPipelineCacheInfo);
    const VkComputePipelineCreateInfo* in_pCreateInfos = pCreateInfos->GetPointer();
    MapStructArrayHandles(pCreateInfos->GetMetaStructPointer(), pCreateInfos->GetLength(), GetObjectInfoTable());
    const VkAllocationCallbacks* in_pAllocator = GetAllocationCallbacks(pAllocator);
    if (!pPipelines->IsNull()) { pPipelines->SetHandleLength(createInfoCount); }
    if (omitted_pipeline_cache_data_) {AllowCompileDuringPipelineCreation(createInfoCount, in_pCreateInfos);}
    VkPipeline* out_pPipelines = pPipelines->GetHandlePointer();
    VkResult replay_result = GetDeviceTable(in_device)->CreateComputePipelines(in_device, in_pipelineCache, createInfoCount, in_pCreateInfos, in_pAllocator, out_pPipelines);
    CheckResult("vkCreateComputePipelines", returnValue, replay_result, call_info);
    AddHandles<PipelineInfo>(device, pPipelines->GetPointer(), pPipelines->GetLength(), out_pPipelines, createInfoCount, &VulkanObjectInfoTable::AddPipelineInfo);
}

void VulkanReplayConsumer::Process_vkDestroyPipeline(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPipeline in_pipeline = /*@@@QKJ*/MapHandle<PipelineInfo>(pipeline, &VulkanObjectInfoTable::GetPipelineInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyPipeline(in_device, in_pipeline, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(pipeline, &VulkanObjectInfoTable::RemovePipelineInfo);
}

void VulkanReplayConsumer::Process_vkCreatePipelineLayout(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkPipelineLayoutCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkPipelineLayout>*     pPipelineLayout)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkPipelineLayoutCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pPipelineLayout->IsNull()) { pPipelineLayout->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkPipelineLayout* /*@@@USD*/out_pPipelineLayout = pPipelineLayout->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreatePipelineLayout(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pPipelineLayout)/*@@@ABC*/;
    CheckResult("vkCreatePipelineLayout", returnValue, replay_result, call_info);
    AddHandle<PipelineLayoutInfo>(device, pPipelineLayout->GetPointer(), /*@@@USD*/out_pPipelineLayout, &VulkanObjectInfoTable::AddPipelineLayoutInfo);
}

void VulkanReplayConsumer::Process_vkDestroyPipelineLayout(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            pipelineLayout,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPipelineLayout in_pipelineLayout = /*@@@QKJ*/MapHandle<PipelineLayoutInfo>(pipelineLayout, &VulkanObjectInfoTable::GetPipelineLayoutInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyPipelineLayout(in_device, in_pipelineLayout, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(pipelineLayout, &VulkanObjectInfoTable::RemovePipelineLayoutInfo);
}

void VulkanReplayConsumer::Process_vkCreateSampler(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkSamplerCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSampler>*            pSampler)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkSamplerCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pSampler->IsNull()) { pSampler->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkSampler* /*@@@USD*/out_pSampler = pSampler->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateSampler(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pSampler)/*@@@ABC*/;
    CheckResult("vkCreateSampler", returnValue, replay_result, call_info);
    AddHandle<SamplerInfo>(device, pSampler->GetPointer(), /*@@@USD*/out_pSampler, &VulkanObjectInfoTable::AddSamplerInfo);
}

void VulkanReplayConsumer::Process_vkDestroySampler(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            sampler,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSampler in_sampler = /*@@@QKJ*/MapHandle<SamplerInfo>(sampler, &VulkanObjectInfoTable::GetSamplerInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroySampler(in_device, in_sampler, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(sampler, &VulkanObjectInfoTable::RemoveSamplerInfo);
}

void VulkanReplayConsumer::Process_vkCreateDescriptorSetLayout(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDescriptorSetLayoutCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkDescriptorSetLayout>* pSetLayout)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDescriptorSetLayoutCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pSetLayout->IsNull()) { pSetLayout->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkDescriptorSetLayout* /*@@@USD*/out_pSetLayout = pSetLayout->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateDescriptorSetLayout(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pSetLayout)/*@@@ABC*/;
    CheckResult("vkCreateDescriptorSetLayout", returnValue, replay_result, call_info);
    AddHandle<DescriptorSetLayoutInfo>(device, pSetLayout->GetPointer(), /*@@@USD*/out_pSetLayout, &VulkanObjectInfoTable::AddDescriptorSetLayoutInfo);
}

void VulkanReplayConsumer::Process_vkDestroyDescriptorSetLayout(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            descriptorSetLayout,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDescriptorSetLayout in_descriptorSetLayout = /*@@@QKJ*/MapHandle<DescriptorSetLayoutInfo>(descriptorSetLayout, &VulkanObjectInfoTable::GetDescriptorSetLayoutInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyDescriptorSetLayout(in_device, in_descriptorSetLayout, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(descriptorSetLayout, &VulkanObjectInfoTable::RemoveDescriptorSetLayoutInfo);
}

void VulkanReplayConsumer::Process_vkCreateDescriptorPool(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDescriptorPoolCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkDescriptorPool>*     pDescriptorPool)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    if (!pDescriptorPool->IsNull()) { pDescriptorPool->SetHandleLength(1); }//@@@HET
    DescriptorPoolInfo handle_info;
    pDescriptorPool->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateDescriptorPool(GetDeviceTable(in_device->handle)->CreateDescriptorPool, returnValue, in_device, pCreateInfo, pAllocator, pDescriptorPool)/*@@@HNM*/;
    CheckResult("vkCreateDescriptorPool", returnValue, replay_result, call_info);
    AddHandle<DescriptorPoolInfo>(device, pDescriptorPool->GetPointer(), pDescriptorPool->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddDescriptorPoolInfo);
}

void VulkanReplayConsumer::Process_vkDestroyDescriptorPool(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            descriptorPool,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_descriptorPool = GetObjectInfoTable().GetDescriptorPoolInfo(descriptorPool);//@@@DFK
    OverrideDestroyDescriptorPool(GetDeviceTable(in_device->handle)->DestroyDescriptorPool, in_device, in_descriptorPool, pAllocator)/*@@@PKQ*/;//@@@HQA
    RemovePoolHandle<DescriptorPoolInfo>(descriptorPool, &VulkanObjectInfoTable::GetDescriptorPoolInfo, &VulkanObjectInfoTable::RemoveDescriptorPoolInfo, &VulkanObjectInfoTable::RemoveDescriptorSetInfo);
}

void VulkanReplayConsumer::Process_vkResetDescriptorPool(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            descriptorPool,
    VkDescriptorPoolResetFlags                  flags)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_descriptorPool = GetObjectInfoTable().GetDescriptorPoolInfo(descriptorPool);//@@@DFK
    VkResult replay_result = OverrideResetDescriptorPool(GetDeviceTable(in_device->handle)->ResetDescriptorPool, returnValue, in_device, in_descriptorPool, flags)/*@@@HNM*/;
    CheckResult("vkResetDescriptorPool", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkAllocateDescriptorSets(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDescriptorSetAllocateInfo>/*@@@PLQ*/* pAllocateInfo,
    HandlePointerDecoder<VkDescriptorSet>*      pDescriptorSets)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pAllocateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    if (!pDescriptorSets->IsNull()) { pDescriptorSets->SetHandleLength(pAllocateInfo->GetPointer()->descriptorSetCount); }//@@@UAZ
    std::vector<DescriptorSetInfo> handle_info(pAllocateInfo->GetPointer()->descriptorSetCount);
    for (size_t i = 0; i < pAllocateInfo->GetPointer()->descriptorSetCount; ++i) { pDescriptorSets->SetConsumerData(i, &handle_info[i]); }//@@@DFK
    VkResult replay_result = OverrideAllocateDescriptorSets(GetDeviceTable(in_device->handle)->AllocateDescriptorSets, returnValue, in_device, pAllocateInfo, pDescriptorSets)/*@@@HNM*/;
    CheckResult("vkAllocateDescriptorSets", returnValue, replay_result, call_info);
    AddPoolHandles<DescriptorPoolInfo, DescriptorSetInfo>(device, handle_mapping::GetPoolId(pAllocateInfo->GetMetaStructPointer()), pDescriptorSets->GetPointer(), pDescriptorSets->GetLength(), pDescriptorSets->GetHandlePointer(), pAllocateInfo->GetPointer()->descriptorSetCount, std::move(handle_info), &VulkanObjectInfoTable::GetDescriptorPoolInfo, &VulkanObjectInfoTable::AddDescriptorSetInfo);//@@@JKU
}

void VulkanReplayConsumer::Process_vkFreeDescriptorSets(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            descriptorPool,
    uint32_t                                    descriptorSetCount,
    HandlePointerDecoder<VkDescriptorSet>*      pDescriptorSets)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDescriptorPool in_descriptorPool = /*@@@QKJ*/MapHandle<DescriptorPoolInfo>(descriptorPool, &VulkanObjectInfoTable::GetDescriptorPoolInfo);
    /*@@@HPA*/const VkDescriptorSet* /*@@@AZI*/in_pDescriptorSets = /*@@@EDO*/MapHandles<DescriptorSetInfo>(pDescriptorSets, descriptorSetCount, &VulkanObjectInfoTable::GetDescriptorSetInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->FreeDescriptorSets(in_device, in_descriptorPool, descriptorSetCount, /*@@@AZI*/in_pDescriptorSets)/*@@@ABC*/;
    CheckResult("vkFreeDescriptorSets", returnValue, replay_result, call_info);
    RemovePoolHandles<DescriptorPoolInfo, DescriptorSetInfo>(descriptorPool, pDescriptorSets, descriptorSetCount, &VulkanObjectInfoTable::GetDescriptorPoolInfo, &VulkanObjectInfoTable::RemoveDescriptorSetInfo);
}

void VulkanReplayConsumer::Process_vkUpdateDescriptorSets(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    uint32_t                                    descriptorWriteCount,
    StructPointerDecoder<Decoded_VkWriteDescriptorSet>/*@@@PLQ*/* pDescriptorWrites,
    uint32_t                                    descriptorCopyCount,
    StructPointerDecoder<Decoded_VkCopyDescriptorSet>/*@@@PLQ*/* pDescriptorCopies)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkWriteDescriptorSet* /*@@@AZI*/in_pDescriptorWrites = /*@@@HUY*/pDescriptorWrites->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pDescriptorWrites->GetMetaStructPointer(), pDescriptorWrites->GetLength(), GetObjectInfoTable());
    /*@@@HPA*/const VkCopyDescriptorSet* /*@@@AZI*/in_pDescriptorCopies = /*@@@HUY*/pDescriptorCopies->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pDescriptorCopies->GetMetaStructPointer(), pDescriptorCopies->GetLength(), GetObjectInfoTable());//@@@DFK
    GetDeviceTable(in_device)->UpdateDescriptorSets(in_device, descriptorWriteCount, /*@@@AZI*/in_pDescriptorWrites, descriptorCopyCount, /*@@@AZI*/in_pDescriptorCopies)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCreateFramebuffer(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkFramebufferCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkFramebuffer>*        pFramebuffer)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    if (!pFramebuffer->IsNull()) { pFramebuffer->SetHandleLength(1); }//@@@HET
    FramebufferInfo handle_info;
    pFramebuffer->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateFramebuffer(GetDeviceTable(in_device->handle)->CreateFramebuffer, returnValue, in_device, pCreateInfo, pAllocator, pFramebuffer)/*@@@HNM*/;
    CheckResult("vkCreateFramebuffer", returnValue, replay_result, call_info);
    AddHandle<FramebufferInfo>(device, pFramebuffer->GetPointer(), pFramebuffer->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddFramebufferInfo);
}

void VulkanReplayConsumer::Process_vkDestroyFramebuffer(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            framebuffer,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkFramebuffer in_framebuffer = /*@@@QKJ*/MapHandle<FramebufferInfo>(framebuffer, &VulkanObjectInfoTable::GetFramebufferInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyFramebuffer(in_device, in_framebuffer, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(framebuffer, &VulkanObjectInfoTable::RemoveFramebufferInfo);
}

void VulkanReplayConsumer::Process_vkCreateRenderPass(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkRenderPassCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkRenderPass>*         pRenderPass)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    if (!pRenderPass->IsNull()) { pRenderPass->SetHandleLength(1); }//@@@HET
    RenderPassInfo handle_info;
    pRenderPass->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateRenderPass(GetDeviceTable(in_device->handle)->CreateRenderPass, returnValue, in_device, pCreateInfo, pAllocator, pRenderPass)/*@@@HNM*/;
    CheckResult("vkCreateRenderPass", returnValue, replay_result, call_info);
    AddHandle<RenderPassInfo>(device, pRenderPass->GetPointer(), pRenderPass->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddRenderPassInfo);
}

void VulkanReplayConsumer::Process_vkDestroyRenderPass(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            renderPass,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkRenderPass in_renderPass = /*@@@QKJ*/MapHandle<RenderPassInfo>(renderPass, &VulkanObjectInfoTable::GetRenderPassInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyRenderPass(in_device, in_renderPass, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(renderPass, &VulkanObjectInfoTable::RemoveRenderPassInfo);
}

void VulkanReplayConsumer::Process_vkGetRenderAreaGranularity(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            renderPass,
    StructPointerDecoder<Decoded_VkExtent2D>/*@@@PLQ*/* pGranularity)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkRenderPass in_renderPass = /*@@@QKJ*/MapHandle<RenderPassInfo>(renderPass, &VulkanObjectInfoTable::GetRenderPassInfo);
    /*@@@HPA*/VkExtent2D* /*@@@USD*/out_pGranularity = pGranularity->IsNull() ? nullptr : pGranularity->AllocateOutputData(1);//@@@DFK
    GetDeviceTable(in_device)->GetRenderAreaGranularity(in_device, in_renderPass, /*@@@USD*/out_pGranularity)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCreateCommandPool(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkCommandPoolCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkCommandPool>*        pCommandPool)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkCommandPoolCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pCommandPool->IsNull()) { pCommandPool->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkCommandPool* /*@@@USD*/out_pCommandPool = pCommandPool->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateCommandPool(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pCommandPool)/*@@@ABC*/;
    CheckResult("vkCreateCommandPool", returnValue, replay_result, call_info);
    AddHandle<CommandPoolInfo>(device, pCommandPool->GetPointer(), /*@@@USD*/out_pCommandPool, &VulkanObjectInfoTable::AddCommandPoolInfo);
}

void VulkanReplayConsumer::Process_vkDestroyCommandPool(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            commandPool,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkCommandPool in_commandPool = /*@@@QKJ*/MapHandle<CommandPoolInfo>(commandPool, &VulkanObjectInfoTable::GetCommandPoolInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyCommandPool(in_device, in_commandPool, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemovePoolHandle<CommandPoolInfo>(commandPool, &VulkanObjectInfoTable::GetCommandPoolInfo, &VulkanObjectInfoTable::RemoveCommandPoolInfo, &VulkanObjectInfoTable::RemoveCommandBufferInfo);
}

void VulkanReplayConsumer::Process_vkResetCommandPool(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            commandPool,
    VkCommandPoolResetFlags                     flags)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkCommandPool in_commandPool = /*@@@QKJ*/MapHandle<CommandPoolInfo>(commandPool, &VulkanObjectInfoTable::GetCommandPoolInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->ResetCommandPool(in_device, in_commandPool, flags)/*@@@ABC*/;
    CheckResult("vkResetCommandPool", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkAllocateCommandBuffers(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkCommandBufferAllocateInfo>/*@@@PLQ*/* pAllocateInfo,
    HandlePointerDecoder<VkCommandBuffer>*      pCommandBuffers)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pAllocateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    if (!pCommandBuffers->IsNull()) { pCommandBuffers->SetHandleLength(pAllocateInfo->GetPointer()->commandBufferCount); }//@@@UAZ
    std::vector<CommandBufferInfo> handle_info(pAllocateInfo->GetPointer()->commandBufferCount);
    for (size_t i = 0; i < pAllocateInfo->GetPointer()->commandBufferCount; ++i) { pCommandBuffers->SetConsumerData(i, &handle_info[i]); }//@@@DFK
    VkResult replay_result = OverrideAllocateCommandBuffers(GetDeviceTable(in_device->handle)->AllocateCommandBuffers, returnValue, in_device, pAllocateInfo, pCommandBuffers)/*@@@HNM*/;
    CheckResult("vkAllocateCommandBuffers", returnValue, replay_result, call_info);
    AddPoolHandles<CommandPoolInfo, CommandBufferInfo>(device, handle_mapping::GetPoolId(pAllocateInfo->GetMetaStructPointer()), pCommandBuffers->GetPointer(), pCommandBuffers->GetLength(), pCommandBuffers->GetHandlePointer(), pAllocateInfo->GetPointer()->commandBufferCount, std::move(handle_info), &VulkanObjectInfoTable::GetCommandPoolInfo, &VulkanObjectInfoTable::AddCommandBufferInfo);//@@@JKU
}

void VulkanReplayConsumer::Process_vkFreeCommandBuffers(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            commandPool,
    uint32_t                                    commandBufferCount,
    HandlePointerDecoder<VkCommandBuffer>*      pCommandBuffers)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkCommandPool in_commandPool = /*@@@QKJ*/MapHandle<CommandPoolInfo>(commandPool, &VulkanObjectInfoTable::GetCommandPoolInfo);
    /*@@@HPA*/const VkCommandBuffer* /*@@@AZI*/in_pCommandBuffers = /*@@@EDO*/MapHandles<CommandBufferInfo>(pCommandBuffers, commandBufferCount, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
    GetDeviceTable(in_device)->FreeCommandBuffers(in_device, in_commandPool, commandBufferCount, /*@@@AZI*/in_pCommandBuffers)/*@@@ABC*/;//@@@HQA
    RemovePoolHandles<CommandPoolInfo, CommandBufferInfo>(commandPool, pCommandBuffers, commandBufferCount, &VulkanObjectInfoTable::GetCommandPoolInfo, &VulkanObjectInfoTable::RemoveCommandBufferInfo);
}

void VulkanReplayConsumer::Process_vkBeginCommandBuffer(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCommandBufferBeginInfo>/*@@@PLQ*/* pBeginInfo)
{
    auto in_commandBuffer = GetObjectInfoTable().GetCommandBufferInfo(commandBuffer);

    MapStructHandles(pBeginInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (call_info.index != g_saveCmdBuf_BeginCommandBuffer_Index)
    {
#endif
    VkResult replay_result = OverrideBeginCommandBuffer(GetDeviceTable(in_commandBuffer->handle)->BeginCommandBuffer, returnValue, in_commandBuffer, pBeginInfo)/*@@@HNM*/;
    CheckResult("vkBeginCommandBuffer", returnValue, replay_result, call_info);
#if TESTCODE
    }
#endif

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@WTN Enable saving of command buffer if we have reached the designated BeginCmdBuffer cmd
        if (call_info.index == g_saveCmdBuf_BeginCommandBuffer_Index)
        {
            g_savingCommandBuffer = commandBuffer;
        }

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkBeginCommandBuffer;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkEndCommandBuffer(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
    {
#endif
    VkResult replay_result = GetDeviceTable(in_commandBuffer)->EndCommandBuffer(in_commandBuffer)/*@@@ABC*/;
    CheckResult("vkEndCommandBuffer", returnValue, replay_result, call_info);
#if TESTCODE
    }
#endif

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkEndCommandBuffer;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
#if TESTCODE
            // Playback the saved cmd buffer
            g_savingCommandBuffer = 0;
            for (auto it = savedDRCmdBuff.begin(); it != savedDRCmdBuff.end(); it++)
            {
                ApiCallInfo replay_call_info;
                replay_call_info.index = 0; //@@@ZXC Set to 0 to keep from triggering another cmdbuf save
                replay_call_info.thread_id = it->thread_id;
                replay_call_info.parameter_buffer_data = it->parameter_buffer_data.data(); // Not really needed since cmd will not be saved,
                replay_call_info.parameter_buffer_size = it->parameter_buffer_size;        // but they are set here for completeness.
                replay_call_info.thread_id = it->thread_id;
                it->decoder->DecodeFunctionCall(it->apiCall, replay_call_info, it->parameter_buffer_data.data(), it->parameter_buffer_size);
            }
            savedDRCmdBuff.clear();
#endif
        }
    }
}

void VulkanReplayConsumer::Process_vkResetCommandBuffer(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    VkCommandBufferResetFlags                   flags)
{
    auto in_commandBuffer = GetObjectInfoTable().GetCommandBufferInfo(commandBuffer);//@@@DFK
    VkResult replay_result = OverrideResetCommandBuffer(GetDeviceTable(in_commandBuffer->handle)->ResetCommandBuffer, returnValue, in_commandBuffer, flags)/*@@@HNM*/;
    CheckResult("vkResetCommandBuffer", returnValue, replay_result, call_info);

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkResetCommandBuffer;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdBindPipeline(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    format::HandleId                            pipeline)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkPipeline in_pipeline = /*@@@QKJ*/MapHandle<PipelineInfo>(pipeline, &VulkanObjectInfoTable::GetPipelineInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBindPipeline(in_commandBuffer, pipelineBindPoint, in_pipeline)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBindPipeline;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBindPipelineHandles(in_commandBuffer, in_pipeline);

    }
}

void VulkanReplayConsumer::Process_vkCmdSetViewport(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    StructPointerDecoder<Decoded_VkViewport>/*@@@PLQ*/* pViewports)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkViewport* /*@@@AZI*/in_pViewports = /*@@@HUY*/pViewports->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetViewport(in_commandBuffer, firstViewport, viewportCount, /*@@@AZI*/in_pViewports)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetViewport;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetScissor(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstScissor,
    uint32_t                                    scissorCount,
    StructPointerDecoder<Decoded_VkRect2D>/*@@@PLQ*/* pScissors)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkRect2D* /*@@@AZI*/in_pScissors = /*@@@HUY*/pScissors->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetScissor(in_commandBuffer, firstScissor, scissorCount, /*@@@AZI*/in_pScissors)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetScissor;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetLineWidth(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    float                                       lineWidth)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetLineWidth(in_commandBuffer, lineWidth)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetLineWidth;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetDepthBias(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    float                                       depthBiasConstantFactor,
    float                                       depthBiasClamp,
    float                                       depthBiasSlopeFactor)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthBias(in_commandBuffer, depthBiasConstantFactor, depthBiasClamp, depthBiasSlopeFactor)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthBias;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetBlendConstants(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    PointerDecoder<float>*                      blendConstants)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const float* /*@@@AZI*/in_blendConstants = /*@@@HUY*/blendConstants->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetBlendConstants(in_commandBuffer, /*@@@AZI*/in_blendConstants)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetBlendConstants;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetDepthBounds(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    float                                       minDepthBounds,
    float                                       maxDepthBounds)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthBounds(in_commandBuffer, minDepthBounds, maxDepthBounds)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthBounds;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetStencilCompareMask(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    compareMask)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetStencilCompareMask(in_commandBuffer, faceMask, compareMask)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetStencilCompareMask;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetStencilWriteMask(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    writeMask)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetStencilWriteMask(in_commandBuffer, faceMask, writeMask)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetStencilWriteMask;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetStencilReference(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkStencilFaceFlags                          faceMask,
    uint32_t                                    reference)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetStencilReference(in_commandBuffer, faceMask, reference)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetStencilReference;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdBindDescriptorSets(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    format::HandleId                            layout,
    uint32_t                                    firstSet,
    uint32_t                                    descriptorSetCount,
    HandlePointerDecoder<VkDescriptorSet>*      pDescriptorSets,
    uint32_t                                    dynamicOffsetCount,
    PointerDecoder<uint32_t>*                   pDynamicOffsets)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkPipelineLayout in_layout = /*@@@QKJ*/MapHandle<PipelineLayoutInfo>(layout, &VulkanObjectInfoTable::GetPipelineLayoutInfo);
    /*@@@HPA*/const VkDescriptorSet* /*@@@AZI*/in_pDescriptorSets = /*@@@EDO*/MapHandles<DescriptorSetInfo>(pDescriptorSets, descriptorSetCount, &VulkanObjectInfoTable::GetDescriptorSetInfo);
    /*@@@HPA*/const uint32_t* /*@@@AZI*/in_pDynamicOffsets = /*@@@HUY*/pDynamicOffsets->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBindDescriptorSets(in_commandBuffer, pipelineBindPoint, in_layout, firstSet, descriptorSetCount, /*@@@AZI*/in_pDescriptorSets, dynamicOffsetCount, /*@@@AZI*/in_pDynamicOffsets)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBindDescriptorSets;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBindDescriptorSetsHandles(in_commandBuffer, in_layout, descriptorSetCount, in_pDescriptorSets);

    }
}

void VulkanReplayConsumer::Process_vkCmdBindIndexBuffer(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    VkIndexType                                 indexType)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBindIndexBuffer(in_commandBuffer, in_buffer, offset, indexType)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBindIndexBuffer;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBindIndexBufferHandles(in_commandBuffer, in_buffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdBindVertexBuffers(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    HandlePointerDecoder<VkBuffer>*             pBuffers,
    PointerDecoder<VkDeviceSize>*               pOffsets)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkBuffer* /*@@@AZI*/in_pBuffers = /*@@@EDO*/MapHandles<BufferInfo>(pBuffers, bindingCount, &VulkanObjectInfoTable::GetBufferInfo);
    /*@@@HPA*/const VkDeviceSize* /*@@@AZI*/in_pOffsets = /*@@@HUY*/pOffsets->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBindVertexBuffers(in_commandBuffer, firstBinding, bindingCount, /*@@@AZI*/in_pBuffers, /*@@@AZI*/in_pOffsets)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBindVertexBuffers;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBindVertexBuffersHandles(in_commandBuffer, bindingCount, in_pBuffers);

    }
}

void VulkanReplayConsumer::Process_vkCmdDraw(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    vertexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstVertex,
    uint32_t                                    firstInstance)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDraw(in_commandBuffer, vertexCount, instanceCount, firstVertex, firstInstance)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDraw;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdDrawIndexed(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    indexCount,
    uint32_t                                    instanceCount,
    uint32_t                                    firstIndex,
    int32_t                                     vertexOffset,
    uint32_t                                    firstInstance)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawIndexed(in_commandBuffer, indexCount, instanceCount, firstIndex, vertexOffset, firstInstance)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawIndexed;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdDrawIndirect(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawIndirect(in_commandBuffer, in_buffer, offset, drawCount, stride)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawIndirect;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDrawIndirectHandles(in_commandBuffer, in_buffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdDrawIndexedIndirect(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawIndexedIndirect(in_commandBuffer, in_buffer, offset, drawCount, stride)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawIndexedIndirect;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDrawIndexedIndirectHandles(in_commandBuffer, in_buffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdDispatch(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDispatch(in_commandBuffer, groupCountX, groupCountY, groupCountZ)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDispatch;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdDispatchIndirect(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDispatchIndirect(in_commandBuffer, in_buffer, offset)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDispatchIndirect;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDispatchIndirectHandles(in_commandBuffer, in_buffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyBuffer(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            srcBuffer,
    format::HandleId                            dstBuffer,
    uint32_t                                    regionCount,
    StructPointerDecoder<Decoded_VkBufferCopy>/*@@@PLQ*/* pRegions)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_srcBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(srcBuffer, &VulkanObjectInfoTable::GetBufferInfo);
    VkBuffer in_dstBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(dstBuffer, &VulkanObjectInfoTable::GetBufferInfo);
    /*@@@HPA*/const VkBufferCopy* /*@@@AZI*/in_pRegions = /*@@@HUY*/pRegions->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyBuffer(in_commandBuffer, in_srcBuffer, in_dstBuffer, regionCount, /*@@@AZI*/in_pRegions)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyBuffer;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyBufferHandles(in_commandBuffer, in_srcBuffer, in_dstBuffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyImage(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    StructPointerDecoder<Decoded_VkImageCopy>/*@@@PLQ*/* pRegions)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkImage in_srcImage = /*@@@QKJ*/MapHandle<ImageInfo>(srcImage, &VulkanObjectInfoTable::GetImageInfo);
    VkImage in_dstImage = /*@@@QKJ*/MapHandle<ImageInfo>(dstImage, &VulkanObjectInfoTable::GetImageInfo);
    /*@@@HPA*/const VkImageCopy* /*@@@AZI*/in_pRegions = /*@@@HUY*/pRegions->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyImage(in_commandBuffer, in_srcImage, srcImageLayout, in_dstImage, dstImageLayout, regionCount, /*@@@AZI*/in_pRegions)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyImage;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyImageHandles(in_commandBuffer, in_srcImage, in_dstImage);

    }
}

void VulkanReplayConsumer::Process_vkCmdBlitImage(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    StructPointerDecoder<Decoded_VkImageBlit>/*@@@PLQ*/* pRegions,
    VkFilter                                    filter)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkImage in_srcImage = /*@@@QKJ*/MapHandle<ImageInfo>(srcImage, &VulkanObjectInfoTable::GetImageInfo);
    VkImage in_dstImage = /*@@@QKJ*/MapHandle<ImageInfo>(dstImage, &VulkanObjectInfoTable::GetImageInfo);
    /*@@@HPA*/const VkImageBlit* /*@@@AZI*/in_pRegions = /*@@@HUY*/pRegions->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBlitImage(in_commandBuffer, in_srcImage, srcImageLayout, in_dstImage, dstImageLayout, regionCount, /*@@@AZI*/in_pRegions, filter)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBlitImage;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBlitImageHandles(in_commandBuffer, in_srcImage, in_dstImage);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyBufferToImage(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            srcBuffer,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    StructPointerDecoder<Decoded_VkBufferImageCopy>/*@@@PLQ*/* pRegions)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_srcBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(srcBuffer, &VulkanObjectInfoTable::GetBufferInfo);
    VkImage in_dstImage = /*@@@QKJ*/MapHandle<ImageInfo>(dstImage, &VulkanObjectInfoTable::GetImageInfo);
    /*@@@HPA*/const VkBufferImageCopy* /*@@@AZI*/in_pRegions = /*@@@HUY*/pRegions->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyBufferToImage(in_commandBuffer, in_srcBuffer, in_dstImage, dstImageLayout, regionCount, /*@@@AZI*/in_pRegions)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyBufferToImage;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyBufferToImageHandles(in_commandBuffer, in_srcBuffer, in_dstImage);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyImageToBuffer(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstBuffer,
    uint32_t                                    regionCount,
    StructPointerDecoder<Decoded_VkBufferImageCopy>/*@@@PLQ*/* pRegions)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkImage in_srcImage = /*@@@QKJ*/MapHandle<ImageInfo>(srcImage, &VulkanObjectInfoTable::GetImageInfo);
    VkBuffer in_dstBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(dstBuffer, &VulkanObjectInfoTable::GetBufferInfo);
    /*@@@HPA*/const VkBufferImageCopy* /*@@@AZI*/in_pRegions = /*@@@HUY*/pRegions->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyImageToBuffer(in_commandBuffer, in_srcImage, srcImageLayout, in_dstBuffer, regionCount, /*@@@AZI*/in_pRegions)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyImageToBuffer;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyImageToBufferHandles(in_commandBuffer, in_srcImage, in_dstBuffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdUpdateBuffer(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                dataSize,
    PointerDecoder<uint8_t>*                    pData)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_dstBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(dstBuffer, &VulkanObjectInfoTable::GetBufferInfo);
    /*@@@HPA*/const void* /*@@@AZI*/in_pData = /*@@@HUY*/pData->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdUpdateBuffer(in_commandBuffer, in_dstBuffer, dstOffset, dataSize, /*@@@AZI*/in_pData)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdUpdateBuffer;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdUpdateBufferHandles(in_commandBuffer, in_dstBuffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdFillBuffer(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                size,
    uint32_t                                    data)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_dstBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(dstBuffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdFillBuffer(in_commandBuffer, in_dstBuffer, dstOffset, size, data)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdFillBuffer;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdFillBufferHandles(in_commandBuffer, in_dstBuffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdClearColorImage(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            image,
    VkImageLayout                               imageLayout,
    StructPointerDecoder<Decoded_VkClearColorValue>/*@@@PLQ*/* pColor,
    uint32_t                                    rangeCount,
    StructPointerDecoder<Decoded_VkImageSubresourceRange>/*@@@PLQ*/* pRanges)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkImage in_image = /*@@@QKJ*/MapHandle<ImageInfo>(image, &VulkanObjectInfoTable::GetImageInfo);
    /*@@@HPA*/const VkClearColorValue* /*@@@AZI*/in_pColor = /*@@@HUY*/pColor->GetPointer();
    /*@@@HPA*/const VkImageSubresourceRange* /*@@@AZI*/in_pRanges = /*@@@HUY*/pRanges->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdClearColorImage(in_commandBuffer, in_image, imageLayout, /*@@@AZI*/in_pColor, rangeCount, /*@@@AZI*/in_pRanges)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdClearColorImage;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdClearColorImageHandles(in_commandBuffer, in_image);

    }
}

void VulkanReplayConsumer::Process_vkCmdClearDepthStencilImage(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            image,
    VkImageLayout                               imageLayout,
    StructPointerDecoder<Decoded_VkClearDepthStencilValue>/*@@@PLQ*/* pDepthStencil,
    uint32_t                                    rangeCount,
    StructPointerDecoder<Decoded_VkImageSubresourceRange>/*@@@PLQ*/* pRanges)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkImage in_image = /*@@@QKJ*/MapHandle<ImageInfo>(image, &VulkanObjectInfoTable::GetImageInfo);
    /*@@@HPA*/const VkClearDepthStencilValue* /*@@@AZI*/in_pDepthStencil = /*@@@HUY*/pDepthStencil->GetPointer();
    /*@@@HPA*/const VkImageSubresourceRange* /*@@@AZI*/in_pRanges = /*@@@HUY*/pRanges->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdClearDepthStencilImage(in_commandBuffer, in_image, imageLayout, /*@@@AZI*/in_pDepthStencil, rangeCount, /*@@@AZI*/in_pRanges)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdClearDepthStencilImage;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdClearDepthStencilImageHandles(in_commandBuffer, in_image);

    }
}

void VulkanReplayConsumer::Process_vkCmdClearAttachments(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    attachmentCount,
    StructPointerDecoder<Decoded_VkClearAttachment>/*@@@PLQ*/* pAttachments,
    uint32_t                                    rectCount,
    StructPointerDecoder<Decoded_VkClearRect>/*@@@PLQ*/* pRects)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkClearAttachment* /*@@@AZI*/in_pAttachments = /*@@@HUY*/pAttachments->GetPointer();
    /*@@@HPA*/const VkClearRect* /*@@@AZI*/in_pRects = /*@@@HUY*/pRects->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdClearAttachments(in_commandBuffer, attachmentCount, /*@@@AZI*/in_pAttachments, rectCount, /*@@@AZI*/in_pRects)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdClearAttachments;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdResolveImage(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            srcImage,
    VkImageLayout                               srcImageLayout,
    format::HandleId                            dstImage,
    VkImageLayout                               dstImageLayout,
    uint32_t                                    regionCount,
    StructPointerDecoder<Decoded_VkImageResolve>/*@@@PLQ*/* pRegions)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkImage in_srcImage = /*@@@QKJ*/MapHandle<ImageInfo>(srcImage, &VulkanObjectInfoTable::GetImageInfo);
    VkImage in_dstImage = /*@@@QKJ*/MapHandle<ImageInfo>(dstImage, &VulkanObjectInfoTable::GetImageInfo);
    /*@@@HPA*/const VkImageResolve* /*@@@AZI*/in_pRegions = /*@@@HUY*/pRegions->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdResolveImage(in_commandBuffer, in_srcImage, srcImageLayout, in_dstImage, dstImageLayout, regionCount, /*@@@AZI*/in_pRegions)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdResolveImage;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdResolveImageHandles(in_commandBuffer, in_srcImage, in_dstImage);

    }
}

void VulkanReplayConsumer::Process_vkCmdSetEvent(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            event,
    VkPipelineStageFlags                        stageMask)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkEvent in_event = /*@@@QKJ*/MapHandle<EventInfo>(event, &VulkanObjectInfoTable::GetEventInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetEvent(in_commandBuffer, in_event, stageMask)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetEvent;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdSetEventHandles(in_commandBuffer, in_event);

    }
}

void VulkanReplayConsumer::Process_vkCmdResetEvent(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            event,
    VkPipelineStageFlags                        stageMask)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkEvent in_event = /*@@@QKJ*/MapHandle<EventInfo>(event, &VulkanObjectInfoTable::GetEventInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdResetEvent(in_commandBuffer, in_event, stageMask)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdResetEvent;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdResetEventHandles(in_commandBuffer, in_event);

    }
}

void VulkanReplayConsumer::Process_vkCmdWaitEvents(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    eventCount,
    HandlePointerDecoder<VkEvent>*              pEvents,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    uint32_t                                    memoryBarrierCount,
    StructPointerDecoder<Decoded_VkMemoryBarrier>/*@@@PLQ*/* pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    StructPointerDecoder<Decoded_VkBufferMemoryBarrier>/*@@@PLQ*/* pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    StructPointerDecoder<Decoded_VkImageMemoryBarrier>/*@@@PLQ*/* pImageMemoryBarriers)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkEvent* /*@@@AZI*/in_pEvents = /*@@@EDO*/MapHandles<EventInfo>(pEvents, eventCount, &VulkanObjectInfoTable::GetEventInfo);
    /*@@@HPA*/const VkMemoryBarrier* /*@@@AZI*/in_pMemoryBarriers = /*@@@HUY*/pMemoryBarriers->GetPointer();
    /*@@@HPA*/const VkBufferMemoryBarrier* /*@@@AZI*/in_pBufferMemoryBarriers = /*@@@HUY*/pBufferMemoryBarriers->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pBufferMemoryBarriers->GetMetaStructPointer(), pBufferMemoryBarriers->GetLength(), GetObjectInfoTable());
    /*@@@HPA*/const VkImageMemoryBarrier* /*@@@AZI*/in_pImageMemoryBarriers = /*@@@HUY*/pImageMemoryBarriers->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pImageMemoryBarriers->GetMetaStructPointer(), pImageMemoryBarriers->GetLength(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdWaitEvents(in_commandBuffer, eventCount, /*@@@AZI*/in_pEvents, srcStageMask, dstStageMask, memoryBarrierCount, /*@@@AZI*/in_pMemoryBarriers, bufferMemoryBarrierCount, /*@@@AZI*/in_pBufferMemoryBarriers, imageMemoryBarrierCount, /*@@@AZI*/in_pImageMemoryBarriers)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdWaitEvents;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdWaitEventsHandles(in_commandBuffer, eventCount, in_pEvents, bufferMemoryBarrierCount, in_pBufferMemoryBarriers, imageMemoryBarrierCount, in_pImageMemoryBarriers);

    }
}

void VulkanReplayConsumer::Process_vkCmdPipelineBarrier(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkPipelineStageFlags                        srcStageMask,
    VkPipelineStageFlags                        dstStageMask,
    VkDependencyFlags                           dependencyFlags,
    uint32_t                                    memoryBarrierCount,
    StructPointerDecoder<Decoded_VkMemoryBarrier>/*@@@PLQ*/* pMemoryBarriers,
    uint32_t                                    bufferMemoryBarrierCount,
    StructPointerDecoder<Decoded_VkBufferMemoryBarrier>/*@@@PLQ*/* pBufferMemoryBarriers,
    uint32_t                                    imageMemoryBarrierCount,
    StructPointerDecoder<Decoded_VkImageMemoryBarrier>/*@@@PLQ*/* pImageMemoryBarriers)
{
    auto in_commandBuffer = GetObjectInfoTable().GetCommandBufferInfo(commandBuffer);

    /*@@@HWC*/MapStructArrayHandles(pBufferMemoryBarriers->GetMetaStructPointer(), pBufferMemoryBarriers->GetLength(), GetObjectInfoTable());

    /*@@@HWC*/MapStructArrayHandles(pImageMemoryBarriers->GetMetaStructPointer(), pImageMemoryBarriers->GetLength(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        OverrideCmdPipelineBarrier(GetDeviceTable(in_commandBuffer->handle)->CmdPipelineBarrier, in_commandBuffer, srcStageMask, dstStageMask, dependencyFlags, memoryBarrierCount, pMemoryBarriers, bufferMemoryBarrierCount, pBufferMemoryBarriers, imageMemoryBarrierCount, pImageMemoryBarriers)/*@@@PKQ*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdPipelineBarrier;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        const VkBufferMemoryBarrier* in_pBufferMemoryBarriers = pBufferMemoryBarriers->GetPointer();
        const VkImageMemoryBarrier* in_pImageMemoryBarriers = pImageMemoryBarriers->GetPointer();
        TrackDRCmdPipelineBarrierHandles(in_commandBuffer, bufferMemoryBarrierCount, in_pBufferMemoryBarriers, imageMemoryBarrierCount, in_pImageMemoryBarriers);

    }
}

void VulkanReplayConsumer::Process_vkCmdBeginQuery(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBeginQuery(in_commandBuffer, in_queryPool, query, flags)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBeginQuery;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBeginQueryHandles(in_commandBuffer, in_queryPool);

    }
}

void VulkanReplayConsumer::Process_vkCmdEndQuery(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdEndQuery(in_commandBuffer, in_queryPool, query)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdEndQuery;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdEndQueryHandles(in_commandBuffer, in_queryPool);

    }
}

void VulkanReplayConsumer::Process_vkCmdResetQueryPool(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdResetQueryPool(in_commandBuffer, in_queryPool, firstQuery, queryCount)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdResetQueryPool;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdResetQueryPoolHandles(in_commandBuffer, in_queryPool);

    }
}

void VulkanReplayConsumer::Process_vkCmdWriteTimestamp(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    format::HandleId                            queryPool,
    uint32_t                                    query)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdWriteTimestamp(in_commandBuffer, pipelineStage, in_queryPool, query)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdWriteTimestamp;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdWriteTimestampHandles(in_commandBuffer, in_queryPool);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyQueryPoolResults(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    VkDeviceSize                                stride,
    VkQueryResultFlags                          flags)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);
    VkBuffer in_dstBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(dstBuffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyQueryPoolResults(in_commandBuffer, in_queryPool, firstQuery, queryCount, in_dstBuffer, dstOffset, stride, flags)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyQueryPoolResults;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyQueryPoolResultsHandles(in_commandBuffer, in_queryPool, in_dstBuffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdPushConstants(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            layout,
    VkShaderStageFlags                          stageFlags,
    uint32_t                                    offset,
    uint32_t                                    size,
    PointerDecoder<uint8_t>*                    pValues)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkPipelineLayout in_layout = /*@@@QKJ*/MapHandle<PipelineLayoutInfo>(layout, &VulkanObjectInfoTable::GetPipelineLayoutInfo);
    /*@@@HPA*/const void* /*@@@AZI*/in_pValues = /*@@@HUY*/pValues->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdPushConstants(in_commandBuffer, in_layout, stageFlags, offset, size, /*@@@AZI*/in_pValues)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdPushConstants;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdPushConstantsHandles(in_commandBuffer, in_layout);

    }
}

void VulkanReplayConsumer::Process_vkCmdBeginRenderPass(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkRenderPassBeginInfo>/*@@@PLQ*/* pRenderPassBegin,
    VkSubpassContents                           contents)
{
    auto in_commandBuffer = GetObjectInfoTable().GetCommandBufferInfo(commandBuffer);

    MapStructHandles(pRenderPassBegin->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        OverrideCmdBeginRenderPass(GetDeviceTable(in_commandBuffer->handle)->CmdBeginRenderPass, in_commandBuffer, pRenderPassBegin, contents)/*@@@PKQ*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBeginRenderPass;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        const VkRenderPassBeginInfo* in_pRenderPassBegin = pRenderPassBegin->GetPointer();
        TrackDRCmdBeginRenderPassHandles(in_commandBuffer, in_pRenderPassBegin);

    }
}

void VulkanReplayConsumer::Process_vkCmdNextSubpass(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkSubpassContents                           contents)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdNextSubpass(in_commandBuffer, contents)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdNextSubpass;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdEndRenderPass(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdEndRenderPass(in_commandBuffer)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdEndRenderPass;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdExecuteCommands(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    commandBufferCount,
    HandlePointerDecoder<VkCommandBuffer>*      pCommandBuffers)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCommandBuffer* /*@@@AZI*/in_pCommandBuffers = /*@@@EDO*/MapHandles<CommandBufferInfo>(pCommandBuffers, commandBufferCount, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdExecuteCommands(in_commandBuffer, commandBufferCount, /*@@@AZI*/in_pCommandBuffers)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdExecuteCommands;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdExecuteCommandsHandles(in_commandBuffer, commandBufferCount, in_pCommandBuffers);

    }
}

void VulkanReplayConsumer::Process_vkBindBufferMemory2(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    StructPointerDecoder<Decoded_VkBindBufferMemoryInfo>/*@@@PLQ*/* pBindInfos)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    /*@@@HWC*/MapStructArrayHandles(pBindInfos->GetMetaStructPointer(), pBindInfos->GetLength(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = OverrideBindBufferMemory2(GetDeviceTable(in_device->handle)->BindBufferMemory2, returnValue, in_device, bindInfoCount, pBindInfos)/*@@@HNM*/;
    CheckResult("vkBindBufferMemory2", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkBindImageMemory2(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    StructPointerDecoder<Decoded_VkBindImageMemoryInfo>/*@@@PLQ*/* pBindInfos)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    /*@@@HWC*/MapStructArrayHandles(pBindInfos->GetMetaStructPointer(), pBindInfos->GetLength(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = OverrideBindImageMemory2(GetDeviceTable(in_device->handle)->BindImageMemory2, returnValue, in_device, bindInfoCount, pBindInfos)/*@@@HNM*/;
    CheckResult("vkBindImageMemory2", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetDeviceGroupPeerMemoryFeatures(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    uint32_t                                    heapIndex,
    uint32_t                                    localDeviceIndex,
    uint32_t                                    remoteDeviceIndex,
    PointerDecoder<VkPeerMemoryFeatureFlags>*   pPeerMemoryFeatures)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/VkPeerMemoryFeatureFlags* /*@@@USD*/out_pPeerMemoryFeatures = pPeerMemoryFeatures->IsNull() ? nullptr : pPeerMemoryFeatures->AllocateOutputData(1, static_cast<VkPeerMemoryFeatureFlags>(0));//@@@DFK
    GetDeviceTable(in_device)->GetDeviceGroupPeerMemoryFeatures(in_device, heapIndex, localDeviceIndex, remoteDeviceIndex, /*@@@USD*/out_pPeerMemoryFeatures)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdSetDeviceMask(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    deviceMask)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDeviceMask(in_commandBuffer, deviceMask)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDeviceMask;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdDispatchBase(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    baseGroupX,
    uint32_t                                    baseGroupY,
    uint32_t                                    baseGroupZ,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDispatchBase(in_commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDispatchBase;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkEnumeratePhysicalDeviceGroups(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    PointerDecoder<uint32_t>*                   pPhysicalDeviceGroupCount,
    StructPointerDecoder<Decoded_VkPhysicalDeviceGroupProperties>/*@@@PLQ*/* pPhysicalDeviceGroupProperties)
{
    auto in_instance = GetObjectInfoTable().GetInstanceInfo(instance);
    pPhysicalDeviceGroupCount->IsNull() ? nullptr : pPhysicalDeviceGroupCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, InstanceInfo>("vkEnumeratePhysicalDeviceGroups", returnValue, instance, kInstanceArrayEnumeratePhysicalDeviceGroups, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties, &VulkanObjectInfoTable::GetInstanceInfo));
    SetStructArrayHandleLengths<Decoded_VkPhysicalDeviceGroupProperties>(pPhysicalDeviceGroupProperties->GetMetaStructPointer(), pPhysicalDeviceGroupProperties->GetLength()); //@@@HAW
    if (!pPhysicalDeviceGroupProperties->IsNull()) { pPhysicalDeviceGroupProperties->AllocateOutputData(*pPhysicalDeviceGroupCount->GetOutputPointer(), VkPhysicalDeviceGroupProperties{ VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES, nullptr }); /*@@@FFA*/  }//@@@DFK
    VkResult replay_result = OverrideEnumeratePhysicalDeviceGroups(GetInstanceTable(in_instance->handle)->EnumeratePhysicalDeviceGroups, returnValue, in_instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)/*@@@HNM*/;
    CheckResult("vkEnumeratePhysicalDeviceGroups", returnValue, replay_result, call_info);
    if (pPhysicalDeviceGroupProperties->IsNull()) { SetOutputArrayCount<InstanceInfo>(instance, kInstanceArrayEnumeratePhysicalDeviceGroups, *pPhysicalDeviceGroupCount->GetOutputPointer(), &VulkanObjectInfoTable::GetInstanceInfo); }
    AddStructArrayHandles<Decoded_VkPhysicalDeviceGroupProperties>(instance, pPhysicalDeviceGroupProperties->GetMetaStructPointer(), pPhysicalDeviceGroupProperties->GetLength(), pPhysicalDeviceGroupProperties->GetOutputPointer(), *pPhysicalDeviceGroupCount->GetOutputPointer(), &GetObjectInfoTable()); //@@@LPI
}

void VulkanReplayConsumer::Process_vkGetImageMemoryRequirements2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkImageMemoryRequirementsInfo2>/*@@@PLQ*/* pInfo,
    StructPointerDecoder<Decoded_VkMemoryRequirements2>/*@@@PLQ*/* pMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkImageMemoryRequirementsInfo2* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkMemoryRequirements2* /*@@@USD*/out_pMemoryRequirements = pMemoryRequirements->IsNull() ? nullptr : pMemoryRequirements->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, nullptr });
    InitializeOutputStructPNext(pMemoryRequirements);//@@@DFK
    GetDeviceTable(in_device)->GetImageMemoryRequirements2(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pMemoryRequirements)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetBufferMemoryRequirements2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkBufferMemoryRequirementsInfo2>/*@@@PLQ*/* pInfo,
    StructPointerDecoder<Decoded_VkMemoryRequirements2>/*@@@PLQ*/* pMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkBufferMemoryRequirementsInfo2* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkMemoryRequirements2* /*@@@USD*/out_pMemoryRequirements = pMemoryRequirements->IsNull() ? nullptr : pMemoryRequirements->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, nullptr });
    InitializeOutputStructPNext(pMemoryRequirements);//@@@DFK
    GetDeviceTable(in_device)->GetBufferMemoryRequirements2(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pMemoryRequirements)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetImageSparseMemoryRequirements2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkImageSparseMemoryRequirementsInfo2>/*@@@PLQ*/* pInfo,
    PointerDecoder<uint32_t>*                   pSparseMemoryRequirementCount,
    StructPointerDecoder<Decoded_VkSparseImageMemoryRequirements2>/*@@@PLQ*/* pSparseMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkImageSparseMemoryRequirementsInfo2* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pSparseMemoryRequirementCount = pSparseMemoryRequirementCount->IsNull() ? nullptr : pSparseMemoryRequirementCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, DeviceInfo>("vkGetImageSparseMemoryRequirements2", VK_SUCCESS, device, kDeviceArrayGetImageSparseMemoryRequirements2, pSparseMemoryRequirementCount, pSparseMemoryRequirements, &VulkanObjectInfoTable::GetDeviceInfo));
    /*@@@HPA*/VkSparseImageMemoryRequirements2* /*@@@USD*/out_pSparseMemoryRequirements = pSparseMemoryRequirements->IsNull() ? nullptr : pSparseMemoryRequirements->AllocateOutputData(*/*@@@USD*/out_pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2{ VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    GetDeviceTable(in_device)->GetImageSparseMemoryRequirements2(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pSparseMemoryRequirementCount, /*@@@USD*/out_pSparseMemoryRequirements)/*@@@ABC*/;//@@@HQA
    if (pSparseMemoryRequirements->IsNull()) { SetOutputArrayCount<DeviceInfo>(device, kDeviceArrayGetImageSparseMemoryRequirements2, */*@@@USD*/out_pSparseMemoryRequirementCount, &VulkanObjectInfoTable::GetDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceFeatures2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceFeatures2>/*@@@PLQ*/* pFeatures)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/VkPhysicalDeviceFeatures2* /*@@@USD*/out_pFeatures = pFeatures->IsNull() ? nullptr : pFeatures->AllocateOutputData(1, { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2, nullptr });
    InitializeOutputStructPNext(pFeatures);//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceFeatures2(in_physicalDevice, /*@@@USD*/out_pFeatures)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceProperties2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceProperties2>/*@@@PLQ*/* pProperties)
{
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);
    pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2, nullptr });
    InitializeOutputStructPNext(pProperties);//@@@DFK
    OverrideGetPhysicalDeviceProperties2(GetInstanceTable(in_physicalDevice->handle)->GetPhysicalDeviceProperties2, in_physicalDevice, pProperties)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceFormatProperties2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    StructPointerDecoder<Decoded_VkFormatProperties2>/*@@@PLQ*/* pFormatProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/VkFormatProperties2* /*@@@USD*/out_pFormatProperties = pFormatProperties->IsNull() ? nullptr : pFormatProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2, nullptr });
    InitializeOutputStructPNext(pFormatProperties);//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceFormatProperties2(in_physicalDevice, format, /*@@@USD*/out_pFormatProperties)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceImageFormatProperties2(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceImageFormatInfo2>/*@@@PLQ*/* pImageFormatInfo,
    StructPointerDecoder<Decoded_VkImageFormatProperties2>/*@@@PLQ*/* pImageFormatProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceImageFormatInfo2* /*@@@AZI*/in_pImageFormatInfo = /*@@@HUY*/pImageFormatInfo->GetPointer();
    /*@@@HPA*/VkImageFormatProperties2* /*@@@USD*/out_pImageFormatProperties = pImageFormatProperties->IsNull() ? nullptr : pImageFormatProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2, nullptr });
    InitializeOutputStructPNext(pImageFormatProperties);//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceImageFormatProperties2(in_physicalDevice, /*@@@AZI*/in_pImageFormatInfo, /*@@@USD*/out_pImageFormatProperties)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceImageFormatProperties2", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceQueueFamilyProperties2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pQueueFamilyPropertyCount,
    StructPointerDecoder<Decoded_VkQueueFamilyProperties2>/*@@@PLQ*/* pQueueFamilyProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pQueueFamilyPropertyCount = pQueueFamilyPropertyCount->IsNull() ? nullptr : pQueueFamilyPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceQueueFamilyProperties2", VK_SUCCESS, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceQueueFamilyProperties2, pQueueFamilyPropertyCount, pQueueFamilyProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkQueueFamilyProperties2* /*@@@USD*/out_pQueueFamilyProperties = pQueueFamilyProperties->IsNull() ? nullptr : pQueueFamilyProperties->AllocateOutputData(*/*@@@USD*/out_pQueueFamilyPropertyCount, VkQueueFamilyProperties2{ VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceQueueFamilyProperties2(in_physicalDevice, /*@@@USD*/out_pQueueFamilyPropertyCount, /*@@@USD*/out_pQueueFamilyProperties)/*@@@ABC*/;//@@@HQA
    if (pQueueFamilyProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceQueueFamilyProperties2, */*@@@USD*/out_pQueueFamilyPropertyCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceMemoryProperties2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceMemoryProperties2>/*@@@PLQ*/* pMemoryProperties)
{
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);
    pMemoryProperties->IsNull() ? nullptr : pMemoryProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2, nullptr });
    InitializeOutputStructPNext(pMemoryProperties);//@@@DFK
    OverrideGetPhysicalDeviceMemoryProperties2(GetInstanceTable(in_physicalDevice->handle)->GetPhysicalDeviceMemoryProperties2, in_physicalDevice, pMemoryProperties)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceSparseImageFormatProperties2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>/*@@@PLQ*/* pFormatInfo,
    PointerDecoder<uint32_t>*                   pPropertyCount,
    StructPointerDecoder<Decoded_VkSparseImageFormatProperties2>/*@@@PLQ*/* pProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceSparseImageFormatInfo2* /*@@@AZI*/in_pFormatInfo = /*@@@HUY*/pFormatInfo->GetPointer();
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPropertyCount = pPropertyCount->IsNull() ? nullptr : pPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceSparseImageFormatProperties2", VK_SUCCESS, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceSparseImageFormatProperties2, pPropertyCount, pProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkSparseImageFormatProperties2* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(*/*@@@USD*/out_pPropertyCount, VkSparseImageFormatProperties2{ VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceSparseImageFormatProperties2(in_physicalDevice, /*@@@AZI*/in_pFormatInfo, /*@@@USD*/out_pPropertyCount, /*@@@USD*/out_pProperties)/*@@@ABC*/;//@@@HQA
    if (pProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceSparseImageFormatProperties2, */*@@@USD*/out_pPropertyCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkTrimCommandPool(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            commandPool,
    VkCommandPoolTrimFlags                      flags)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkCommandPool in_commandPool = /*@@@QKJ*/MapHandle<CommandPoolInfo>(commandPool, &VulkanObjectInfoTable::GetCommandPoolInfo);//@@@DFK
    GetDeviceTable(in_device)->TrimCommandPool(in_device, in_commandPool, flags)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetDeviceQueue2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDeviceQueueInfo2>/*@@@PLQ*/* pQueueInfo,
    HandlePointerDecoder<VkQueue>*              pQueue)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    if (!pQueue->IsNull()) { pQueue->SetHandleLength(1); }//@@@HET
    QueueInfo handle_info;
    pQueue->SetConsumerData(0, &handle_info);//@@@DFK
    OverrideGetDeviceQueue2(GetDeviceTable(in_device->handle)->GetDeviceQueue2, in_device, pQueueInfo, pQueue)/*@@@PKQ*/;//@@@HQA
    AddHandle<QueueInfo>(device, pQueue->GetPointer(), pQueue->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddQueueInfo);
}

void VulkanReplayConsumer::Process_vkCreateSamplerYcbcrConversion(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkSamplerYcbcrConversionCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSamplerYcbcrConversion>* pYcbcrConversion)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkSamplerYcbcrConversionCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pYcbcrConversion->IsNull()) { pYcbcrConversion->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkSamplerYcbcrConversion* /*@@@USD*/out_pYcbcrConversion = pYcbcrConversion->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateSamplerYcbcrConversion(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pYcbcrConversion)/*@@@ABC*/;
    CheckResult("vkCreateSamplerYcbcrConversion", returnValue, replay_result, call_info);
    AddHandle<SamplerYcbcrConversionInfo>(device, pYcbcrConversion->GetPointer(), /*@@@USD*/out_pYcbcrConversion, &VulkanObjectInfoTable::AddSamplerYcbcrConversionInfo);
}

void VulkanReplayConsumer::Process_vkDestroySamplerYcbcrConversion(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            ycbcrConversion,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSamplerYcbcrConversion in_ycbcrConversion = /*@@@QKJ*/MapHandle<SamplerYcbcrConversionInfo>(ycbcrConversion, &VulkanObjectInfoTable::GetSamplerYcbcrConversionInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroySamplerYcbcrConversion(in_device, in_ycbcrConversion, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(ycbcrConversion, &VulkanObjectInfoTable::RemoveSamplerYcbcrConversionInfo);
}

void VulkanReplayConsumer::Process_vkCreateDescriptorUpdateTemplate(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDescriptorUpdateTemplateCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkDescriptorUpdateTemplate>* pDescriptorUpdateTemplate)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    if (!pDescriptorUpdateTemplate->IsNull()) { pDescriptorUpdateTemplate->SetHandleLength(1); }//@@@HET
    DescriptorUpdateTemplateInfo handle_info;
    pDescriptorUpdateTemplate->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateDescriptorUpdateTemplate(GetDeviceTable(in_device->handle)->CreateDescriptorUpdateTemplate, returnValue, in_device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)/*@@@HNM*/;
    CheckResult("vkCreateDescriptorUpdateTemplate", returnValue, replay_result, call_info);
    AddHandle<DescriptorUpdateTemplateInfo>(device, pDescriptorUpdateTemplate->GetPointer(), pDescriptorUpdateTemplate->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddDescriptorUpdateTemplateInfo);
}

void VulkanReplayConsumer::Process_vkDestroyDescriptorUpdateTemplate(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            descriptorUpdateTemplate,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_descriptorUpdateTemplate = GetObjectInfoTable().GetDescriptorUpdateTemplateInfo(descriptorUpdateTemplate);//@@@DFK
    OverrideDestroyDescriptorUpdateTemplate(GetDeviceTable(in_device->handle)->DestroyDescriptorUpdateTemplate, in_device, in_descriptorUpdateTemplate, pAllocator)/*@@@PKQ*/;//@@@HQA
    RemoveHandle(descriptorUpdateTemplate, &VulkanObjectInfoTable::RemoveDescriptorUpdateTemplateInfo);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceExternalBufferProperties(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceExternalBufferInfo>/*@@@PLQ*/* pExternalBufferInfo,
    StructPointerDecoder<Decoded_VkExternalBufferProperties>/*@@@PLQ*/* pExternalBufferProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceExternalBufferInfo* /*@@@AZI*/in_pExternalBufferInfo = /*@@@HUY*/pExternalBufferInfo->GetPointer();
    /*@@@HPA*/VkExternalBufferProperties* /*@@@USD*/out_pExternalBufferProperties = pExternalBufferProperties->IsNull() ? nullptr : pExternalBufferProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES, nullptr });
    InitializeOutputStructPNext(pExternalBufferProperties);//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceExternalBufferProperties(in_physicalDevice, /*@@@AZI*/in_pExternalBufferInfo, /*@@@USD*/out_pExternalBufferProperties)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceExternalFenceProperties(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceExternalFenceInfo>/*@@@PLQ*/* pExternalFenceInfo,
    StructPointerDecoder<Decoded_VkExternalFenceProperties>/*@@@PLQ*/* pExternalFenceProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceExternalFenceInfo* /*@@@AZI*/in_pExternalFenceInfo = /*@@@HUY*/pExternalFenceInfo->GetPointer();
    /*@@@HPA*/VkExternalFenceProperties* /*@@@USD*/out_pExternalFenceProperties = pExternalFenceProperties->IsNull() ? nullptr : pExternalFenceProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES, nullptr });
    InitializeOutputStructPNext(pExternalFenceProperties);//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceExternalFenceProperties(in_physicalDevice, /*@@@AZI*/in_pExternalFenceInfo, /*@@@USD*/out_pExternalFenceProperties)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceExternalSemaphoreProperties(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>/*@@@PLQ*/* pExternalSemaphoreInfo,
    StructPointerDecoder<Decoded_VkExternalSemaphoreProperties>/*@@@PLQ*/* pExternalSemaphoreProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceExternalSemaphoreInfo* /*@@@AZI*/in_pExternalSemaphoreInfo = /*@@@HUY*/pExternalSemaphoreInfo->GetPointer();
    /*@@@HPA*/VkExternalSemaphoreProperties* /*@@@USD*/out_pExternalSemaphoreProperties = pExternalSemaphoreProperties->IsNull() ? nullptr : pExternalSemaphoreProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES, nullptr });
    InitializeOutputStructPNext(pExternalSemaphoreProperties);//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceExternalSemaphoreProperties(in_physicalDevice, /*@@@AZI*/in_pExternalSemaphoreInfo, /*@@@USD*/out_pExternalSemaphoreProperties)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetDescriptorSetLayoutSupport(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDescriptorSetLayoutCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkDescriptorSetLayoutSupport>/*@@@PLQ*/* pSupport)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDescriptorSetLayoutCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkDescriptorSetLayoutSupport* /*@@@USD*/out_pSupport = pSupport->IsNull() ? nullptr : pSupport->AllocateOutputData(1, { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT, nullptr });
    InitializeOutputStructPNext(pSupport);//@@@DFK
    GetDeviceTable(in_device)->GetDescriptorSetLayoutSupport(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@USD*/out_pSupport)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdDrawIndirectCount(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);
    VkBuffer in_countBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(countBuffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawIndirectCount(in_commandBuffer, in_buffer, offset, in_countBuffer, countBufferOffset, maxDrawCount, stride)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawIndirectCount;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDrawIndirectCountHandles(in_commandBuffer, in_buffer, in_countBuffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdDrawIndexedIndirectCount(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);
    VkBuffer in_countBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(countBuffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawIndexedIndirectCount(in_commandBuffer, in_buffer, offset, in_countBuffer, countBufferOffset, maxDrawCount, stride)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawIndexedIndirectCount;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDrawIndexedIndirectCountHandles(in_commandBuffer, in_buffer, in_countBuffer);

    }
}

void VulkanReplayConsumer::Process_vkCreateRenderPass2(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkRenderPassCreateInfo2>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkRenderPass>*         pRenderPass)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    if (!pRenderPass->IsNull()) { pRenderPass->SetHandleLength(1); }//@@@HET
    RenderPassInfo handle_info;
    pRenderPass->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateRenderPass2(GetDeviceTable(in_device->handle)->CreateRenderPass2, returnValue, in_device, pCreateInfo, pAllocator, pRenderPass)/*@@@HNM*/;
    CheckResult("vkCreateRenderPass2", returnValue, replay_result, call_info);
    AddHandle<RenderPassInfo>(device, pRenderPass->GetPointer(), pRenderPass->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddRenderPassInfo);
}

void VulkanReplayConsumer::Process_vkCmdBeginRenderPass2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkRenderPassBeginInfo>/*@@@PLQ*/* pRenderPassBegin,
    StructPointerDecoder<Decoded_VkSubpassBeginInfo>/*@@@PLQ*/* pSubpassBeginInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkRenderPassBeginInfo* /*@@@AZI*/in_pRenderPassBegin = /*@@@HUY*/pRenderPassBegin->GetPointer();
    MapStructHandles(pRenderPassBegin->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/const VkSubpassBeginInfo* /*@@@AZI*/in_pSubpassBeginInfo = /*@@@HUY*/pSubpassBeginInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBeginRenderPass2(in_commandBuffer, /*@@@AZI*/in_pRenderPassBegin, /*@@@AZI*/in_pSubpassBeginInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBeginRenderPass2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBeginRenderPass2Handles(in_commandBuffer, in_pRenderPassBegin);

    }
}

void VulkanReplayConsumer::Process_vkCmdNextSubpass2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkSubpassBeginInfo>/*@@@PLQ*/* pSubpassBeginInfo,
    StructPointerDecoder<Decoded_VkSubpassEndInfo>/*@@@PLQ*/* pSubpassEndInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkSubpassBeginInfo* /*@@@AZI*/in_pSubpassBeginInfo = /*@@@HUY*/pSubpassBeginInfo->GetPointer();
    /*@@@HPA*/const VkSubpassEndInfo* /*@@@AZI*/in_pSubpassEndInfo = /*@@@HUY*/pSubpassEndInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdNextSubpass2(in_commandBuffer, /*@@@AZI*/in_pSubpassBeginInfo, /*@@@AZI*/in_pSubpassEndInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdNextSubpass2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdEndRenderPass2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkSubpassEndInfo>/*@@@PLQ*/* pSubpassEndInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkSubpassEndInfo* /*@@@AZI*/in_pSubpassEndInfo = /*@@@HUY*/pSubpassEndInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdEndRenderPass2(in_commandBuffer, /*@@@AZI*/in_pSubpassEndInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdEndRenderPass2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkResetQueryPool(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);//@@@DFK
    GetDeviceTable(in_device)->ResetQueryPool(in_device, in_queryPool, firstQuery, queryCount)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetSemaphoreCounterValue(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            semaphore,
    PointerDecoder<uint64_t>*                   pValue)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSemaphore in_semaphore = /*@@@QKJ*/MapHandle<SemaphoreInfo>(semaphore, &VulkanObjectInfoTable::GetSemaphoreInfo);
    /*@@@HPA*/uint64_t* /*@@@USD*/out_pValue = pValue->IsNull() ? nullptr : pValue->AllocateOutputData(1, static_cast<uint64_t>(0));//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetSemaphoreCounterValue(in_device, in_semaphore, /*@@@USD*/out_pValue)/*@@@ABC*/;
    CheckResult("vkGetSemaphoreCounterValue", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkWaitSemaphores(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkSemaphoreWaitInfo>/*@@@PLQ*/* pWaitInfo,
    uint64_t                                    timeout)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pWaitInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = OverrideWaitSemaphores(GetDeviceTable(in_device->handle)->WaitSemaphores, returnValue, in_device, pWaitInfo, timeout)/*@@@HNM*/;
    CheckResult("vkWaitSemaphores", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkSignalSemaphore(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkSemaphoreSignalInfo>/*@@@PLQ*/* pSignalInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkSemaphoreSignalInfo* /*@@@AZI*/in_pSignalInfo = /*@@@HUY*/pSignalInfo->GetPointer();
    MapStructHandles(pSignalInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->SignalSemaphore(in_device, /*@@@AZI*/in_pSignalInfo)/*@@@ABC*/;
    CheckResult("vkSignalSemaphore", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetBufferDeviceAddress(
    const ApiCallInfo&                          call_info,
    VkDeviceAddress                             returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkBufferDeviceAddressInfo>/*@@@PLQ*/* pInfo)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    OverrideGetBufferDeviceAddress(GetDeviceTable(in_device->handle)->GetBufferDeviceAddress, in_device, pInfo)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetBufferOpaqueCaptureAddress(
    const ApiCallInfo&                          call_info,
    uint64_t                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkBufferDeviceAddressInfo>/*@@@PLQ*/* pInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkBufferDeviceAddressInfo* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    GetDeviceTable(in_device)->GetBufferOpaqueCaptureAddress(in_device, /*@@@AZI*/in_pInfo)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetDeviceMemoryOpaqueCaptureAddress(
    const ApiCallInfo&                          call_info,
    uint64_t                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDeviceMemoryOpaqueCaptureAddressInfo>/*@@@PLQ*/* pInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDeviceMemoryOpaqueCaptureAddressInfo* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    GetDeviceTable(in_device)->GetDeviceMemoryOpaqueCaptureAddress(in_device, /*@@@AZI*/in_pInfo)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceToolProperties(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pToolCount,
    StructPointerDecoder<Decoded_VkPhysicalDeviceToolProperties>/*@@@PLQ*/* pToolProperties)
{
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);
    pToolCount->IsNull() ? nullptr : pToolCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceToolProperties", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceToolProperties, pToolCount, pToolProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    if (!pToolProperties->IsNull()) { pToolProperties->AllocateOutputData(*pToolCount->GetOutputPointer(), VkPhysicalDeviceToolProperties{ VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES, nullptr }); /*@@@FFA*/  }//@@@DFK
    VkResult replay_result = OverrideGetPhysicalDeviceToolProperties(GetInstanceTable(in_physicalDevice->handle)->GetPhysicalDeviceToolProperties, returnValue, in_physicalDevice, pToolCount, pToolProperties)/*@@@HNM*/;
    CheckResult("vkGetPhysicalDeviceToolProperties", returnValue, replay_result, call_info);
    if (pToolProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceToolProperties, *pToolCount->GetOutputPointer(), &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkCreatePrivateDataSlot(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkPrivateDataSlotCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkPrivateDataSlot>*    pPrivateDataSlot)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkPrivateDataSlotCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pPrivateDataSlot->IsNull()) { pPrivateDataSlot->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkPrivateDataSlot* /*@@@USD*/out_pPrivateDataSlot = pPrivateDataSlot->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreatePrivateDataSlot(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pPrivateDataSlot)/*@@@ABC*/;
    CheckResult("vkCreatePrivateDataSlot", returnValue, replay_result, call_info);
    AddHandle<PrivateDataSlotInfo>(device, pPrivateDataSlot->GetPointer(), /*@@@USD*/out_pPrivateDataSlot, &VulkanObjectInfoTable::AddPrivateDataSlotInfo);
}

void VulkanReplayConsumer::Process_vkDestroyPrivateDataSlot(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            privateDataSlot,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPrivateDataSlot in_privateDataSlot = /*@@@QKJ*/MapHandle<PrivateDataSlotInfo>(privateDataSlot, &VulkanObjectInfoTable::GetPrivateDataSlotInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyPrivateDataSlot(in_device, in_privateDataSlot, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(privateDataSlot, &VulkanObjectInfoTable::RemovePrivateDataSlotInfo);
}

void VulkanReplayConsumer::Process_vkSetPrivateData(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkObjectType                                objectType,
    uint64_t                                    objectHandle,
    format::HandleId                            privateDataSlot,
    uint64_t                                    data)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    uint64_t in_objectHandle = /*@@@REX*/MapHandle(objectHandle, objectType);
    VkPrivateDataSlot in_privateDataSlot = /*@@@QKJ*/MapHandle<PrivateDataSlotInfo>(privateDataSlot, &VulkanObjectInfoTable::GetPrivateDataSlotInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->SetPrivateData(in_device, objectType, in_objectHandle, in_privateDataSlot, data)/*@@@ABC*/;
    CheckResult("vkSetPrivateData", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPrivateData(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    VkObjectType                                objectType,
    uint64_t                                    objectHandle,
    format::HandleId                            privateDataSlot,
    PointerDecoder<uint64_t>*                   pData)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    uint64_t in_objectHandle = /*@@@REX*/MapHandle(objectHandle, objectType);
    VkPrivateDataSlot in_privateDataSlot = /*@@@QKJ*/MapHandle<PrivateDataSlotInfo>(privateDataSlot, &VulkanObjectInfoTable::GetPrivateDataSlotInfo);
    /*@@@HPA*/uint64_t* /*@@@USD*/out_pData = pData->IsNull() ? nullptr : pData->AllocateOutputData(1, static_cast<uint64_t>(0));//@@@DFK
    GetDeviceTable(in_device)->GetPrivateData(in_device, objectType, in_objectHandle, in_privateDataSlot, /*@@@USD*/out_pData)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdSetEvent2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            event,
    StructPointerDecoder<Decoded_VkDependencyInfo>/*@@@PLQ*/* pDependencyInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkEvent in_event = /*@@@QKJ*/MapHandle<EventInfo>(event, &VulkanObjectInfoTable::GetEventInfo);
    /*@@@HPA*/const VkDependencyInfo* /*@@@AZI*/in_pDependencyInfo = /*@@@HUY*/pDependencyInfo->GetPointer();
    MapStructHandles(pDependencyInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetEvent2(in_commandBuffer, in_event, /*@@@AZI*/in_pDependencyInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetEvent2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdSetEvent2Handles(in_commandBuffer, in_event, in_pDependencyInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdResetEvent2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            event,
    VkPipelineStageFlags2                       stageMask)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkEvent in_event = /*@@@QKJ*/MapHandle<EventInfo>(event, &VulkanObjectInfoTable::GetEventInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdResetEvent2(in_commandBuffer, in_event, stageMask)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdResetEvent2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdResetEvent2Handles(in_commandBuffer, in_event);

    }
}

void VulkanReplayConsumer::Process_vkCmdWaitEvents2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    eventCount,
    HandlePointerDecoder<VkEvent>*              pEvents,
    StructPointerDecoder<Decoded_VkDependencyInfo>/*@@@PLQ*/* pDependencyInfos)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkEvent* /*@@@AZI*/in_pEvents = /*@@@EDO*/MapHandles<EventInfo>(pEvents, eventCount, &VulkanObjectInfoTable::GetEventInfo);
    /*@@@HPA*/const VkDependencyInfo* /*@@@AZI*/in_pDependencyInfos = /*@@@HUY*/pDependencyInfos->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pDependencyInfos->GetMetaStructPointer(), pDependencyInfos->GetLength(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdWaitEvents2(in_commandBuffer, eventCount, /*@@@AZI*/in_pEvents, /*@@@AZI*/in_pDependencyInfos)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdWaitEvents2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdWaitEvents2Handles(in_commandBuffer, eventCount, in_pEvents, in_pDependencyInfos);

    }
}

void VulkanReplayConsumer::Process_vkCmdPipelineBarrier2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkDependencyInfo>/*@@@PLQ*/* pDependencyInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkDependencyInfo* /*@@@AZI*/in_pDependencyInfo = /*@@@HUY*/pDependencyInfo->GetPointer();
    MapStructHandles(pDependencyInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdPipelineBarrier2(in_commandBuffer, /*@@@AZI*/in_pDependencyInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdPipelineBarrier2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdPipelineBarrier2Handles(in_commandBuffer, in_pDependencyInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdWriteTimestamp2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkPipelineStageFlags2                       stage,
    format::HandleId                            queryPool,
    uint32_t                                    query)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdWriteTimestamp2(in_commandBuffer, stage, in_queryPool, query)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdWriteTimestamp2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdWriteTimestamp2Handles(in_commandBuffer, in_queryPool);

    }
}

void VulkanReplayConsumer::Process_vkQueueSubmit2(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            queue,
    uint32_t                                    submitCount,
    StructPointerDecoder<Decoded_VkSubmitInfo2>/*@@@PLQ*/* pSubmits,
    format::HandleId                            fence)
{
    auto in_queue = GetObjectInfoTable().GetQueueInfo(queue);

    /*@@@HWC*/MapStructArrayHandles(pSubmits->GetMetaStructPointer(), pSubmits->GetLength(), GetObjectInfoTable());
    auto in_fence = GetObjectInfoTable().GetFenceInfo(fence);//@@@DFK
    VkResult replay_result = OverrideQueueSubmit2(GetDeviceTable(in_queue->handle)->QueueSubmit2, returnValue, in_queue, submitCount, pSubmits, in_fence)/*@@@HNM*/;
    CheckResult("vkQueueSubmit2", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdCopyBuffer2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCopyBufferInfo2>/*@@@PLQ*/* pCopyBufferInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCopyBufferInfo2* /*@@@AZI*/in_pCopyBufferInfo = /*@@@HUY*/pCopyBufferInfo->GetPointer();
    MapStructHandles(pCopyBufferInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyBuffer2(in_commandBuffer, /*@@@AZI*/in_pCopyBufferInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyBuffer2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyBuffer2Handles(in_commandBuffer, in_pCopyBufferInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyImage2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCopyImageInfo2>/*@@@PLQ*/* pCopyImageInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCopyImageInfo2* /*@@@AZI*/in_pCopyImageInfo = /*@@@HUY*/pCopyImageInfo->GetPointer();
    MapStructHandles(pCopyImageInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyImage2(in_commandBuffer, /*@@@AZI*/in_pCopyImageInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyImage2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyImage2Handles(in_commandBuffer, in_pCopyImageInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyBufferToImage2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCopyBufferToImageInfo2>/*@@@PLQ*/* pCopyBufferToImageInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCopyBufferToImageInfo2* /*@@@AZI*/in_pCopyBufferToImageInfo = /*@@@HUY*/pCopyBufferToImageInfo->GetPointer();
    MapStructHandles(pCopyBufferToImageInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyBufferToImage2(in_commandBuffer, /*@@@AZI*/in_pCopyBufferToImageInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyBufferToImage2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyBufferToImage2Handles(in_commandBuffer, in_pCopyBufferToImageInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyImageToBuffer2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCopyImageToBufferInfo2>/*@@@PLQ*/* pCopyImageToBufferInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCopyImageToBufferInfo2* /*@@@AZI*/in_pCopyImageToBufferInfo = /*@@@HUY*/pCopyImageToBufferInfo->GetPointer();
    MapStructHandles(pCopyImageToBufferInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyImageToBuffer2(in_commandBuffer, /*@@@AZI*/in_pCopyImageToBufferInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyImageToBuffer2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyImageToBuffer2Handles(in_commandBuffer, in_pCopyImageToBufferInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdBlitImage2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkBlitImageInfo2>/*@@@PLQ*/* pBlitImageInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkBlitImageInfo2* /*@@@AZI*/in_pBlitImageInfo = /*@@@HUY*/pBlitImageInfo->GetPointer();
    MapStructHandles(pBlitImageInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBlitImage2(in_commandBuffer, /*@@@AZI*/in_pBlitImageInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBlitImage2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBlitImage2Handles(in_commandBuffer, in_pBlitImageInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdResolveImage2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkResolveImageInfo2>/*@@@PLQ*/* pResolveImageInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkResolveImageInfo2* /*@@@AZI*/in_pResolveImageInfo = /*@@@HUY*/pResolveImageInfo->GetPointer();
    MapStructHandles(pResolveImageInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdResolveImage2(in_commandBuffer, /*@@@AZI*/in_pResolveImageInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdResolveImage2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdResolveImage2Handles(in_commandBuffer, in_pResolveImageInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdBeginRendering(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkRenderingInfo>/*@@@PLQ*/* pRenderingInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkRenderingInfo* /*@@@AZI*/in_pRenderingInfo = /*@@@HUY*/pRenderingInfo->GetPointer();
    MapStructHandles(pRenderingInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBeginRendering(in_commandBuffer, /*@@@AZI*/in_pRenderingInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBeginRendering;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBeginRenderingHandles(in_commandBuffer, in_pRenderingInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdEndRendering(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdEndRendering(in_commandBuffer)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdEndRendering;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetCullMode(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkCullModeFlags                             cullMode)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetCullMode(in_commandBuffer, cullMode)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetCullMode;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetFrontFace(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkFrontFace                                 frontFace)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetFrontFace(in_commandBuffer, frontFace)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetFrontFace;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetPrimitiveTopology(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkPrimitiveTopology                         primitiveTopology)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetPrimitiveTopology(in_commandBuffer, primitiveTopology)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetPrimitiveTopology;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetViewportWithCount(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    viewportCount,
    StructPointerDecoder<Decoded_VkViewport>/*@@@PLQ*/* pViewports)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkViewport* /*@@@AZI*/in_pViewports = /*@@@HUY*/pViewports->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetViewportWithCount(in_commandBuffer, viewportCount, /*@@@AZI*/in_pViewports)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetViewportWithCount;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetScissorWithCount(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    scissorCount,
    StructPointerDecoder<Decoded_VkRect2D>/*@@@PLQ*/* pScissors)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkRect2D* /*@@@AZI*/in_pScissors = /*@@@HUY*/pScissors->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetScissorWithCount(in_commandBuffer, scissorCount, /*@@@AZI*/in_pScissors)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetScissorWithCount;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdBindVertexBuffers2(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    HandlePointerDecoder<VkBuffer>*             pBuffers,
    PointerDecoder<VkDeviceSize>*               pOffsets,
    PointerDecoder<VkDeviceSize>*               pSizes,
    PointerDecoder<VkDeviceSize>*               pStrides)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkBuffer* /*@@@AZI*/in_pBuffers = /*@@@EDO*/MapHandles<BufferInfo>(pBuffers, bindingCount, &VulkanObjectInfoTable::GetBufferInfo);
    /*@@@HPA*/const VkDeviceSize* /*@@@AZI*/in_pOffsets = /*@@@HUY*/pOffsets->GetPointer();
    /*@@@HPA*/const VkDeviceSize* /*@@@AZI*/in_pSizes = /*@@@HUY*/pSizes->GetPointer();
    /*@@@HPA*/const VkDeviceSize* /*@@@AZI*/in_pStrides = /*@@@HUY*/pStrides->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBindVertexBuffers2(in_commandBuffer, firstBinding, bindingCount, /*@@@AZI*/in_pBuffers, /*@@@AZI*/in_pOffsets, /*@@@AZI*/in_pSizes, /*@@@AZI*/in_pStrides)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBindVertexBuffers2;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBindVertexBuffers2Handles(in_commandBuffer, bindingCount, in_pBuffers);

    }
}

void VulkanReplayConsumer::Process_vkCmdSetDepthTestEnable(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    depthTestEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthTestEnable(in_commandBuffer, depthTestEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthTestEnable;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetDepthWriteEnable(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    depthWriteEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthWriteEnable(in_commandBuffer, depthWriteEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthWriteEnable;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetDepthCompareOp(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkCompareOp                                 depthCompareOp)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthCompareOp(in_commandBuffer, depthCompareOp)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthCompareOp;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetDepthBoundsTestEnable(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    depthBoundsTestEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthBoundsTestEnable(in_commandBuffer, depthBoundsTestEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthBoundsTestEnable;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetStencilTestEnable(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    stencilTestEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetStencilTestEnable(in_commandBuffer, stencilTestEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetStencilTestEnable;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetStencilOp(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkStencilFaceFlags                          faceMask,
    VkStencilOp                                 failOp,
    VkStencilOp                                 passOp,
    VkStencilOp                                 depthFailOp,
    VkCompareOp                                 compareOp)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetStencilOp(in_commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetStencilOp;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetRasterizerDiscardEnable(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    rasterizerDiscardEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetRasterizerDiscardEnable(in_commandBuffer, rasterizerDiscardEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetRasterizerDiscardEnable;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetDepthBiasEnable(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    depthBiasEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthBiasEnable(in_commandBuffer, depthBiasEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthBiasEnable;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetPrimitiveRestartEnable(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    primitiveRestartEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetPrimitiveRestartEnable(in_commandBuffer, primitiveRestartEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetPrimitiveRestartEnable;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkGetDeviceBufferMemoryRequirements(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDeviceBufferMemoryRequirements>/*@@@PLQ*/* pInfo,
    StructPointerDecoder<Decoded_VkMemoryRequirements2>/*@@@PLQ*/* pMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDeviceBufferMemoryRequirements* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    /*@@@HPA*/VkMemoryRequirements2* /*@@@USD*/out_pMemoryRequirements = pMemoryRequirements->IsNull() ? nullptr : pMemoryRequirements->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, nullptr });
    InitializeOutputStructPNext(pMemoryRequirements);//@@@DFK
    GetDeviceTable(in_device)->GetDeviceBufferMemoryRequirements(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pMemoryRequirements)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetDeviceImageMemoryRequirements(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDeviceImageMemoryRequirements>/*@@@PLQ*/* pInfo,
    StructPointerDecoder<Decoded_VkMemoryRequirements2>/*@@@PLQ*/* pMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDeviceImageMemoryRequirements* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkMemoryRequirements2* /*@@@USD*/out_pMemoryRequirements = pMemoryRequirements->IsNull() ? nullptr : pMemoryRequirements->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, nullptr });
    InitializeOutputStructPNext(pMemoryRequirements);//@@@DFK
    GetDeviceTable(in_device)->GetDeviceImageMemoryRequirements(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pMemoryRequirements)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetDeviceImageSparseMemoryRequirements(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDeviceImageMemoryRequirements>/*@@@PLQ*/* pInfo,
    PointerDecoder<uint32_t>*                   pSparseMemoryRequirementCount,
    StructPointerDecoder<Decoded_VkSparseImageMemoryRequirements2>/*@@@PLQ*/* pSparseMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDeviceImageMemoryRequirements* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pSparseMemoryRequirementCount = pSparseMemoryRequirementCount->IsNull() ? nullptr : pSparseMemoryRequirementCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, DeviceInfo>("vkGetDeviceImageSparseMemoryRequirements", VK_SUCCESS, device, kDeviceArrayGetDeviceImageSparseMemoryRequirements, pSparseMemoryRequirementCount, pSparseMemoryRequirements, &VulkanObjectInfoTable::GetDeviceInfo));
    /*@@@HPA*/VkSparseImageMemoryRequirements2* /*@@@USD*/out_pSparseMemoryRequirements = pSparseMemoryRequirements->IsNull() ? nullptr : pSparseMemoryRequirements->AllocateOutputData(*/*@@@USD*/out_pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2{ VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    GetDeviceTable(in_device)->GetDeviceImageSparseMemoryRequirements(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pSparseMemoryRequirementCount, /*@@@USD*/out_pSparseMemoryRequirements)/*@@@ABC*/;//@@@HQA
    if (pSparseMemoryRequirements->IsNull()) { SetOutputArrayCount<DeviceInfo>(device, kDeviceArrayGetDeviceImageSparseMemoryRequirements, */*@@@USD*/out_pSparseMemoryRequirementCount, &VulkanObjectInfoTable::GetDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkDestroySurfaceKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            instance,
    format::HandleId                            surface,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    auto in_instance = GetObjectInfoTable().GetInstanceInfo(instance);
    auto in_surface = GetObjectInfoTable().GetSurfaceKHRInfo(surface);
    if (in_surface == nullptr || in_surface->surface_creation_skipped) { return; }//@@@DFK
    OverrideDestroySurfaceKHR(GetInstanceTable(in_instance->handle)->DestroySurfaceKHR, in_instance, in_surface, pAllocator)/*@@@PKQ*/;//@@@HQA
    RemoveHandle(surface, &VulkanObjectInfoTable::RemoveSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceSurfaceSupportKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    format::HandleId                            surface,
    PointerDecoder<VkBool32>*                   pSupported)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetPhysicalDeviceSurfaceSupportKHR for offscreen.");
        return;
    }
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    VkSurfaceKHR in_surface = /*@@@QKJ*/MapHandle<SurfaceKHRInfo>(surface, &VulkanObjectInfoTable::GetSurfaceKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(surface) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(surface)->surface_creation_skipped) { return; }
    /*@@@HPA*/VkBool32* /*@@@USD*/out_pSupported = pSupported->IsNull() ? nullptr : pSupported->AllocateOutputData(1, static_cast<VkBool32>(0));//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceSurfaceSupportKHR(in_physicalDevice, queueFamilyIndex, in_surface, /*@@@USD*/out_pSupported)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceSurfaceSupportKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    StructPointerDecoder<Decoded_VkSurfaceCapabilitiesKHR>/*@@@PLQ*/* pSurfaceCapabilities)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetPhysicalDeviceSurfaceCapabilitiesKHR for offscreen.");
        return;
    }
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);
    auto in_surface = GetObjectInfoTable().GetSurfaceKHRInfo(surface);
    if (in_surface == nullptr || in_surface->surface_creation_skipped) { return; }
    pSurfaceCapabilities->IsNull() ? nullptr : pSurfaceCapabilities->AllocateOutputData(1);//@@@DFK
    VkResult replay_result = OverrideGetPhysicalDeviceSurfaceCapabilitiesKHR(GetInstanceTable(in_physicalDevice->handle)->GetPhysicalDeviceSurfaceCapabilitiesKHR, returnValue, in_physicalDevice, in_surface, pSurfaceCapabilities)/*@@@HNM*/;
    CheckResult("vkGetPhysicalDeviceSurfaceCapabilitiesKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceSurfaceFormatsKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    PointerDecoder<uint32_t>*                   pSurfaceFormatCount,
    StructPointerDecoder<Decoded_VkSurfaceFormatKHR>/*@@@PLQ*/* pSurfaceFormats)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetPhysicalDeviceSurfaceFormatsKHR for offscreen.");
        return;
    }
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    VkSurfaceKHR in_surface = /*@@@QKJ*/MapHandle<SurfaceKHRInfo>(surface, &VulkanObjectInfoTable::GetSurfaceKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(surface) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(surface)->surface_creation_skipped) { return; }
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pSurfaceFormatCount = pSurfaceFormatCount->IsNull() ? nullptr : pSurfaceFormatCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, SurfaceKHRInfo>("vkGetPhysicalDeviceSurfaceFormatsKHR", returnValue, surface, kSurfaceKHRArrayGetPhysicalDeviceSurfaceFormatsKHR, pSurfaceFormatCount, pSurfaceFormats, &VulkanObjectInfoTable::GetSurfaceKHRInfo));
    /*@@@HPA*/VkSurfaceFormatKHR* /*@@@USD*/out_pSurfaceFormats = pSurfaceFormats->IsNull() ? nullptr : pSurfaceFormats->AllocateOutputData(*/*@@@USD*/out_pSurfaceFormatCount); /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceSurfaceFormatsKHR(in_physicalDevice, in_surface, /*@@@USD*/out_pSurfaceFormatCount, /*@@@USD*/out_pSurfaceFormats)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceSurfaceFormatsKHR", returnValue, replay_result, call_info);
    if (pSurfaceFormats->IsNull()) { SetOutputArrayCount<SurfaceKHRInfo>(surface, kSurfaceKHRArrayGetPhysicalDeviceSurfaceFormatsKHR, */*@@@USD*/out_pSurfaceFormatCount, &VulkanObjectInfoTable::GetSurfaceKHRInfo); }
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceSurfacePresentModesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    PointerDecoder<uint32_t>*                   pPresentModeCount,
    PointerDecoder<VkPresentModeKHR>*           pPresentModes)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetPhysicalDeviceSurfacePresentModesKHR for offscreen.");
        return;
    }
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    VkSurfaceKHR in_surface = /*@@@QKJ*/MapHandle<SurfaceKHRInfo>(surface, &VulkanObjectInfoTable::GetSurfaceKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(surface) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(surface)->surface_creation_skipped) { return; }
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPresentModeCount = pPresentModeCount->IsNull() ? nullptr : pPresentModeCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, SurfaceKHRInfo>("vkGetPhysicalDeviceSurfacePresentModesKHR", returnValue, surface, kSurfaceKHRArrayGetPhysicalDeviceSurfacePresentModesKHR, pPresentModeCount, pPresentModes, &VulkanObjectInfoTable::GetSurfaceKHRInfo));
    /*@@@HPA*/VkPresentModeKHR* /*@@@USD*/out_pPresentModes = pPresentModes->IsNull() ? nullptr : pPresentModes->AllocateOutputData(*/*@@@USD*/out_pPresentModeCount); //@@@DEA//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceSurfacePresentModesKHR(in_physicalDevice, in_surface, /*@@@USD*/out_pPresentModeCount, /*@@@USD*/out_pPresentModes)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceSurfacePresentModesKHR", returnValue, replay_result, call_info);
    if (pPresentModes->IsNull()) { SetOutputArrayCount<SurfaceKHRInfo>(surface, kSurfaceKHRArrayGetPhysicalDeviceSurfacePresentModesKHR, */*@@@USD*/out_pPresentModeCount, &VulkanObjectInfoTable::GetSurfaceKHRInfo); }
}

void VulkanReplayConsumer::Process_vkCreateSwapchainKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkSwapchainCreateInfoKHR>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSwapchainKHR>*       pSwapchain)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    if (!pSwapchain->IsNull()) { pSwapchain->SetHandleLength(1); }//@@@HET
    SwapchainKHRInfo handle_info;
    pSwapchain->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateSwapchainKHR(GetDeviceTable(in_device->handle)->CreateSwapchainKHR, returnValue, in_device, pCreateInfo, pAllocator, pSwapchain)/*@@@HNM*/;
    CheckResult("vkCreateSwapchainKHR", returnValue, replay_result, call_info);
    AddHandle<SwapchainKHRInfo>(device, pSwapchain->GetPointer(), pSwapchain->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddSwapchainKHRInfo);
}

void VulkanReplayConsumer::Process_vkDestroySwapchainKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_swapchain = GetObjectInfoTable().GetSwapchainKHRInfo(swapchain);//@@@DFK
    OverrideDestroySwapchainKHR(GetDeviceTable(in_device->handle)->DestroySwapchainKHR, in_device, in_swapchain, pAllocator)/*@@@PKQ*/;//@@@HQA
    RemoveHandle(swapchain, &VulkanObjectInfoTable::RemoveSwapchainKHRInfo);
}

void VulkanReplayConsumer::Process_vkGetSwapchainImagesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    PointerDecoder<uint32_t>*                   pSwapchainImageCount,
    HandlePointerDecoder<VkImage>*              pSwapchainImages)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_swapchain = GetObjectInfoTable().GetSwapchainKHRInfo(swapchain);
    pSwapchainImageCount->IsNull() ? nullptr : pSwapchainImageCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, SwapchainKHRInfo>("vkGetSwapchainImagesKHR", returnValue, swapchain, kSwapchainKHRArrayGetSwapchainImagesKHR, pSwapchainImageCount, pSwapchainImages, &VulkanObjectInfoTable::GetSwapchainKHRInfo));
    if (!pSwapchainImages->IsNull()) { pSwapchainImages->SetHandleLength(*pSwapchainImageCount->GetOutputPointer()); }//@@@UAZ
    std::vector<ImageInfo> handle_info(*pSwapchainImageCount->GetOutputPointer());
    for (size_t i = 0; i < *pSwapchainImageCount->GetOutputPointer(); ++i) { pSwapchainImages->SetConsumerData(i, &handle_info[i]); }//@@@DFK
    VkResult replay_result = OverrideGetSwapchainImagesKHR(GetDeviceTable(in_device->handle)->GetSwapchainImagesKHR, returnValue, in_device, in_swapchain, pSwapchainImageCount, pSwapchainImages)/*@@@HNM*/;
    CheckResult("vkGetSwapchainImagesKHR", returnValue, replay_result, call_info);
    if (pSwapchainImages->IsNull()) { SetOutputArrayCount<SwapchainKHRInfo>(swapchain, kSwapchainKHRArrayGetSwapchainImagesKHR, *pSwapchainImageCount->GetOutputPointer(), &VulkanObjectInfoTable::GetSwapchainKHRInfo); }
    AddHandles<ImageInfo>(device, pSwapchainImages->GetPointer(), pSwapchainImages->GetLength(), pSwapchainImages->GetHandlePointer(), *pSwapchainImageCount->GetOutputPointer(), std::move(handle_info), &VulkanObjectInfoTable::AddImageInfo);//@@@ZZA
}

void VulkanReplayConsumer::Process_vkAcquireNextImageKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    uint64_t                                    timeout,
    format::HandleId                            semaphore,
    format::HandleId                            fence,
    PointerDecoder<uint32_t>*                   pImageIndex)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_swapchain = GetObjectInfoTable().GetSwapchainKHRInfo(swapchain);
    auto in_semaphore = GetObjectInfoTable().GetSemaphoreInfo(semaphore);
    auto in_fence = GetObjectInfoTable().GetFenceInfo(fence);
    pImageIndex->IsNull() ? nullptr : pImageIndex->AllocateOutputData(1, static_cast<uint32_t>(0));//@@@DFK
    VkResult replay_result = OverrideAcquireNextImageKHR(GetDeviceTable(in_device->handle)->AcquireNextImageKHR, returnValue, in_device, in_swapchain, timeout, in_semaphore, in_fence, pImageIndex)/*@@@HNM*/;
    CheckResult("vkAcquireNextImageKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkQueuePresentKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            queue,
    StructPointerDecoder<Decoded_VkPresentInfoKHR>/*@@@PLQ*/* pPresentInfo)
{
    auto in_queue = GetObjectInfoTable().GetQueueInfo(queue);

    MapStructHandles(pPresentInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = OverrideQueuePresentKHR(GetDeviceTable(in_queue->handle)->QueuePresentKHR, returnValue, in_queue, pPresentInfo)/*@@@HNM*/;
    CheckResult("vkQueuePresentKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetDeviceGroupPresentCapabilitiesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDeviceGroupPresentCapabilitiesKHR>/*@@@PLQ*/* pDeviceGroupPresentCapabilities)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetDeviceGroupPresentCapabilitiesKHR for offscreen.");
        return;
    }
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/VkDeviceGroupPresentCapabilitiesKHR* /*@@@USD*/out_pDeviceGroupPresentCapabilities = pDeviceGroupPresentCapabilities->IsNull() ? nullptr : pDeviceGroupPresentCapabilities->AllocateOutputData(1, { VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR, nullptr });
    InitializeOutputStructPNext(pDeviceGroupPresentCapabilities);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetDeviceGroupPresentCapabilitiesKHR(in_device, /*@@@USD*/out_pDeviceGroupPresentCapabilities)/*@@@ABC*/;
    CheckResult("vkGetDeviceGroupPresentCapabilitiesKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetDeviceGroupSurfacePresentModesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            surface,
    PointerDecoder<VkDeviceGroupPresentModeFlagsKHR>* pModes)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetDeviceGroupSurfacePresentModesKHR for offscreen.");
        return;
    }
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSurfaceKHR in_surface = /*@@@QKJ*/MapHandle<SurfaceKHRInfo>(surface, &VulkanObjectInfoTable::GetSurfaceKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(surface) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(surface)->surface_creation_skipped) { return; }
    /*@@@HPA*/VkDeviceGroupPresentModeFlagsKHR* /*@@@USD*/out_pModes = pModes->IsNull() ? nullptr : pModes->AllocateOutputData(1, static_cast<VkDeviceGroupPresentModeFlagsKHR>(0));//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetDeviceGroupSurfacePresentModesKHR(in_device, in_surface, /*@@@USD*/out_pModes)/*@@@ABC*/;
    CheckResult("vkGetDeviceGroupSurfacePresentModesKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDevicePresentRectanglesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    PointerDecoder<uint32_t>*                   pRectCount,
    StructPointerDecoder<Decoded_VkRect2D>/*@@@PLQ*/* pRects)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetPhysicalDevicePresentRectanglesKHR for offscreen.");
        return;
    }
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    VkSurfaceKHR in_surface = /*@@@QKJ*/MapHandle<SurfaceKHRInfo>(surface, &VulkanObjectInfoTable::GetSurfaceKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(surface) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(surface)->surface_creation_skipped) { return; }
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pRectCount = pRectCount->IsNull() ? nullptr : pRectCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, SurfaceKHRInfo>("vkGetPhysicalDevicePresentRectanglesKHR", returnValue, surface, kSurfaceKHRArrayGetPhysicalDevicePresentRectanglesKHR, pRectCount, pRects, &VulkanObjectInfoTable::GetSurfaceKHRInfo));
    /*@@@HPA*/VkRect2D* /*@@@USD*/out_pRects = pRects->IsNull() ? nullptr : pRects->AllocateOutputData(*/*@@@USD*/out_pRectCount); /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDevicePresentRectanglesKHR(in_physicalDevice, in_surface, /*@@@USD*/out_pRectCount, /*@@@USD*/out_pRects)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDevicePresentRectanglesKHR", returnValue, replay_result, call_info);
    if (pRects->IsNull()) { SetOutputArrayCount<SurfaceKHRInfo>(surface, kSurfaceKHRArrayGetPhysicalDevicePresentRectanglesKHR, */*@@@USD*/out_pRectCount, &VulkanObjectInfoTable::GetSurfaceKHRInfo); }
}

void VulkanReplayConsumer::Process_vkAcquireNextImage2KHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkAcquireNextImageInfoKHR>/*@@@PLQ*/* pAcquireInfo,
    PointerDecoder<uint32_t>*                   pImageIndex)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pAcquireInfo->GetMetaStructPointer(), GetObjectInfoTable());
    pImageIndex->IsNull() ? nullptr : pImageIndex->AllocateOutputData(1, static_cast<uint32_t>(0));//@@@DFK
    VkResult replay_result = OverrideAcquireNextImage2KHR(GetDeviceTable(in_device->handle)->AcquireNextImage2KHR, returnValue, in_device, pAcquireInfo, pImageIndex)/*@@@HNM*/;
    CheckResult("vkAcquireNextImage2KHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceDisplayPropertiesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pPropertyCount,
    StructPointerDecoder<Decoded_VkDisplayPropertiesKHR>/*@@@PLQ*/* pProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPropertyCount = pPropertyCount->IsNull() ? nullptr : pPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceDisplayPropertiesKHR", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceDisplayPropertiesKHR, pPropertyCount, pProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkDisplayPropertiesKHR* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(*/*@@@USD*/out_pPropertyCount); /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceDisplayPropertiesKHR(in_physicalDevice, /*@@@USD*/out_pPropertyCount, /*@@@USD*/out_pProperties)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceDisplayPropertiesKHR", returnValue, replay_result, call_info);
    if (pProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceDisplayPropertiesKHR, */*@@@USD*/out_pPropertyCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
    AddStructArrayHandles<Decoded_VkDisplayPropertiesKHR>(physicalDevice, pProperties->GetMetaStructPointer(), pProperties->GetLength(), /*@@@USD*/out_pProperties, */*@@@USD*/out_pPropertyCount, &GetObjectInfoTable()); //@@@IOH
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceDisplayPlanePropertiesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pPropertyCount,
    StructPointerDecoder<Decoded_VkDisplayPlanePropertiesKHR>/*@@@PLQ*/* pProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPropertyCount = pPropertyCount->IsNull() ? nullptr : pPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceDisplayPlanePropertiesKHR", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceDisplayPlanePropertiesKHR, pPropertyCount, pProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkDisplayPlanePropertiesKHR* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(*/*@@@USD*/out_pPropertyCount); /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceDisplayPlanePropertiesKHR(in_physicalDevice, /*@@@USD*/out_pPropertyCount, /*@@@USD*/out_pProperties)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceDisplayPlanePropertiesKHR", returnValue, replay_result, call_info);
    if (pProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceDisplayPlanePropertiesKHR, */*@@@USD*/out_pPropertyCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
    AddStructArrayHandles<Decoded_VkDisplayPlanePropertiesKHR>(physicalDevice, pProperties->GetMetaStructPointer(), pProperties->GetLength(), /*@@@USD*/out_pProperties, */*@@@USD*/out_pPropertyCount, &GetObjectInfoTable()); //@@@IOH
}

void VulkanReplayConsumer::Process_vkGetDisplayPlaneSupportedDisplaysKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    planeIndex,
    PointerDecoder<uint32_t>*                   pDisplayCount,
    HandlePointerDecoder<VkDisplayKHR>*         pDisplays)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pDisplayCount = pDisplayCount->IsNull() ? nullptr : pDisplayCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetDisplayPlaneSupportedDisplaysKHR", returnValue, physicalDevice, kPhysicalDeviceArrayGetDisplayPlaneSupportedDisplaysKHR, pDisplayCount, pDisplays, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    if (!pDisplays->IsNull()) { pDisplays->SetHandleLength(*/*@@@USD*/out_pDisplayCount); }//@@@UAZ
    /*@@@HPA*/VkDisplayKHR* /*@@@USD*/out_pDisplays = pDisplays->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetDisplayPlaneSupportedDisplaysKHR(in_physicalDevice, planeIndex, /*@@@USD*/out_pDisplayCount, /*@@@USD*/out_pDisplays)/*@@@ABC*/;
    CheckResult("vkGetDisplayPlaneSupportedDisplaysKHR", returnValue, replay_result, call_info);
    if (pDisplays->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetDisplayPlaneSupportedDisplaysKHR, */*@@@USD*/out_pDisplayCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
    AddHandles<DisplayKHRInfo>(physicalDevice, pDisplays->GetPointer(), pDisplays->GetLength(), /*@@@USD*/out_pDisplays, */*@@@USD*/out_pDisplayCount, &VulkanObjectInfoTable::AddDisplayKHRInfo);//@@@UPQ
}

void VulkanReplayConsumer::Process_vkGetDisplayModePropertiesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display,
    PointerDecoder<uint32_t>*                   pPropertyCount,
    StructPointerDecoder<Decoded_VkDisplayModePropertiesKHR>/*@@@PLQ*/* pProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    VkDisplayKHR in_display = /*@@@QKJ*/MapHandle<DisplayKHRInfo>(display, &VulkanObjectInfoTable::GetDisplayKHRInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPropertyCount = pPropertyCount->IsNull() ? nullptr : pPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, DisplayKHRInfo>("vkGetDisplayModePropertiesKHR", returnValue, display, kDisplayKHRArrayGetDisplayModePropertiesKHR, pPropertyCount, pProperties, &VulkanObjectInfoTable::GetDisplayKHRInfo));
    /*@@@HPA*/VkDisplayModePropertiesKHR* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(*/*@@@USD*/out_pPropertyCount); /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetDisplayModePropertiesKHR(in_physicalDevice, in_display, /*@@@USD*/out_pPropertyCount, /*@@@USD*/out_pProperties)/*@@@ABC*/;
    CheckResult("vkGetDisplayModePropertiesKHR", returnValue, replay_result, call_info);
    if (pProperties->IsNull()) { SetOutputArrayCount<DisplayKHRInfo>(display, kDisplayKHRArrayGetDisplayModePropertiesKHR, */*@@@USD*/out_pPropertyCount, &VulkanObjectInfoTable::GetDisplayKHRInfo); }
    AddStructArrayHandles<Decoded_VkDisplayModePropertiesKHR>(physicalDevice, pProperties->GetMetaStructPointer(), pProperties->GetLength(), /*@@@USD*/out_pProperties, */*@@@USD*/out_pPropertyCount, &GetObjectInfoTable()); //@@@IOH
}

void VulkanReplayConsumer::Process_vkCreateDisplayModeKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display,
    StructPointerDecoder<Decoded_VkDisplayModeCreateInfoKHR>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkDisplayModeKHR>*     pMode)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    VkDisplayKHR in_display = /*@@@QKJ*/MapHandle<DisplayKHRInfo>(display, &VulkanObjectInfoTable::GetDisplayKHRInfo);
    /*@@@HPA*/const VkDisplayModeCreateInfoKHR* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pMode->IsNull()) { pMode->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkDisplayModeKHR* /*@@@USD*/out_pMode = pMode->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->CreateDisplayModeKHR(in_physicalDevice, in_display, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pMode)/*@@@ABC*/;
    CheckResult("vkCreateDisplayModeKHR", returnValue, replay_result, call_info);
    AddHandle<DisplayModeKHRInfo>(physicalDevice, pMode->GetPointer(), /*@@@USD*/out_pMode, &VulkanObjectInfoTable::AddDisplayModeKHRInfo);
}

void VulkanReplayConsumer::Process_vkGetDisplayPlaneCapabilitiesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            mode,
    uint32_t                                    planeIndex,
    StructPointerDecoder<Decoded_VkDisplayPlaneCapabilitiesKHR>/*@@@PLQ*/* pCapabilities)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    VkDisplayModeKHR in_mode = /*@@@QKJ*/MapHandle<DisplayModeKHRInfo>(mode, &VulkanObjectInfoTable::GetDisplayModeKHRInfo);
    /*@@@HPA*/VkDisplayPlaneCapabilitiesKHR* /*@@@USD*/out_pCapabilities = pCapabilities->IsNull() ? nullptr : pCapabilities->AllocateOutputData(1);//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetDisplayPlaneCapabilitiesKHR(in_physicalDevice, in_mode, planeIndex, /*@@@USD*/out_pCapabilities)/*@@@ABC*/;
    CheckResult("vkGetDisplayPlaneCapabilitiesKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCreateDisplayPlaneSurfaceKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkDisplaySurfaceCreateInfoKHR>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    auto in_instance = GetObjectInfoTable().GetInstanceInfo(instance);

    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }//@@@HET
    SurfaceKHRInfo handle_info;
    pSurface->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateDisplayPlaneSurfaceKHR(GetInstanceTable(in_instance->handle)->CreateDisplayPlaneSurfaceKHR, returnValue, in_instance, pCreateInfo, pAllocator, pSurface)/*@@@HNM*/;
    CheckResult("vkCreateDisplayPlaneSurfaceKHR", returnValue, replay_result, call_info);
    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), pSurface->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkCreateSharedSwapchainsKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    swapchainCount,
    StructPointerDecoder<Decoded_VkSwapchainCreateInfoKHR>/*@@@PLQ*/* pCreateInfos,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSwapchainKHR>*       pSwapchains)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    /*@@@HWC*/MapStructArrayHandles(pCreateInfos->GetMetaStructPointer(), pCreateInfos->GetLength(), GetObjectInfoTable());
    if (!pSwapchains->IsNull()) { pSwapchains->SetHandleLength(swapchainCount); }//@@@UAZ
    std::vector<SwapchainKHRInfo> handle_info(swapchainCount);
    for (size_t i = 0; i < swapchainCount; ++i) { pSwapchains->SetConsumerData(i, &handle_info[i]); }//@@@DFK
    VkResult replay_result = OverrideCreateSharedSwapchainsKHR(GetDeviceTable(in_device->handle)->CreateSharedSwapchainsKHR, returnValue, in_device, swapchainCount, pCreateInfos, pAllocator, pSwapchains)/*@@@HNM*/;
    CheckResult("vkCreateSharedSwapchainsKHR", returnValue, replay_result, call_info);
    AddHandles<SwapchainKHRInfo>(device, pSwapchains->GetPointer(), pSwapchains->GetLength(), pSwapchains->GetHandlePointer(), swapchainCount, std::move(handle_info), &VulkanObjectInfoTable::AddSwapchainKHRInfo);//@@@ZZA
}

void VulkanReplayConsumer::Process_vkCreateXlibSurfaceKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkXlibSurfaceCreateInfoKHR>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    auto in_instance = GetObjectInfoTable().GetInstanceInfo(instance);
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }//@@@HET
    SurfaceKHRInfo handle_info;
    pSurface->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateXlibSurfaceKHR(GetInstanceTable(in_instance->handle)->CreateXlibSurfaceKHR, returnValue, in_instance, pCreateInfo, pAllocator, pSurface)/*@@@HNM*/;
    CheckResult("vkCreateXlibSurfaceKHR", returnValue, replay_result, call_info);
    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), pSurface->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceXlibPresentationSupportKHR(
    const ApiCallInfo&                          call_info,
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint64_t                                    dpy,
    size_t                                      visualID)
{
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);
    /*@@@HPA*/Display* /*@@@AZI*/in_dpy = /*@@@WSX*/static_cast<Display*>(PreProcessExternalObject(dpy, format::ApiCallId::ApiCall_vkGetPhysicalDeviceXlibPresentationSupportKHR, "vkGetPhysicalDeviceXlibPresentationSupportKHR"));//@@@DFK
    OverrideGetPhysicalDeviceXlibPresentationSupportKHR(GetInstanceTable(in_physicalDevice->handle)->GetPhysicalDeviceXlibPresentationSupportKHR, in_physicalDevice, queueFamilyIndex, /*@@@AZI*/in_dpy, visualID)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCreateXcbSurfaceKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkXcbSurfaceCreateInfoKHR>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    auto in_instance = GetObjectInfoTable().GetInstanceInfo(instance);
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }//@@@HET
    SurfaceKHRInfo handle_info;
    pSurface->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateXcbSurfaceKHR(GetInstanceTable(in_instance->handle)->CreateXcbSurfaceKHR, returnValue, in_instance, pCreateInfo, pAllocator, pSurface)/*@@@HNM*/;
    CheckResult("vkCreateXcbSurfaceKHR", returnValue, replay_result, call_info);
    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), pSurface->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceXcbPresentationSupportKHR(
    const ApiCallInfo&                          call_info,
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint64_t                                    connection,
    uint32_t                                    visual_id)
{
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);
    /*@@@HPA*/xcb_connection_t* /*@@@AZI*/in_connection = /*@@@WSX*/static_cast<xcb_connection_t*>(PreProcessExternalObject(connection, format::ApiCallId::ApiCall_vkGetPhysicalDeviceXcbPresentationSupportKHR, "vkGetPhysicalDeviceXcbPresentationSupportKHR"));//@@@DFK
    OverrideGetPhysicalDeviceXcbPresentationSupportKHR(GetInstanceTable(in_physicalDevice->handle)->GetPhysicalDeviceXcbPresentationSupportKHR, in_physicalDevice, queueFamilyIndex, /*@@@AZI*/in_connection, visual_id)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCreateWaylandSurfaceKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkWaylandSurfaceCreateInfoKHR>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    auto in_instance = GetObjectInfoTable().GetInstanceInfo(instance);
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }//@@@HET
    SurfaceKHRInfo handle_info;
    pSurface->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateWaylandSurfaceKHR(GetInstanceTable(in_instance->handle)->CreateWaylandSurfaceKHR, returnValue, in_instance, pCreateInfo, pAllocator, pSurface)/*@@@HNM*/;
    CheckResult("vkCreateWaylandSurfaceKHR", returnValue, replay_result, call_info);
    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), pSurface->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceWaylandPresentationSupportKHR(
    const ApiCallInfo&                          call_info,
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint64_t                                    display)
{
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);
    /*@@@HPA*/struct wl_display* /*@@@AZI*/in_display = /*@@@WSX*/static_cast<struct wl_display*>(PreProcessExternalObject(display, format::ApiCallId::ApiCall_vkGetPhysicalDeviceWaylandPresentationSupportKHR, "vkGetPhysicalDeviceWaylandPresentationSupportKHR"));//@@@DFK
    OverrideGetPhysicalDeviceWaylandPresentationSupportKHR(GetInstanceTable(in_physicalDevice->handle)->GetPhysicalDeviceWaylandPresentationSupportKHR, in_physicalDevice, queueFamilyIndex, /*@@@AZI*/in_display)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCreateAndroidSurfaceKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkAndroidSurfaceCreateInfoKHR>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    auto in_instance = GetObjectInfoTable().GetInstanceInfo(instance);
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }//@@@HET
    SurfaceKHRInfo handle_info;
    pSurface->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateAndroidSurfaceKHR(GetInstanceTable(in_instance->handle)->CreateAndroidSurfaceKHR, returnValue, in_instance, pCreateInfo, pAllocator, pSurface)/*@@@HNM*/;
    CheckResult("vkCreateAndroidSurfaceKHR", returnValue, replay_result, call_info);
    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), pSurface->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkCreateWin32SurfaceKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkWin32SurfaceCreateInfoKHR>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    auto in_instance = GetObjectInfoTable().GetInstanceInfo(instance);
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }//@@@HET
    SurfaceKHRInfo handle_info;
    pSurface->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateWin32SurfaceKHR(GetInstanceTable(in_instance->handle)->CreateWin32SurfaceKHR, returnValue, in_instance, pCreateInfo, pAllocator, pSurface)/*@@@HNM*/;
    CheckResult("vkCreateWin32SurfaceKHR", returnValue, replay_result, call_info);
    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), pSurface->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceWin32PresentationSupportKHR(
    const ApiCallInfo&                          call_info,
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex)
{
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);//@@@DFK
    OverrideGetPhysicalDeviceWin32PresentationSupportKHR(GetInstanceTable(in_physicalDevice->handle)->GetPhysicalDeviceWin32PresentationSupportKHR, in_physicalDevice, queueFamilyIndex)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceVideoCapabilitiesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkVideoProfileInfoKHR>/*@@@PLQ*/* pVideoProfile,
    StructPointerDecoder<Decoded_VkVideoCapabilitiesKHR>/*@@@PLQ*/* pCapabilities)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkVideoProfileInfoKHR* /*@@@AZI*/in_pVideoProfile = /*@@@HUY*/pVideoProfile->GetPointer();
    /*@@@HPA*/VkVideoCapabilitiesKHR* /*@@@USD*/out_pCapabilities = pCapabilities->IsNull() ? nullptr : pCapabilities->AllocateOutputData(1, { VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR, nullptr });
    InitializeOutputStructPNext(pCapabilities);//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceVideoCapabilitiesKHR(in_physicalDevice, /*@@@AZI*/in_pVideoProfile, /*@@@USD*/out_pCapabilities)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceVideoCapabilitiesKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceVideoFormatPropertiesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceVideoFormatInfoKHR>/*@@@PLQ*/* pVideoFormatInfo,
    PointerDecoder<uint32_t>*                   pVideoFormatPropertyCount,
    StructPointerDecoder<Decoded_VkVideoFormatPropertiesKHR>/*@@@PLQ*/* pVideoFormatProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceVideoFormatInfoKHR* /*@@@AZI*/in_pVideoFormatInfo = /*@@@HUY*/pVideoFormatInfo->GetPointer();
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pVideoFormatPropertyCount = pVideoFormatPropertyCount->IsNull() ? nullptr : pVideoFormatPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceVideoFormatPropertiesKHR", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceVideoFormatPropertiesKHR, pVideoFormatPropertyCount, pVideoFormatProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkVideoFormatPropertiesKHR* /*@@@USD*/out_pVideoFormatProperties = pVideoFormatProperties->IsNull() ? nullptr : pVideoFormatProperties->AllocateOutputData(*/*@@@USD*/out_pVideoFormatPropertyCount, VkVideoFormatPropertiesKHR{ VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceVideoFormatPropertiesKHR(in_physicalDevice, /*@@@AZI*/in_pVideoFormatInfo, /*@@@USD*/out_pVideoFormatPropertyCount, /*@@@USD*/out_pVideoFormatProperties)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceVideoFormatPropertiesKHR", returnValue, replay_result, call_info);
    if (pVideoFormatProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceVideoFormatPropertiesKHR, */*@@@USD*/out_pVideoFormatPropertyCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkCreateVideoSessionKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkVideoSessionCreateInfoKHR>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkVideoSessionKHR>*    pVideoSession)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkVideoSessionCreateInfoKHR* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pVideoSession->IsNull()) { pVideoSession->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkVideoSessionKHR* /*@@@USD*/out_pVideoSession = pVideoSession->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateVideoSessionKHR(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pVideoSession)/*@@@ABC*/;
    CheckResult("vkCreateVideoSessionKHR", returnValue, replay_result, call_info);
    AddHandle<VideoSessionKHRInfo>(device, pVideoSession->GetPointer(), /*@@@USD*/out_pVideoSession, &VulkanObjectInfoTable::AddVideoSessionKHRInfo);
}

void VulkanReplayConsumer::Process_vkDestroyVideoSessionKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            videoSession,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkVideoSessionKHR in_videoSession = /*@@@QKJ*/MapHandle<VideoSessionKHRInfo>(videoSession, &VulkanObjectInfoTable::GetVideoSessionKHRInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyVideoSessionKHR(in_device, in_videoSession, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(videoSession, &VulkanObjectInfoTable::RemoveVideoSessionKHRInfo);
}

void VulkanReplayConsumer::Process_vkGetVideoSessionMemoryRequirementsKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            videoSession,
    PointerDecoder<uint32_t>*                   pMemoryRequirementsCount,
    StructPointerDecoder<Decoded_VkVideoSessionMemoryRequirementsKHR>/*@@@PLQ*/* pMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkVideoSessionKHR in_videoSession = /*@@@QKJ*/MapHandle<VideoSessionKHRInfo>(videoSession, &VulkanObjectInfoTable::GetVideoSessionKHRInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pMemoryRequirementsCount = pMemoryRequirementsCount->IsNull() ? nullptr : pMemoryRequirementsCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, VideoSessionKHRInfo>("vkGetVideoSessionMemoryRequirementsKHR", returnValue, videoSession, kVideoSessionKHRArrayGetVideoSessionMemoryRequirementsKHR, pMemoryRequirementsCount, pMemoryRequirements, &VulkanObjectInfoTable::GetVideoSessionKHRInfo));
    /*@@@HPA*/VkVideoSessionMemoryRequirementsKHR* /*@@@USD*/out_pMemoryRequirements = pMemoryRequirements->IsNull() ? nullptr : pMemoryRequirements->AllocateOutputData(*/*@@@USD*/out_pMemoryRequirementsCount, VkVideoSessionMemoryRequirementsKHR{ VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetVideoSessionMemoryRequirementsKHR(in_device, in_videoSession, /*@@@USD*/out_pMemoryRequirementsCount, /*@@@USD*/out_pMemoryRequirements)/*@@@ABC*/;
    CheckResult("vkGetVideoSessionMemoryRequirementsKHR", returnValue, replay_result, call_info);
    if (pMemoryRequirements->IsNull()) { SetOutputArrayCount<VideoSessionKHRInfo>(videoSession, kVideoSessionKHRArrayGetVideoSessionMemoryRequirementsKHR, */*@@@USD*/out_pMemoryRequirementsCount, &VulkanObjectInfoTable::GetVideoSessionKHRInfo); }
}

void VulkanReplayConsumer::Process_vkBindVideoSessionMemoryKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            videoSession,
    uint32_t                                    bindSessionMemoryInfoCount,
    StructPointerDecoder<Decoded_VkBindVideoSessionMemoryInfoKHR>/*@@@PLQ*/* pBindSessionMemoryInfos)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkVideoSessionKHR in_videoSession = /*@@@QKJ*/MapHandle<VideoSessionKHRInfo>(videoSession, &VulkanObjectInfoTable::GetVideoSessionKHRInfo);
    /*@@@HPA*/const VkBindVideoSessionMemoryInfoKHR* /*@@@AZI*/in_pBindSessionMemoryInfos = /*@@@HUY*/pBindSessionMemoryInfos->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pBindSessionMemoryInfos->GetMetaStructPointer(), pBindSessionMemoryInfos->GetLength(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->BindVideoSessionMemoryKHR(in_device, in_videoSession, bindSessionMemoryInfoCount, /*@@@AZI*/in_pBindSessionMemoryInfos)/*@@@ABC*/;
    CheckResult("vkBindVideoSessionMemoryKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCreateVideoSessionParametersKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkVideoSessionParametersCreateInfoKHR>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkVideoSessionParametersKHR>* pVideoSessionParameters)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkVideoSessionParametersCreateInfoKHR* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pVideoSessionParameters->IsNull()) { pVideoSessionParameters->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkVideoSessionParametersKHR* /*@@@USD*/out_pVideoSessionParameters = pVideoSessionParameters->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateVideoSessionParametersKHR(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pVideoSessionParameters)/*@@@ABC*/;
    CheckResult("vkCreateVideoSessionParametersKHR", returnValue, replay_result, call_info);
    AddHandle<VideoSessionParametersKHRInfo>(device, pVideoSessionParameters->GetPointer(), /*@@@USD*/out_pVideoSessionParameters, &VulkanObjectInfoTable::AddVideoSessionParametersKHRInfo);
}

void VulkanReplayConsumer::Process_vkUpdateVideoSessionParametersKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            videoSessionParameters,
    StructPointerDecoder<Decoded_VkVideoSessionParametersUpdateInfoKHR>/*@@@PLQ*/* pUpdateInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkVideoSessionParametersKHR in_videoSessionParameters = /*@@@QKJ*/MapHandle<VideoSessionParametersKHRInfo>(videoSessionParameters, &VulkanObjectInfoTable::GetVideoSessionParametersKHRInfo);
    /*@@@HPA*/const VkVideoSessionParametersUpdateInfoKHR* /*@@@AZI*/in_pUpdateInfo = /*@@@HUY*/pUpdateInfo->GetPointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->UpdateVideoSessionParametersKHR(in_device, in_videoSessionParameters, /*@@@AZI*/in_pUpdateInfo)/*@@@ABC*/;
    CheckResult("vkUpdateVideoSessionParametersKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkDestroyVideoSessionParametersKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            videoSessionParameters,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkVideoSessionParametersKHR in_videoSessionParameters = /*@@@QKJ*/MapHandle<VideoSessionParametersKHRInfo>(videoSessionParameters, &VulkanObjectInfoTable::GetVideoSessionParametersKHRInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyVideoSessionParametersKHR(in_device, in_videoSessionParameters, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(videoSessionParameters, &VulkanObjectInfoTable::RemoveVideoSessionParametersKHRInfo);
}

void VulkanReplayConsumer::Process_vkCmdBeginVideoCodingKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkVideoBeginCodingInfoKHR>/*@@@PLQ*/* pBeginInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkVideoBeginCodingInfoKHR* /*@@@AZI*/in_pBeginInfo = /*@@@HUY*/pBeginInfo->GetPointer();
    MapStructHandles(pBeginInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBeginVideoCodingKHR(in_commandBuffer, /*@@@AZI*/in_pBeginInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBeginVideoCodingKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBeginVideoCodingKHRHandles(in_commandBuffer, in_pBeginInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdEndVideoCodingKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkVideoEndCodingInfoKHR>/*@@@PLQ*/* pEndCodingInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkVideoEndCodingInfoKHR* /*@@@AZI*/in_pEndCodingInfo = /*@@@HUY*/pEndCodingInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdEndVideoCodingKHR(in_commandBuffer, /*@@@AZI*/in_pEndCodingInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdEndVideoCodingKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdControlVideoCodingKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkVideoCodingControlInfoKHR>/*@@@PLQ*/* pCodingControlInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkVideoCodingControlInfoKHR* /*@@@AZI*/in_pCodingControlInfo = /*@@@HUY*/pCodingControlInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdControlVideoCodingKHR(in_commandBuffer, /*@@@AZI*/in_pCodingControlInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdControlVideoCodingKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdDecodeVideoKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkVideoDecodeInfoKHR>/*@@@PLQ*/* pDecodeInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkVideoDecodeInfoKHR* /*@@@AZI*/in_pDecodeInfo = /*@@@HUY*/pDecodeInfo->GetPointer();
    MapStructHandles(pDecodeInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDecodeVideoKHR(in_commandBuffer, /*@@@AZI*/in_pDecodeInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDecodeVideoKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDecodeVideoKHRHandles(in_commandBuffer, in_pDecodeInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdBeginRenderingKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkRenderingInfo>/*@@@PLQ*/* pRenderingInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkRenderingInfo* /*@@@AZI*/in_pRenderingInfo = /*@@@HUY*/pRenderingInfo->GetPointer();
    MapStructHandles(pRenderingInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBeginRenderingKHR(in_commandBuffer, /*@@@AZI*/in_pRenderingInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBeginRenderingKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBeginRenderingKHRHandles(in_commandBuffer, in_pRenderingInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdEndRenderingKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdEndRenderingKHR(in_commandBuffer)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdEndRenderingKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceFeatures2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceFeatures2>/*@@@PLQ*/* pFeatures)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/VkPhysicalDeviceFeatures2* /*@@@USD*/out_pFeatures = pFeatures->IsNull() ? nullptr : pFeatures->AllocateOutputData(1, { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2, nullptr });
    InitializeOutputStructPNext(pFeatures);//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceFeatures2KHR(in_physicalDevice, /*@@@USD*/out_pFeatures)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceProperties2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceProperties2>/*@@@PLQ*/* pProperties)
{
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);
    pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2, nullptr });
    InitializeOutputStructPNext(pProperties);//@@@DFK
    OverrideGetPhysicalDeviceProperties2(GetInstanceTable(in_physicalDevice->handle)->GetPhysicalDeviceProperties2KHR, in_physicalDevice, pProperties)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceFormatProperties2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    StructPointerDecoder<Decoded_VkFormatProperties2>/*@@@PLQ*/* pFormatProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/VkFormatProperties2* /*@@@USD*/out_pFormatProperties = pFormatProperties->IsNull() ? nullptr : pFormatProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2, nullptr });
    InitializeOutputStructPNext(pFormatProperties);//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceFormatProperties2KHR(in_physicalDevice, format, /*@@@USD*/out_pFormatProperties)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceImageFormatProperties2KHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceImageFormatInfo2>/*@@@PLQ*/* pImageFormatInfo,
    StructPointerDecoder<Decoded_VkImageFormatProperties2>/*@@@PLQ*/* pImageFormatProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceImageFormatInfo2* /*@@@AZI*/in_pImageFormatInfo = /*@@@HUY*/pImageFormatInfo->GetPointer();
    /*@@@HPA*/VkImageFormatProperties2* /*@@@USD*/out_pImageFormatProperties = pImageFormatProperties->IsNull() ? nullptr : pImageFormatProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2, nullptr });
    InitializeOutputStructPNext(pImageFormatProperties);//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceImageFormatProperties2KHR(in_physicalDevice, /*@@@AZI*/in_pImageFormatInfo, /*@@@USD*/out_pImageFormatProperties)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceImageFormatProperties2KHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceQueueFamilyProperties2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pQueueFamilyPropertyCount,
    StructPointerDecoder<Decoded_VkQueueFamilyProperties2>/*@@@PLQ*/* pQueueFamilyProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pQueueFamilyPropertyCount = pQueueFamilyPropertyCount->IsNull() ? nullptr : pQueueFamilyPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceQueueFamilyProperties2KHR", VK_SUCCESS, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceQueueFamilyProperties2KHR, pQueueFamilyPropertyCount, pQueueFamilyProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkQueueFamilyProperties2* /*@@@USD*/out_pQueueFamilyProperties = pQueueFamilyProperties->IsNull() ? nullptr : pQueueFamilyProperties->AllocateOutputData(*/*@@@USD*/out_pQueueFamilyPropertyCount, VkQueueFamilyProperties2{ VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceQueueFamilyProperties2KHR(in_physicalDevice, /*@@@USD*/out_pQueueFamilyPropertyCount, /*@@@USD*/out_pQueueFamilyProperties)/*@@@ABC*/;//@@@HQA
    if (pQueueFamilyProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceQueueFamilyProperties2KHR, */*@@@USD*/out_pQueueFamilyPropertyCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceMemoryProperties2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceMemoryProperties2>/*@@@PLQ*/* pMemoryProperties)
{
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);
    pMemoryProperties->IsNull() ? nullptr : pMemoryProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2, nullptr });
    InitializeOutputStructPNext(pMemoryProperties);//@@@DFK
    OverrideGetPhysicalDeviceMemoryProperties2(GetInstanceTable(in_physicalDevice->handle)->GetPhysicalDeviceMemoryProperties2KHR, in_physicalDevice, pMemoryProperties)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceSparseImageFormatProperties2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceSparseImageFormatInfo2>/*@@@PLQ*/* pFormatInfo,
    PointerDecoder<uint32_t>*                   pPropertyCount,
    StructPointerDecoder<Decoded_VkSparseImageFormatProperties2>/*@@@PLQ*/* pProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceSparseImageFormatInfo2* /*@@@AZI*/in_pFormatInfo = /*@@@HUY*/pFormatInfo->GetPointer();
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPropertyCount = pPropertyCount->IsNull() ? nullptr : pPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceSparseImageFormatProperties2KHR", VK_SUCCESS, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceSparseImageFormatProperties2KHR, pPropertyCount, pProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkSparseImageFormatProperties2* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(*/*@@@USD*/out_pPropertyCount, VkSparseImageFormatProperties2{ VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceSparseImageFormatProperties2KHR(in_physicalDevice, /*@@@AZI*/in_pFormatInfo, /*@@@USD*/out_pPropertyCount, /*@@@USD*/out_pProperties)/*@@@ABC*/;//@@@HQA
    if (pProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceSparseImageFormatProperties2KHR, */*@@@USD*/out_pPropertyCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkGetDeviceGroupPeerMemoryFeaturesKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    uint32_t                                    heapIndex,
    uint32_t                                    localDeviceIndex,
    uint32_t                                    remoteDeviceIndex,
    PointerDecoder<VkPeerMemoryFeatureFlags>*   pPeerMemoryFeatures)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/VkPeerMemoryFeatureFlags* /*@@@USD*/out_pPeerMemoryFeatures = pPeerMemoryFeatures->IsNull() ? nullptr : pPeerMemoryFeatures->AllocateOutputData(1, static_cast<VkPeerMemoryFeatureFlags>(0));//@@@DFK
    GetDeviceTable(in_device)->GetDeviceGroupPeerMemoryFeaturesKHR(in_device, heapIndex, localDeviceIndex, remoteDeviceIndex, /*@@@USD*/out_pPeerMemoryFeatures)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdSetDeviceMaskKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    deviceMask)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDeviceMaskKHR(in_commandBuffer, deviceMask)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDeviceMaskKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdDispatchBaseKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    baseGroupX,
    uint32_t                                    baseGroupY,
    uint32_t                                    baseGroupZ,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDispatchBaseKHR(in_commandBuffer, baseGroupX, baseGroupY, baseGroupZ, groupCountX, groupCountY, groupCountZ)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDispatchBaseKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkTrimCommandPoolKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            commandPool,
    VkCommandPoolTrimFlags                      flags)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkCommandPool in_commandPool = /*@@@QKJ*/MapHandle<CommandPoolInfo>(commandPool, &VulkanObjectInfoTable::GetCommandPoolInfo);//@@@DFK
    GetDeviceTable(in_device)->TrimCommandPoolKHR(in_device, in_commandPool, flags)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkEnumeratePhysicalDeviceGroupsKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    PointerDecoder<uint32_t>*                   pPhysicalDeviceGroupCount,
    StructPointerDecoder<Decoded_VkPhysicalDeviceGroupProperties>/*@@@PLQ*/* pPhysicalDeviceGroupProperties)
{
    auto in_instance = GetObjectInfoTable().GetInstanceInfo(instance);
    pPhysicalDeviceGroupCount->IsNull() ? nullptr : pPhysicalDeviceGroupCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, InstanceInfo>("vkEnumeratePhysicalDeviceGroupsKHR", returnValue, instance, kInstanceArrayEnumeratePhysicalDeviceGroupsKHR, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties, &VulkanObjectInfoTable::GetInstanceInfo));
    SetStructArrayHandleLengths<Decoded_VkPhysicalDeviceGroupProperties>(pPhysicalDeviceGroupProperties->GetMetaStructPointer(), pPhysicalDeviceGroupProperties->GetLength()); //@@@HAW
    if (!pPhysicalDeviceGroupProperties->IsNull()) { pPhysicalDeviceGroupProperties->AllocateOutputData(*pPhysicalDeviceGroupCount->GetOutputPointer(), VkPhysicalDeviceGroupProperties{ VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES, nullptr }); /*@@@FFA*/  }//@@@DFK
    VkResult replay_result = OverrideEnumeratePhysicalDeviceGroups(GetInstanceTable(in_instance->handle)->EnumeratePhysicalDeviceGroupsKHR, returnValue, in_instance, pPhysicalDeviceGroupCount, pPhysicalDeviceGroupProperties)/*@@@HNM*/;
    CheckResult("vkEnumeratePhysicalDeviceGroupsKHR", returnValue, replay_result, call_info);
    if (pPhysicalDeviceGroupProperties->IsNull()) { SetOutputArrayCount<InstanceInfo>(instance, kInstanceArrayEnumeratePhysicalDeviceGroupsKHR, *pPhysicalDeviceGroupCount->GetOutputPointer(), &VulkanObjectInfoTable::GetInstanceInfo); }
    AddStructArrayHandles<Decoded_VkPhysicalDeviceGroupProperties>(instance, pPhysicalDeviceGroupProperties->GetMetaStructPointer(), pPhysicalDeviceGroupProperties->GetLength(), pPhysicalDeviceGroupProperties->GetOutputPointer(), *pPhysicalDeviceGroupCount->GetOutputPointer(), &GetObjectInfoTable()); //@@@LPI
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceExternalBufferPropertiesKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceExternalBufferInfo>/*@@@PLQ*/* pExternalBufferInfo,
    StructPointerDecoder<Decoded_VkExternalBufferProperties>/*@@@PLQ*/* pExternalBufferProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceExternalBufferInfo* /*@@@AZI*/in_pExternalBufferInfo = /*@@@HUY*/pExternalBufferInfo->GetPointer();
    /*@@@HPA*/VkExternalBufferProperties* /*@@@USD*/out_pExternalBufferProperties = pExternalBufferProperties->IsNull() ? nullptr : pExternalBufferProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES, nullptr });
    InitializeOutputStructPNext(pExternalBufferProperties);//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceExternalBufferPropertiesKHR(in_physicalDevice, /*@@@AZI*/in_pExternalBufferInfo, /*@@@USD*/out_pExternalBufferProperties)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetMemoryWin32HandleKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkMemoryGetWin32HandleInfoKHR>/*@@@PLQ*/* pGetWin32HandleInfo,
    PointerDecoder<uint64_t, void*>*            pHandle)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkMemoryGetWin32HandleInfoKHR* /*@@@AZI*/in_pGetWin32HandleInfo = /*@@@HUY*/pGetWin32HandleInfo->GetPointer();
    MapStructHandles(pGetWin32HandleInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/HANDLE* /*@@@USD*/out_pHandle = pHandle->IsNull() ? nullptr : reinterpret_cast<HANDLE*>(pHandle->AllocateOutputData(1));//@@CCC//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetMemoryWin32HandleKHR(in_device, /*@@@AZI*/in_pGetWin32HandleInfo, /*@@@USD*/out_pHandle)/*@@@ABC*/;
    CheckResult("vkGetMemoryWin32HandleKHR", returnValue, replay_result, call_info);
    PostProcessExternalObject(replay_result, (*pHandle->GetPointer()), static_cast<void*>(*/*@@@USD*/out_pHandle), format::ApiCallId::ApiCall_vkGetMemoryWin32HandleKHR, "vkGetMemoryWin32HandleKHR");//@@HPP
}

void VulkanReplayConsumer::Process_vkGetMemoryWin32HandlePropertiesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    uint64_t                                    handle,
    StructPointerDecoder<Decoded_VkMemoryWin32HandlePropertiesKHR>/*@@@PLQ*/* pMemoryWin32HandleProperties)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/HANDLE /*@@@AZI*/in_handle = /*@@@WSX*/static_cast<HANDLE>(PreProcessExternalObject(handle, format::ApiCallId::ApiCall_vkGetMemoryWin32HandlePropertiesKHR, "vkGetMemoryWin32HandlePropertiesKHR"));
    /*@@@HPA*/VkMemoryWin32HandlePropertiesKHR* /*@@@USD*/out_pMemoryWin32HandleProperties = pMemoryWin32HandleProperties->IsNull() ? nullptr : pMemoryWin32HandleProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR, nullptr });
    InitializeOutputStructPNext(pMemoryWin32HandleProperties);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetMemoryWin32HandlePropertiesKHR(in_device, handleType, /*@@@AZI*/in_handle, /*@@@USD*/out_pMemoryWin32HandleProperties)/*@@@ABC*/;
    CheckResult("vkGetMemoryWin32HandlePropertiesKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetMemoryFdKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkMemoryGetFdInfoKHR>/*@@@PLQ*/* pGetFdInfo,
    PointerDecoder<int>*                        pFd)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkMemoryGetFdInfoKHR* /*@@@AZI*/in_pGetFdInfo = /*@@@HUY*/pGetFdInfo->GetPointer();
    MapStructHandles(pGetFdInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/int* /*@@@USD*/out_pFd = pFd->IsNull() ? nullptr : pFd->AllocateOutputData(1, static_cast<int>(0));//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetMemoryFdKHR(in_device, /*@@@AZI*/in_pGetFdInfo, /*@@@USD*/out_pFd)/*@@@ABC*/;
    CheckResult("vkGetMemoryFdKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetMemoryFdPropertiesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    int                                         fd,
    StructPointerDecoder<Decoded_VkMemoryFdPropertiesKHR>/*@@@PLQ*/* pMemoryFdProperties)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/VkMemoryFdPropertiesKHR* /*@@@USD*/out_pMemoryFdProperties = pMemoryFdProperties->IsNull() ? nullptr : pMemoryFdProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR, nullptr });
    InitializeOutputStructPNext(pMemoryFdProperties);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetMemoryFdPropertiesKHR(in_device, handleType, fd, /*@@@USD*/out_pMemoryFdProperties)/*@@@ABC*/;
    CheckResult("vkGetMemoryFdPropertiesKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceExternalSemaphoreInfo>/*@@@PLQ*/* pExternalSemaphoreInfo,
    StructPointerDecoder<Decoded_VkExternalSemaphoreProperties>/*@@@PLQ*/* pExternalSemaphoreProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceExternalSemaphoreInfo* /*@@@AZI*/in_pExternalSemaphoreInfo = /*@@@HUY*/pExternalSemaphoreInfo->GetPointer();
    /*@@@HPA*/VkExternalSemaphoreProperties* /*@@@USD*/out_pExternalSemaphoreProperties = pExternalSemaphoreProperties->IsNull() ? nullptr : pExternalSemaphoreProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES, nullptr });
    InitializeOutputStructPNext(pExternalSemaphoreProperties);//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceExternalSemaphorePropertiesKHR(in_physicalDevice, /*@@@AZI*/in_pExternalSemaphoreInfo, /*@@@USD*/out_pExternalSemaphoreProperties)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkImportSemaphoreWin32HandleKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkImportSemaphoreWin32HandleInfoKHR>/*@@@PLQ*/* pImportSemaphoreWin32HandleInfo)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pImportSemaphoreWin32HandleInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = OverrideImportSemaphoreWin32HandleKHR(GetDeviceTable(in_device->handle)->ImportSemaphoreWin32HandleKHR, returnValue, in_device, pImportSemaphoreWin32HandleInfo)/*@@@HNM*/;
    CheckResult("vkImportSemaphoreWin32HandleKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetSemaphoreWin32HandleKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkSemaphoreGetWin32HandleInfoKHR>/*@@@PLQ*/* pGetWin32HandleInfo,
    PointerDecoder<uint64_t, void*>*            pHandle)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkSemaphoreGetWin32HandleInfoKHR* /*@@@AZI*/in_pGetWin32HandleInfo = /*@@@HUY*/pGetWin32HandleInfo->GetPointer();
    MapStructHandles(pGetWin32HandleInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/HANDLE* /*@@@USD*/out_pHandle = pHandle->IsNull() ? nullptr : reinterpret_cast<HANDLE*>(pHandle->AllocateOutputData(1));//@@CCC//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetSemaphoreWin32HandleKHR(in_device, /*@@@AZI*/in_pGetWin32HandleInfo, /*@@@USD*/out_pHandle)/*@@@ABC*/;
    CheckResult("vkGetSemaphoreWin32HandleKHR", returnValue, replay_result, call_info);
    PostProcessExternalObject(replay_result, (*pHandle->GetPointer()), static_cast<void*>(*/*@@@USD*/out_pHandle), format::ApiCallId::ApiCall_vkGetSemaphoreWin32HandleKHR, "vkGetSemaphoreWin32HandleKHR");//@@HPP
}

void VulkanReplayConsumer::Process_vkImportSemaphoreFdKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkImportSemaphoreFdInfoKHR>/*@@@PLQ*/* pImportSemaphoreFdInfo)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pImportSemaphoreFdInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = OverrideImportSemaphoreFdKHR(GetDeviceTable(in_device->handle)->ImportSemaphoreFdKHR, returnValue, in_device, pImportSemaphoreFdInfo)/*@@@HNM*/;
    CheckResult("vkImportSemaphoreFdKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetSemaphoreFdKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkSemaphoreGetFdInfoKHR>/*@@@PLQ*/* pGetFdInfo,
    PointerDecoder<int>*                        pFd)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pGetFdInfo->GetMetaStructPointer(), GetObjectInfoTable());
    pFd->IsNull() ? nullptr : pFd->AllocateOutputData(1, static_cast<int>(0));//@@@DFK
    VkResult replay_result = OverrideGetSemaphoreFdKHR(GetDeviceTable(in_device->handle)->GetSemaphoreFdKHR, returnValue, in_device, pGetFdInfo, pFd)/*@@@HNM*/;
    CheckResult("vkGetSemaphoreFdKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdPushDescriptorSetKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    format::HandleId                            layout,
    uint32_t                                    set,
    uint32_t                                    descriptorWriteCount,
    StructPointerDecoder<Decoded_VkWriteDescriptorSet>/*@@@PLQ*/* pDescriptorWrites)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkPipelineLayout in_layout = /*@@@QKJ*/MapHandle<PipelineLayoutInfo>(layout, &VulkanObjectInfoTable::GetPipelineLayoutInfo);
    /*@@@HPA*/const VkWriteDescriptorSet* /*@@@AZI*/in_pDescriptorWrites = /*@@@HUY*/pDescriptorWrites->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pDescriptorWrites->GetMetaStructPointer(), pDescriptorWrites->GetLength(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdPushDescriptorSetKHR(in_commandBuffer, pipelineBindPoint, in_layout, set, descriptorWriteCount, /*@@@AZI*/in_pDescriptorWrites)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdPushDescriptorSetKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdPushDescriptorSetKHRHandles(in_commandBuffer, in_layout, descriptorWriteCount, in_pDescriptorWrites);

    }
}

void VulkanReplayConsumer::Process_vkCreateDescriptorUpdateTemplateKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDescriptorUpdateTemplateCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkDescriptorUpdateTemplate>* pDescriptorUpdateTemplate)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    if (!pDescriptorUpdateTemplate->IsNull()) { pDescriptorUpdateTemplate->SetHandleLength(1); }//@@@HET
    DescriptorUpdateTemplateInfo handle_info;
    pDescriptorUpdateTemplate->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateDescriptorUpdateTemplate(GetDeviceTable(in_device->handle)->CreateDescriptorUpdateTemplateKHR, returnValue, in_device, pCreateInfo, pAllocator, pDescriptorUpdateTemplate)/*@@@HNM*/;
    CheckResult("vkCreateDescriptorUpdateTemplateKHR", returnValue, replay_result, call_info);
    AddHandle<DescriptorUpdateTemplateInfo>(device, pDescriptorUpdateTemplate->GetPointer(), pDescriptorUpdateTemplate->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddDescriptorUpdateTemplateInfo);
}

void VulkanReplayConsumer::Process_vkDestroyDescriptorUpdateTemplateKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            descriptorUpdateTemplate,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_descriptorUpdateTemplate = GetObjectInfoTable().GetDescriptorUpdateTemplateInfo(descriptorUpdateTemplate);//@@@DFK
    OverrideDestroyDescriptorUpdateTemplate(GetDeviceTable(in_device->handle)->DestroyDescriptorUpdateTemplateKHR, in_device, in_descriptorUpdateTemplate, pAllocator)/*@@@PKQ*/;//@@@HQA
    RemoveHandle(descriptorUpdateTemplate, &VulkanObjectInfoTable::RemoveDescriptorUpdateTemplateInfo);
}

void VulkanReplayConsumer::Process_vkCreateRenderPass2KHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkRenderPassCreateInfo2>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkRenderPass>*         pRenderPass)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    if (!pRenderPass->IsNull()) { pRenderPass->SetHandleLength(1); }//@@@HET
    RenderPassInfo handle_info;
    pRenderPass->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateRenderPass2(GetDeviceTable(in_device->handle)->CreateRenderPass2KHR, returnValue, in_device, pCreateInfo, pAllocator, pRenderPass)/*@@@HNM*/;
    CheckResult("vkCreateRenderPass2KHR", returnValue, replay_result, call_info);
    AddHandle<RenderPassInfo>(device, pRenderPass->GetPointer(), pRenderPass->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddRenderPassInfo);
}

void VulkanReplayConsumer::Process_vkCmdBeginRenderPass2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkRenderPassBeginInfo>/*@@@PLQ*/* pRenderPassBegin,
    StructPointerDecoder<Decoded_VkSubpassBeginInfo>/*@@@PLQ*/* pSubpassBeginInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkRenderPassBeginInfo* /*@@@AZI*/in_pRenderPassBegin = /*@@@HUY*/pRenderPassBegin->GetPointer();
    MapStructHandles(pRenderPassBegin->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/const VkSubpassBeginInfo* /*@@@AZI*/in_pSubpassBeginInfo = /*@@@HUY*/pSubpassBeginInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBeginRenderPass2KHR(in_commandBuffer, /*@@@AZI*/in_pRenderPassBegin, /*@@@AZI*/in_pSubpassBeginInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBeginRenderPass2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBeginRenderPass2KHRHandles(in_commandBuffer, in_pRenderPassBegin);

    }
}

void VulkanReplayConsumer::Process_vkCmdNextSubpass2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkSubpassBeginInfo>/*@@@PLQ*/* pSubpassBeginInfo,
    StructPointerDecoder<Decoded_VkSubpassEndInfo>/*@@@PLQ*/* pSubpassEndInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkSubpassBeginInfo* /*@@@AZI*/in_pSubpassBeginInfo = /*@@@HUY*/pSubpassBeginInfo->GetPointer();
    /*@@@HPA*/const VkSubpassEndInfo* /*@@@AZI*/in_pSubpassEndInfo = /*@@@HUY*/pSubpassEndInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdNextSubpass2KHR(in_commandBuffer, /*@@@AZI*/in_pSubpassBeginInfo, /*@@@AZI*/in_pSubpassEndInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdNextSubpass2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdEndRenderPass2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkSubpassEndInfo>/*@@@PLQ*/* pSubpassEndInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkSubpassEndInfo* /*@@@AZI*/in_pSubpassEndInfo = /*@@@HUY*/pSubpassEndInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdEndRenderPass2KHR(in_commandBuffer, /*@@@AZI*/in_pSubpassEndInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdEndRenderPass2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkGetSwapchainStatusKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetSwapchainStatusKHR for offscreen.");
        return;
    }
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSwapchainKHR in_swapchain = /*@@@QKJ*/MapHandle<SwapchainKHRInfo>(swapchain, &VulkanObjectInfoTable::GetSwapchainKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id)->surface_creation_skipped) { return; }//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetSwapchainStatusKHR(in_device, in_swapchain)/*@@@ABC*/;
    CheckResult("vkGetSwapchainStatusKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceExternalFencePropertiesKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceExternalFenceInfo>/*@@@PLQ*/* pExternalFenceInfo,
    StructPointerDecoder<Decoded_VkExternalFenceProperties>/*@@@PLQ*/* pExternalFenceProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceExternalFenceInfo* /*@@@AZI*/in_pExternalFenceInfo = /*@@@HUY*/pExternalFenceInfo->GetPointer();
    /*@@@HPA*/VkExternalFenceProperties* /*@@@USD*/out_pExternalFenceProperties = pExternalFenceProperties->IsNull() ? nullptr : pExternalFenceProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES, nullptr });
    InitializeOutputStructPNext(pExternalFenceProperties);//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceExternalFencePropertiesKHR(in_physicalDevice, /*@@@AZI*/in_pExternalFenceInfo, /*@@@USD*/out_pExternalFenceProperties)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkImportFenceWin32HandleKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkImportFenceWin32HandleInfoKHR>/*@@@PLQ*/* pImportFenceWin32HandleInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkImportFenceWin32HandleInfoKHR* /*@@@AZI*/in_pImportFenceWin32HandleInfo = /*@@@HUY*/pImportFenceWin32HandleInfo->GetPointer();
    MapStructHandles(pImportFenceWin32HandleInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->ImportFenceWin32HandleKHR(in_device, /*@@@AZI*/in_pImportFenceWin32HandleInfo)/*@@@ABC*/;
    CheckResult("vkImportFenceWin32HandleKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetFenceWin32HandleKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkFenceGetWin32HandleInfoKHR>/*@@@PLQ*/* pGetWin32HandleInfo,
    PointerDecoder<uint64_t, void*>*            pHandle)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkFenceGetWin32HandleInfoKHR* /*@@@AZI*/in_pGetWin32HandleInfo = /*@@@HUY*/pGetWin32HandleInfo->GetPointer();
    MapStructHandles(pGetWin32HandleInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/HANDLE* /*@@@USD*/out_pHandle = pHandle->IsNull() ? nullptr : reinterpret_cast<HANDLE*>(pHandle->AllocateOutputData(1));//@@CCC//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetFenceWin32HandleKHR(in_device, /*@@@AZI*/in_pGetWin32HandleInfo, /*@@@USD*/out_pHandle)/*@@@ABC*/;
    CheckResult("vkGetFenceWin32HandleKHR", returnValue, replay_result, call_info);
    PostProcessExternalObject(replay_result, (*pHandle->GetPointer()), static_cast<void*>(*/*@@@USD*/out_pHandle), format::ApiCallId::ApiCall_vkGetFenceWin32HandleKHR, "vkGetFenceWin32HandleKHR");//@@HPP
}

void VulkanReplayConsumer::Process_vkImportFenceFdKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkImportFenceFdInfoKHR>/*@@@PLQ*/* pImportFenceFdInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkImportFenceFdInfoKHR* /*@@@AZI*/in_pImportFenceFdInfo = /*@@@HUY*/pImportFenceFdInfo->GetPointer();
    MapStructHandles(pImportFenceFdInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->ImportFenceFdKHR(in_device, /*@@@AZI*/in_pImportFenceFdInfo)/*@@@ABC*/;
    CheckResult("vkImportFenceFdKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetFenceFdKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkFenceGetFdInfoKHR>/*@@@PLQ*/* pGetFdInfo,
    PointerDecoder<int>*                        pFd)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkFenceGetFdInfoKHR* /*@@@AZI*/in_pGetFdInfo = /*@@@HUY*/pGetFdInfo->GetPointer();
    MapStructHandles(pGetFdInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/int* /*@@@USD*/out_pFd = pFd->IsNull() ? nullptr : pFd->AllocateOutputData(1, static_cast<int>(0));//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetFenceFdKHR(in_device, /*@@@AZI*/in_pGetFdInfo, /*@@@USD*/out_pFd)/*@@@ABC*/;
    CheckResult("vkGetFenceFdKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    PointerDecoder<uint32_t>*                   pCounterCount,
    StructPointerDecoder<Decoded_VkPerformanceCounterKHR>/*@@@PLQ*/* pCounters,
    StructPointerDecoder<Decoded_VkPerformanceCounterDescriptionKHR>/*@@@PLQ*/* pCounterDescriptions)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pCounterCount = pCounterCount->IsNull() ? nullptr : pCounterCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", returnValue, physicalDevice, kPhysicalDeviceArrayEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR, pCounterCount, pCounterDescriptions, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkPerformanceCounterKHR* /*@@@USD*/out_pCounters = pCounters->IsNull() ? nullptr : pCounters->AllocateOutputData(*/*@@@USD*/out_pCounterCount, VkPerformanceCounterKHR{ VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR, nullptr }); /*@@@FFA*/  /*@@@DRW*/
    /*@@@HPA*/VkPerformanceCounterDescriptionKHR* /*@@@USD*/out_pCounterDescriptions = pCounterDescriptions->IsNull() ? nullptr : pCounterDescriptions->AllocateOutputData(*/*@@@USD*/out_pCounterCount, VkPerformanceCounterDescriptionKHR{ VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->EnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR(in_physicalDevice, queueFamilyIndex, /*@@@USD*/out_pCounterCount, /*@@@USD*/out_pCounters, /*@@@USD*/out_pCounterDescriptions)/*@@@ABC*/;
    CheckResult("vkEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR", returnValue, replay_result, call_info);
    if (pCounters->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR, */*@@@USD*/out_pCounterCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
    if (pCounterDescriptions->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayEnumeratePhysicalDeviceQueueFamilyPerformanceQueryCountersKHR, */*@@@USD*/out_pCounterCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkQueryPoolPerformanceCreateInfoKHR>/*@@@PLQ*/* pPerformanceQueryCreateInfo,
    PointerDecoder<uint32_t>*                   pNumPasses)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkQueryPoolPerformanceCreateInfoKHR* /*@@@AZI*/in_pPerformanceQueryCreateInfo = /*@@@HUY*/pPerformanceQueryCreateInfo->GetPointer();
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pNumPasses = pNumPasses->IsNull() ? nullptr : pNumPasses->AllocateOutputData(1, static_cast<uint32_t>(0));//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceQueueFamilyPerformanceQueryPassesKHR(in_physicalDevice, /*@@@AZI*/in_pPerformanceQueryCreateInfo, /*@@@USD*/out_pNumPasses)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkAcquireProfilingLockKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkAcquireProfilingLockInfoKHR>/*@@@PLQ*/* pInfo)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);//@@@DFK
    VkResult replay_result = OverrideAcquireProfilingLockKHR(GetDeviceTable(in_device->handle)->AcquireProfilingLockKHR, returnValue, in_device, pInfo)/*@@@HNM*/;
    CheckResult("vkAcquireProfilingLockKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkReleaseProfilingLockKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);//@@@DFK
    GetDeviceTable(in_device)->ReleaseProfilingLockKHR(in_device)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceSurfaceCapabilities2KHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>/*@@@PLQ*/* pSurfaceInfo,
    StructPointerDecoder<Decoded_VkSurfaceCapabilities2KHR>/*@@@PLQ*/* pSurfaceCapabilities)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetPhysicalDeviceSurfaceCapabilities2KHR for offscreen.");
        return;
    }
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);

    /*@@@EWC*/if (pSurfaceInfo->GetPointer()->surface == VK_NULL_HANDLE) { return; }
    MapStructHandles(pSurfaceInfo->GetMetaStructPointer(), GetObjectInfoTable());
    auto /*@@@UIW*/in_pSurfaceInfo_meta = pSurfaceInfo->GetMetaStructPointer();
    /*@@@HSW*/if (GetObjectInfoTable().GetSurfaceKHRInfo(/*@@@UIW*/in_pSurfaceInfo_meta->surface) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(/*@@@UIW*/in_pSurfaceInfo_meta->surface)->surface_creation_skipped) { return; }
    pSurfaceCapabilities->IsNull() ? nullptr : pSurfaceCapabilities->AllocateOutputData(1, { VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR, nullptr });
    InitializeOutputStructPNext(pSurfaceCapabilities);//@@@DFK
    VkResult replay_result = OverrideGetPhysicalDeviceSurfaceCapabilities2KHR(GetInstanceTable(in_physicalDevice->handle)->GetPhysicalDeviceSurfaceCapabilities2KHR, returnValue, in_physicalDevice, pSurfaceInfo, pSurfaceCapabilities)/*@@@HNM*/;
    CheckResult("vkGetPhysicalDeviceSurfaceCapabilities2KHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceSurfaceFormats2KHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>/*@@@PLQ*/* pSurfaceInfo,
    PointerDecoder<uint32_t>*                   pSurfaceFormatCount,
    StructPointerDecoder<Decoded_VkSurfaceFormat2KHR>/*@@@PLQ*/* pSurfaceFormats)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetPhysicalDeviceSurfaceFormats2KHR for offscreen.");
        return;
    }
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceSurfaceInfo2KHR* /*@@@AZI*/in_pSurfaceInfo = /*@@@HUY*/pSurfaceInfo->GetPointer();
    /*@@@EWC*/if (pSurfaceInfo->GetPointer()->surface == VK_NULL_HANDLE) { return; }
    MapStructHandles(pSurfaceInfo->GetMetaStructPointer(), GetObjectInfoTable());
    auto /*@@@UIW*/in_pSurfaceInfo_meta = pSurfaceInfo->GetMetaStructPointer();
    /*@@@HSW*/if (GetObjectInfoTable().GetSurfaceKHRInfo(/*@@@UIW*/in_pSurfaceInfo_meta->surface) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(/*@@@UIW*/in_pSurfaceInfo_meta->surface)->surface_creation_skipped) { return; }
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pSurfaceFormatCount = pSurfaceFormatCount->IsNull() ? nullptr : pSurfaceFormatCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceSurfaceFormats2KHR", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceSurfaceFormats2KHR, pSurfaceFormatCount, pSurfaceFormats, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkSurfaceFormat2KHR* /*@@@USD*/out_pSurfaceFormats = pSurfaceFormats->IsNull() ? nullptr : pSurfaceFormats->AllocateOutputData(*/*@@@USD*/out_pSurfaceFormatCount, VkSurfaceFormat2KHR{ VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceSurfaceFormats2KHR(in_physicalDevice, /*@@@AZI*/in_pSurfaceInfo, /*@@@USD*/out_pSurfaceFormatCount, /*@@@USD*/out_pSurfaceFormats)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceSurfaceFormats2KHR", returnValue, replay_result, call_info);
    if (pSurfaceFormats->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceSurfaceFormats2KHR, */*@@@USD*/out_pSurfaceFormatCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceDisplayProperties2KHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pPropertyCount,
    StructPointerDecoder<Decoded_VkDisplayProperties2KHR>/*@@@PLQ*/* pProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPropertyCount = pPropertyCount->IsNull() ? nullptr : pPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceDisplayProperties2KHR", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceDisplayProperties2KHR, pPropertyCount, pProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkDisplayProperties2KHR* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(*/*@@@USD*/out_pPropertyCount, VkDisplayProperties2KHR{ VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceDisplayProperties2KHR(in_physicalDevice, /*@@@USD*/out_pPropertyCount, /*@@@USD*/out_pProperties)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceDisplayProperties2KHR", returnValue, replay_result, call_info);
    if (pProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceDisplayProperties2KHR, */*@@@USD*/out_pPropertyCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
    AddStructArrayHandles<Decoded_VkDisplayProperties2KHR>(physicalDevice, pProperties->GetMetaStructPointer(), pProperties->GetLength(), /*@@@USD*/out_pProperties, */*@@@USD*/out_pPropertyCount, &GetObjectInfoTable()); //@@@IOH
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceDisplayPlaneProperties2KHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pPropertyCount,
    StructPointerDecoder<Decoded_VkDisplayPlaneProperties2KHR>/*@@@PLQ*/* pProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPropertyCount = pPropertyCount->IsNull() ? nullptr : pPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceDisplayPlaneProperties2KHR", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceDisplayPlaneProperties2KHR, pPropertyCount, pProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkDisplayPlaneProperties2KHR* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(*/*@@@USD*/out_pPropertyCount, VkDisplayPlaneProperties2KHR{ VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceDisplayPlaneProperties2KHR(in_physicalDevice, /*@@@USD*/out_pPropertyCount, /*@@@USD*/out_pProperties)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceDisplayPlaneProperties2KHR", returnValue, replay_result, call_info);
    if (pProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceDisplayPlaneProperties2KHR, */*@@@USD*/out_pPropertyCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
    AddStructArrayHandles<Decoded_VkDisplayPlaneProperties2KHR>(physicalDevice, pProperties->GetMetaStructPointer(), pProperties->GetLength(), /*@@@USD*/out_pProperties, */*@@@USD*/out_pPropertyCount, &GetObjectInfoTable()); //@@@IOH
}

void VulkanReplayConsumer::Process_vkGetDisplayModeProperties2KHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display,
    PointerDecoder<uint32_t>*                   pPropertyCount,
    StructPointerDecoder<Decoded_VkDisplayModeProperties2KHR>/*@@@PLQ*/* pProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    VkDisplayKHR in_display = /*@@@QKJ*/MapHandle<DisplayKHRInfo>(display, &VulkanObjectInfoTable::GetDisplayKHRInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPropertyCount = pPropertyCount->IsNull() ? nullptr : pPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, DisplayKHRInfo>("vkGetDisplayModeProperties2KHR", returnValue, display, kDisplayKHRArrayGetDisplayModeProperties2KHR, pPropertyCount, pProperties, &VulkanObjectInfoTable::GetDisplayKHRInfo));
    /*@@@HPA*/VkDisplayModeProperties2KHR* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(*/*@@@USD*/out_pPropertyCount, VkDisplayModeProperties2KHR{ VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetDisplayModeProperties2KHR(in_physicalDevice, in_display, /*@@@USD*/out_pPropertyCount, /*@@@USD*/out_pProperties)/*@@@ABC*/;
    CheckResult("vkGetDisplayModeProperties2KHR", returnValue, replay_result, call_info);
    if (pProperties->IsNull()) { SetOutputArrayCount<DisplayKHRInfo>(display, kDisplayKHRArrayGetDisplayModeProperties2KHR, */*@@@USD*/out_pPropertyCount, &VulkanObjectInfoTable::GetDisplayKHRInfo); }
    AddStructArrayHandles<Decoded_VkDisplayModeProperties2KHR>(physicalDevice, pProperties->GetMetaStructPointer(), pProperties->GetLength(), /*@@@USD*/out_pProperties, */*@@@USD*/out_pPropertyCount, &GetObjectInfoTable()); //@@@IOH
}

void VulkanReplayConsumer::Process_vkGetDisplayPlaneCapabilities2KHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkDisplayPlaneInfo2KHR>/*@@@PLQ*/* pDisplayPlaneInfo,
    StructPointerDecoder<Decoded_VkDisplayPlaneCapabilities2KHR>/*@@@PLQ*/* pCapabilities)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkDisplayPlaneInfo2KHR* /*@@@AZI*/in_pDisplayPlaneInfo = /*@@@HUY*/pDisplayPlaneInfo->GetPointer();
    MapStructHandles(pDisplayPlaneInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkDisplayPlaneCapabilities2KHR* /*@@@USD*/out_pCapabilities = pCapabilities->IsNull() ? nullptr : pCapabilities->AllocateOutputData(1, { VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR, nullptr });
    InitializeOutputStructPNext(pCapabilities);//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetDisplayPlaneCapabilities2KHR(in_physicalDevice, /*@@@AZI*/in_pDisplayPlaneInfo, /*@@@USD*/out_pCapabilities)/*@@@ABC*/;
    CheckResult("vkGetDisplayPlaneCapabilities2KHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetImageMemoryRequirements2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkImageMemoryRequirementsInfo2>/*@@@PLQ*/* pInfo,
    StructPointerDecoder<Decoded_VkMemoryRequirements2>/*@@@PLQ*/* pMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkImageMemoryRequirementsInfo2* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkMemoryRequirements2* /*@@@USD*/out_pMemoryRequirements = pMemoryRequirements->IsNull() ? nullptr : pMemoryRequirements->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, nullptr });
    InitializeOutputStructPNext(pMemoryRequirements);//@@@DFK
    GetDeviceTable(in_device)->GetImageMemoryRequirements2KHR(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pMemoryRequirements)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetBufferMemoryRequirements2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkBufferMemoryRequirementsInfo2>/*@@@PLQ*/* pInfo,
    StructPointerDecoder<Decoded_VkMemoryRequirements2>/*@@@PLQ*/* pMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkBufferMemoryRequirementsInfo2* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkMemoryRequirements2* /*@@@USD*/out_pMemoryRequirements = pMemoryRequirements->IsNull() ? nullptr : pMemoryRequirements->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, nullptr });
    InitializeOutputStructPNext(pMemoryRequirements);//@@@DFK
    GetDeviceTable(in_device)->GetBufferMemoryRequirements2KHR(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pMemoryRequirements)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetImageSparseMemoryRequirements2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkImageSparseMemoryRequirementsInfo2>/*@@@PLQ*/* pInfo,
    PointerDecoder<uint32_t>*                   pSparseMemoryRequirementCount,
    StructPointerDecoder<Decoded_VkSparseImageMemoryRequirements2>/*@@@PLQ*/* pSparseMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkImageSparseMemoryRequirementsInfo2* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pSparseMemoryRequirementCount = pSparseMemoryRequirementCount->IsNull() ? nullptr : pSparseMemoryRequirementCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, DeviceInfo>("vkGetImageSparseMemoryRequirements2KHR", VK_SUCCESS, device, kDeviceArrayGetImageSparseMemoryRequirements2KHR, pSparseMemoryRequirementCount, pSparseMemoryRequirements, &VulkanObjectInfoTable::GetDeviceInfo));
    /*@@@HPA*/VkSparseImageMemoryRequirements2* /*@@@USD*/out_pSparseMemoryRequirements = pSparseMemoryRequirements->IsNull() ? nullptr : pSparseMemoryRequirements->AllocateOutputData(*/*@@@USD*/out_pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2{ VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    GetDeviceTable(in_device)->GetImageSparseMemoryRequirements2KHR(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pSparseMemoryRequirementCount, /*@@@USD*/out_pSparseMemoryRequirements)/*@@@ABC*/;//@@@HQA
    if (pSparseMemoryRequirements->IsNull()) { SetOutputArrayCount<DeviceInfo>(device, kDeviceArrayGetImageSparseMemoryRequirements2KHR, */*@@@USD*/out_pSparseMemoryRequirementCount, &VulkanObjectInfoTable::GetDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkCreateSamplerYcbcrConversionKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkSamplerYcbcrConversionCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSamplerYcbcrConversion>* pYcbcrConversion)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkSamplerYcbcrConversionCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pYcbcrConversion->IsNull()) { pYcbcrConversion->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkSamplerYcbcrConversion* /*@@@USD*/out_pYcbcrConversion = pYcbcrConversion->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateSamplerYcbcrConversionKHR(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pYcbcrConversion)/*@@@ABC*/;
    CheckResult("vkCreateSamplerYcbcrConversionKHR", returnValue, replay_result, call_info);
    AddHandle<SamplerYcbcrConversionInfo>(device, pYcbcrConversion->GetPointer(), /*@@@USD*/out_pYcbcrConversion, &VulkanObjectInfoTable::AddSamplerYcbcrConversionInfo);
}

void VulkanReplayConsumer::Process_vkDestroySamplerYcbcrConversionKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            ycbcrConversion,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSamplerYcbcrConversion in_ycbcrConversion = /*@@@QKJ*/MapHandle<SamplerYcbcrConversionInfo>(ycbcrConversion, &VulkanObjectInfoTable::GetSamplerYcbcrConversionInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroySamplerYcbcrConversionKHR(in_device, in_ycbcrConversion, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(ycbcrConversion, &VulkanObjectInfoTable::RemoveSamplerYcbcrConversionInfo);
}

void VulkanReplayConsumer::Process_vkBindBufferMemory2KHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    StructPointerDecoder<Decoded_VkBindBufferMemoryInfo>/*@@@PLQ*/* pBindInfos)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    /*@@@HWC*/MapStructArrayHandles(pBindInfos->GetMetaStructPointer(), pBindInfos->GetLength(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = OverrideBindBufferMemory2(GetDeviceTable(in_device->handle)->BindBufferMemory2KHR, returnValue, in_device, bindInfoCount, pBindInfos)/*@@@HNM*/;
    CheckResult("vkBindBufferMemory2KHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkBindImageMemory2KHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    StructPointerDecoder<Decoded_VkBindImageMemoryInfo>/*@@@PLQ*/* pBindInfos)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    /*@@@HWC*/MapStructArrayHandles(pBindInfos->GetMetaStructPointer(), pBindInfos->GetLength(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = OverrideBindImageMemory2(GetDeviceTable(in_device->handle)->BindImageMemory2KHR, returnValue, in_device, bindInfoCount, pBindInfos)/*@@@HNM*/;
    CheckResult("vkBindImageMemory2KHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetDescriptorSetLayoutSupportKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDescriptorSetLayoutCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkDescriptorSetLayoutSupport>/*@@@PLQ*/* pSupport)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDescriptorSetLayoutCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkDescriptorSetLayoutSupport* /*@@@USD*/out_pSupport = pSupport->IsNull() ? nullptr : pSupport->AllocateOutputData(1, { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT, nullptr });
    InitializeOutputStructPNext(pSupport);//@@@DFK
    GetDeviceTable(in_device)->GetDescriptorSetLayoutSupportKHR(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@USD*/out_pSupport)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdDrawIndirectCountKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);
    VkBuffer in_countBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(countBuffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawIndirectCountKHR(in_commandBuffer, in_buffer, offset, in_countBuffer, countBufferOffset, maxDrawCount, stride)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawIndirectCountKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDrawIndirectCountKHRHandles(in_commandBuffer, in_buffer, in_countBuffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdDrawIndexedIndirectCountKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);
    VkBuffer in_countBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(countBuffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawIndexedIndirectCountKHR(in_commandBuffer, in_buffer, offset, in_countBuffer, countBufferOffset, maxDrawCount, stride)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawIndexedIndirectCountKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDrawIndexedIndirectCountKHRHandles(in_commandBuffer, in_buffer, in_countBuffer);

    }
}

void VulkanReplayConsumer::Process_vkGetSemaphoreCounterValueKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            semaphore,
    PointerDecoder<uint64_t>*                   pValue)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSemaphore in_semaphore = /*@@@QKJ*/MapHandle<SemaphoreInfo>(semaphore, &VulkanObjectInfoTable::GetSemaphoreInfo);
    /*@@@HPA*/uint64_t* /*@@@USD*/out_pValue = pValue->IsNull() ? nullptr : pValue->AllocateOutputData(1, static_cast<uint64_t>(0));//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetSemaphoreCounterValueKHR(in_device, in_semaphore, /*@@@USD*/out_pValue)/*@@@ABC*/;
    CheckResult("vkGetSemaphoreCounterValueKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkWaitSemaphoresKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkSemaphoreWaitInfo>/*@@@PLQ*/* pWaitInfo,
    uint64_t                                    timeout)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkSemaphoreWaitInfo* /*@@@AZI*/in_pWaitInfo = /*@@@HUY*/pWaitInfo->GetPointer();
    MapStructHandles(pWaitInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->WaitSemaphoresKHR(in_device, /*@@@AZI*/in_pWaitInfo, timeout)/*@@@ABC*/;
    CheckResult("vkWaitSemaphoresKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkSignalSemaphoreKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkSemaphoreSignalInfo>/*@@@PLQ*/* pSignalInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkSemaphoreSignalInfo* /*@@@AZI*/in_pSignalInfo = /*@@@HUY*/pSignalInfo->GetPointer();
    MapStructHandles(pSignalInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->SignalSemaphoreKHR(in_device, /*@@@AZI*/in_pSignalInfo)/*@@@ABC*/;
    CheckResult("vkSignalSemaphoreKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceFragmentShadingRatesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pFragmentShadingRateCount,
    StructPointerDecoder<Decoded_VkPhysicalDeviceFragmentShadingRateKHR>/*@@@PLQ*/* pFragmentShadingRates)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pFragmentShadingRateCount = pFragmentShadingRateCount->IsNull() ? nullptr : pFragmentShadingRateCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceFragmentShadingRatesKHR", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceFragmentShadingRatesKHR, pFragmentShadingRateCount, pFragmentShadingRates, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkPhysicalDeviceFragmentShadingRateKHR* /*@@@USD*/out_pFragmentShadingRates = pFragmentShadingRates->IsNull() ? nullptr : pFragmentShadingRates->AllocateOutputData(*/*@@@USD*/out_pFragmentShadingRateCount, VkPhysicalDeviceFragmentShadingRateKHR{ VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceFragmentShadingRatesKHR(in_physicalDevice, /*@@@USD*/out_pFragmentShadingRateCount, /*@@@USD*/out_pFragmentShadingRates)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceFragmentShadingRatesKHR", returnValue, replay_result, call_info);
    if (pFragmentShadingRates->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceFragmentShadingRatesKHR, */*@@@USD*/out_pFragmentShadingRateCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkCmdSetFragmentShadingRateKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkExtent2D>/*@@@PLQ*/* pFragmentSize,
    PointerDecoder<VkFragmentShadingRateCombinerOpKHR>* combinerOps)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkExtent2D* /*@@@AZI*/in_pFragmentSize = /*@@@HUY*/pFragmentSize->GetPointer();
    /*@@@HPA*/const VkFragmentShadingRateCombinerOpKHR* /*@@@AZI*/in_combinerOps = /*@@@HUY*/combinerOps->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetFragmentShadingRateKHR(in_commandBuffer, /*@@@AZI*/in_pFragmentSize, /*@@@AZI*/in_combinerOps)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetFragmentShadingRateKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetRenderingAttachmentLocationsKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkRenderingAttachmentLocationInfoKHR>* pLocationInfo)
{
    VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    const VkRenderingAttachmentLocationInfoKHR* in_pLocationInfo = pLocationInfo->GetPointer();

    GetDeviceTable(in_commandBuffer)->CmdSetRenderingAttachmentLocationsKHR(in_commandBuffer, in_pLocationInfo);
}

void VulkanReplayConsumer::Process_vkCmdSetRenderingInputAttachmentIndicesKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkRenderingInputAttachmentIndexInfoKHR>* pLocationInfo)
{
    VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    const VkRenderingInputAttachmentIndexInfoKHR* in_pLocationInfo = pLocationInfo->GetPointer();

    GetDeviceTable(in_commandBuffer)->CmdSetRenderingInputAttachmentIndicesKHR(in_commandBuffer, in_pLocationInfo);
}

void VulkanReplayConsumer::Process_vkWaitForPresentKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    uint64_t                                    presentId,
    uint64_t                                    timeout)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkWaitForPresentKHR for offscreen.");
        return;
    }
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_swapchain = GetObjectInfoTable().GetSwapchainKHRInfo(swapchain);//@@@DFK
    VkResult replay_result = OverrideWaitForPresentKHR(GetDeviceTable(in_device->handle)->WaitForPresentKHR, returnValue, in_device, in_swapchain, presentId, timeout)/*@@@HNM*/;
    CheckResult("vkWaitForPresentKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetBufferDeviceAddressKHR(
    const ApiCallInfo&                          call_info,
    VkDeviceAddress                             returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkBufferDeviceAddressInfo>/*@@@PLQ*/* pInfo)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    OverrideGetBufferDeviceAddress(GetDeviceTable(in_device->handle)->GetBufferDeviceAddressKHR, in_device, pInfo)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetBufferOpaqueCaptureAddressKHR(
    const ApiCallInfo&                          call_info,
    uint64_t                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkBufferDeviceAddressInfo>/*@@@PLQ*/* pInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkBufferDeviceAddressInfo* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    GetDeviceTable(in_device)->GetBufferOpaqueCaptureAddressKHR(in_device, /*@@@AZI*/in_pInfo)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetDeviceMemoryOpaqueCaptureAddressKHR(
    const ApiCallInfo&                          call_info,
    uint64_t                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDeviceMemoryOpaqueCaptureAddressInfo>/*@@@PLQ*/* pInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDeviceMemoryOpaqueCaptureAddressInfo* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    GetDeviceTable(in_device)->GetDeviceMemoryOpaqueCaptureAddressKHR(in_device, /*@@@AZI*/in_pInfo)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCreateDeferredOperationKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkDeferredOperationKHR>* pDeferredOperation)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pDeferredOperation->IsNull()) { pDeferredOperation->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkDeferredOperationKHR* /*@@@USD*/out_pDeferredOperation = pDeferredOperation->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateDeferredOperationKHR(in_device, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pDeferredOperation)/*@@@ABC*/;
    CheckResult("vkCreateDeferredOperationKHR", returnValue, replay_result, call_info);
    AddHandle<DeferredOperationKHRInfo>(device, pDeferredOperation->GetPointer(), /*@@@USD*/out_pDeferredOperation, &VulkanObjectInfoTable::AddDeferredOperationKHRInfo);
}

void VulkanReplayConsumer::Process_vkDestroyDeferredOperationKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            operation,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDeferredOperationKHR in_operation = /*@@@QKJ*/MapHandle<DeferredOperationKHRInfo>(operation, &VulkanObjectInfoTable::GetDeferredOperationKHRInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyDeferredOperationKHR(in_device, in_operation, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(operation, &VulkanObjectInfoTable::RemoveDeferredOperationKHRInfo);
}

void VulkanReplayConsumer::Process_vkGetDeferredOperationMaxConcurrencyKHR(
    const ApiCallInfo&                          call_info,
    uint32_t                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            operation)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDeferredOperationKHR in_operation = /*@@@QKJ*/MapHandle<DeferredOperationKHRInfo>(operation, &VulkanObjectInfoTable::GetDeferredOperationKHRInfo);//@@@DFK
    GetDeviceTable(in_device)->GetDeferredOperationMaxConcurrencyKHR(in_device, in_operation)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetDeferredOperationResultKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            operation)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDeferredOperationKHR in_operation = /*@@@QKJ*/MapHandle<DeferredOperationKHRInfo>(operation, &VulkanObjectInfoTable::GetDeferredOperationKHRInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetDeferredOperationResultKHR(in_device, in_operation)/*@@@ABC*/;
    CheckResult("vkGetDeferredOperationResultKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkDeferredOperationJoinKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            operation)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_operation = GetObjectInfoTable().GetDeferredOperationKHRInfo(operation);//@@@DFK
    VkResult replay_result = OverrideDeferredOperationJoinKHR(GetDeviceTable(in_device->handle)->DeferredOperationJoinKHR, returnValue, in_device, in_operation)/*@@@HNM*/;
    CheckResult("vkDeferredOperationJoinKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPipelineExecutablePropertiesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkPipelineInfoKHR>/*@@@PLQ*/* pPipelineInfo,
    PointerDecoder<uint32_t>*                   pExecutableCount,
    StructPointerDecoder<Decoded_VkPipelineExecutablePropertiesKHR>/*@@@PLQ*/* pProperties)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkPipelineInfoKHR* /*@@@AZI*/in_pPipelineInfo = /*@@@HUY*/pPipelineInfo->GetPointer();
    MapStructHandles(pPipelineInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pExecutableCount = pExecutableCount->IsNull() ? nullptr : pExecutableCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, DeviceInfo>("vkGetPipelineExecutablePropertiesKHR", returnValue, device, kDeviceArrayGetPipelineExecutablePropertiesKHR, pExecutableCount, pProperties, &VulkanObjectInfoTable::GetDeviceInfo));
    /*@@@HPA*/VkPipelineExecutablePropertiesKHR* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(*/*@@@USD*/out_pExecutableCount, VkPipelineExecutablePropertiesKHR{ VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetPipelineExecutablePropertiesKHR(in_device, /*@@@AZI*/in_pPipelineInfo, /*@@@USD*/out_pExecutableCount, /*@@@USD*/out_pProperties)/*@@@ABC*/;
    CheckResult("vkGetPipelineExecutablePropertiesKHR", returnValue, replay_result, call_info);
    if (pProperties->IsNull()) { SetOutputArrayCount<DeviceInfo>(device, kDeviceArrayGetPipelineExecutablePropertiesKHR, */*@@@USD*/out_pExecutableCount, &VulkanObjectInfoTable::GetDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkGetPipelineExecutableStatisticsKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkPipelineExecutableInfoKHR>/*@@@PLQ*/* pExecutableInfo,
    PointerDecoder<uint32_t>*                   pStatisticCount,
    StructPointerDecoder<Decoded_VkPipelineExecutableStatisticKHR>/*@@@PLQ*/* pStatistics)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkPipelineExecutableInfoKHR* /*@@@AZI*/in_pExecutableInfo = /*@@@HUY*/pExecutableInfo->GetPointer();
    MapStructHandles(pExecutableInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pStatisticCount = pStatisticCount->IsNull() ? nullptr : pStatisticCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, DeviceInfo>("vkGetPipelineExecutableStatisticsKHR", returnValue, device, kDeviceArrayGetPipelineExecutableStatisticsKHR, pStatisticCount, pStatistics, &VulkanObjectInfoTable::GetDeviceInfo));
    /*@@@HPA*/VkPipelineExecutableStatisticKHR* /*@@@USD*/out_pStatistics = pStatistics->IsNull() ? nullptr : pStatistics->AllocateOutputData(*/*@@@USD*/out_pStatisticCount, VkPipelineExecutableStatisticKHR{ VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetPipelineExecutableStatisticsKHR(in_device, /*@@@AZI*/in_pExecutableInfo, /*@@@USD*/out_pStatisticCount, /*@@@USD*/out_pStatistics)/*@@@ABC*/;
    CheckResult("vkGetPipelineExecutableStatisticsKHR", returnValue, replay_result, call_info);
    if (pStatistics->IsNull()) { SetOutputArrayCount<DeviceInfo>(device, kDeviceArrayGetPipelineExecutableStatisticsKHR, */*@@@USD*/out_pStatisticCount, &VulkanObjectInfoTable::GetDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkGetPipelineExecutableInternalRepresentationsKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkPipelineExecutableInfoKHR>/*@@@PLQ*/* pExecutableInfo,
    PointerDecoder<uint32_t>*                   pInternalRepresentationCount,
    StructPointerDecoder<Decoded_VkPipelineExecutableInternalRepresentationKHR>/*@@@PLQ*/* pInternalRepresentations)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkPipelineExecutableInfoKHR* /*@@@AZI*/in_pExecutableInfo = /*@@@HUY*/pExecutableInfo->GetPointer();
    MapStructHandles(pExecutableInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pInternalRepresentationCount = pInternalRepresentationCount->IsNull() ? nullptr : pInternalRepresentationCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, DeviceInfo>("vkGetPipelineExecutableInternalRepresentationsKHR", returnValue, device, kDeviceArrayGetPipelineExecutableInternalRepresentationsKHR, pInternalRepresentationCount, pInternalRepresentations, &VulkanObjectInfoTable::GetDeviceInfo));
    /*@@@HPA*/VkPipelineExecutableInternalRepresentationKHR* /*@@@USD*/out_pInternalRepresentations = pInternalRepresentations->IsNull() ? nullptr : pInternalRepresentations->AllocateOutputData(*/*@@@USD*/out_pInternalRepresentationCount, VkPipelineExecutableInternalRepresentationKHR{ VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetPipelineExecutableInternalRepresentationsKHR(in_device, /*@@@AZI*/in_pExecutableInfo, /*@@@USD*/out_pInternalRepresentationCount, /*@@@USD*/out_pInternalRepresentations)/*@@@ABC*/;
    CheckResult("vkGetPipelineExecutableInternalRepresentationsKHR", returnValue, replay_result, call_info);
    if (pInternalRepresentations->IsNull()) { SetOutputArrayCount<DeviceInfo>(device, kDeviceArrayGetPipelineExecutableInternalRepresentationsKHR, */*@@@USD*/out_pInternalRepresentationCount, &VulkanObjectInfoTable::GetDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkMapMemory2KHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkMemoryMapInfoKHR>/*@@@PLQ*/* pMemoryMapInfo,
    PointerDecoder<uint64_t, void*>*            ppData)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkMemoryMapInfoKHR* /*@@@AZI*/in_pMemoryMapInfo = /*@@@HUY*/pMemoryMapInfo->GetPointer();
    MapStructHandles(pMemoryMapInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/void** /*@@@USD*/out_ppData = ppData->IsNull() ? nullptr : ppData->AllocateOutputData(1);//@@@PEA//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->MapMemory2KHR(in_device, /*@@@AZI*/in_pMemoryMapInfo, /*@@@USD*/out_ppData)/*@@@ABC*/;
    CheckResult("vkMapMemory2KHR", returnValue, replay_result, call_info);
    PostProcessExternalObject(replay_result, (*ppData->GetPointer()), *ppData->GetOutputPointer(), format::ApiCallId::ApiCall_vkMapMemory2KHR, "vkMapMemory2KHR");//@@EDS
}

void VulkanReplayConsumer::Process_vkUnmapMemory2KHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkMemoryUnmapInfoKHR>/*@@@PLQ*/* pMemoryUnmapInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkMemoryUnmapInfoKHR* /*@@@AZI*/in_pMemoryUnmapInfo = /*@@@HUY*/pMemoryUnmapInfo->GetPointer();
    MapStructHandles(pMemoryUnmapInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->UnmapMemory2KHR(in_device, /*@@@AZI*/in_pMemoryUnmapInfo)/*@@@ABC*/;
    CheckResult("vkUnmapMemory2KHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR>/*@@@PLQ*/* pQualityLevelInfo,
    StructPointerDecoder<Decoded_VkVideoEncodeQualityLevelPropertiesKHR>/*@@@PLQ*/* pQualityLevelProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* /*@@@AZI*/in_pQualityLevelInfo = /*@@@HUY*/pQualityLevelInfo->GetPointer();
    /*@@@HPA*/VkVideoEncodeQualityLevelPropertiesKHR* /*@@@USD*/out_pQualityLevelProperties = pQualityLevelProperties->IsNull() ? nullptr : pQualityLevelProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR, nullptr });
    InitializeOutputStructPNext(pQualityLevelProperties);//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR(in_physicalDevice, /*@@@AZI*/in_pQualityLevelInfo, /*@@@USD*/out_pQualityLevelProperties)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceVideoEncodeQualityLevelPropertiesKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetEncodedVideoSessionParametersKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkVideoEncodeSessionParametersGetInfoKHR>/*@@@PLQ*/* pVideoSessionParametersInfo,
    StructPointerDecoder<Decoded_VkVideoEncodeSessionParametersFeedbackInfoKHR>/*@@@PLQ*/* pFeedbackInfo,
    PointerDecoder<size_t>*                     pDataSize,
    PointerDecoder<uint8_t>*                    pData)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkVideoEncodeSessionParametersGetInfoKHR* /*@@@AZI*/in_pVideoSessionParametersInfo = /*@@@HUY*/pVideoSessionParametersInfo->GetPointer();
    MapStructHandles(pVideoSessionParametersInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkVideoEncodeSessionParametersFeedbackInfoKHR* /*@@@USD*/out_pFeedbackInfo = pFeedbackInfo->IsNull() ? nullptr : pFeedbackInfo->AllocateOutputData(1, { VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR, nullptr });
    InitializeOutputStructPNext(pFeedbackInfo);
    /*@@@HPA*/size_t* /*@@@USD*/out_pDataSize = pDataSize->IsNull() ? nullptr : pDataSize->AllocateOutputData(1, GetOutputArrayCount<size_t, DeviceInfo>("vkGetEncodedVideoSessionParametersKHR", returnValue, device, kDeviceArrayGetEncodedVideoSessionParametersKHR, pDataSize, pData, &VulkanObjectInfoTable::GetDeviceInfo));
    /*@@@HPA*/void* /*@@@USD*/out_pData = pData->IsNull() ? nullptr : pData->AllocateOutputData(*/*@@@USD*/out_pDataSize);//@@@EJH//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetEncodedVideoSessionParametersKHR(in_device, /*@@@AZI*/in_pVideoSessionParametersInfo, /*@@@USD*/out_pFeedbackInfo, /*@@@USD*/out_pDataSize, /*@@@USD*/out_pData)/*@@@ABC*/;
    CheckResult("vkGetEncodedVideoSessionParametersKHR", returnValue, replay_result, call_info);
    if (pData->IsNull()) { SetOutputArrayCount<DeviceInfo>(device, kDeviceArrayGetEncodedVideoSessionParametersKHR, */*@@@USD*/out_pDataSize, &VulkanObjectInfoTable::GetDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkCmdEncodeVideoKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkVideoEncodeInfoKHR>/*@@@PLQ*/* pEncodeInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkVideoEncodeInfoKHR* /*@@@AZI*/in_pEncodeInfo = /*@@@HUY*/pEncodeInfo->GetPointer();
    MapStructHandles(pEncodeInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdEncodeVideoKHR(in_commandBuffer, /*@@@AZI*/in_pEncodeInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdEncodeVideoKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdEncodeVideoKHRHandles(in_commandBuffer, in_pEncodeInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdSetEvent2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            event,
    StructPointerDecoder<Decoded_VkDependencyInfo>/*@@@PLQ*/* pDependencyInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkEvent in_event = /*@@@QKJ*/MapHandle<EventInfo>(event, &VulkanObjectInfoTable::GetEventInfo);
    /*@@@HPA*/const VkDependencyInfo* /*@@@AZI*/in_pDependencyInfo = /*@@@HUY*/pDependencyInfo->GetPointer();
    MapStructHandles(pDependencyInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetEvent2KHR(in_commandBuffer, in_event, /*@@@AZI*/in_pDependencyInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetEvent2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdSetEvent2KHRHandles(in_commandBuffer, in_event, in_pDependencyInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdResetEvent2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            event,
    VkPipelineStageFlags2                       stageMask)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkEvent in_event = /*@@@QKJ*/MapHandle<EventInfo>(event, &VulkanObjectInfoTable::GetEventInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdResetEvent2KHR(in_commandBuffer, in_event, stageMask)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdResetEvent2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdResetEvent2KHRHandles(in_commandBuffer, in_event);

    }
}

void VulkanReplayConsumer::Process_vkCmdWaitEvents2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    eventCount,
    HandlePointerDecoder<VkEvent>*              pEvents,
    StructPointerDecoder<Decoded_VkDependencyInfo>/*@@@PLQ*/* pDependencyInfos)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkEvent* /*@@@AZI*/in_pEvents = /*@@@EDO*/MapHandles<EventInfo>(pEvents, eventCount, &VulkanObjectInfoTable::GetEventInfo);
    /*@@@HPA*/const VkDependencyInfo* /*@@@AZI*/in_pDependencyInfos = /*@@@HUY*/pDependencyInfos->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pDependencyInfos->GetMetaStructPointer(), pDependencyInfos->GetLength(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdWaitEvents2KHR(in_commandBuffer, eventCount, /*@@@AZI*/in_pEvents, /*@@@AZI*/in_pDependencyInfos)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdWaitEvents2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdWaitEvents2KHRHandles(in_commandBuffer, eventCount, in_pEvents, in_pDependencyInfos);

    }
}

void VulkanReplayConsumer::Process_vkCmdPipelineBarrier2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkDependencyInfo>/*@@@PLQ*/* pDependencyInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkDependencyInfo* /*@@@AZI*/in_pDependencyInfo = /*@@@HUY*/pDependencyInfo->GetPointer();
    MapStructHandles(pDependencyInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdPipelineBarrier2KHR(in_commandBuffer, /*@@@AZI*/in_pDependencyInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdPipelineBarrier2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdPipelineBarrier2KHRHandles(in_commandBuffer, in_pDependencyInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdWriteTimestamp2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkPipelineStageFlags2                       stage,
    format::HandleId                            queryPool,
    uint32_t                                    query)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdWriteTimestamp2KHR(in_commandBuffer, stage, in_queryPool, query)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdWriteTimestamp2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdWriteTimestamp2KHRHandles(in_commandBuffer, in_queryPool);

    }
}

void VulkanReplayConsumer::Process_vkQueueSubmit2KHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            queue,
    uint32_t                                    submitCount,
    StructPointerDecoder<Decoded_VkSubmitInfo2>/*@@@PLQ*/* pSubmits,
    format::HandleId                            fence)
{
    auto in_queue = GetObjectInfoTable().GetQueueInfo(queue);

    /*@@@HWC*/MapStructArrayHandles(pSubmits->GetMetaStructPointer(), pSubmits->GetLength(), GetObjectInfoTable());
    auto in_fence = GetObjectInfoTable().GetFenceInfo(fence);//@@@DFK
    VkResult replay_result = OverrideQueueSubmit2(GetDeviceTable(in_queue->handle)->QueueSubmit2KHR, returnValue, in_queue, submitCount, pSubmits, in_fence)/*@@@HNM*/;
    CheckResult("vkQueueSubmit2KHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdWriteBufferMarker2AMD(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkPipelineStageFlags2                       stage,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    uint32_t                                    marker)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_dstBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(dstBuffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdWriteBufferMarker2AMD(in_commandBuffer, stage, in_dstBuffer, dstOffset, marker)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdWriteBufferMarker2AMD;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdWriteBufferMarker2AMDHandles(in_commandBuffer, in_dstBuffer);

    }
}

void VulkanReplayConsumer::Process_vkGetQueueCheckpointData2NV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            queue,
    PointerDecoder<uint32_t>*                   pCheckpointDataCount,
    StructPointerDecoder<Decoded_VkCheckpointData2NV>/*@@@PLQ*/* pCheckpointData)
{
    VkQueue in_queue = /*@@@QKJ*/MapHandle<QueueInfo>(queue, &VulkanObjectInfoTable::GetQueueInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pCheckpointDataCount = pCheckpointDataCount->IsNull() ? nullptr : pCheckpointDataCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, QueueInfo>("vkGetQueueCheckpointData2NV", VK_SUCCESS, queue, kQueueArrayGetQueueCheckpointData2NV, pCheckpointDataCount, pCheckpointData, &VulkanObjectInfoTable::GetQueueInfo));
    /*@@@HPA*/VkCheckpointData2NV* /*@@@USD*/out_pCheckpointData = pCheckpointData->IsNull() ? nullptr : pCheckpointData->AllocateOutputData(*/*@@@USD*/out_pCheckpointDataCount, VkCheckpointData2NV{ VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    GetDeviceTable(in_queue)->GetQueueCheckpointData2NV(in_queue, /*@@@USD*/out_pCheckpointDataCount, /*@@@USD*/out_pCheckpointData)/*@@@ABC*/;//@@@HQA
    if (pCheckpointData->IsNull()) { SetOutputArrayCount<QueueInfo>(queue, kQueueArrayGetQueueCheckpointData2NV, */*@@@USD*/out_pCheckpointDataCount, &VulkanObjectInfoTable::GetQueueInfo); }
}

void VulkanReplayConsumer::Process_vkCmdCopyBuffer2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCopyBufferInfo2>/*@@@PLQ*/* pCopyBufferInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCopyBufferInfo2* /*@@@AZI*/in_pCopyBufferInfo = /*@@@HUY*/pCopyBufferInfo->GetPointer();
    MapStructHandles(pCopyBufferInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyBuffer2KHR(in_commandBuffer, /*@@@AZI*/in_pCopyBufferInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyBuffer2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyBuffer2KHRHandles(in_commandBuffer, in_pCopyBufferInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyImage2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCopyImageInfo2>/*@@@PLQ*/* pCopyImageInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCopyImageInfo2* /*@@@AZI*/in_pCopyImageInfo = /*@@@HUY*/pCopyImageInfo->GetPointer();
    MapStructHandles(pCopyImageInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyImage2KHR(in_commandBuffer, /*@@@AZI*/in_pCopyImageInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyImage2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyImage2KHRHandles(in_commandBuffer, in_pCopyImageInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyBufferToImage2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCopyBufferToImageInfo2>/*@@@PLQ*/* pCopyBufferToImageInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCopyBufferToImageInfo2* /*@@@AZI*/in_pCopyBufferToImageInfo = /*@@@HUY*/pCopyBufferToImageInfo->GetPointer();
    MapStructHandles(pCopyBufferToImageInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyBufferToImage2KHR(in_commandBuffer, /*@@@AZI*/in_pCopyBufferToImageInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyBufferToImage2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyBufferToImage2KHRHandles(in_commandBuffer, in_pCopyBufferToImageInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyImageToBuffer2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCopyImageToBufferInfo2>/*@@@PLQ*/* pCopyImageToBufferInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCopyImageToBufferInfo2* /*@@@AZI*/in_pCopyImageToBufferInfo = /*@@@HUY*/pCopyImageToBufferInfo->GetPointer();
    MapStructHandles(pCopyImageToBufferInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyImageToBuffer2KHR(in_commandBuffer, /*@@@AZI*/in_pCopyImageToBufferInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyImageToBuffer2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyImageToBuffer2KHRHandles(in_commandBuffer, in_pCopyImageToBufferInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdBlitImage2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkBlitImageInfo2>/*@@@PLQ*/* pBlitImageInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkBlitImageInfo2* /*@@@AZI*/in_pBlitImageInfo = /*@@@HUY*/pBlitImageInfo->GetPointer();
    MapStructHandles(pBlitImageInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBlitImage2KHR(in_commandBuffer, /*@@@AZI*/in_pBlitImageInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBlitImage2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBlitImage2KHRHandles(in_commandBuffer, in_pBlitImageInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdResolveImage2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkResolveImageInfo2>/*@@@PLQ*/* pResolveImageInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkResolveImageInfo2* /*@@@AZI*/in_pResolveImageInfo = /*@@@HUY*/pResolveImageInfo->GetPointer();
    MapStructHandles(pResolveImageInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdResolveImage2KHR(in_commandBuffer, /*@@@AZI*/in_pResolveImageInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdResolveImage2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdResolveImage2KHRHandles(in_commandBuffer, in_pResolveImageInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdTraceRaysIndirect2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkDeviceAddress                             indirectDeviceAddress)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdTraceRaysIndirect2KHR(in_commandBuffer, indirectDeviceAddress)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdTraceRaysIndirect2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkGetDeviceBufferMemoryRequirementsKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDeviceBufferMemoryRequirements>/*@@@PLQ*/* pInfo,
    StructPointerDecoder<Decoded_VkMemoryRequirements2>/*@@@PLQ*/* pMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDeviceBufferMemoryRequirements* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    /*@@@HPA*/VkMemoryRequirements2* /*@@@USD*/out_pMemoryRequirements = pMemoryRequirements->IsNull() ? nullptr : pMemoryRequirements->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, nullptr });
    InitializeOutputStructPNext(pMemoryRequirements);//@@@DFK
    GetDeviceTable(in_device)->GetDeviceBufferMemoryRequirementsKHR(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pMemoryRequirements)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetDeviceImageMemoryRequirementsKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDeviceImageMemoryRequirements>/*@@@PLQ*/* pInfo,
    StructPointerDecoder<Decoded_VkMemoryRequirements2>/*@@@PLQ*/* pMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDeviceImageMemoryRequirements* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkMemoryRequirements2* /*@@@USD*/out_pMemoryRequirements = pMemoryRequirements->IsNull() ? nullptr : pMemoryRequirements->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, nullptr });
    InitializeOutputStructPNext(pMemoryRequirements);//@@@DFK
    GetDeviceTable(in_device)->GetDeviceImageMemoryRequirementsKHR(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pMemoryRequirements)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetDeviceImageSparseMemoryRequirementsKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDeviceImageMemoryRequirements>/*@@@PLQ*/* pInfo,
    PointerDecoder<uint32_t>*                   pSparseMemoryRequirementCount,
    StructPointerDecoder<Decoded_VkSparseImageMemoryRequirements2>/*@@@PLQ*/* pSparseMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDeviceImageMemoryRequirements* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pSparseMemoryRequirementCount = pSparseMemoryRequirementCount->IsNull() ? nullptr : pSparseMemoryRequirementCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, DeviceInfo>("vkGetDeviceImageSparseMemoryRequirementsKHR", VK_SUCCESS, device, kDeviceArrayGetDeviceImageSparseMemoryRequirementsKHR, pSparseMemoryRequirementCount, pSparseMemoryRequirements, &VulkanObjectInfoTable::GetDeviceInfo));
    /*@@@HPA*/VkSparseImageMemoryRequirements2* /*@@@USD*/out_pSparseMemoryRequirements = pSparseMemoryRequirements->IsNull() ? nullptr : pSparseMemoryRequirements->AllocateOutputData(*/*@@@USD*/out_pSparseMemoryRequirementCount, VkSparseImageMemoryRequirements2{ VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    GetDeviceTable(in_device)->GetDeviceImageSparseMemoryRequirementsKHR(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pSparseMemoryRequirementCount, /*@@@USD*/out_pSparseMemoryRequirements)/*@@@ABC*/;//@@@HQA
    if (pSparseMemoryRequirements->IsNull()) { SetOutputArrayCount<DeviceInfo>(device, kDeviceArrayGetDeviceImageSparseMemoryRequirementsKHR, */*@@@USD*/out_pSparseMemoryRequirementCount, &VulkanObjectInfoTable::GetDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkCmdBindIndexBuffer2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    VkDeviceSize                                size,
    VkIndexType                                 indexType)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBindIndexBuffer2KHR(in_commandBuffer, in_buffer, offset, size, indexType)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBindIndexBuffer2KHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBindIndexBuffer2KHRHandles(in_commandBuffer, in_buffer);

    }
}

void VulkanReplayConsumer::Process_vkGetRenderingAreaGranularityKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkRenderingAreaInfoKHR>/*@@@PLQ*/* pRenderingAreaInfo,
    StructPointerDecoder<Decoded_VkExtent2D>/*@@@PLQ*/* pGranularity)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkRenderingAreaInfoKHR* /*@@@AZI*/in_pRenderingAreaInfo = /*@@@HUY*/pRenderingAreaInfo->GetPointer();
    /*@@@HPA*/VkExtent2D* /*@@@USD*/out_pGranularity = pGranularity->IsNull() ? nullptr : pGranularity->AllocateOutputData(1);//@@@DFK
    GetDeviceTable(in_device)->GetRenderingAreaGranularityKHR(in_device, /*@@@AZI*/in_pRenderingAreaInfo, /*@@@USD*/out_pGranularity)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetDeviceImageSubresourceLayoutKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDeviceImageSubresourceInfoKHR>/*@@@PLQ*/* pInfo,
    StructPointerDecoder<Decoded_VkSubresourceLayout2KHR>/*@@@PLQ*/* pLayout)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDeviceImageSubresourceInfoKHR* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkSubresourceLayout2KHR* /*@@@USD*/out_pLayout = pLayout->IsNull() ? nullptr : pLayout->AllocateOutputData(1, { VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR, nullptr });
    InitializeOutputStructPNext(pLayout);//@@@DFK
    GetDeviceTable(in_device)->GetDeviceImageSubresourceLayoutKHR(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pLayout)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetImageSubresourceLayout2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            image,
    StructPointerDecoder<Decoded_VkImageSubresource2KHR>/*@@@PLQ*/* pSubresource,
    StructPointerDecoder<Decoded_VkSubresourceLayout2KHR>/*@@@PLQ*/* pLayout)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkImage in_image = /*@@@QKJ*/MapHandle<ImageInfo>(image, &VulkanObjectInfoTable::GetImageInfo);
    /*@@@HPA*/const VkImageSubresource2KHR* /*@@@AZI*/in_pSubresource = /*@@@HUY*/pSubresource->GetPointer();
    /*@@@HPA*/VkSubresourceLayout2KHR* /*@@@USD*/out_pLayout = pLayout->IsNull() ? nullptr : pLayout->AllocateOutputData(1, { VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR, nullptr });
    InitializeOutputStructPNext(pLayout);//@@@DFK
    GetDeviceTable(in_device)->GetImageSubresourceLayout2KHR(in_device, in_image, /*@@@AZI*/in_pSubresource, /*@@@USD*/out_pLayout)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pPropertyCount,
    StructPointerDecoder<Decoded_VkCooperativeMatrixPropertiesKHR>/*@@@PLQ*/* pProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPropertyCount = pPropertyCount->IsNull() ? nullptr : pPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceCooperativeMatrixPropertiesKHR, pPropertyCount, pProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkCooperativeMatrixPropertiesKHR* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(*/*@@@USD*/out_pPropertyCount, VkCooperativeMatrixPropertiesKHR{ VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceCooperativeMatrixPropertiesKHR(in_physicalDevice, /*@@@USD*/out_pPropertyCount, /*@@@USD*/out_pProperties)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceCooperativeMatrixPropertiesKHR", returnValue, replay_result, call_info);
    if (pProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceCooperativeMatrixPropertiesKHR, */*@@@USD*/out_pPropertyCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkCmdSetLineStippleKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    lineStippleFactor,
    uint16_t                                    lineStipplePattern)
{
    VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

    GetDeviceTable(in_commandBuffer)->CmdSetLineStippleKHR(in_commandBuffer, lineStippleFactor, lineStipplePattern);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceCalibrateableTimeDomainsKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pTimeDomainCount,
    PointerDecoder<VkTimeDomainKHR>*            pTimeDomains)
{
    VkPhysicalDevice in_physicalDevice = MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    uint32_t* out_pTimeDomainCount = pTimeDomainCount->IsNull() ? nullptr : pTimeDomainCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceCalibrateableTimeDomainsKHR", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceCalibrateableTimeDomainsKHR, pTimeDomainCount, pTimeDomains, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    VkTimeDomainKHR* out_pTimeDomains = pTimeDomains->IsNull() ? nullptr : pTimeDomains->AllocateOutputData(*out_pTimeDomainCount);

    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceCalibrateableTimeDomainsKHR(in_physicalDevice, out_pTimeDomainCount, out_pTimeDomains);
    CheckResult("vkGetPhysicalDeviceCalibrateableTimeDomainsKHR", returnValue, replay_result, call_info);

    if (pTimeDomains->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceCalibrateableTimeDomainsKHR, *out_pTimeDomainCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkGetCalibratedTimestampsKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    timestampCount,
    StructPointerDecoder<Decoded_VkCalibratedTimestampInfoKHR>* pTimestampInfos,
    PointerDecoder<uint64_t>*                   pTimestamps,
    PointerDecoder<uint64_t>*                   pMaxDeviation)
{
    VkDevice in_device = MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    const VkCalibratedTimestampInfoKHR* in_pTimestampInfos = pTimestampInfos->GetPointer();
    uint64_t* out_pTimestamps = pTimestamps->IsNull() ? nullptr : pTimestamps->AllocateOutputData(timestampCount);
    uint64_t* out_pMaxDeviation = pMaxDeviation->IsNull() ? nullptr : pMaxDeviation->AllocateOutputData(1, static_cast<uint64_t>(0));

    VkResult replay_result = GetDeviceTable(in_device)->GetCalibratedTimestampsKHR(in_device, timestampCount, in_pTimestampInfos, out_pTimestamps, out_pMaxDeviation);
    CheckResult("vkGetCalibratedTimestampsKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdBindDescriptorSets2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkBindDescriptorSetsInfoKHR>* pBindDescriptorSetsInfo)
{
    VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    const VkBindDescriptorSetsInfoKHR* in_pBindDescriptorSetsInfo = pBindDescriptorSetsInfo->GetPointer();
    MapStructHandles(pBindDescriptorSetsInfo->GetMetaStructPointer(), GetObjectInfoTable());

    GetDeviceTable(in_commandBuffer)->CmdBindDescriptorSets2KHR(in_commandBuffer, in_pBindDescriptorSetsInfo);
}

void VulkanReplayConsumer::Process_vkCmdPushConstants2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkPushConstantsInfoKHR>* pPushConstantsInfo)
{
    VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    const VkPushConstantsInfoKHR* in_pPushConstantsInfo = pPushConstantsInfo->GetPointer();
    MapStructHandles(pPushConstantsInfo->GetMetaStructPointer(), GetObjectInfoTable());

    GetDeviceTable(in_commandBuffer)->CmdPushConstants2KHR(in_commandBuffer, in_pPushConstantsInfo);
}

void VulkanReplayConsumer::Process_vkCmdPushDescriptorSet2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkPushDescriptorSetInfoKHR>* pPushDescriptorSetInfo)
{
    VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    const VkPushDescriptorSetInfoKHR* in_pPushDescriptorSetInfo = pPushDescriptorSetInfo->GetPointer();
    MapStructHandles(pPushDescriptorSetInfo->GetMetaStructPointer(), GetObjectInfoTable());

    GetDeviceTable(in_commandBuffer)->CmdPushDescriptorSet2KHR(in_commandBuffer, in_pPushDescriptorSetInfo);
}

void VulkanReplayConsumer::Process_vkCmdPushDescriptorSetWithTemplate2KHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkPushDescriptorSetWithTemplateInfoKHR>* pPushDescriptorSetWithTemplateInfo)
{
    VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    const VkPushDescriptorSetWithTemplateInfoKHR* in_pPushDescriptorSetWithTemplateInfo = pPushDescriptorSetWithTemplateInfo->GetPointer();
    MapStructHandles(pPushDescriptorSetWithTemplateInfo->GetMetaStructPointer(), GetObjectInfoTable());

    GetDeviceTable(in_commandBuffer)->CmdPushDescriptorSetWithTemplate2KHR(in_commandBuffer, in_pPushDescriptorSetWithTemplateInfo);
}

void VulkanReplayConsumer::Process_vkCmdSetDescriptorBufferOffsets2EXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkSetDescriptorBufferOffsetsInfoEXT>* pSetDescriptorBufferOffsetsInfo)
{
    VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    const VkSetDescriptorBufferOffsetsInfoEXT* in_pSetDescriptorBufferOffsetsInfo = pSetDescriptorBufferOffsetsInfo->GetPointer();
    MapStructHandles(pSetDescriptorBufferOffsetsInfo->GetMetaStructPointer(), GetObjectInfoTable());

    GetDeviceTable(in_commandBuffer)->CmdSetDescriptorBufferOffsets2EXT(in_commandBuffer, in_pSetDescriptorBufferOffsetsInfo);
}

void VulkanReplayConsumer::Process_vkCmdBindDescriptorBufferEmbeddedSamplers2EXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkBindDescriptorBufferEmbeddedSamplersInfoEXT>* pBindDescriptorBufferEmbeddedSamplersInfo)
{
    VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    const VkBindDescriptorBufferEmbeddedSamplersInfoEXT* in_pBindDescriptorBufferEmbeddedSamplersInfo = pBindDescriptorBufferEmbeddedSamplersInfo->GetPointer();
    MapStructHandles(pBindDescriptorBufferEmbeddedSamplersInfo->GetMetaStructPointer(), GetObjectInfoTable());

    GetDeviceTable(in_commandBuffer)->CmdBindDescriptorBufferEmbeddedSamplers2EXT(in_commandBuffer, in_pBindDescriptorBufferEmbeddedSamplersInfo);
}

void VulkanReplayConsumer::Process_vkFrameBoundaryANDROID(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            semaphore,
    format::HandleId                            image)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSemaphore in_semaphore = /*@@@QKJ*/MapHandle<SemaphoreInfo>(semaphore, &VulkanObjectInfoTable::GetSemaphoreInfo);
    VkImage in_image = /*@@@QKJ*/MapHandle<ImageInfo>(image, &VulkanObjectInfoTable::GetImageInfo);//@@@DFK
    GetDeviceTable(in_device)->FrameBoundaryANDROID(in_device, in_semaphore, in_image)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCreateDebugReportCallbackEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkDebugReportCallbackCreateInfoEXT>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkDebugReportCallbackEXT>* pCallback)
{
    auto in_instance = GetObjectInfoTable().GetInstanceInfo(instance);
    if (!pCallback->IsNull()) { pCallback->SetHandleLength(1); }//@@@HET
    DebugReportCallbackEXTInfo handle_info;
    pCallback->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateDebugReportCallbackEXT(GetInstanceTable(in_instance->handle)->CreateDebugReportCallbackEXT, returnValue, in_instance, pCreateInfo, pAllocator, pCallback)/*@@@HNM*/;
    CheckResult("vkCreateDebugReportCallbackEXT", returnValue, replay_result, call_info);
    AddHandle<DebugReportCallbackEXTInfo>(instance, pCallback->GetPointer(), pCallback->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddDebugReportCallbackEXTInfo);
}

void VulkanReplayConsumer::Process_vkDestroyDebugReportCallbackEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            instance,
    format::HandleId                            callback,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkInstance in_instance = /*@@@QKJ*/MapHandle<InstanceInfo>(instance, &VulkanObjectInfoTable::GetInstanceInfo);
    VkDebugReportCallbackEXT in_callback = /*@@@QKJ*/MapHandle<DebugReportCallbackEXTInfo>(callback, &VulkanObjectInfoTable::GetDebugReportCallbackEXTInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetInstanceTable(in_instance)->DestroyDebugReportCallbackEXT(in_instance, in_callback, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(callback, &VulkanObjectInfoTable::RemoveDebugReportCallbackEXTInfo);
}

void VulkanReplayConsumer::Process_vkDebugReportMessageEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            instance,
    VkDebugReportFlagsEXT                       flags,
    VkDebugReportObjectTypeEXT                  objectType,
    uint64_t                                    object,
    size_t                                      location,
    int32_t                                     messageCode,
    StringDecoder*                              pLayerPrefix,
    StringDecoder*                              pMessage)
{
    VkInstance in_instance = /*@@@QKJ*/MapHandle<InstanceInfo>(instance, &VulkanObjectInfoTable::GetInstanceInfo);
    uint64_t in_object = /*@@@REX*/MapHandle(object, objectType);
    /*@@@HPA*/const char* /*@@@AZI*/in_pLayerPrefix = /*@@@HUY*/pLayerPrefix->GetPointer();
    /*@@@HPA*/const char* /*@@@AZI*/in_pMessage = /*@@@HUY*/pMessage->GetPointer();//@@@DFK
    GetInstanceTable(in_instance)->DebugReportMessageEXT(in_instance, flags, objectType, in_object, location, messageCode, /*@@@AZI*/in_pLayerPrefix, /*@@@AZI*/in_pMessage)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkDebugMarkerSetObjectTagEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDebugMarkerObjectTagInfoEXT>/*@@@PLQ*/* pTagInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDebugMarkerObjectTagInfoEXT* /*@@@AZI*/in_pTagInfo = /*@@@HUY*/pTagInfo->GetPointer();
    MapStructHandles(pTagInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->DebugMarkerSetObjectTagEXT(in_device, /*@@@AZI*/in_pTagInfo)/*@@@ABC*/;
    CheckResult("vkDebugMarkerSetObjectTagEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkDebugMarkerSetObjectNameEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDebugMarkerObjectNameInfoEXT>/*@@@PLQ*/* pNameInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDebugMarkerObjectNameInfoEXT* /*@@@AZI*/in_pNameInfo = /*@@@HUY*/pNameInfo->GetPointer();
    MapStructHandles(pNameInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->DebugMarkerSetObjectNameEXT(in_device, /*@@@AZI*/in_pNameInfo)/*@@@ABC*/;
    CheckResult("vkDebugMarkerSetObjectNameEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdDebugMarkerBeginEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkDebugMarkerMarkerInfoEXT>/*@@@PLQ*/* pMarkerInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkDebugMarkerMarkerInfoEXT* /*@@@AZI*/in_pMarkerInfo = /*@@@HUY*/pMarkerInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDebugMarkerBeginEXT(in_commandBuffer, /*@@@AZI*/in_pMarkerInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDebugMarkerBeginEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdDebugMarkerEndEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDebugMarkerEndEXT(in_commandBuffer)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDebugMarkerEndEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdDebugMarkerInsertEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkDebugMarkerMarkerInfoEXT>/*@@@PLQ*/* pMarkerInfo)
{
    auto in_commandBuffer = GetObjectInfoTable().GetCommandBufferInfo(commandBuffer);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        OverrideCmdDebugMarkerInsertEXT(GetDeviceTable(in_commandBuffer->handle)->CmdDebugMarkerInsertEXT, in_commandBuffer, pMarkerInfo)/*@@@PKQ*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDebugMarkerInsertEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdBindTransformFeedbackBuffersEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    HandlePointerDecoder<VkBuffer>*             pBuffers,
    PointerDecoder<VkDeviceSize>*               pOffsets,
    PointerDecoder<VkDeviceSize>*               pSizes)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkBuffer* /*@@@AZI*/in_pBuffers = /*@@@EDO*/MapHandles<BufferInfo>(pBuffers, bindingCount, &VulkanObjectInfoTable::GetBufferInfo);
    /*@@@HPA*/const VkDeviceSize* /*@@@AZI*/in_pOffsets = /*@@@HUY*/pOffsets->GetPointer();
    /*@@@HPA*/const VkDeviceSize* /*@@@AZI*/in_pSizes = /*@@@HUY*/pSizes->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBindTransformFeedbackBuffersEXT(in_commandBuffer, firstBinding, bindingCount, /*@@@AZI*/in_pBuffers, /*@@@AZI*/in_pOffsets, /*@@@AZI*/in_pSizes)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBindTransformFeedbackBuffersEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBindTransformFeedbackBuffersEXTHandles(in_commandBuffer, bindingCount, in_pBuffers);

    }
}

void VulkanReplayConsumer::Process_vkCmdBeginTransformFeedbackEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstCounterBuffer,
    uint32_t                                    counterBufferCount,
    HandlePointerDecoder<VkBuffer>*             pCounterBuffers,
    PointerDecoder<VkDeviceSize>*               pCounterBufferOffsets)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkBuffer* /*@@@AZI*/in_pCounterBuffers = /*@@@EDO*/MapHandles<BufferInfo>(pCounterBuffers, counterBufferCount, &VulkanObjectInfoTable::GetBufferInfo);
    /*@@@HPA*/const VkDeviceSize* /*@@@AZI*/in_pCounterBufferOffsets = /*@@@HUY*/pCounterBufferOffsets->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBeginTransformFeedbackEXT(in_commandBuffer, firstCounterBuffer, counterBufferCount, /*@@@AZI*/in_pCounterBuffers, /*@@@AZI*/in_pCounterBufferOffsets)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBeginTransformFeedbackEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBeginTransformFeedbackEXTHandles(in_commandBuffer, counterBufferCount, in_pCounterBuffers);

    }
}

void VulkanReplayConsumer::Process_vkCmdEndTransformFeedbackEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstCounterBuffer,
    uint32_t                                    counterBufferCount,
    HandlePointerDecoder<VkBuffer>*             pCounterBuffers,
    PointerDecoder<VkDeviceSize>*               pCounterBufferOffsets)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkBuffer* /*@@@AZI*/in_pCounterBuffers = /*@@@EDO*/MapHandles<BufferInfo>(pCounterBuffers, counterBufferCount, &VulkanObjectInfoTable::GetBufferInfo);
    /*@@@HPA*/const VkDeviceSize* /*@@@AZI*/in_pCounterBufferOffsets = /*@@@HUY*/pCounterBufferOffsets->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdEndTransformFeedbackEXT(in_commandBuffer, firstCounterBuffer, counterBufferCount, /*@@@AZI*/in_pCounterBuffers, /*@@@AZI*/in_pCounterBufferOffsets)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdEndTransformFeedbackEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdEndTransformFeedbackEXTHandles(in_commandBuffer, counterBufferCount, in_pCounterBuffers);

    }
}

void VulkanReplayConsumer::Process_vkCmdBeginQueryIndexedEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query,
    VkQueryControlFlags                         flags,
    uint32_t                                    index)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBeginQueryIndexedEXT(in_commandBuffer, in_queryPool, query, flags, index)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBeginQueryIndexedEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBeginQueryIndexedEXTHandles(in_commandBuffer, in_queryPool);

    }
}

void VulkanReplayConsumer::Process_vkCmdEndQueryIndexedEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            queryPool,
    uint32_t                                    query,
    uint32_t                                    index)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdEndQueryIndexedEXT(in_commandBuffer, in_queryPool, query, index)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdEndQueryIndexedEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdEndQueryIndexedEXTHandles(in_commandBuffer, in_queryPool);

    }
}

void VulkanReplayConsumer::Process_vkCmdDrawIndirectByteCountEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    instanceCount,
    uint32_t                                    firstInstance,
    format::HandleId                            counterBuffer,
    VkDeviceSize                                counterBufferOffset,
    uint32_t                                    counterOffset,
    uint32_t                                    vertexStride)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_counterBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(counterBuffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawIndirectByteCountEXT(in_commandBuffer, instanceCount, firstInstance, in_counterBuffer, counterBufferOffset, counterOffset, vertexStride)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawIndirectByteCountEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDrawIndirectByteCountEXTHandles(in_commandBuffer, in_counterBuffer);

    }
}

void VulkanReplayConsumer::Process_vkGetImageViewHandleNVX(
    const ApiCallInfo&                          call_info,
    uint32_t                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkImageViewHandleInfoNVX>/*@@@PLQ*/* pInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkImageViewHandleInfoNVX* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    GetDeviceTable(in_device)->GetImageViewHandleNVX(in_device, /*@@@AZI*/in_pInfo)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetImageViewAddressNVX(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            imageView,
    StructPointerDecoder<Decoded_VkImageViewAddressPropertiesNVX>/*@@@PLQ*/* pProperties)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkImageView in_imageView = /*@@@QKJ*/MapHandle<ImageViewInfo>(imageView, &VulkanObjectInfoTable::GetImageViewInfo);
    /*@@@HPA*/VkImageViewAddressPropertiesNVX* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX, nullptr });
    InitializeOutputStructPNext(pProperties);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetImageViewAddressNVX(in_device, in_imageView, /*@@@USD*/out_pProperties)/*@@@ABC*/;
    CheckResult("vkGetImageViewAddressNVX", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdDrawIndirectCountAMD(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);
    VkBuffer in_countBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(countBuffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawIndirectCountAMD(in_commandBuffer, in_buffer, offset, in_countBuffer, countBufferOffset, maxDrawCount, stride)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawIndirectCountAMD;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDrawIndirectCountAMDHandles(in_commandBuffer, in_buffer, in_countBuffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdDrawIndexedIndirectCountAMD(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);
    VkBuffer in_countBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(countBuffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawIndexedIndirectCountAMD(in_commandBuffer, in_buffer, offset, in_countBuffer, countBufferOffset, maxDrawCount, stride)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawIndexedIndirectCountAMD;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDrawIndexedIndirectCountAMDHandles(in_commandBuffer, in_buffer, in_countBuffer);

    }
}

void VulkanReplayConsumer::Process_vkGetShaderInfoAMD(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    VkShaderStageFlagBits                       shaderStage,
    VkShaderInfoTypeAMD                         infoType,
    PointerDecoder<size_t>*                     pInfoSize,
    PointerDecoder<uint8_t>*                    pInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPipeline in_pipeline = /*@@@QKJ*/MapHandle<PipelineInfo>(pipeline, &VulkanObjectInfoTable::GetPipelineInfo);
    /*@@@HPA*/size_t* /*@@@USD*/out_pInfoSize = pInfoSize->IsNull() ? nullptr : pInfoSize->AllocateOutputData(1, GetOutputArrayCount<size_t, PipelineInfo>("vkGetShaderInfoAMD", returnValue, pipeline, kPipelineArrayGetShaderInfoAMD, pInfoSize, pInfo, &VulkanObjectInfoTable::GetPipelineInfo));
    /*@@@HPA*/void* /*@@@USD*/out_pInfo = pInfo->IsNull() ? nullptr : pInfo->AllocateOutputData(*/*@@@USD*/out_pInfoSize);//@@@EJH//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetShaderInfoAMD(in_device, in_pipeline, shaderStage, infoType, /*@@@USD*/out_pInfoSize, /*@@@USD*/out_pInfo)/*@@@ABC*/;
    CheckResult("vkGetShaderInfoAMD", returnValue, replay_result, call_info);
    if (pInfo->IsNull()) { SetOutputArrayCount<PipelineInfo>(pipeline, kPipelineArrayGetShaderInfoAMD, */*@@@USD*/out_pInfoSize, &VulkanObjectInfoTable::GetPipelineInfo); }
}

void VulkanReplayConsumer::Process_vkCreateStreamDescriptorSurfaceGGP(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkStreamDescriptorSurfaceCreateInfoGGP>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    VkInstance in_instance = /*@@@QKJ*/MapHandle<InstanceInfo>(instance, &VulkanObjectInfoTable::GetInstanceInfo);
    /*@@@HPA*/const VkStreamDescriptorSurfaceCreateInfoGGP* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkSurfaceKHR* /*@@@USD*/out_pSurface = pSurface->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetInstanceTable(in_instance)->CreateStreamDescriptorSurfaceGGP(in_instance, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pSurface)/*@@@ABC*/;
    CheckResult("vkCreateStreamDescriptorSurfaceGGP", returnValue, replay_result, call_info);
    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), /*@@@USD*/out_pSurface, &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceExternalImageFormatPropertiesNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    VkFormat                                    format,
    VkImageType                                 type,
    VkImageTiling                               tiling,
    VkImageUsageFlags                           usage,
    VkImageCreateFlags                          flags,
    VkExternalMemoryHandleTypeFlagsNV           externalHandleType,
    StructPointerDecoder<Decoded_VkExternalImageFormatPropertiesNV>/*@@@PLQ*/* pExternalImageFormatProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/VkExternalImageFormatPropertiesNV* /*@@@USD*/out_pExternalImageFormatProperties = pExternalImageFormatProperties->IsNull() ? nullptr : pExternalImageFormatProperties->AllocateOutputData(1);//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceExternalImageFormatPropertiesNV(in_physicalDevice, format, type, tiling, usage, flags, externalHandleType, /*@@@USD*/out_pExternalImageFormatProperties)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceExternalImageFormatPropertiesNV", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetMemoryWin32HandleNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            memory,
    VkExternalMemoryHandleTypeFlagsNV           handleType,
    PointerDecoder<uint64_t, void*>*            pHandle)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDeviceMemory in_memory = /*@@@QKJ*/MapHandle<DeviceMemoryInfo>(memory, &VulkanObjectInfoTable::GetDeviceMemoryInfo);
    /*@@@HPA*/HANDLE* /*@@@USD*/out_pHandle = pHandle->IsNull() ? nullptr : reinterpret_cast<HANDLE*>(pHandle->AllocateOutputData(1));//@@CCC//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetMemoryWin32HandleNV(in_device, in_memory, handleType, /*@@@USD*/out_pHandle)/*@@@ABC*/;
    CheckResult("vkGetMemoryWin32HandleNV", returnValue, replay_result, call_info);
    PostProcessExternalObject(replay_result, (*pHandle->GetPointer()), static_cast<void*>(*/*@@@USD*/out_pHandle), format::ApiCallId::ApiCall_vkGetMemoryWin32HandleNV, "vkGetMemoryWin32HandleNV");//@@HPP
}

void VulkanReplayConsumer::Process_vkCreateViSurfaceNN(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkViSurfaceCreateInfoNN>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    VkInstance in_instance = /*@@@QKJ*/MapHandle<InstanceInfo>(instance, &VulkanObjectInfoTable::GetInstanceInfo);
    /*@@@HPA*/const VkViSurfaceCreateInfoNN* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkSurfaceKHR* /*@@@USD*/out_pSurface = pSurface->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetInstanceTable(in_instance)->CreateViSurfaceNN(in_instance, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pSurface)/*@@@ABC*/;
    CheckResult("vkCreateViSurfaceNN", returnValue, replay_result, call_info);
    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), /*@@@USD*/out_pSurface, &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkCmdBeginConditionalRenderingEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkConditionalRenderingBeginInfoEXT>/*@@@PLQ*/* pConditionalRenderingBegin)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkConditionalRenderingBeginInfoEXT* /*@@@AZI*/in_pConditionalRenderingBegin = /*@@@HUY*/pConditionalRenderingBegin->GetPointer();
    MapStructHandles(pConditionalRenderingBegin->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBeginConditionalRenderingEXT(in_commandBuffer, /*@@@AZI*/in_pConditionalRenderingBegin)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBeginConditionalRenderingEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBeginConditionalRenderingEXTHandles(in_commandBuffer, in_pConditionalRenderingBegin);

    }
}

void VulkanReplayConsumer::Process_vkCmdEndConditionalRenderingEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdEndConditionalRenderingEXT(in_commandBuffer)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdEndConditionalRenderingEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetViewportWScalingNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    StructPointerDecoder<Decoded_VkViewportWScalingNV>/*@@@PLQ*/* pViewportWScalings)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkViewportWScalingNV* /*@@@AZI*/in_pViewportWScalings = /*@@@HUY*/pViewportWScalings->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetViewportWScalingNV(in_commandBuffer, firstViewport, viewportCount, /*@@@AZI*/in_pViewportWScalings)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetViewportWScalingNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkReleaseDisplayEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    VkDisplayKHR in_display = /*@@@QKJ*/MapHandle<DisplayKHRInfo>(display, &VulkanObjectInfoTable::GetDisplayKHRInfo);//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->ReleaseDisplayEXT(in_physicalDevice, in_display)/*@@@ABC*/;
    CheckResult("vkReleaseDisplayEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkAcquireXlibDisplayEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint64_t                                    dpy,
    format::HandleId                            display)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/Display* /*@@@AZI*/in_dpy = /*@@@WSX*/static_cast<Display*>(PreProcessExternalObject(dpy, format::ApiCallId::ApiCall_vkAcquireXlibDisplayEXT, "vkAcquireXlibDisplayEXT"));
    VkDisplayKHR in_display = /*@@@QKJ*/MapHandle<DisplayKHRInfo>(display, &VulkanObjectInfoTable::GetDisplayKHRInfo);//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->AcquireXlibDisplayEXT(in_physicalDevice, /*@@@AZI*/in_dpy, in_display)/*@@@ABC*/;
    CheckResult("vkAcquireXlibDisplayEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetRandROutputDisplayEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint64_t                                    dpy,
    size_t                                      rrOutput,
    HandlePointerDecoder<VkDisplayKHR>*         pDisplay)
{
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);
    /*@@@HPA*/Display* /*@@@AZI*/in_dpy = /*@@@WSX*/static_cast<Display*>(PreProcessExternalObject(dpy, format::ApiCallId::ApiCall_vkGetRandROutputDisplayEXT, "vkGetRandROutputDisplayEXT"));
    if (!pDisplay->IsNull()) { pDisplay->SetHandleLength(1); }//@@@HET
    DisplayKHRInfo handle_info;
    pDisplay->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideGetRandROutputDisplayEXT(GetInstanceTable(in_physicalDevice->handle)->GetRandROutputDisplayEXT, returnValue, in_physicalDevice, /*@@@AZI*/in_dpy, rrOutput, pDisplay)/*@@@HNM*/;
    CheckResult("vkGetRandROutputDisplayEXT", returnValue, replay_result, call_info);
    AddHandle<DisplayKHRInfo>(physicalDevice, pDisplay->GetPointer(), pDisplay->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddDisplayKHRInfo);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceSurfaceCapabilities2EXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            surface,
    StructPointerDecoder<Decoded_VkSurfaceCapabilities2EXT>/*@@@PLQ*/* pSurfaceCapabilities)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetPhysicalDeviceSurfaceCapabilities2EXT for offscreen.");
        return;
    }
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    VkSurfaceKHR in_surface = /*@@@QKJ*/MapHandle<SurfaceKHRInfo>(surface, &VulkanObjectInfoTable::GetSurfaceKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(surface) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(surface)->surface_creation_skipped) { return; }
    /*@@@HPA*/VkSurfaceCapabilities2EXT* /*@@@USD*/out_pSurfaceCapabilities = pSurfaceCapabilities->IsNull() ? nullptr : pSurfaceCapabilities->AllocateOutputData(1, { VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT, nullptr });
    InitializeOutputStructPNext(pSurfaceCapabilities);//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceSurfaceCapabilities2EXT(in_physicalDevice, in_surface, /*@@@USD*/out_pSurfaceCapabilities)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceSurfaceCapabilities2EXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkDisplayPowerControlEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            display,
    StructPointerDecoder<Decoded_VkDisplayPowerInfoEXT>/*@@@PLQ*/* pDisplayPowerInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDisplayKHR in_display = /*@@@QKJ*/MapHandle<DisplayKHRInfo>(display, &VulkanObjectInfoTable::GetDisplayKHRInfo);
    /*@@@HPA*/const VkDisplayPowerInfoEXT* /*@@@AZI*/in_pDisplayPowerInfo = /*@@@HUY*/pDisplayPowerInfo->GetPointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->DisplayPowerControlEXT(in_device, in_display, /*@@@AZI*/in_pDisplayPowerInfo)/*@@@ABC*/;
    CheckResult("vkDisplayPowerControlEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkRegisterDeviceEventEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDeviceEventInfoEXT>/*@@@PLQ*/* pDeviceEventInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkFence>*              pFence)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDeviceEventInfoEXT* /*@@@AZI*/in_pDeviceEventInfo = /*@@@HUY*/pDeviceEventInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pFence->IsNull()) { pFence->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkFence* /*@@@USD*/out_pFence = pFence->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->RegisterDeviceEventEXT(in_device, /*@@@AZI*/in_pDeviceEventInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pFence)/*@@@ABC*/;
    CheckResult("vkRegisterDeviceEventEXT", returnValue, replay_result, call_info);
    AddHandle<FenceInfo>(device, pFence->GetPointer(), /*@@@USD*/out_pFence, &VulkanObjectInfoTable::AddFenceInfo);
}

void VulkanReplayConsumer::Process_vkRegisterDisplayEventEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            display,
    StructPointerDecoder<Decoded_VkDisplayEventInfoEXT>/*@@@PLQ*/* pDisplayEventInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkFence>*              pFence)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDisplayKHR in_display = /*@@@QKJ*/MapHandle<DisplayKHRInfo>(display, &VulkanObjectInfoTable::GetDisplayKHRInfo);
    /*@@@HPA*/const VkDisplayEventInfoEXT* /*@@@AZI*/in_pDisplayEventInfo = /*@@@HUY*/pDisplayEventInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pFence->IsNull()) { pFence->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkFence* /*@@@USD*/out_pFence = pFence->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->RegisterDisplayEventEXT(in_device, in_display, /*@@@AZI*/in_pDisplayEventInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pFence)/*@@@ABC*/;
    CheckResult("vkRegisterDisplayEventEXT", returnValue, replay_result, call_info);
    AddHandle<FenceInfo>(device, pFence->GetPointer(), /*@@@USD*/out_pFence, &VulkanObjectInfoTable::AddFenceInfo);
}

void VulkanReplayConsumer::Process_vkGetSwapchainCounterEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    VkSurfaceCounterFlagBitsEXT                 counter,
    PointerDecoder<uint64_t>*                   pCounterValue)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetSwapchainCounterEXT for offscreen.");
        return;
    }
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSwapchainKHR in_swapchain = /*@@@QKJ*/MapHandle<SwapchainKHRInfo>(swapchain, &VulkanObjectInfoTable::GetSwapchainKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id)->surface_creation_skipped) { return; }
    /*@@@HPA*/uint64_t* /*@@@USD*/out_pCounterValue = pCounterValue->IsNull() ? nullptr : pCounterValue->AllocateOutputData(1, static_cast<uint64_t>(0));//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetSwapchainCounterEXT(in_device, in_swapchain, counter, /*@@@USD*/out_pCounterValue)/*@@@ABC*/;
    CheckResult("vkGetSwapchainCounterEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetRefreshCycleDurationGOOGLE(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    StructPointerDecoder<Decoded_VkRefreshCycleDurationGOOGLE>/*@@@PLQ*/* pDisplayTimingProperties)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetRefreshCycleDurationGOOGLE for offscreen.");
        return;
    }
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSwapchainKHR in_swapchain = /*@@@QKJ*/MapHandle<SwapchainKHRInfo>(swapchain, &VulkanObjectInfoTable::GetSwapchainKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id)->surface_creation_skipped) { return; }
    /*@@@HPA*/VkRefreshCycleDurationGOOGLE* /*@@@USD*/out_pDisplayTimingProperties = pDisplayTimingProperties->IsNull() ? nullptr : pDisplayTimingProperties->AllocateOutputData(1);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetRefreshCycleDurationGOOGLE(in_device, in_swapchain, /*@@@USD*/out_pDisplayTimingProperties)/*@@@ABC*/;
    CheckResult("vkGetRefreshCycleDurationGOOGLE", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPastPresentationTimingGOOGLE(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    PointerDecoder<uint32_t>*                   pPresentationTimingCount,
    StructPointerDecoder<Decoded_VkPastPresentationTimingGOOGLE>/*@@@PLQ*/* pPresentationTimings)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetPastPresentationTimingGOOGLE for offscreen.");
        return;
    }
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSwapchainKHR in_swapchain = /*@@@QKJ*/MapHandle<SwapchainKHRInfo>(swapchain, &VulkanObjectInfoTable::GetSwapchainKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id)->surface_creation_skipped) { return; }
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPresentationTimingCount = pPresentationTimingCount->IsNull() ? nullptr : pPresentationTimingCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, SwapchainKHRInfo>("vkGetPastPresentationTimingGOOGLE", returnValue, swapchain, kSwapchainKHRArrayGetPastPresentationTimingGOOGLE, pPresentationTimingCount, pPresentationTimings, &VulkanObjectInfoTable::GetSwapchainKHRInfo));
    /*@@@HPA*/VkPastPresentationTimingGOOGLE* /*@@@USD*/out_pPresentationTimings = pPresentationTimings->IsNull() ? nullptr : pPresentationTimings->AllocateOutputData(*/*@@@USD*/out_pPresentationTimingCount); /*@@@DRW*///@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetPastPresentationTimingGOOGLE(in_device, in_swapchain, /*@@@USD*/out_pPresentationTimingCount, /*@@@USD*/out_pPresentationTimings)/*@@@ABC*/;
    CheckResult("vkGetPastPresentationTimingGOOGLE", returnValue, replay_result, call_info);
    if (pPresentationTimings->IsNull()) { SetOutputArrayCount<SwapchainKHRInfo>(swapchain, kSwapchainKHRArrayGetPastPresentationTimingGOOGLE, */*@@@USD*/out_pPresentationTimingCount, &VulkanObjectInfoTable::GetSwapchainKHRInfo); }
}

void VulkanReplayConsumer::Process_vkCmdSetDiscardRectangleEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstDiscardRectangle,
    uint32_t                                    discardRectangleCount,
    StructPointerDecoder<Decoded_VkRect2D>/*@@@PLQ*/* pDiscardRectangles)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkRect2D* /*@@@AZI*/in_pDiscardRectangles = /*@@@HUY*/pDiscardRectangles->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDiscardRectangleEXT(in_commandBuffer, firstDiscardRectangle, discardRectangleCount, /*@@@AZI*/in_pDiscardRectangles)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDiscardRectangleEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetDiscardRectangleEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    discardRectangleEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDiscardRectangleEnableEXT(in_commandBuffer, discardRectangleEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDiscardRectangleEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetDiscardRectangleModeEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkDiscardRectangleModeEXT                   discardRectangleMode)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDiscardRectangleModeEXT(in_commandBuffer, discardRectangleMode)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDiscardRectangleModeEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkSetHdrMetadataEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    uint32_t                                    swapchainCount,
    HandlePointerDecoder<VkSwapchainKHR>*       pSwapchains,
    StructPointerDecoder<Decoded_VkHdrMetadataEXT>/*@@@PLQ*/* pMetadata)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkSetHdrMetadataEXT for offscreen.");
        return;
    }
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkSwapchainKHR* /*@@@AZI*/in_pSwapchains = /*@@@EDO*/MapHandles<SwapchainKHRInfo>(pSwapchains, swapchainCount, &VulkanObjectInfoTable::GetSwapchainKHRInfo);
    /*@@@HPA*/const VkHdrMetadataEXT* /*@@@AZI*/in_pMetadata = /*@@@HUY*/pMetadata->GetPointer();//@@@DFK
    GetDeviceTable(in_device)->SetHdrMetadataEXT(in_device, swapchainCount, /*@@@AZI*/in_pSwapchains, /*@@@AZI*/in_pMetadata)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCreateIOSSurfaceMVK(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkIOSSurfaceCreateInfoMVK>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    VkInstance in_instance = /*@@@QKJ*/MapHandle<InstanceInfo>(instance, &VulkanObjectInfoTable::GetInstanceInfo);
    /*@@@HPA*/const VkIOSSurfaceCreateInfoMVK* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkSurfaceKHR* /*@@@USD*/out_pSurface = pSurface->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetInstanceTable(in_instance)->CreateIOSSurfaceMVK(in_instance, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pSurface)/*@@@ABC*/;
    CheckResult("vkCreateIOSSurfaceMVK", returnValue, replay_result, call_info);
    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), /*@@@USD*/out_pSurface, &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkCreateMacOSSurfaceMVK(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkMacOSSurfaceCreateInfoMVK>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    VkInstance in_instance = /*@@@QKJ*/MapHandle<InstanceInfo>(instance, &VulkanObjectInfoTable::GetInstanceInfo);
    /*@@@HPA*/const VkMacOSSurfaceCreateInfoMVK* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkSurfaceKHR* /*@@@USD*/out_pSurface = pSurface->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetInstanceTable(in_instance)->CreateMacOSSurfaceMVK(in_instance, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pSurface)/*@@@ABC*/;
    CheckResult("vkCreateMacOSSurfaceMVK", returnValue, replay_result, call_info);
    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), /*@@@USD*/out_pSurface, &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkSetDebugUtilsObjectNameEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDebugUtilsObjectNameInfoEXT>/*@@@PLQ*/* pNameInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDebugUtilsObjectNameInfoEXT* /*@@@AZI*/in_pNameInfo = /*@@@HUY*/pNameInfo->GetPointer();
    MapStructHandles(pNameInfo->GetMetaStructPointer(), GetObjectInfoTable());
    DeviceInfo* device_info = GetObjectInfoTable().GetDeviceInfo(device);
    VkPhysicalDevice             physical_device = device_info->parent;//@@@DFK
    VkResult replay_result = GetInstanceTable(physical_device)->SetDebugUtilsObjectNameEXT(in_device, /*@@@AZI*/in_pNameInfo)/*@@@ABC*/;
    CheckResult("vkSetDebugUtilsObjectNameEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkSetDebugUtilsObjectTagEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDebugUtilsObjectTagInfoEXT>/*@@@PLQ*/* pTagInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDebugUtilsObjectTagInfoEXT* /*@@@AZI*/in_pTagInfo = /*@@@HUY*/pTagInfo->GetPointer();
    MapStructHandles(pTagInfo->GetMetaStructPointer(), GetObjectInfoTable());
    DeviceInfo* device_info = GetObjectInfoTable().GetDeviceInfo(device);
    VkPhysicalDevice             physical_device = device_info->parent;//@@@DFK
    VkResult replay_result = GetInstanceTable(physical_device)->SetDebugUtilsObjectTagEXT(in_device, /*@@@AZI*/in_pTagInfo)/*@@@ABC*/;
    CheckResult("vkSetDebugUtilsObjectTagEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkQueueBeginDebugUtilsLabelEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            queue,
    StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>/*@@@PLQ*/* pLabelInfo)
{
    VkQueue in_queue = /*@@@QKJ*/MapHandle<QueueInfo>(queue, &VulkanObjectInfoTable::GetQueueInfo);
    /*@@@HPA*/const VkDebugUtilsLabelEXT* /*@@@AZI*/in_pLabelInfo = /*@@@HUY*/pLabelInfo->GetPointer();//@@@DFK
    GetDeviceTable(in_queue)->QueueBeginDebugUtilsLabelEXT(in_queue, /*@@@AZI*/in_pLabelInfo)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkQueueEndDebugUtilsLabelEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            queue)
{
    VkQueue in_queue = /*@@@QKJ*/MapHandle<QueueInfo>(queue, &VulkanObjectInfoTable::GetQueueInfo);//@@@DFK
    GetDeviceTable(in_queue)->QueueEndDebugUtilsLabelEXT(in_queue)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkQueueInsertDebugUtilsLabelEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            queue,
    StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>/*@@@PLQ*/* pLabelInfo)
{
    VkQueue in_queue = /*@@@QKJ*/MapHandle<QueueInfo>(queue, &VulkanObjectInfoTable::GetQueueInfo);
    /*@@@HPA*/const VkDebugUtilsLabelEXT* /*@@@AZI*/in_pLabelInfo = /*@@@HUY*/pLabelInfo->GetPointer();//@@@DFK
    GetDeviceTable(in_queue)->QueueInsertDebugUtilsLabelEXT(in_queue, /*@@@AZI*/in_pLabelInfo)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdBeginDebugUtilsLabelEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>/*@@@PLQ*/* pLabelInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkDebugUtilsLabelEXT* /*@@@AZI*/in_pLabelInfo = /*@@@HUY*/pLabelInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBeginDebugUtilsLabelEXT(in_commandBuffer, /*@@@AZI*/in_pLabelInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBeginDebugUtilsLabelEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdEndDebugUtilsLabelEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdEndDebugUtilsLabelEXT(in_commandBuffer)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdEndDebugUtilsLabelEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdInsertDebugUtilsLabelEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkDebugUtilsLabelEXT>/*@@@PLQ*/* pLabelInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkDebugUtilsLabelEXT* /*@@@AZI*/in_pLabelInfo = /*@@@HUY*/pLabelInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdInsertDebugUtilsLabelEXT(in_commandBuffer, /*@@@AZI*/in_pLabelInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdInsertDebugUtilsLabelEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCreateDebugUtilsMessengerEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkDebugUtilsMessengerCreateInfoEXT>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkDebugUtilsMessengerEXT>* pMessenger)
{
    auto in_instance = GetObjectInfoTable().GetInstanceInfo(instance);
    if (!pMessenger->IsNull()) { pMessenger->SetHandleLength(1); }//@@@HET
    DebugUtilsMessengerEXTInfo handle_info;
    pMessenger->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateDebugUtilsMessengerEXT(GetInstanceTable(in_instance->handle)->CreateDebugUtilsMessengerEXT, returnValue, in_instance, pCreateInfo, pAllocator, pMessenger)/*@@@HNM*/;
    CheckResult("vkCreateDebugUtilsMessengerEXT", returnValue, replay_result, call_info);
    AddHandle<DebugUtilsMessengerEXTInfo>(instance, pMessenger->GetPointer(), pMessenger->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddDebugUtilsMessengerEXTInfo);
}

void VulkanReplayConsumer::Process_vkDestroyDebugUtilsMessengerEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            instance,
    format::HandleId                            messenger,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkInstance in_instance = /*@@@QKJ*/MapHandle<InstanceInfo>(instance, &VulkanObjectInfoTable::GetInstanceInfo);
    VkDebugUtilsMessengerEXT in_messenger = /*@@@QKJ*/MapHandle<DebugUtilsMessengerEXTInfo>(messenger, &VulkanObjectInfoTable::GetDebugUtilsMessengerEXTInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetInstanceTable(in_instance)->DestroyDebugUtilsMessengerEXT(in_instance, in_messenger, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(messenger, &VulkanObjectInfoTable::RemoveDebugUtilsMessengerEXTInfo);
}

void VulkanReplayConsumer::Process_vkSubmitDebugUtilsMessageEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            instance,
    VkDebugUtilsMessageSeverityFlagBitsEXT      messageSeverity,
    VkDebugUtilsMessageTypeFlagsEXT             messageTypes,
    StructPointerDecoder<Decoded_VkDebugUtilsMessengerCallbackDataEXT>/*@@@PLQ*/* pCallbackData)
{
    VkInstance in_instance = /*@@@QKJ*/MapHandle<InstanceInfo>(instance, &VulkanObjectInfoTable::GetInstanceInfo);
    /*@@@HPA*/const VkDebugUtilsMessengerCallbackDataEXT* /*@@@AZI*/in_pCallbackData = /*@@@HUY*/pCallbackData->GetPointer();//@@@DFK
    GetInstanceTable(in_instance)->SubmitDebugUtilsMessageEXT(in_instance, messageSeverity, messageTypes, /*@@@AZI*/in_pCallbackData)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetAndroidHardwareBufferPropertiesANDROID(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint64_t                                    buffer,
    StructPointerDecoder<Decoded_VkAndroidHardwareBufferPropertiesANDROID>/*@@@PLQ*/* pProperties)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    /*@@@HPA*/const struct AHardwareBuffer* /*@@@AZI*/in_buffer = /*@@@WSX*/static_cast<const struct AHardwareBuffer*>(PreProcessExternalObject(buffer, format::ApiCallId::ApiCall_vkGetAndroidHardwareBufferPropertiesANDROID, "vkGetAndroidHardwareBufferPropertiesANDROID"));
    pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID, nullptr });
    InitializeOutputStructPNext(pProperties);//@@@DFK
    VkResult replay_result = OverrideGetAndroidHardwareBufferPropertiesANDROID(GetDeviceTable(in_device->handle)->GetAndroidHardwareBufferPropertiesANDROID, returnValue, in_device, /*@@@AZI*/in_buffer, pProperties)/*@@@HNM*/;
    CheckResult("vkGetAndroidHardwareBufferPropertiesANDROID", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetMemoryAndroidHardwareBufferANDROID(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID>/*@@@PLQ*/* pInfo,
    PointerDecoder<uint64_t, void*>*            pBuffer)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkMemoryGetAndroidHardwareBufferInfoANDROID* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/struct AHardwareBuffer** /*@@@USD*/out_pBuffer = pBuffer->IsNull() ? nullptr : reinterpret_cast<struct AHardwareBuffer**>(pBuffer->AllocateOutputData(1));//@@CCC//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetMemoryAndroidHardwareBufferANDROID(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pBuffer)/*@@@ABC*/;
    CheckResult("vkGetMemoryAndroidHardwareBufferANDROID", returnValue, replay_result, call_info);
    PostProcessExternalObject(replay_result, (*pBuffer->GetPointer()), static_cast<void*>(*/*@@@USD*/out_pBuffer), format::ApiCallId::ApiCall_vkGetMemoryAndroidHardwareBufferANDROID, "vkGetMemoryAndroidHardwareBufferANDROID");//@@HPP
}

void VulkanReplayConsumer::Process_vkCmdSetSampleLocationsEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkSampleLocationsInfoEXT>/*@@@PLQ*/* pSampleLocationsInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkSampleLocationsInfoEXT* /*@@@AZI*/in_pSampleLocationsInfo = /*@@@HUY*/pSampleLocationsInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetSampleLocationsEXT(in_commandBuffer, /*@@@AZI*/in_pSampleLocationsInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetSampleLocationsEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceMultisamplePropertiesEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            physicalDevice,
    VkSampleCountFlagBits                       samples,
    StructPointerDecoder<Decoded_VkMultisamplePropertiesEXT>/*@@@PLQ*/* pMultisampleProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/VkMultisamplePropertiesEXT* /*@@@USD*/out_pMultisampleProperties = pMultisampleProperties->IsNull() ? nullptr : pMultisampleProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT, nullptr });
    InitializeOutputStructPNext(pMultisampleProperties);//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceMultisamplePropertiesEXT(in_physicalDevice, samples, /*@@@USD*/out_pMultisampleProperties)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetImageDrmFormatModifierPropertiesEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            image,
    StructPointerDecoder<Decoded_VkImageDrmFormatModifierPropertiesEXT>/*@@@PLQ*/* pProperties)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkImage in_image = /*@@@QKJ*/MapHandle<ImageInfo>(image, &VulkanObjectInfoTable::GetImageInfo);
    /*@@@HPA*/VkImageDrmFormatModifierPropertiesEXT* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT, nullptr });
    InitializeOutputStructPNext(pProperties);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetImageDrmFormatModifierPropertiesEXT(in_device, in_image, /*@@@USD*/out_pProperties)/*@@@ABC*/;
    CheckResult("vkGetImageDrmFormatModifierPropertiesEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCreateValidationCacheEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkValidationCacheCreateInfoEXT>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkValidationCacheEXT>* pValidationCache)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkValidationCacheCreateInfoEXT* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pValidationCache->IsNull()) { pValidationCache->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkValidationCacheEXT* /*@@@USD*/out_pValidationCache = pValidationCache->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateValidationCacheEXT(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pValidationCache)/*@@@ABC*/;
    CheckResult("vkCreateValidationCacheEXT", returnValue, replay_result, call_info);
    AddHandle<ValidationCacheEXTInfo>(device, pValidationCache->GetPointer(), /*@@@USD*/out_pValidationCache, &VulkanObjectInfoTable::AddValidationCacheEXTInfo);
}

void VulkanReplayConsumer::Process_vkDestroyValidationCacheEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            validationCache,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkValidationCacheEXT in_validationCache = /*@@@QKJ*/MapHandle<ValidationCacheEXTInfo>(validationCache, &VulkanObjectInfoTable::GetValidationCacheEXTInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyValidationCacheEXT(in_device, in_validationCache, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(validationCache, &VulkanObjectInfoTable::RemoveValidationCacheEXTInfo);
}

void VulkanReplayConsumer::Process_vkMergeValidationCachesEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            dstCache,
    uint32_t                                    srcCacheCount,
    HandlePointerDecoder<VkValidationCacheEXT>* pSrcCaches)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkValidationCacheEXT in_dstCache = /*@@@QKJ*/MapHandle<ValidationCacheEXTInfo>(dstCache, &VulkanObjectInfoTable::GetValidationCacheEXTInfo);
    /*@@@HPA*/const VkValidationCacheEXT* /*@@@AZI*/in_pSrcCaches = /*@@@EDO*/MapHandles<ValidationCacheEXTInfo>(pSrcCaches, srcCacheCount, &VulkanObjectInfoTable::GetValidationCacheEXTInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->MergeValidationCachesEXT(in_device, in_dstCache, srcCacheCount, /*@@@AZI*/in_pSrcCaches)/*@@@ABC*/;
    CheckResult("vkMergeValidationCachesEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetValidationCacheDataEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            validationCache,
    PointerDecoder<size_t>*                     pDataSize,
    PointerDecoder<uint8_t>*                    pData)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkValidationCacheEXT in_validationCache = /*@@@QKJ*/MapHandle<ValidationCacheEXTInfo>(validationCache, &VulkanObjectInfoTable::GetValidationCacheEXTInfo);
    /*@@@HPA*/size_t* /*@@@USD*/out_pDataSize = pDataSize->IsNull() ? nullptr : pDataSize->AllocateOutputData(1, GetOutputArrayCount<size_t, ValidationCacheEXTInfo>("vkGetValidationCacheDataEXT", returnValue, validationCache, kValidationCacheEXTArrayGetValidationCacheDataEXT, pDataSize, pData, &VulkanObjectInfoTable::GetValidationCacheEXTInfo));
    /*@@@HPA*/void* /*@@@USD*/out_pData = pData->IsNull() ? nullptr : pData->AllocateOutputData(*/*@@@USD*/out_pDataSize);//@@@EJH//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetValidationCacheDataEXT(in_device, in_validationCache, /*@@@USD*/out_pDataSize, /*@@@USD*/out_pData)/*@@@ABC*/;
    CheckResult("vkGetValidationCacheDataEXT", returnValue, replay_result, call_info);
    if (pData->IsNull()) { SetOutputArrayCount<ValidationCacheEXTInfo>(validationCache, kValidationCacheEXTArrayGetValidationCacheDataEXT, */*@@@USD*/out_pDataSize, &VulkanObjectInfoTable::GetValidationCacheEXTInfo); }
}

void VulkanReplayConsumer::Process_vkCmdBindShadingRateImageNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            imageView,
    VkImageLayout                               imageLayout)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkImageView in_imageView = /*@@@QKJ*/MapHandle<ImageViewInfo>(imageView, &VulkanObjectInfoTable::GetImageViewInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBindShadingRateImageNV(in_commandBuffer, in_imageView, imageLayout)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBindShadingRateImageNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBindShadingRateImageNVHandles(in_commandBuffer, in_imageView);

    }
}

void VulkanReplayConsumer::Process_vkCmdSetViewportShadingRatePaletteNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    StructPointerDecoder<Decoded_VkShadingRatePaletteNV>/*@@@PLQ*/* pShadingRatePalettes)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkShadingRatePaletteNV* /*@@@AZI*/in_pShadingRatePalettes = /*@@@HUY*/pShadingRatePalettes->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetViewportShadingRatePaletteNV(in_commandBuffer, firstViewport, viewportCount, /*@@@AZI*/in_pShadingRatePalettes)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetViewportShadingRatePaletteNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetCoarseSampleOrderNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkCoarseSampleOrderTypeNV                   sampleOrderType,
    uint32_t                                    customSampleOrderCount,
    StructPointerDecoder<Decoded_VkCoarseSampleOrderCustomNV>/*@@@PLQ*/* pCustomSampleOrders)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCoarseSampleOrderCustomNV* /*@@@AZI*/in_pCustomSampleOrders = /*@@@HUY*/pCustomSampleOrders->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetCoarseSampleOrderNV(in_commandBuffer, sampleOrderType, customSampleOrderCount, /*@@@AZI*/in_pCustomSampleOrders)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetCoarseSampleOrderNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCreateAccelerationStructureNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkAccelerationStructureCreateInfoNV>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkAccelerationStructureNV>* pAccelerationStructure)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkAccelerationStructureCreateInfoNV* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pAccelerationStructure->IsNull()) { pAccelerationStructure->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkAccelerationStructureNV* /*@@@USD*/out_pAccelerationStructure = pAccelerationStructure->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateAccelerationStructureNV(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pAccelerationStructure)/*@@@ABC*/;
    CheckResult("vkCreateAccelerationStructureNV", returnValue, replay_result, call_info);
    AddHandle<AccelerationStructureNVInfo>(device, pAccelerationStructure->GetPointer(), /*@@@USD*/out_pAccelerationStructure, &VulkanObjectInfoTable::AddAccelerationStructureNVInfo);
}

void VulkanReplayConsumer::Process_vkDestroyAccelerationStructureNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            accelerationStructure,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkAccelerationStructureNV in_accelerationStructure = /*@@@QKJ*/MapHandle<AccelerationStructureNVInfo>(accelerationStructure, &VulkanObjectInfoTable::GetAccelerationStructureNVInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyAccelerationStructureNV(in_device, in_accelerationStructure, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(accelerationStructure, &VulkanObjectInfoTable::RemoveAccelerationStructureNVInfo);
}

void VulkanReplayConsumer::Process_vkGetAccelerationStructureMemoryRequirementsNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkAccelerationStructureMemoryRequirementsInfoNV>/*@@@PLQ*/* pInfo,
    StructPointerDecoder<Decoded_VkMemoryRequirements2KHR>/*@@@PLQ*/* pMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkAccelerationStructureMemoryRequirementsInfoNV* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkMemoryRequirements2KHR* /*@@@USD*/out_pMemoryRequirements = pMemoryRequirements->IsNull() ? nullptr : pMemoryRequirements->AllocateOutputData(1);//@@@DFK
    GetDeviceTable(in_device)->GetAccelerationStructureMemoryRequirementsNV(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pMemoryRequirements)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkBindAccelerationStructureMemoryNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    bindInfoCount,
    StructPointerDecoder<Decoded_VkBindAccelerationStructureMemoryInfoNV>/*@@@PLQ*/* pBindInfos)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkBindAccelerationStructureMemoryInfoNV* /*@@@AZI*/in_pBindInfos = /*@@@HUY*/pBindInfos->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pBindInfos->GetMetaStructPointer(), pBindInfos->GetLength(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->BindAccelerationStructureMemoryNV(in_device, bindInfoCount, /*@@@AZI*/in_pBindInfos)/*@@@ABC*/;
    CheckResult("vkBindAccelerationStructureMemoryNV", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdBuildAccelerationStructureNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkAccelerationStructureInfoNV>/*@@@PLQ*/* pInfo,
    format::HandleId                            instanceData,
    VkDeviceSize                                instanceOffset,
    VkBool32                                    update,
    format::HandleId                            dst,
    format::HandleId                            src,
    format::HandleId                            scratch,
    VkDeviceSize                                scratchOffset)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkAccelerationStructureInfoNV* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    VkBuffer in_instanceData = /*@@@QKJ*/MapHandle<BufferInfo>(instanceData, &VulkanObjectInfoTable::GetBufferInfo);
    VkAccelerationStructureNV in_dst = /*@@@QKJ*/MapHandle<AccelerationStructureNVInfo>(dst, &VulkanObjectInfoTable::GetAccelerationStructureNVInfo);
    VkAccelerationStructureNV in_src = /*@@@QKJ*/MapHandle<AccelerationStructureNVInfo>(src, &VulkanObjectInfoTable::GetAccelerationStructureNVInfo);
    VkBuffer in_scratch = /*@@@QKJ*/MapHandle<BufferInfo>(scratch, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBuildAccelerationStructureNV(in_commandBuffer, /*@@@AZI*/in_pInfo, in_instanceData, instanceOffset, update, in_dst, in_src, in_scratch, scratchOffset)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBuildAccelerationStructureNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBuildAccelerationStructureNVHandles(in_commandBuffer, in_pInfo, in_instanceData, in_dst, in_src, in_scratch);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyAccelerationStructureNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            dst,
    format::HandleId                            src,
    VkCopyAccelerationStructureModeKHR          mode)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkAccelerationStructureNV in_dst = /*@@@QKJ*/MapHandle<AccelerationStructureNVInfo>(dst, &VulkanObjectInfoTable::GetAccelerationStructureNVInfo);
    VkAccelerationStructureNV in_src = /*@@@QKJ*/MapHandle<AccelerationStructureNVInfo>(src, &VulkanObjectInfoTable::GetAccelerationStructureNVInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyAccelerationStructureNV(in_commandBuffer, in_dst, in_src, mode)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyAccelerationStructureNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyAccelerationStructureNVHandles(in_commandBuffer, in_dst, in_src);

    }
}

void VulkanReplayConsumer::Process_vkCmdTraceRaysNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            raygenShaderBindingTableBuffer,
    VkDeviceSize                                raygenShaderBindingOffset,
    format::HandleId                            missShaderBindingTableBuffer,
    VkDeviceSize                                missShaderBindingOffset,
    VkDeviceSize                                missShaderBindingStride,
    format::HandleId                            hitShaderBindingTableBuffer,
    VkDeviceSize                                hitShaderBindingOffset,
    VkDeviceSize                                hitShaderBindingStride,
    format::HandleId                            callableShaderBindingTableBuffer,
    VkDeviceSize                                callableShaderBindingOffset,
    VkDeviceSize                                callableShaderBindingStride,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_raygenShaderBindingTableBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(raygenShaderBindingTableBuffer, &VulkanObjectInfoTable::GetBufferInfo);
    VkBuffer in_missShaderBindingTableBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(missShaderBindingTableBuffer, &VulkanObjectInfoTable::GetBufferInfo);
    VkBuffer in_hitShaderBindingTableBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(hitShaderBindingTableBuffer, &VulkanObjectInfoTable::GetBufferInfo);
    VkBuffer in_callableShaderBindingTableBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(callableShaderBindingTableBuffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdTraceRaysNV(in_commandBuffer, in_raygenShaderBindingTableBuffer, raygenShaderBindingOffset, in_missShaderBindingTableBuffer, missShaderBindingOffset, missShaderBindingStride, in_hitShaderBindingTableBuffer, hitShaderBindingOffset, hitShaderBindingStride, in_callableShaderBindingTableBuffer, callableShaderBindingOffset, callableShaderBindingStride, width, height, depth)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdTraceRaysNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdTraceRaysNVHandles(in_commandBuffer, in_raygenShaderBindingTableBuffer, in_missShaderBindingTableBuffer, in_hitShaderBindingTableBuffer, in_callableShaderBindingTableBuffer);

    }
}

void VulkanReplayConsumer::Process_vkCreateRayTracingPipelinesNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipelineCache,
    uint32_t                                    createInfoCount,
    StructPointerDecoder<Decoded_VkRayTracingPipelineCreateInfoNV>/*@@@PLQ*/* pCreateInfos,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkPipeline>*           pPipelines)
{/*@@@GBN*/
//@@@START
    VkDevice in_device = MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPipelineCache in_pipelineCache = MapHandle<PipelineCacheInfo>(pipelineCache, &VulkanObjectInfoTable::GetPipelineCacheInfo);
    const VkRayTracingPipelineCreateInfoNV* in_pCreateInfos = pCreateInfos->GetPointer();
    MapStructArrayHandles(pCreateInfos->GetMetaStructPointer(), pCreateInfos->GetLength(), GetObjectInfoTable());
    const VkAllocationCallbacks* in_pAllocator = GetAllocationCallbacks(pAllocator);
    if (!pPipelines->IsNull()) { pPipelines->SetHandleLength(createInfoCount); }
    if (omitted_pipeline_cache_data_) {AllowCompileDuringPipelineCreation(createInfoCount, in_pCreateInfos);}
    VkPipeline* out_pPipelines = pPipelines->GetHandlePointer();
    VkResult replay_result = GetDeviceTable(in_device)->CreateRayTracingPipelinesNV(in_device, in_pipelineCache, createInfoCount, in_pCreateInfos, in_pAllocator, out_pPipelines);
    CheckResult("vkCreateRayTracingPipelinesNV", returnValue, replay_result, call_info);
    AddHandles<PipelineInfo>(device, pPipelines->GetPointer(), pPipelines->GetLength(), out_pPipelines, createInfoCount, &VulkanObjectInfoTable::AddPipelineInfo);
}

void VulkanReplayConsumer::Process_vkGetRayTracingShaderGroupHandlesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    uint32_t                                    firstGroup,
    uint32_t                                    groupCount,
    size_t                                      dataSize,
    PointerDecoder<uint8_t>*                    pData)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);
    auto in_pipeline = GetObjectInfoTable().GetPipelineInfo(pipeline);
    if (!pData->IsNull()) { pData->AllocateOutputData(dataSize); }//@@@ENH//@@@DFK
    VkResult replay_result = OverrideGetRayTracingShaderGroupHandlesKHR(GetDeviceTable(in_device->handle)->GetRayTracingShaderGroupHandlesKHR, returnValue, in_device, in_pipeline, firstGroup, groupCount, dataSize, pData)/*@@@HNM*/;
    CheckResult("vkGetRayTracingShaderGroupHandlesKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetRayTracingShaderGroupHandlesNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    uint32_t                                    firstGroup,
    uint32_t                                    groupCount,
    size_t                                      dataSize,
    PointerDecoder<uint8_t>*                    pData)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPipeline in_pipeline = /*@@@QKJ*/MapHandle<PipelineInfo>(pipeline, &VulkanObjectInfoTable::GetPipelineInfo);
    /*@@@HPA*/void* /*@@@USD*/out_pData = pData->IsNull() ? nullptr : pData->AllocateOutputData(dataSize);//@@@EJH//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetRayTracingShaderGroupHandlesNV(in_device, in_pipeline, firstGroup, groupCount, dataSize, /*@@@USD*/out_pData)/*@@@ABC*/;
    CheckResult("vkGetRayTracingShaderGroupHandlesNV", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetAccelerationStructureHandleNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            accelerationStructure,
    size_t                                      dataSize,
    PointerDecoder<uint8_t>*                    pData)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkAccelerationStructureNV in_accelerationStructure = /*@@@QKJ*/MapHandle<AccelerationStructureNVInfo>(accelerationStructure, &VulkanObjectInfoTable::GetAccelerationStructureNVInfo);
    /*@@@HPA*/void* /*@@@USD*/out_pData = pData->IsNull() ? nullptr : pData->AllocateOutputData(dataSize);//@@@EJH//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetAccelerationStructureHandleNV(in_device, in_accelerationStructure, dataSize, /*@@@USD*/out_pData)/*@@@ABC*/;
    CheckResult("vkGetAccelerationStructureHandleNV", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdWriteAccelerationStructuresPropertiesNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    accelerationStructureCount,
    HandlePointerDecoder<VkAccelerationStructureNV>* pAccelerationStructures,
    VkQueryType                                 queryType,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkAccelerationStructureNV* /*@@@AZI*/in_pAccelerationStructures = /*@@@EDO*/MapHandles<AccelerationStructureNVInfo>(pAccelerationStructures, accelerationStructureCount, &VulkanObjectInfoTable::GetAccelerationStructureNVInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdWriteAccelerationStructuresPropertiesNV(in_commandBuffer, accelerationStructureCount, /*@@@AZI*/in_pAccelerationStructures, queryType, in_queryPool, firstQuery)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdWriteAccelerationStructuresPropertiesNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdWriteAccelerationStructuresPropertiesNVHandles(in_commandBuffer, accelerationStructureCount, in_pAccelerationStructures, in_queryPool);

    }
}

void VulkanReplayConsumer::Process_vkCompileDeferredNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    uint32_t                                    shader)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPipeline in_pipeline = /*@@@QKJ*/MapHandle<PipelineInfo>(pipeline, &VulkanObjectInfoTable::GetPipelineInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CompileDeferredNV(in_device, in_pipeline, shader)/*@@@ABC*/;
    CheckResult("vkCompileDeferredNV", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetMemoryHostPointerPropertiesEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    uint64_t                                    pHostPointer,
    StructPointerDecoder<Decoded_VkMemoryHostPointerPropertiesEXT>/*@@@PLQ*/* pMemoryHostPointerProperties)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const void* /*@@@AZI*/in_pHostPointer = /*@@@WPX*/PreProcessExternalObject(pHostPointer, format::ApiCallId::ApiCall_vkGetMemoryHostPointerPropertiesEXT, "vkGetMemoryHostPointerPropertiesEXT");
    /*@@@HPA*/VkMemoryHostPointerPropertiesEXT* /*@@@USD*/out_pMemoryHostPointerProperties = pMemoryHostPointerProperties->IsNull() ? nullptr : pMemoryHostPointerProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT, nullptr });
    InitializeOutputStructPNext(pMemoryHostPointerProperties);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetMemoryHostPointerPropertiesEXT(in_device, handleType, /*@@@AZI*/in_pHostPointer, /*@@@USD*/out_pMemoryHostPointerProperties)/*@@@ABC*/;
    CheckResult("vkGetMemoryHostPointerPropertiesEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdWriteBufferMarkerAMD(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkPipelineStageFlagBits                     pipelineStage,
    format::HandleId                            dstBuffer,
    VkDeviceSize                                dstOffset,
    uint32_t                                    marker)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_dstBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(dstBuffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdWriteBufferMarkerAMD(in_commandBuffer, pipelineStage, in_dstBuffer, dstOffset, marker)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdWriteBufferMarkerAMD;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdWriteBufferMarkerAMDHandles(in_commandBuffer, in_dstBuffer);

    }
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceCalibrateableTimeDomainsEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pTimeDomainCount,
    PointerDecoder<VkTimeDomainKHR>*            pTimeDomains)
{

    VkPhysicalDevice in_physicalDevice = MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    uint32_t* out_pTimeDomainCount = pTimeDomainCount->IsNull() ? nullptr : pTimeDomainCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceCalibrateableTimeDomainsEXT, pTimeDomainCount, pTimeDomains, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    VkTimeDomainKHR* out_pTimeDomains = pTimeDomains->IsNull() ? nullptr : pTimeDomains->AllocateOutputData(*out_pTimeDomainCount);

    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceCalibrateableTimeDomainsEXT(in_physicalDevice, out_pTimeDomainCount, out_pTimeDomains);
    CheckResult("vkGetPhysicalDeviceCalibrateableTimeDomainsEXT", returnValue, replay_result, call_info);
    if (pTimeDomains->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceCalibrateableTimeDomainsEXT, *out_pTimeDomainCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkGetCalibratedTimestampsEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    timestampCount,
    StructPointerDecoder<Decoded_VkCalibratedTimestampInfoKHR>* pTimestampInfos,
    PointerDecoder<uint64_t>*                   pTimestamps,
    PointerDecoder<uint64_t>*                   pMaxDeviation)
{/*@@@GBN*/
//@@@START
    VkDevice in_device = MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    const VkCalibratedTimestampInfoKHR* in_pTimestampInfos = pTimestampInfos->GetPointer();
    uint64_t* out_pTimestamps = pTimestamps->IsNull() ? nullptr : pTimestamps->AllocateOutputData(timestampCount);
    uint64_t* out_pMaxDeviation = pMaxDeviation->IsNull() ? nullptr : pMaxDeviation->AllocateOutputData(1, static_cast<uint64_t>(0));
    VkResult replay_result = GetDeviceTable(in_device)->GetCalibratedTimestampsEXT(in_device, timestampCount, in_pTimestampInfos, out_pTimestamps, out_pMaxDeviation);
    CheckResult("vkGetCalibratedTimestampsEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdDrawMeshTasksNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    taskCount,
    uint32_t                                    firstTask)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawMeshTasksNV(in_commandBuffer, taskCount, firstTask)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawMeshTasksNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdDrawMeshTasksIndirectNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawMeshTasksIndirectNV(in_commandBuffer, in_buffer, offset, drawCount, stride)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawMeshTasksIndirectNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDrawMeshTasksIndirectNVHandles(in_commandBuffer, in_buffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdDrawMeshTasksIndirectCountNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);
    VkBuffer in_countBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(countBuffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawMeshTasksIndirectCountNV(in_commandBuffer, in_buffer, offset, in_countBuffer, countBufferOffset, maxDrawCount, stride)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawMeshTasksIndirectCountNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDrawMeshTasksIndirectCountNVHandles(in_commandBuffer, in_buffer, in_countBuffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdSetExclusiveScissorEnableNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstExclusiveScissor,
    uint32_t                                    exclusiveScissorCount,
    PointerDecoder<VkBool32>*                   pExclusiveScissorEnables)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkBool32* /*@@@AZI*/in_pExclusiveScissorEnables = /*@@@HUY*/pExclusiveScissorEnables->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetExclusiveScissorEnableNV(in_commandBuffer, firstExclusiveScissor, exclusiveScissorCount, /*@@@AZI*/in_pExclusiveScissorEnables)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetExclusiveScissorEnableNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetExclusiveScissorNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstExclusiveScissor,
    uint32_t                                    exclusiveScissorCount,
    StructPointerDecoder<Decoded_VkRect2D>/*@@@PLQ*/* pExclusiveScissors)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkRect2D* /*@@@AZI*/in_pExclusiveScissors = /*@@@HUY*/pExclusiveScissors->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetExclusiveScissorNV(in_commandBuffer, firstExclusiveScissor, exclusiveScissorCount, /*@@@AZI*/in_pExclusiveScissors)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetExclusiveScissorNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetCheckpointNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint64_t                                    pCheckpointMarker)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const void* /*@@@AZI*/in_pCheckpointMarker = /*@@@WPX*/PreProcessExternalObject(pCheckpointMarker, format::ApiCallId::ApiCall_vkCmdSetCheckpointNV, "vkCmdSetCheckpointNV");//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetCheckpointNV(in_commandBuffer, /*@@@AZI*/in_pCheckpointMarker)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetCheckpointNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkGetQueueCheckpointDataNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            queue,
    PointerDecoder<uint32_t>*                   pCheckpointDataCount,
    StructPointerDecoder<Decoded_VkCheckpointDataNV>/*@@@PLQ*/* pCheckpointData)
{
    VkQueue in_queue = /*@@@QKJ*/MapHandle<QueueInfo>(queue, &VulkanObjectInfoTable::GetQueueInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pCheckpointDataCount = pCheckpointDataCount->IsNull() ? nullptr : pCheckpointDataCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, QueueInfo>("vkGetQueueCheckpointDataNV", VK_SUCCESS, queue, kQueueArrayGetQueueCheckpointDataNV, pCheckpointDataCount, pCheckpointData, &VulkanObjectInfoTable::GetQueueInfo));
    /*@@@HPA*/VkCheckpointDataNV* /*@@@USD*/out_pCheckpointData = pCheckpointData->IsNull() ? nullptr : pCheckpointData->AllocateOutputData(*/*@@@USD*/out_pCheckpointDataCount, VkCheckpointDataNV{ VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    GetDeviceTable(in_queue)->GetQueueCheckpointDataNV(in_queue, /*@@@USD*/out_pCheckpointDataCount, /*@@@USD*/out_pCheckpointData)/*@@@ABC*/;//@@@HQA
    if (pCheckpointData->IsNull()) { SetOutputArrayCount<QueueInfo>(queue, kQueueArrayGetQueueCheckpointDataNV, */*@@@USD*/out_pCheckpointDataCount, &VulkanObjectInfoTable::GetQueueInfo); }
}

void VulkanReplayConsumer::Process_vkInitializePerformanceApiINTEL(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkInitializePerformanceApiInfoINTEL>/*@@@PLQ*/* pInitializeInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkInitializePerformanceApiInfoINTEL* /*@@@AZI*/in_pInitializeInfo = /*@@@HUY*/pInitializeInfo->GetPointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->InitializePerformanceApiINTEL(in_device, /*@@@AZI*/in_pInitializeInfo)/*@@@ABC*/;
    CheckResult("vkInitializePerformanceApiINTEL", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkUninitializePerformanceApiINTEL(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);//@@@DFK
    GetDeviceTable(in_device)->UninitializePerformanceApiINTEL(in_device)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdSetPerformanceMarkerINTEL(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkPerformanceMarkerInfoINTEL>/*@@@PLQ*/* pMarkerInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkPerformanceMarkerInfoINTEL* /*@@@AZI*/in_pMarkerInfo = /*@@@HUY*/pMarkerInfo->GetPointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_commandBuffer)->CmdSetPerformanceMarkerINTEL(in_commandBuffer, /*@@@AZI*/in_pMarkerInfo)/*@@@ABC*/;
    CheckResult("vkCmdSetPerformanceMarkerINTEL", returnValue, replay_result, call_info);

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetPerformanceMarkerINTEL;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetPerformanceStreamMarkerINTEL(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkPerformanceStreamMarkerInfoINTEL>/*@@@PLQ*/* pMarkerInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkPerformanceStreamMarkerInfoINTEL* /*@@@AZI*/in_pMarkerInfo = /*@@@HUY*/pMarkerInfo->GetPointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_commandBuffer)->CmdSetPerformanceStreamMarkerINTEL(in_commandBuffer, /*@@@AZI*/in_pMarkerInfo)/*@@@ABC*/;
    CheckResult("vkCmdSetPerformanceStreamMarkerINTEL", returnValue, replay_result, call_info);

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetPerformanceStreamMarkerINTEL;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetPerformanceOverrideINTEL(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkPerformanceOverrideInfoINTEL>/*@@@PLQ*/* pOverrideInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkPerformanceOverrideInfoINTEL* /*@@@AZI*/in_pOverrideInfo = /*@@@HUY*/pOverrideInfo->GetPointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_commandBuffer)->CmdSetPerformanceOverrideINTEL(in_commandBuffer, /*@@@AZI*/in_pOverrideInfo)/*@@@ABC*/;
    CheckResult("vkCmdSetPerformanceOverrideINTEL", returnValue, replay_result, call_info);

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetPerformanceOverrideINTEL;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkAcquirePerformanceConfigurationINTEL(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkPerformanceConfigurationAcquireInfoINTEL>/*@@@PLQ*/* pAcquireInfo,
    HandlePointerDecoder<VkPerformanceConfigurationINTEL>* pConfiguration)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkPerformanceConfigurationAcquireInfoINTEL* /*@@@AZI*/in_pAcquireInfo = /*@@@HUY*/pAcquireInfo->GetPointer();
    if (!pConfiguration->IsNull()) { pConfiguration->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkPerformanceConfigurationINTEL* /*@@@USD*/out_pConfiguration = pConfiguration->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->AcquirePerformanceConfigurationINTEL(in_device, /*@@@AZI*/in_pAcquireInfo, /*@@@USD*/out_pConfiguration)/*@@@ABC*/;
    CheckResult("vkAcquirePerformanceConfigurationINTEL", returnValue, replay_result, call_info);
    AddHandle<PerformanceConfigurationINTELInfo>(device, pConfiguration->GetPointer(), /*@@@USD*/out_pConfiguration, &VulkanObjectInfoTable::AddPerformanceConfigurationINTELInfo);
}

void VulkanReplayConsumer::Process_vkReleasePerformanceConfigurationINTEL(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            configuration)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPerformanceConfigurationINTEL in_configuration = /*@@@QKJ*/MapHandle<PerformanceConfigurationINTELInfo>(configuration, &VulkanObjectInfoTable::GetPerformanceConfigurationINTELInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->ReleasePerformanceConfigurationINTEL(in_device, in_configuration)/*@@@ABC*/;
    CheckResult("vkReleasePerformanceConfigurationINTEL", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkQueueSetPerformanceConfigurationINTEL(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            queue,
    format::HandleId                            configuration)
{
    VkQueue in_queue = /*@@@QKJ*/MapHandle<QueueInfo>(queue, &VulkanObjectInfoTable::GetQueueInfo);
    VkPerformanceConfigurationINTEL in_configuration = /*@@@QKJ*/MapHandle<PerformanceConfigurationINTELInfo>(configuration, &VulkanObjectInfoTable::GetPerformanceConfigurationINTELInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_queue)->QueueSetPerformanceConfigurationINTEL(in_queue, in_configuration)/*@@@ABC*/;
    CheckResult("vkQueueSetPerformanceConfigurationINTEL", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPerformanceParameterINTEL(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkPerformanceParameterTypeINTEL             parameter,
    StructPointerDecoder<Decoded_VkPerformanceValueINTEL>/*@@@PLQ*/* pValue)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/VkPerformanceValueINTEL* /*@@@USD*/out_pValue = pValue->IsNull() ? nullptr : pValue->AllocateOutputData(1);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetPerformanceParameterINTEL(in_device, parameter, /*@@@USD*/out_pValue)/*@@@ABC*/;
    CheckResult("vkGetPerformanceParameterINTEL", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkSetLocalDimmingAMD(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            swapChain,
    VkBool32                                    localDimmingEnable)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkSetLocalDimmingAMD for offscreen.");
        return;
    }
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSwapchainKHR in_swapChain = /*@@@QKJ*/MapHandle<SwapchainKHRInfo>(swapChain, &VulkanObjectInfoTable::GetSwapchainKHRInfo);//@@@DFK
    GetDeviceTable(in_device)->SetLocalDimmingAMD(in_device, in_swapChain, localDimmingEnable)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCreateImagePipeSurfaceFUCHSIA(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    VkInstance in_instance = /*@@@QKJ*/MapHandle<InstanceInfo>(instance, &VulkanObjectInfoTable::GetInstanceInfo);
    /*@@@HPA*/const VkImagePipeSurfaceCreateInfoFUCHSIA* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkSurfaceKHR* /*@@@USD*/out_pSurface = pSurface->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetInstanceTable(in_instance)->CreateImagePipeSurfaceFUCHSIA(in_instance, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pSurface)/*@@@ABC*/;
    CheckResult("vkCreateImagePipeSurfaceFUCHSIA", returnValue, replay_result, call_info);
    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), /*@@@USD*/out_pSurface, &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkCreateMetalSurfaceEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkMetalSurfaceCreateInfoEXT>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    auto in_instance = GetObjectInfoTable().GetInstanceInfo(instance);
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }
    SurfaceKHRInfo handle_info;
    pSurface->SetConsumerData(0, &handle_info);

    VkResult replay_result = OverrideCreateMetalSurfaceEXT(GetInstanceTable(in_instance->handle)->CreateMetalSurfaceEXT, returnValue, in_instance, pCreateInfo, pAllocator, pSurface);
    CheckResult("vkCreateMetalSurfaceEXT", returnValue, replay_result, call_info);

    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), pSurface->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkGetBufferDeviceAddressEXT(
    const ApiCallInfo&                          call_info,
    VkDeviceAddress                             returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkBufferDeviceAddressInfo>/*@@@PLQ*/* pInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkBufferDeviceAddressInfo* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    GetDeviceTable(in_device)->GetBufferDeviceAddressEXT(in_device, /*@@@AZI*/in_pInfo)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceToolPropertiesEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pToolCount,
    StructPointerDecoder<Decoded_VkPhysicalDeviceToolProperties>/*@@@PLQ*/* pToolProperties)
{
    auto in_physicalDevice = GetObjectInfoTable().GetPhysicalDeviceInfo(physicalDevice);
    pToolCount->IsNull() ? nullptr : pToolCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceToolPropertiesEXT", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceToolPropertiesEXT, pToolCount, pToolProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    if (!pToolProperties->IsNull()) { pToolProperties->AllocateOutputData(*pToolCount->GetOutputPointer(), VkPhysicalDeviceToolProperties{ VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES, nullptr }); /*@@@FFA*/  }//@@@DFK
    VkResult replay_result = OverrideGetPhysicalDeviceToolProperties(GetInstanceTable(in_physicalDevice->handle)->GetPhysicalDeviceToolPropertiesEXT, returnValue, in_physicalDevice, pToolCount, pToolProperties)/*@@@HNM*/;
    CheckResult("vkGetPhysicalDeviceToolPropertiesEXT", returnValue, replay_result, call_info);
    if (pToolProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceToolPropertiesEXT, *pToolCount->GetOutputPointer(), &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceCooperativeMatrixPropertiesNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pPropertyCount,
    StructPointerDecoder<Decoded_VkCooperativeMatrixPropertiesNV>/*@@@PLQ*/* pProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPropertyCount = pPropertyCount->IsNull() ? nullptr : pPropertyCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceCooperativeMatrixPropertiesNV, pPropertyCount, pProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkCooperativeMatrixPropertiesNV* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(*/*@@@USD*/out_pPropertyCount, VkCooperativeMatrixPropertiesNV{ VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceCooperativeMatrixPropertiesNV(in_physicalDevice, /*@@@USD*/out_pPropertyCount, /*@@@USD*/out_pProperties)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceCooperativeMatrixPropertiesNV", returnValue, replay_result, call_info);
    if (pProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceCooperativeMatrixPropertiesNV, */*@@@USD*/out_pPropertyCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    PointerDecoder<uint32_t>*                   pCombinationCount,
    StructPointerDecoder<Decoded_VkFramebufferMixedSamplesCombinationNV>/*@@@PLQ*/* pCombinations)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pCombinationCount = pCombinationCount->IsNull() ? nullptr : pCombinationCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV, pCombinationCount, pCombinations, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkFramebufferMixedSamplesCombinationNV* /*@@@USD*/out_pCombinations = pCombinations->IsNull() ? nullptr : pCombinations->AllocateOutputData(*/*@@@USD*/out_pCombinationCount, VkFramebufferMixedSamplesCombinationNV{ VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV(in_physicalDevice, /*@@@USD*/out_pCombinationCount, /*@@@USD*/out_pCombinations)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV", returnValue, replay_result, call_info);
    if (pCombinations->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceSupportedFramebufferMixedSamplesCombinationsNV, */*@@@USD*/out_pCombinationCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceSurfacePresentModes2EXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>/*@@@PLQ*/* pSurfaceInfo,
    PointerDecoder<uint32_t>*                   pPresentModeCount,
    PointerDecoder<VkPresentModeKHR>*           pPresentModes)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetPhysicalDeviceSurfacePresentModes2EXT for offscreen.");
        return;
    }
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceSurfaceInfo2KHR* /*@@@AZI*/in_pSurfaceInfo = /*@@@HUY*/pSurfaceInfo->GetPointer();
    /*@@@EWC*/if (pSurfaceInfo->GetPointer()->surface == VK_NULL_HANDLE) { return; }
    MapStructHandles(pSurfaceInfo->GetMetaStructPointer(), GetObjectInfoTable());
    auto /*@@@UIW*/in_pSurfaceInfo_meta = pSurfaceInfo->GetMetaStructPointer();
    /*@@@HSW*/if (GetObjectInfoTable().GetSurfaceKHRInfo(/*@@@UIW*/in_pSurfaceInfo_meta->surface) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(/*@@@UIW*/in_pSurfaceInfo_meta->surface)->surface_creation_skipped) { return; }
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPresentModeCount = pPresentModeCount->IsNull() ? nullptr : pPresentModeCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceSurfacePresentModes2EXT", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceSurfacePresentModes2EXT, pPresentModeCount, pPresentModes, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkPresentModeKHR* /*@@@USD*/out_pPresentModes = pPresentModes->IsNull() ? nullptr : pPresentModes->AllocateOutputData(*/*@@@USD*/out_pPresentModeCount); //@@@DEA//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceSurfacePresentModes2EXT(in_physicalDevice, /*@@@AZI*/in_pSurfaceInfo, /*@@@USD*/out_pPresentModeCount, /*@@@USD*/out_pPresentModes)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceSurfacePresentModes2EXT", returnValue, replay_result, call_info);
    if (pPresentModes->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceSurfacePresentModes2EXT, */*@@@USD*/out_pPresentModeCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkAcquireFullScreenExclusiveModeEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain)
{
    if ((options_.swapchain_option == util::SwapchainOption::kOffscreen) || (options_.force_windowed_origin == true) || (options_.force_windowed == true))
    {
        GFXRECON_LOG_DEBUG("Skip vkAcquireFullScreenExclusiveModeEXT for offscreen or force windowed mode.");
        return;
    }
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSwapchainKHR in_swapchain = /*@@@QKJ*/MapHandle<SwapchainKHRInfo>(swapchain, &VulkanObjectInfoTable::GetSwapchainKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id)->surface_creation_skipped) { return; }//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->AcquireFullScreenExclusiveModeEXT(in_device, in_swapchain)/*@@@ABC*/;
    CheckResult("vkAcquireFullScreenExclusiveModeEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkReleaseFullScreenExclusiveModeEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkReleaseFullScreenExclusiveModeEXT for offscreen.");
        return;
    }
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSwapchainKHR in_swapchain = /*@@@QKJ*/MapHandle<SwapchainKHRInfo>(swapchain, &VulkanObjectInfoTable::GetSwapchainKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id)->surface_creation_skipped) { return; }//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->ReleaseFullScreenExclusiveModeEXT(in_device, in_swapchain)/*@@@ABC*/;
    CheckResult("vkReleaseFullScreenExclusiveModeEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetDeviceGroupSurfacePresentModes2EXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkPhysicalDeviceSurfaceInfo2KHR>/*@@@PLQ*/* pSurfaceInfo,
    PointerDecoder<VkDeviceGroupPresentModeFlagsKHR>* pModes)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetDeviceGroupSurfacePresentModes2EXT for offscreen.");
        return;
    }
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkPhysicalDeviceSurfaceInfo2KHR* /*@@@AZI*/in_pSurfaceInfo = /*@@@HUY*/pSurfaceInfo->GetPointer();
    /*@@@EWC*/if (pSurfaceInfo->GetPointer()->surface == VK_NULL_HANDLE) { return; }
    MapStructHandles(pSurfaceInfo->GetMetaStructPointer(), GetObjectInfoTable());
    auto /*@@@UIW*/in_pSurfaceInfo_meta = pSurfaceInfo->GetMetaStructPointer();
    /*@@@HSW*/if (GetObjectInfoTable().GetSurfaceKHRInfo(/*@@@UIW*/in_pSurfaceInfo_meta->surface) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(/*@@@UIW*/in_pSurfaceInfo_meta->surface)->surface_creation_skipped) { return; }
    /*@@@HPA*/VkDeviceGroupPresentModeFlagsKHR* /*@@@USD*/out_pModes = pModes->IsNull() ? nullptr : pModes->AllocateOutputData(1, static_cast<VkDeviceGroupPresentModeFlagsKHR>(0));//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetDeviceGroupSurfacePresentModes2EXT(in_device, /*@@@AZI*/in_pSurfaceInfo, /*@@@USD*/out_pModes)/*@@@ABC*/;
    CheckResult("vkGetDeviceGroupSurfacePresentModes2EXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCreateHeadlessSurfaceEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkHeadlessSurfaceCreateInfoEXT>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    auto in_instance = GetObjectInfoTable().GetInstanceInfo(instance);
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }//@@@HET
    SurfaceKHRInfo handle_info;
    pSurface->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateHeadlessSurfaceEXT(GetInstanceTable(in_instance->handle)->CreateHeadlessSurfaceEXT, returnValue, in_instance, pCreateInfo, pAllocator, pSurface)/*@@@HNM*/;
    CheckResult("vkCreateHeadlessSurfaceEXT", returnValue, replay_result, call_info);
    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), pSurface->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkCmdSetLineStippleEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    lineStippleFactor,
    uint16_t                                    lineStipplePattern)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetLineStippleEXT(in_commandBuffer, lineStippleFactor, lineStipplePattern)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetLineStippleEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkResetQueryPoolEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery,
    uint32_t                                    queryCount)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);//@@@DFK
    GetDeviceTable(in_device)->ResetQueryPoolEXT(in_device, in_queryPool, firstQuery, queryCount)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdSetCullModeEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkCullModeFlags                             cullMode)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetCullModeEXT(in_commandBuffer, cullMode)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetCullModeEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetFrontFaceEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkFrontFace                                 frontFace)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetFrontFaceEXT(in_commandBuffer, frontFace)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetFrontFaceEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetPrimitiveTopologyEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkPrimitiveTopology                         primitiveTopology)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetPrimitiveTopologyEXT(in_commandBuffer, primitiveTopology)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetPrimitiveTopologyEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetViewportWithCountEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    viewportCount,
    StructPointerDecoder<Decoded_VkViewport>/*@@@PLQ*/* pViewports)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkViewport* /*@@@AZI*/in_pViewports = /*@@@HUY*/pViewports->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetViewportWithCountEXT(in_commandBuffer, viewportCount, /*@@@AZI*/in_pViewports)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetViewportWithCountEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetScissorWithCountEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    scissorCount,
    StructPointerDecoder<Decoded_VkRect2D>/*@@@PLQ*/* pScissors)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkRect2D* /*@@@AZI*/in_pScissors = /*@@@HUY*/pScissors->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetScissorWithCountEXT(in_commandBuffer, scissorCount, /*@@@AZI*/in_pScissors)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetScissorWithCountEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdBindVertexBuffers2EXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstBinding,
    uint32_t                                    bindingCount,
    HandlePointerDecoder<VkBuffer>*             pBuffers,
    PointerDecoder<VkDeviceSize>*               pOffsets,
    PointerDecoder<VkDeviceSize>*               pSizes,
    PointerDecoder<VkDeviceSize>*               pStrides)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkBuffer* /*@@@AZI*/in_pBuffers = /*@@@EDO*/MapHandles<BufferInfo>(pBuffers, bindingCount, &VulkanObjectInfoTable::GetBufferInfo);
    /*@@@HPA*/const VkDeviceSize* /*@@@AZI*/in_pOffsets = /*@@@HUY*/pOffsets->GetPointer();
    /*@@@HPA*/const VkDeviceSize* /*@@@AZI*/in_pSizes = /*@@@HUY*/pSizes->GetPointer();
    /*@@@HPA*/const VkDeviceSize* /*@@@AZI*/in_pStrides = /*@@@HUY*/pStrides->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBindVertexBuffers2EXT(in_commandBuffer, firstBinding, bindingCount, /*@@@AZI*/in_pBuffers, /*@@@AZI*/in_pOffsets, /*@@@AZI*/in_pSizes, /*@@@AZI*/in_pStrides)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBindVertexBuffers2EXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBindVertexBuffers2EXTHandles(in_commandBuffer, bindingCount, in_pBuffers);

    }
}

void VulkanReplayConsumer::Process_vkCmdSetDepthTestEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    depthTestEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthTestEnableEXT(in_commandBuffer, depthTestEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthTestEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetDepthWriteEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    depthWriteEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthWriteEnableEXT(in_commandBuffer, depthWriteEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthWriteEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetDepthCompareOpEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkCompareOp                                 depthCompareOp)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthCompareOpEXT(in_commandBuffer, depthCompareOp)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthCompareOpEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetDepthBoundsTestEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    depthBoundsTestEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthBoundsTestEnableEXT(in_commandBuffer, depthBoundsTestEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthBoundsTestEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetStencilTestEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    stencilTestEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetStencilTestEnableEXT(in_commandBuffer, stencilTestEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetStencilTestEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetStencilOpEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkStencilFaceFlags                          faceMask,
    VkStencilOp                                 failOp,
    VkStencilOp                                 passOp,
    VkStencilOp                                 depthFailOp,
    VkCompareOp                                 compareOp)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetStencilOpEXT(in_commandBuffer, faceMask, failOp, passOp, depthFailOp, compareOp)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetStencilOpEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCopyMemoryToImageEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkCopyMemoryToImageInfoEXT>/*@@@PLQ*/* pCopyMemoryToImageInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkCopyMemoryToImageInfoEXT* /*@@@AZI*/in_pCopyMemoryToImageInfo = /*@@@HUY*/pCopyMemoryToImageInfo->GetPointer();
    MapStructHandles(pCopyMemoryToImageInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CopyMemoryToImageEXT(in_device, /*@@@AZI*/in_pCopyMemoryToImageInfo)/*@@@ABC*/;
    CheckResult("vkCopyMemoryToImageEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCopyImageToMemoryEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkCopyImageToMemoryInfoEXT>/*@@@PLQ*/* pCopyImageToMemoryInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkCopyImageToMemoryInfoEXT* /*@@@AZI*/in_pCopyImageToMemoryInfo = /*@@@HUY*/pCopyImageToMemoryInfo->GetPointer();
    MapStructHandles(pCopyImageToMemoryInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CopyImageToMemoryEXT(in_device, /*@@@AZI*/in_pCopyImageToMemoryInfo)/*@@@ABC*/;
    CheckResult("vkCopyImageToMemoryEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCopyImageToImageEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkCopyImageToImageInfoEXT>/*@@@PLQ*/* pCopyImageToImageInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkCopyImageToImageInfoEXT* /*@@@AZI*/in_pCopyImageToImageInfo = /*@@@HUY*/pCopyImageToImageInfo->GetPointer();
    MapStructHandles(pCopyImageToImageInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CopyImageToImageEXT(in_device, /*@@@AZI*/in_pCopyImageToImageInfo)/*@@@ABC*/;
    CheckResult("vkCopyImageToImageEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkTransitionImageLayoutEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    transitionCount,
    StructPointerDecoder<Decoded_VkHostImageLayoutTransitionInfoEXT>/*@@@PLQ*/* pTransitions)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkHostImageLayoutTransitionInfoEXT* /*@@@AZI*/in_pTransitions = /*@@@HUY*/pTransitions->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pTransitions->GetMetaStructPointer(), pTransitions->GetLength(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->TransitionImageLayoutEXT(in_device, transitionCount, /*@@@AZI*/in_pTransitions)/*@@@ABC*/;
    CheckResult("vkTransitionImageLayoutEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetImageSubresourceLayout2EXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            image,
    StructPointerDecoder<Decoded_VkImageSubresource2KHR>/*@@@PLQ*/* pSubresource,
    StructPointerDecoder<Decoded_VkSubresourceLayout2KHR>/*@@@PLQ*/* pLayout)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkImage in_image = /*@@@QKJ*/MapHandle<ImageInfo>(image, &VulkanObjectInfoTable::GetImageInfo);
    /*@@@HPA*/const VkImageSubresource2KHR* /*@@@AZI*/in_pSubresource = /*@@@HUY*/pSubresource->GetPointer();
    /*@@@HPA*/VkSubresourceLayout2KHR* /*@@@USD*/out_pLayout = pLayout->IsNull() ? nullptr : pLayout->AllocateOutputData(1, { VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR, nullptr });
    InitializeOutputStructPNext(pLayout);//@@@DFK
    GetDeviceTable(in_device)->GetImageSubresourceLayout2EXT(in_device, in_image, /*@@@AZI*/in_pSubresource, /*@@@USD*/out_pLayout)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkReleaseSwapchainImagesEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkReleaseSwapchainImagesInfoEXT>/*@@@PLQ*/* pReleaseInfo)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkReleaseSwapchainImagesEXT for offscreen.");
        return;
    }
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkReleaseSwapchainImagesInfoEXT* /*@@@AZI*/in_pReleaseInfo = /*@@@HUY*/pReleaseInfo->GetPointer();
    MapStructHandles(pReleaseInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->ReleaseSwapchainImagesEXT(in_device, /*@@@AZI*/in_pReleaseInfo)/*@@@ABC*/;
    CheckResult("vkReleaseSwapchainImagesEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetGeneratedCommandsMemoryRequirementsNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkGeneratedCommandsMemoryRequirementsInfoNV>/*@@@PLQ*/* pInfo,
    StructPointerDecoder<Decoded_VkMemoryRequirements2>/*@@@PLQ*/* pMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkGeneratedCommandsMemoryRequirementsInfoNV* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkMemoryRequirements2* /*@@@USD*/out_pMemoryRequirements = pMemoryRequirements->IsNull() ? nullptr : pMemoryRequirements->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, nullptr });
    InitializeOutputStructPNext(pMemoryRequirements);//@@@DFK
    GetDeviceTable(in_device)->GetGeneratedCommandsMemoryRequirementsNV(in_device, /*@@@AZI*/in_pInfo, /*@@@USD*/out_pMemoryRequirements)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdPreprocessGeneratedCommandsNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkGeneratedCommandsInfoNV>/*@@@PLQ*/* pGeneratedCommandsInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkGeneratedCommandsInfoNV* /*@@@AZI*/in_pGeneratedCommandsInfo = /*@@@HUY*/pGeneratedCommandsInfo->GetPointer();
    MapStructHandles(pGeneratedCommandsInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdPreprocessGeneratedCommandsNV(in_commandBuffer, /*@@@AZI*/in_pGeneratedCommandsInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdPreprocessGeneratedCommandsNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdPreprocessGeneratedCommandsNVHandles(in_commandBuffer, in_pGeneratedCommandsInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdExecuteGeneratedCommandsNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    isPreprocessed,
    StructPointerDecoder<Decoded_VkGeneratedCommandsInfoNV>/*@@@PLQ*/* pGeneratedCommandsInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkGeneratedCommandsInfoNV* /*@@@AZI*/in_pGeneratedCommandsInfo = /*@@@HUY*/pGeneratedCommandsInfo->GetPointer();
    MapStructHandles(pGeneratedCommandsInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdExecuteGeneratedCommandsNV(in_commandBuffer, isPreprocessed, /*@@@AZI*/in_pGeneratedCommandsInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdExecuteGeneratedCommandsNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdExecuteGeneratedCommandsNVHandles(in_commandBuffer, in_pGeneratedCommandsInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdBindPipelineShaderGroupNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    format::HandleId                            pipeline,
    uint32_t                                    groupIndex)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkPipeline in_pipeline = /*@@@QKJ*/MapHandle<PipelineInfo>(pipeline, &VulkanObjectInfoTable::GetPipelineInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBindPipelineShaderGroupNV(in_commandBuffer, pipelineBindPoint, in_pipeline, groupIndex)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBindPipelineShaderGroupNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBindPipelineShaderGroupNVHandles(in_commandBuffer, in_pipeline);

    }
}

void VulkanReplayConsumer::Process_vkCreateIndirectCommandsLayoutNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkIndirectCommandsLayoutCreateInfoNV>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkIndirectCommandsLayoutNV>* pIndirectCommandsLayout)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkIndirectCommandsLayoutCreateInfoNV* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pIndirectCommandsLayout->IsNull()) { pIndirectCommandsLayout->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkIndirectCommandsLayoutNV* /*@@@USD*/out_pIndirectCommandsLayout = pIndirectCommandsLayout->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateIndirectCommandsLayoutNV(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pIndirectCommandsLayout)/*@@@ABC*/;
    CheckResult("vkCreateIndirectCommandsLayoutNV", returnValue, replay_result, call_info);
    AddHandle<IndirectCommandsLayoutNVInfo>(device, pIndirectCommandsLayout->GetPointer(), /*@@@USD*/out_pIndirectCommandsLayout, &VulkanObjectInfoTable::AddIndirectCommandsLayoutNVInfo);
}

void VulkanReplayConsumer::Process_vkDestroyIndirectCommandsLayoutNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            indirectCommandsLayout,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkIndirectCommandsLayoutNV in_indirectCommandsLayout = /*@@@QKJ*/MapHandle<IndirectCommandsLayoutNVInfo>(indirectCommandsLayout, &VulkanObjectInfoTable::GetIndirectCommandsLayoutNVInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyIndirectCommandsLayoutNV(in_device, in_indirectCommandsLayout, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(indirectCommandsLayout, &VulkanObjectInfoTable::RemoveIndirectCommandsLayoutNVInfo);
}

void VulkanReplayConsumer::Process_vkCmdSetDepthBias2EXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkDepthBiasInfoEXT>/*@@@PLQ*/* pDepthBiasInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkDepthBiasInfoEXT* /*@@@AZI*/in_pDepthBiasInfo = /*@@@HUY*/pDepthBiasInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthBias2EXT(in_commandBuffer, /*@@@AZI*/in_pDepthBiasInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthBias2EXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkAcquireDrmDisplayEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    int32_t                                     drmFd,
    format::HandleId                            display)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    VkDisplayKHR in_display = /*@@@QKJ*/MapHandle<DisplayKHRInfo>(display, &VulkanObjectInfoTable::GetDisplayKHRInfo);//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->AcquireDrmDisplayEXT(in_physicalDevice, drmFd, in_display)/*@@@ABC*/;
    CheckResult("vkAcquireDrmDisplayEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetDrmDisplayEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    int32_t                                     drmFd,
    uint32_t                                    connectorId,
    HandlePointerDecoder<VkDisplayKHR>*         display)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    if (!display->IsNull()) { display->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkDisplayKHR* /*@@@USD*/out_display = display->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetDrmDisplayEXT(in_physicalDevice, drmFd, connectorId, /*@@@USD*/out_display)/*@@@ABC*/;
    CheckResult("vkGetDrmDisplayEXT", returnValue, replay_result, call_info);
    AddHandle<DisplayKHRInfo>(physicalDevice, display->GetPointer(), /*@@@USD*/out_display, &VulkanObjectInfoTable::AddDisplayKHRInfo);
}

void VulkanReplayConsumer::Process_vkCreatePrivateDataSlotEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkPrivateDataSlotCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkPrivateDataSlot>*    pPrivateDataSlot)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkPrivateDataSlotCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pPrivateDataSlot->IsNull()) { pPrivateDataSlot->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkPrivateDataSlot* /*@@@USD*/out_pPrivateDataSlot = pPrivateDataSlot->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreatePrivateDataSlotEXT(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pPrivateDataSlot)/*@@@ABC*/;
    CheckResult("vkCreatePrivateDataSlotEXT", returnValue, replay_result, call_info);
    AddHandle<PrivateDataSlotInfo>(device, pPrivateDataSlot->GetPointer(), /*@@@USD*/out_pPrivateDataSlot, &VulkanObjectInfoTable::AddPrivateDataSlotInfo);
}

void VulkanReplayConsumer::Process_vkDestroyPrivateDataSlotEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            privateDataSlot,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPrivateDataSlot in_privateDataSlot = /*@@@QKJ*/MapHandle<PrivateDataSlotInfo>(privateDataSlot, &VulkanObjectInfoTable::GetPrivateDataSlotInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyPrivateDataSlotEXT(in_device, in_privateDataSlot, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(privateDataSlot, &VulkanObjectInfoTable::RemovePrivateDataSlotInfo);
}

void VulkanReplayConsumer::Process_vkSetPrivateDataEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkObjectType                                objectType,
    uint64_t                                    objectHandle,
    format::HandleId                            privateDataSlot,
    uint64_t                                    data)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    uint64_t in_objectHandle = /*@@@REX*/MapHandle(objectHandle, objectType);
    VkPrivateDataSlot in_privateDataSlot = /*@@@QKJ*/MapHandle<PrivateDataSlotInfo>(privateDataSlot, &VulkanObjectInfoTable::GetPrivateDataSlotInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->SetPrivateDataEXT(in_device, objectType, in_objectHandle, in_privateDataSlot, data)/*@@@ABC*/;
    CheckResult("vkSetPrivateDataEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetPrivateDataEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    VkObjectType                                objectType,
    uint64_t                                    objectHandle,
    format::HandleId                            privateDataSlot,
    PointerDecoder<uint64_t>*                   pData)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    uint64_t in_objectHandle = /*@@@REX*/MapHandle(objectHandle, objectType);
    VkPrivateDataSlot in_privateDataSlot = /*@@@QKJ*/MapHandle<PrivateDataSlotInfo>(privateDataSlot, &VulkanObjectInfoTable::GetPrivateDataSlotInfo);
    /*@@@HPA*/uint64_t* /*@@@USD*/out_pData = pData->IsNull() ? nullptr : pData->AllocateOutputData(1, static_cast<uint64_t>(0));//@@@DFK
    GetDeviceTable(in_device)->GetPrivateDataEXT(in_device, objectType, in_objectHandle, in_privateDataSlot, /*@@@USD*/out_pData)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdSetFragmentShadingRateEnumNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkFragmentShadingRateNV                     shadingRate,
    PointerDecoder<VkFragmentShadingRateCombinerOpKHR>* combinerOps)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkFragmentShadingRateCombinerOpKHR* /*@@@AZI*/in_combinerOps = /*@@@HUY*/combinerOps->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetFragmentShadingRateEnumNV(in_commandBuffer, shadingRate, /*@@@AZI*/in_combinerOps)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetFragmentShadingRateEnumNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkGetDeviceFaultInfoEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDeviceFaultCountsEXT>/*@@@PLQ*/* pFaultCounts,
    StructPointerDecoder<Decoded_VkDeviceFaultInfoEXT>/*@@@PLQ*/* pFaultInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/VkDeviceFaultCountsEXT* /*@@@USD*/out_pFaultCounts = pFaultCounts->IsNull() ? nullptr : pFaultCounts->AllocateOutputData(1, { VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT, nullptr });
    InitializeOutputStructPNext(pFaultCounts);
    /*@@@HPA*/VkDeviceFaultInfoEXT* /*@@@USD*/out_pFaultInfo = pFaultInfo->IsNull() ? nullptr : pFaultInfo->AllocateOutputData(1, { VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT, nullptr });
    InitializeOutputStructPNext(pFaultInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetDeviceFaultInfoEXT(in_device, /*@@@USD*/out_pFaultCounts, /*@@@USD*/out_pFaultInfo)/*@@@ABC*/;
    CheckResult("vkGetDeviceFaultInfoEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkAcquireWinrtDisplayNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    format::HandleId                            display)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    VkDisplayKHR in_display = /*@@@QKJ*/MapHandle<DisplayKHRInfo>(display, &VulkanObjectInfoTable::GetDisplayKHRInfo);//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->AcquireWinrtDisplayNV(in_physicalDevice, in_display)/*@@@ABC*/;
    CheckResult("vkAcquireWinrtDisplayNV", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetWinrtDisplayNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    deviceRelativeId,
    HandlePointerDecoder<VkDisplayKHR>*         pDisplay)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    if (!pDisplay->IsNull()) { pDisplay->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkDisplayKHR* /*@@@USD*/out_pDisplay = pDisplay->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetWinrtDisplayNV(in_physicalDevice, deviceRelativeId, /*@@@USD*/out_pDisplay)/*@@@ABC*/;
    CheckResult("vkGetWinrtDisplayNV", returnValue, replay_result, call_info);
    AddHandle<DisplayKHRInfo>(physicalDevice, pDisplay->GetPointer(), /*@@@USD*/out_pDisplay, &VulkanObjectInfoTable::AddDisplayKHRInfo);
}

void VulkanReplayConsumer::Process_vkCreateDirectFBSurfaceEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkDirectFBSurfaceCreateInfoEXT>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    VkInstance in_instance = /*@@@QKJ*/MapHandle<InstanceInfo>(instance, &VulkanObjectInfoTable::GetInstanceInfo);
    /*@@@HPA*/const VkDirectFBSurfaceCreateInfoEXT* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkSurfaceKHR* /*@@@USD*/out_pSurface = pSurface->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetInstanceTable(in_instance)->CreateDirectFBSurfaceEXT(in_instance, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pSurface)/*@@@ABC*/;
    CheckResult("vkCreateDirectFBSurfaceEXT", returnValue, replay_result, call_info);
    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), /*@@@USD*/out_pSurface, &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceDirectFBPresentationSupportEXT(
    const ApiCallInfo&                          call_info,
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint64_t                                    dfb)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/IDirectFB* /*@@@AZI*/in_dfb = /*@@@WSX*/static_cast<IDirectFB*>(PreProcessExternalObject(dfb, format::ApiCallId::ApiCall_vkGetPhysicalDeviceDirectFBPresentationSupportEXT, "vkGetPhysicalDeviceDirectFBPresentationSupportEXT"));//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceDirectFBPresentationSupportEXT(in_physicalDevice, queueFamilyIndex, /*@@@AZI*/in_dfb)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdSetVertexInputEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    vertexBindingDescriptionCount,
    StructPointerDecoder<Decoded_VkVertexInputBindingDescription2EXT>/*@@@PLQ*/* pVertexBindingDescriptions,
    uint32_t                                    vertexAttributeDescriptionCount,
    StructPointerDecoder<Decoded_VkVertexInputAttributeDescription2EXT>/*@@@PLQ*/* pVertexAttributeDescriptions)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkVertexInputBindingDescription2EXT* /*@@@AZI*/in_pVertexBindingDescriptions = /*@@@HUY*/pVertexBindingDescriptions->GetPointer();
    /*@@@HPA*/const VkVertexInputAttributeDescription2EXT* /*@@@AZI*/in_pVertexAttributeDescriptions = /*@@@HUY*/pVertexAttributeDescriptions->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetVertexInputEXT(in_commandBuffer, vertexBindingDescriptionCount, /*@@@AZI*/in_pVertexBindingDescriptions, vertexAttributeDescriptionCount, /*@@@AZI*/in_pVertexAttributeDescriptions)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetVertexInputEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkGetMemoryZirconHandleFUCHSIA(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkMemoryGetZirconHandleInfoFUCHSIA>/*@@@PLQ*/* pGetZirconHandleInfo,
    PointerDecoder<uint32_t>*                   pZirconHandle)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkMemoryGetZirconHandleInfoFUCHSIA* /*@@@AZI*/in_pGetZirconHandleInfo = /*@@@HUY*/pGetZirconHandleInfo->GetPointer();
    MapStructHandles(pGetZirconHandleInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/zx_handle_t* /*@@@USD*/out_pZirconHandle = pZirconHandle->IsNull() ? nullptr : pZirconHandle->AllocateOutputData(1, static_cast<uint32_t>(0));//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetMemoryZirconHandleFUCHSIA(in_device, /*@@@AZI*/in_pGetZirconHandleInfo, /*@@@USD*/out_pZirconHandle)/*@@@ABC*/;
    CheckResult("vkGetMemoryZirconHandleFUCHSIA", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetMemoryZirconHandlePropertiesFUCHSIA(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    VkExternalMemoryHandleTypeFlagBits          handleType,
    uint32_t                                    zirconHandle,
    StructPointerDecoder<Decoded_VkMemoryZirconHandlePropertiesFUCHSIA>/*@@@PLQ*/* pMemoryZirconHandleProperties)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/VkMemoryZirconHandlePropertiesFUCHSIA* /*@@@USD*/out_pMemoryZirconHandleProperties = pMemoryZirconHandleProperties->IsNull() ? nullptr : pMemoryZirconHandleProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA, nullptr });
    InitializeOutputStructPNext(pMemoryZirconHandleProperties);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetMemoryZirconHandlePropertiesFUCHSIA(in_device, handleType, zirconHandle, /*@@@USD*/out_pMemoryZirconHandleProperties)/*@@@ABC*/;
    CheckResult("vkGetMemoryZirconHandlePropertiesFUCHSIA", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkImportSemaphoreZirconHandleFUCHSIA(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkImportSemaphoreZirconHandleInfoFUCHSIA>/*@@@PLQ*/* pImportSemaphoreZirconHandleInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkImportSemaphoreZirconHandleInfoFUCHSIA* /*@@@AZI*/in_pImportSemaphoreZirconHandleInfo = /*@@@HUY*/pImportSemaphoreZirconHandleInfo->GetPointer();
    MapStructHandles(pImportSemaphoreZirconHandleInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->ImportSemaphoreZirconHandleFUCHSIA(in_device, /*@@@AZI*/in_pImportSemaphoreZirconHandleInfo)/*@@@ABC*/;
    CheckResult("vkImportSemaphoreZirconHandleFUCHSIA", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkGetSemaphoreZirconHandleFUCHSIA(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkSemaphoreGetZirconHandleInfoFUCHSIA>/*@@@PLQ*/* pGetZirconHandleInfo,
    PointerDecoder<uint32_t>*                   pZirconHandle)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkSemaphoreGetZirconHandleInfoFUCHSIA* /*@@@AZI*/in_pGetZirconHandleInfo = /*@@@HUY*/pGetZirconHandleInfo->GetPointer();
    MapStructHandles(pGetZirconHandleInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/zx_handle_t* /*@@@USD*/out_pZirconHandle = pZirconHandle->IsNull() ? nullptr : pZirconHandle->AllocateOutputData(1, static_cast<uint32_t>(0));//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetSemaphoreZirconHandleFUCHSIA(in_device, /*@@@AZI*/in_pGetZirconHandleInfo, /*@@@USD*/out_pZirconHandle)/*@@@ABC*/;
    CheckResult("vkGetSemaphoreZirconHandleFUCHSIA", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdBindInvocationMaskHUAWEI(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            imageView,
    VkImageLayout                               imageLayout)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkImageView in_imageView = /*@@@QKJ*/MapHandle<ImageViewInfo>(imageView, &VulkanObjectInfoTable::GetImageViewInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBindInvocationMaskHUAWEI(in_commandBuffer, in_imageView, imageLayout)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBindInvocationMaskHUAWEI;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBindInvocationMaskHUAWEIHandles(in_commandBuffer, in_imageView);

    }
}

void VulkanReplayConsumer::Process_vkGetMemoryRemoteAddressNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkMemoryGetRemoteAddressInfoNV>/*@@@PLQ*/* pMemoryGetRemoteAddressInfo,
    PointerDecoder<uint64_t, void*>*            pAddress)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkMemoryGetRemoteAddressInfoNV* /*@@@AZI*/in_pMemoryGetRemoteAddressInfo = /*@@@HUY*/pMemoryGetRemoteAddressInfo->GetPointer();
    MapStructHandles(pMemoryGetRemoteAddressInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkRemoteAddressNV* /*@@@USD*/out_pAddress = pAddress->IsNull() ? nullptr : reinterpret_cast<VkRemoteAddressNV*>(pAddress->AllocateOutputData(1));//@@CCC//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetMemoryRemoteAddressNV(in_device, /*@@@AZI*/in_pMemoryGetRemoteAddressInfo, /*@@@USD*/out_pAddress)/*@@@ABC*/;
    CheckResult("vkGetMemoryRemoteAddressNV", returnValue, replay_result, call_info);
    PostProcessExternalObject(replay_result, (*pAddress->GetPointer()), static_cast<void*>(*/*@@@USD*/out_pAddress), format::ApiCallId::ApiCall_vkGetMemoryRemoteAddressNV, "vkGetMemoryRemoteAddressNV");//@@HPP
}

void VulkanReplayConsumer::Process_vkCmdSetPatchControlPointsEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    patchControlPoints)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetPatchControlPointsEXT(in_commandBuffer, patchControlPoints)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetPatchControlPointsEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetRasterizerDiscardEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    rasterizerDiscardEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetRasterizerDiscardEnableEXT(in_commandBuffer, rasterizerDiscardEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetRasterizerDiscardEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetDepthBiasEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    depthBiasEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthBiasEnableEXT(in_commandBuffer, depthBiasEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthBiasEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetLogicOpEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkLogicOp                                   logicOp)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetLogicOpEXT(in_commandBuffer, logicOp)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetLogicOpEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetPrimitiveRestartEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    primitiveRestartEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetPrimitiveRestartEnableEXT(in_commandBuffer, primitiveRestartEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetPrimitiveRestartEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCreateScreenSurfaceQNX(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            instance,
    StructPointerDecoder<Decoded_VkScreenSurfaceCreateInfoQNX>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkSurfaceKHR>*         pSurface)
{
    VkInstance in_instance = /*@@@QKJ*/MapHandle<InstanceInfo>(instance, &VulkanObjectInfoTable::GetInstanceInfo);
    /*@@@HPA*/const VkScreenSurfaceCreateInfoQNX* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pSurface->IsNull()) { pSurface->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkSurfaceKHR* /*@@@USD*/out_pSurface = pSurface->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetInstanceTable(in_instance)->CreateScreenSurfaceQNX(in_instance, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pSurface)/*@@@ABC*/;
    CheckResult("vkCreateScreenSurfaceQNX", returnValue, replay_result, call_info);
    AddHandle<SurfaceKHRInfo>(instance, pSurface->GetPointer(), /*@@@USD*/out_pSurface, &VulkanObjectInfoTable::AddSurfaceKHRInfo);
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceScreenPresentationSupportQNX(
    const ApiCallInfo&                          call_info,
    VkBool32                                    returnValue,
    format::HandleId                            physicalDevice,
    uint32_t                                    queueFamilyIndex,
    uint64_t                                    window)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/struct _screen_window* /*@@@AZI*/in_window = /*@@@WSX*/static_cast<struct _screen_window*>(PreProcessExternalObject(window, format::ApiCallId::ApiCall_vkGetPhysicalDeviceScreenPresentationSupportQNX, "vkGetPhysicalDeviceScreenPresentationSupportQNX"));//@@@DFK
    GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceScreenPresentationSupportQNX(in_physicalDevice, queueFamilyIndex, /*@@@AZI*/in_window)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdSetColorWriteEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    attachmentCount,
    PointerDecoder<VkBool32>*                   pColorWriteEnables)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkBool32* /*@@@AZI*/in_pColorWriteEnables = /*@@@HUY*/pColorWriteEnables->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetColorWriteEnableEXT(in_commandBuffer, attachmentCount, /*@@@AZI*/in_pColorWriteEnables)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetColorWriteEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdDrawMultiEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    drawCount,
    StructPointerDecoder<Decoded_VkMultiDrawInfoEXT>/*@@@PLQ*/* pVertexInfo,
    uint32_t                                    instanceCount,
    uint32_t                                    firstInstance,
    uint32_t                                    stride)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkMultiDrawInfoEXT* /*@@@AZI*/in_pVertexInfo = /*@@@HUY*/pVertexInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawMultiEXT(in_commandBuffer, drawCount, /*@@@AZI*/in_pVertexInfo, instanceCount, firstInstance, stride)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawMultiEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdDrawMultiIndexedEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    drawCount,
    StructPointerDecoder<Decoded_VkMultiDrawIndexedInfoEXT>/*@@@PLQ*/* pIndexInfo,
    uint32_t                                    instanceCount,
    uint32_t                                    firstInstance,
    uint32_t                                    stride,
    PointerDecoder<int32_t>*                    pVertexOffset)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkMultiDrawIndexedInfoEXT* /*@@@AZI*/in_pIndexInfo = /*@@@HUY*/pIndexInfo->GetPointer();
    /*@@@HPA*/const int32_t* /*@@@AZI*/in_pVertexOffset = /*@@@HUY*/pVertexOffset->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawMultiIndexedEXT(in_commandBuffer, drawCount, /*@@@AZI*/in_pIndexInfo, instanceCount, firstInstance, stride, /*@@@AZI*/in_pVertexOffset)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawMultiIndexedEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCreateMicromapEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkMicromapCreateInfoEXT>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkMicromapEXT>*        pMicromap)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkMicromapCreateInfoEXT* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pMicromap->IsNull()) { pMicromap->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkMicromapEXT* /*@@@USD*/out_pMicromap = pMicromap->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateMicromapEXT(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pMicromap)/*@@@ABC*/;
    CheckResult("vkCreateMicromapEXT", returnValue, replay_result, call_info);
    AddHandle<MicromapEXTInfo>(device, pMicromap->GetPointer(), /*@@@USD*/out_pMicromap, &VulkanObjectInfoTable::AddMicromapEXTInfo);
}

void VulkanReplayConsumer::Process_vkDestroyMicromapEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            micromap,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkMicromapEXT in_micromap = /*@@@QKJ*/MapHandle<MicromapEXTInfo>(micromap, &VulkanObjectInfoTable::GetMicromapEXTInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyMicromapEXT(in_device, in_micromap, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(micromap, &VulkanObjectInfoTable::RemoveMicromapEXTInfo);
}

void VulkanReplayConsumer::Process_vkCmdBuildMicromapsEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    infoCount,
    StructPointerDecoder<Decoded_VkMicromapBuildInfoEXT>/*@@@PLQ*/* pInfos)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkMicromapBuildInfoEXT* /*@@@AZI*/in_pInfos = /*@@@HUY*/pInfos->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pInfos->GetMetaStructPointer(), pInfos->GetLength(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBuildMicromapsEXT(in_commandBuffer, infoCount, /*@@@AZI*/in_pInfos)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBuildMicromapsEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBuildMicromapsEXTHandles(in_commandBuffer, infoCount, in_pInfos);

    }
}

void VulkanReplayConsumer::Process_vkBuildMicromapsEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            deferredOperation,
    uint32_t                                    infoCount,
    StructPointerDecoder<Decoded_VkMicromapBuildInfoEXT>/*@@@PLQ*/* pInfos)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDeferredOperationKHR in_deferredOperation = /*@@@QKJ*/MapHandle<DeferredOperationKHRInfo>(deferredOperation, &VulkanObjectInfoTable::GetDeferredOperationKHRInfo);
    /*@@@HPA*/const VkMicromapBuildInfoEXT* /*@@@AZI*/in_pInfos = /*@@@HUY*/pInfos->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pInfos->GetMetaStructPointer(), pInfos->GetLength(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->BuildMicromapsEXT(in_device, in_deferredOperation, infoCount, /*@@@AZI*/in_pInfos)/*@@@ABC*/;
    CheckResult("vkBuildMicromapsEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCopyMicromapEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            deferredOperation,
    StructPointerDecoder<Decoded_VkCopyMicromapInfoEXT>/*@@@PLQ*/* pInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDeferredOperationKHR in_deferredOperation = /*@@@QKJ*/MapHandle<DeferredOperationKHRInfo>(deferredOperation, &VulkanObjectInfoTable::GetDeferredOperationKHRInfo);
    /*@@@HPA*/const VkCopyMicromapInfoEXT* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CopyMicromapEXT(in_device, in_deferredOperation, /*@@@AZI*/in_pInfo)/*@@@ABC*/;
    CheckResult("vkCopyMicromapEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCopyMicromapToMemoryEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            deferredOperation,
    StructPointerDecoder<Decoded_VkCopyMicromapToMemoryInfoEXT>/*@@@PLQ*/* pInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDeferredOperationKHR in_deferredOperation = /*@@@QKJ*/MapHandle<DeferredOperationKHRInfo>(deferredOperation, &VulkanObjectInfoTable::GetDeferredOperationKHRInfo);
    /*@@@HPA*/const VkCopyMicromapToMemoryInfoEXT* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CopyMicromapToMemoryEXT(in_device, in_deferredOperation, /*@@@AZI*/in_pInfo)/*@@@ABC*/;
    CheckResult("vkCopyMicromapToMemoryEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCopyMemoryToMicromapEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            deferredOperation,
    StructPointerDecoder<Decoded_VkCopyMemoryToMicromapInfoEXT>/*@@@PLQ*/* pInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDeferredOperationKHR in_deferredOperation = /*@@@QKJ*/MapHandle<DeferredOperationKHRInfo>(deferredOperation, &VulkanObjectInfoTable::GetDeferredOperationKHRInfo);
    /*@@@HPA*/const VkCopyMemoryToMicromapInfoEXT* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CopyMemoryToMicromapEXT(in_device, in_deferredOperation, /*@@@AZI*/in_pInfo)/*@@@ABC*/;
    CheckResult("vkCopyMemoryToMicromapEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkWriteMicromapsPropertiesEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    micromapCount,
    HandlePointerDecoder<VkMicromapEXT>*        pMicromaps,
    VkQueryType                                 queryType,
    size_t                                      dataSize,
    PointerDecoder<uint8_t>*                    pData,
    size_t                                      stride)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkMicromapEXT* /*@@@AZI*/in_pMicromaps = /*@@@EDO*/MapHandles<MicromapEXTInfo>(pMicromaps, micromapCount, &VulkanObjectInfoTable::GetMicromapEXTInfo);
    /*@@@HPA*/void* /*@@@USD*/out_pData = pData->IsNull() ? nullptr : pData->AllocateOutputData(dataSize);//@@@EJH//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->WriteMicromapsPropertiesEXT(in_device, micromapCount, /*@@@AZI*/in_pMicromaps, queryType, dataSize, /*@@@USD*/out_pData, stride)/*@@@ABC*/;
    CheckResult("vkWriteMicromapsPropertiesEXT", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdCopyMicromapEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCopyMicromapInfoEXT>/*@@@PLQ*/* pInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCopyMicromapInfoEXT* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyMicromapEXT(in_commandBuffer, /*@@@AZI*/in_pInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyMicromapEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyMicromapEXTHandles(in_commandBuffer, in_pInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyMicromapToMemoryEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCopyMicromapToMemoryInfoEXT>/*@@@PLQ*/* pInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCopyMicromapToMemoryInfoEXT* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyMicromapToMemoryEXT(in_commandBuffer, /*@@@AZI*/in_pInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyMicromapToMemoryEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyMicromapToMemoryEXTHandles(in_commandBuffer, in_pInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyMemoryToMicromapEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCopyMemoryToMicromapInfoEXT>/*@@@PLQ*/* pInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCopyMemoryToMicromapInfoEXT* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyMemoryToMicromapEXT(in_commandBuffer, /*@@@AZI*/in_pInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyMemoryToMicromapEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyMemoryToMicromapEXTHandles(in_commandBuffer, in_pInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdWriteMicromapsPropertiesEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    micromapCount,
    HandlePointerDecoder<VkMicromapEXT>*        pMicromaps,
    VkQueryType                                 queryType,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkMicromapEXT* /*@@@AZI*/in_pMicromaps = /*@@@EDO*/MapHandles<MicromapEXTInfo>(pMicromaps, micromapCount, &VulkanObjectInfoTable::GetMicromapEXTInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdWriteMicromapsPropertiesEXT(in_commandBuffer, micromapCount, /*@@@AZI*/in_pMicromaps, queryType, in_queryPool, firstQuery)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdWriteMicromapsPropertiesEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdWriteMicromapsPropertiesEXTHandles(in_commandBuffer, micromapCount, in_pMicromaps, in_queryPool);

    }
}

void VulkanReplayConsumer::Process_vkGetDeviceMicromapCompatibilityEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkMicromapVersionInfoEXT>/*@@@PLQ*/* pVersionInfo,
    PointerDecoder<VkAccelerationStructureCompatibilityKHR>* pCompatibility)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkMicromapVersionInfoEXT* /*@@@AZI*/in_pVersionInfo = /*@@@HUY*/pVersionInfo->GetPointer();
    /*@@@HPA*/VkAccelerationStructureCompatibilityKHR* /*@@@USD*/out_pCompatibility = pCompatibility->IsNull() ? nullptr : pCompatibility->AllocateOutputData(1, static_cast<VkAccelerationStructureCompatibilityKHR>(0));//@@@DFK
    GetDeviceTable(in_device)->GetDeviceMicromapCompatibilityEXT(in_device, /*@@@AZI*/in_pVersionInfo, /*@@@USD*/out_pCompatibility)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetMicromapBuildSizesEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    VkAccelerationStructureBuildTypeKHR         buildType,
    StructPointerDecoder<Decoded_VkMicromapBuildInfoEXT>/*@@@PLQ*/* pBuildInfo,
    StructPointerDecoder<Decoded_VkMicromapBuildSizesInfoEXT>/*@@@PLQ*/* pSizeInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkMicromapBuildInfoEXT* /*@@@AZI*/in_pBuildInfo = /*@@@HUY*/pBuildInfo->GetPointer();
    MapStructHandles(pBuildInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkMicromapBuildSizesInfoEXT* /*@@@USD*/out_pSizeInfo = pSizeInfo->IsNull() ? nullptr : pSizeInfo->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT, nullptr });
    InitializeOutputStructPNext(pSizeInfo);//@@@DFK
    GetDeviceTable(in_device)->GetMicromapBuildSizesEXT(in_device, buildType, /*@@@AZI*/in_pBuildInfo, /*@@@USD*/out_pSizeInfo)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdDrawClusterHUAWEI(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawClusterHUAWEI(in_commandBuffer, groupCountX, groupCountY, groupCountZ)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawClusterHUAWEI;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdDrawClusterIndirectHUAWEI(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawClusterIndirectHUAWEI(in_commandBuffer, in_buffer, offset)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawClusterIndirectHUAWEI;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDrawClusterIndirectHUAWEIHandles(in_commandBuffer, in_buffer);

    }
}

void VulkanReplayConsumer::Process_vkSetDeviceMemoryPriorityEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            memory,
    float                                       priority)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDeviceMemory in_memory = /*@@@QKJ*/MapHandle<DeviceMemoryInfo>(memory, &VulkanObjectInfoTable::GetDeviceMemoryInfo);//@@@DFK
    GetDeviceTable(in_device)->SetDeviceMemoryPriorityEXT(in_device, in_memory, priority)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetDescriptorSetLayoutHostMappingInfoVALVE(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkDescriptorSetBindingReferenceVALVE>/*@@@PLQ*/* pBindingReference,
    StructPointerDecoder<Decoded_VkDescriptorSetLayoutHostMappingInfoVALVE>/*@@@PLQ*/* pHostMapping)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkDescriptorSetBindingReferenceVALVE* /*@@@AZI*/in_pBindingReference = /*@@@HUY*/pBindingReference->GetPointer();
    MapStructHandles(pBindingReference->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkDescriptorSetLayoutHostMappingInfoVALVE* /*@@@USD*/out_pHostMapping = pHostMapping->IsNull() ? nullptr : pHostMapping->AllocateOutputData(1, { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE, nullptr });
    InitializeOutputStructPNext(pHostMapping);//@@@DFK
    GetDeviceTable(in_device)->GetDescriptorSetLayoutHostMappingInfoVALVE(in_device, /*@@@AZI*/in_pBindingReference, /*@@@USD*/out_pHostMapping)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetDescriptorSetHostMappingVALVE(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            descriptorSet,
    PointerDecoder<uint64_t, void*>*            ppData)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDescriptorSet in_descriptorSet = /*@@@QKJ*/MapHandle<DescriptorSetInfo>(descriptorSet, &VulkanObjectInfoTable::GetDescriptorSetInfo);
    /*@@@HPA*/void** /*@@@USD*/out_ppData = ppData->IsNull() ? nullptr : ppData->AllocateOutputData(1);//@@@PEA//@@@DFK
    GetDeviceTable(in_device)->GetDescriptorSetHostMappingVALVE(in_device, in_descriptorSet, /*@@@USD*/out_ppData)/*@@@ABC*/;//@@@HQA
    PostProcessExternalObject(VK_SUCCESS, (*ppData->GetPointer()), *ppData->GetOutputPointer(), format::ApiCallId::ApiCall_vkGetDescriptorSetHostMappingVALVE, "vkGetDescriptorSetHostMappingVALVE");//@@OSH
}

void VulkanReplayConsumer::Process_vkGetPipelineIndirectMemoryRequirementsNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkComputePipelineCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkMemoryRequirements2>/*@@@PLQ*/* pMemoryRequirements)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkComputePipelineCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkMemoryRequirements2* /*@@@USD*/out_pMemoryRequirements = pMemoryRequirements->IsNull() ? nullptr : pMemoryRequirements->AllocateOutputData(1, { VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2, nullptr });
    InitializeOutputStructPNext(pMemoryRequirements);//@@@DFK
    GetDeviceTable(in_device)->GetPipelineIndirectMemoryRequirementsNV(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@USD*/out_pMemoryRequirements)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdUpdatePipelineIndirectBufferNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkPipelineBindPoint                         pipelineBindPoint,
    format::HandleId                            pipeline)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkPipeline in_pipeline = /*@@@QKJ*/MapHandle<PipelineInfo>(pipeline, &VulkanObjectInfoTable::GetPipelineInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdUpdatePipelineIndirectBufferNV(in_commandBuffer, pipelineBindPoint, in_pipeline)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdUpdatePipelineIndirectBufferNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdUpdatePipelineIndirectBufferNVHandles(in_commandBuffer, in_pipeline);

    }
}

void VulkanReplayConsumer::Process_vkGetPipelineIndirectDeviceAddressNV(
    const ApiCallInfo&                          call_info,
    VkDeviceAddress                             returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkPipelineIndirectDeviceAddressInfoNV>/*@@@PLQ*/* pInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkPipelineIndirectDeviceAddressInfoNV* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    GetDeviceTable(in_device)->GetPipelineIndirectDeviceAddressNV(in_device, /*@@@AZI*/in_pInfo)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdSetDepthClampEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    depthClampEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthClampEnableEXT(in_commandBuffer, depthClampEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthClampEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetPolygonModeEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkPolygonMode                               polygonMode)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetPolygonModeEXT(in_commandBuffer, polygonMode)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetPolygonModeEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetRasterizationSamplesEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkSampleCountFlagBits                       rasterizationSamples)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetRasterizationSamplesEXT(in_commandBuffer, rasterizationSamples)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetRasterizationSamplesEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetSampleMaskEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkSampleCountFlagBits                       samples,
    PointerDecoder<VkSampleMask>*               pSampleMask)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkSampleMask* /*@@@AZI*/in_pSampleMask = /*@@@HUY*/pSampleMask->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetSampleMaskEXT(in_commandBuffer, samples, /*@@@AZI*/in_pSampleMask)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetSampleMaskEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetAlphaToCoverageEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    alphaToCoverageEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetAlphaToCoverageEnableEXT(in_commandBuffer, alphaToCoverageEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetAlphaToCoverageEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetAlphaToOneEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    alphaToOneEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetAlphaToOneEnableEXT(in_commandBuffer, alphaToOneEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetAlphaToOneEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetLogicOpEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    logicOpEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetLogicOpEnableEXT(in_commandBuffer, logicOpEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetLogicOpEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetColorBlendEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstAttachment,
    uint32_t                                    attachmentCount,
    PointerDecoder<VkBool32>*                   pColorBlendEnables)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkBool32* /*@@@AZI*/in_pColorBlendEnables = /*@@@HUY*/pColorBlendEnables->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetColorBlendEnableEXT(in_commandBuffer, firstAttachment, attachmentCount, /*@@@AZI*/in_pColorBlendEnables)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetColorBlendEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetColorBlendEquationEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstAttachment,
    uint32_t                                    attachmentCount,
    StructPointerDecoder<Decoded_VkColorBlendEquationEXT>/*@@@PLQ*/* pColorBlendEquations)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkColorBlendEquationEXT* /*@@@AZI*/in_pColorBlendEquations = /*@@@HUY*/pColorBlendEquations->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetColorBlendEquationEXT(in_commandBuffer, firstAttachment, attachmentCount, /*@@@AZI*/in_pColorBlendEquations)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetColorBlendEquationEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetColorWriteMaskEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstAttachment,
    uint32_t                                    attachmentCount,
    PointerDecoder<VkColorComponentFlags>*      pColorWriteMasks)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkColorComponentFlags* /*@@@AZI*/in_pColorWriteMasks = /*@@@HUY*/pColorWriteMasks->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetColorWriteMaskEXT(in_commandBuffer, firstAttachment, attachmentCount, /*@@@AZI*/in_pColorWriteMasks)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetColorWriteMaskEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetTessellationDomainOriginEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkTessellationDomainOrigin                  domainOrigin)
{
    VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

    GetDeviceTable(in_commandBuffer)->CmdSetTessellationDomainOriginEXT(in_commandBuffer, domainOrigin);
}

void VulkanReplayConsumer::Process_vkCmdSetRasterizationStreamEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    rasterizationStream)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetRasterizationStreamEXT(in_commandBuffer, rasterizationStream)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetRasterizationStreamEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetConservativeRasterizationModeEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkConservativeRasterizationModeEXT          conservativeRasterizationMode)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetConservativeRasterizationModeEXT(in_commandBuffer, conservativeRasterizationMode)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetConservativeRasterizationModeEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetExtraPrimitiveOverestimationSizeEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    float                                       extraPrimitiveOverestimationSize)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetExtraPrimitiveOverestimationSizeEXT(in_commandBuffer, extraPrimitiveOverestimationSize)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetExtraPrimitiveOverestimationSizeEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetDepthClipEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    depthClipEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthClipEnableEXT(in_commandBuffer, depthClipEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthClipEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetSampleLocationsEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    sampleLocationsEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetSampleLocationsEnableEXT(in_commandBuffer, sampleLocationsEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetSampleLocationsEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetColorBlendAdvancedEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstAttachment,
    uint32_t                                    attachmentCount,
    StructPointerDecoder<Decoded_VkColorBlendAdvancedEXT>/*@@@PLQ*/* pColorBlendAdvanced)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkColorBlendAdvancedEXT* /*@@@AZI*/in_pColorBlendAdvanced = /*@@@HUY*/pColorBlendAdvanced->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetColorBlendAdvancedEXT(in_commandBuffer, firstAttachment, attachmentCount, /*@@@AZI*/in_pColorBlendAdvanced)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetColorBlendAdvancedEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetProvokingVertexModeEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkProvokingVertexModeEXT                    provokingVertexMode)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetProvokingVertexModeEXT(in_commandBuffer, provokingVertexMode)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetProvokingVertexModeEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetLineRasterizationModeEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkLineRasterizationModeEXT                  lineRasterizationMode)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetLineRasterizationModeEXT(in_commandBuffer, lineRasterizationMode)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetLineRasterizationModeEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetLineStippleEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    stippledLineEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetLineStippleEnableEXT(in_commandBuffer, stippledLineEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetLineStippleEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetDepthClipNegativeOneToOneEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    negativeOneToOne)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetDepthClipNegativeOneToOneEXT(in_commandBuffer, negativeOneToOne)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetDepthClipNegativeOneToOneEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetViewportWScalingEnableNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    viewportWScalingEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetViewportWScalingEnableNV(in_commandBuffer, viewportWScalingEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetViewportWScalingEnableNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetViewportSwizzleNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    firstViewport,
    uint32_t                                    viewportCount,
    StructPointerDecoder<Decoded_VkViewportSwizzleNV>/*@@@PLQ*/* pViewportSwizzles)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkViewportSwizzleNV* /*@@@AZI*/in_pViewportSwizzles = /*@@@HUY*/pViewportSwizzles->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetViewportSwizzleNV(in_commandBuffer, firstViewport, viewportCount, /*@@@AZI*/in_pViewportSwizzles)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetViewportSwizzleNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetCoverageToColorEnableNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    coverageToColorEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetCoverageToColorEnableNV(in_commandBuffer, coverageToColorEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetCoverageToColorEnableNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetCoverageToColorLocationNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    coverageToColorLocation)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetCoverageToColorLocationNV(in_commandBuffer, coverageToColorLocation)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetCoverageToColorLocationNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetCoverageModulationModeNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkCoverageModulationModeNV                  coverageModulationMode)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetCoverageModulationModeNV(in_commandBuffer, coverageModulationMode)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetCoverageModulationModeNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetCoverageModulationTableEnableNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    coverageModulationTableEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetCoverageModulationTableEnableNV(in_commandBuffer, coverageModulationTableEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetCoverageModulationTableEnableNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetCoverageModulationTableNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    coverageModulationTableCount,
    PointerDecoder<float>*                      pCoverageModulationTable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const float* /*@@@AZI*/in_pCoverageModulationTable = /*@@@HUY*/pCoverageModulationTable->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetCoverageModulationTableNV(in_commandBuffer, coverageModulationTableCount, /*@@@AZI*/in_pCoverageModulationTable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetCoverageModulationTableNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetShadingRateImageEnableNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    shadingRateImageEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetShadingRateImageEnableNV(in_commandBuffer, shadingRateImageEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetShadingRateImageEnableNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetRepresentativeFragmentTestEnableNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkBool32                                    representativeFragmentTestEnable)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetRepresentativeFragmentTestEnableNV(in_commandBuffer, representativeFragmentTestEnable)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetRepresentativeFragmentTestEnableNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdSetCoverageReductionModeNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkCoverageReductionModeNV                   coverageReductionMode)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetCoverageReductionModeNV(in_commandBuffer, coverageReductionMode)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetCoverageReductionModeNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkGetShaderModuleIdentifierEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            shaderModule,
    StructPointerDecoder<Decoded_VkShaderModuleIdentifierEXT>/*@@@PLQ*/* pIdentifier)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkShaderModule in_shaderModule = /*@@@QKJ*/MapHandle<ShaderModuleInfo>(shaderModule, &VulkanObjectInfoTable::GetShaderModuleInfo);
    /*@@@HPA*/VkShaderModuleIdentifierEXT* /*@@@USD*/out_pIdentifier = pIdentifier->IsNull() ? nullptr : pIdentifier->AllocateOutputData(1, { VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT, nullptr });
    InitializeOutputStructPNext(pIdentifier);//@@@DFK
    GetDeviceTable(in_device)->GetShaderModuleIdentifierEXT(in_device, in_shaderModule, /*@@@USD*/out_pIdentifier)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetShaderModuleCreateInfoIdentifierEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkShaderModuleCreateInfo>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkShaderModuleIdentifierEXT>/*@@@PLQ*/* pIdentifier)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkShaderModuleCreateInfo* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkShaderModuleIdentifierEXT* /*@@@USD*/out_pIdentifier = pIdentifier->IsNull() ? nullptr : pIdentifier->AllocateOutputData(1, { VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT, nullptr });
    InitializeOutputStructPNext(pIdentifier);//@@@DFK
    GetDeviceTable(in_device)->GetShaderModuleCreateInfoIdentifierEXT(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@USD*/out_pIdentifier)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetPhysicalDeviceOpticalFlowImageFormatsNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            physicalDevice,
    StructPointerDecoder<Decoded_VkOpticalFlowImageFormatInfoNV>/*@@@PLQ*/* pOpticalFlowImageFormatInfo,
    PointerDecoder<uint32_t>*                   pFormatCount,
    StructPointerDecoder<Decoded_VkOpticalFlowImageFormatPropertiesNV>/*@@@PLQ*/* pImageFormatProperties)
{
    VkPhysicalDevice in_physicalDevice = /*@@@QKJ*/MapHandle<PhysicalDeviceInfo>(physicalDevice, &VulkanObjectInfoTable::GetPhysicalDeviceInfo);
    /*@@@HPA*/const VkOpticalFlowImageFormatInfoNV* /*@@@AZI*/in_pOpticalFlowImageFormatInfo = /*@@@HUY*/pOpticalFlowImageFormatInfo->GetPointer();
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pFormatCount = pFormatCount->IsNull() ? nullptr : pFormatCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, PhysicalDeviceInfo>("vkGetPhysicalDeviceOpticalFlowImageFormatsNV", returnValue, physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceOpticalFlowImageFormatsNV, pFormatCount, pImageFormatProperties, &VulkanObjectInfoTable::GetPhysicalDeviceInfo));
    /*@@@HPA*/VkOpticalFlowImageFormatPropertiesNV* /*@@@USD*/out_pImageFormatProperties = pImageFormatProperties->IsNull() ? nullptr : pImageFormatProperties->AllocateOutputData(*/*@@@USD*/out_pFormatCount, VkOpticalFlowImageFormatPropertiesNV{ VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetInstanceTable(in_physicalDevice)->GetPhysicalDeviceOpticalFlowImageFormatsNV(in_physicalDevice, /*@@@AZI*/in_pOpticalFlowImageFormatInfo, /*@@@USD*/out_pFormatCount, /*@@@USD*/out_pImageFormatProperties)/*@@@ABC*/;
    CheckResult("vkGetPhysicalDeviceOpticalFlowImageFormatsNV", returnValue, replay_result, call_info);
    if (pImageFormatProperties->IsNull()) { SetOutputArrayCount<PhysicalDeviceInfo>(physicalDevice, kPhysicalDeviceArrayGetPhysicalDeviceOpticalFlowImageFormatsNV, */*@@@USD*/out_pFormatCount, &VulkanObjectInfoTable::GetPhysicalDeviceInfo); }
}

void VulkanReplayConsumer::Process_vkCreateOpticalFlowSessionNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkOpticalFlowSessionCreateInfoNV>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkOpticalFlowSessionNV>* pSession)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkOpticalFlowSessionCreateInfoNV* /*@@@AZI*/in_pCreateInfo = /*@@@HUY*/pCreateInfo->GetPointer();
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pSession->IsNull()) { pSession->SetHandleLength(1); }//@@@HET
    /*@@@HPA*/VkOpticalFlowSessionNV* /*@@@USD*/out_pSession = pSession->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateOpticalFlowSessionNV(in_device, /*@@@AZI*/in_pCreateInfo, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pSession)/*@@@ABC*/;
    CheckResult("vkCreateOpticalFlowSessionNV", returnValue, replay_result, call_info);
    AddHandle<OpticalFlowSessionNVInfo>(device, pSession->GetPointer(), /*@@@USD*/out_pSession, &VulkanObjectInfoTable::AddOpticalFlowSessionNVInfo);
}

void VulkanReplayConsumer::Process_vkDestroyOpticalFlowSessionNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            session,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkOpticalFlowSessionNV in_session = /*@@@QKJ*/MapHandle<OpticalFlowSessionNVInfo>(session, &VulkanObjectInfoTable::GetOpticalFlowSessionNVInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyOpticalFlowSessionNV(in_device, in_session, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(session, &VulkanObjectInfoTable::RemoveOpticalFlowSessionNVInfo);
}

void VulkanReplayConsumer::Process_vkBindOpticalFlowSessionImageNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            session,
    VkOpticalFlowSessionBindingPointNV          bindingPoint,
    format::HandleId                            view,
    VkImageLayout                               layout)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkOpticalFlowSessionNV in_session = /*@@@QKJ*/MapHandle<OpticalFlowSessionNVInfo>(session, &VulkanObjectInfoTable::GetOpticalFlowSessionNVInfo);
    VkImageView in_view = /*@@@QKJ*/MapHandle<ImageViewInfo>(view, &VulkanObjectInfoTable::GetImageViewInfo);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->BindOpticalFlowSessionImageNV(in_device, in_session, bindingPoint, in_view, layout)/*@@@ABC*/;
    CheckResult("vkBindOpticalFlowSessionImageNV", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdOpticalFlowExecuteNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            session,
    StructPointerDecoder<Decoded_VkOpticalFlowExecuteInfoNV>/*@@@PLQ*/* pExecuteInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkOpticalFlowSessionNV in_session = /*@@@QKJ*/MapHandle<OpticalFlowSessionNVInfo>(session, &VulkanObjectInfoTable::GetOpticalFlowSessionNVInfo);
    /*@@@HPA*/const VkOpticalFlowExecuteInfoNV* /*@@@AZI*/in_pExecuteInfo = /*@@@HUY*/pExecuteInfo->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdOpticalFlowExecuteNV(in_commandBuffer, in_session, /*@@@AZI*/in_pExecuteInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdOpticalFlowExecuteNV;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdOpticalFlowExecuteNVHandles(in_commandBuffer, in_session);

    }
}

void VulkanReplayConsumer::Process_vkCreateShadersEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    createInfoCount,
    StructPointerDecoder<Decoded_VkShaderCreateInfoEXT>/*@@@PLQ*/* pCreateInfos,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkShaderEXT>*          pShaders)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkShaderCreateInfoEXT* /*@@@AZI*/in_pCreateInfos = /*@@@HUY*/pCreateInfos->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pCreateInfos->GetMetaStructPointer(), pCreateInfos->GetLength(), GetObjectInfoTable());
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);
    if (!pShaders->IsNull()) { pShaders->SetHandleLength(createInfoCount); }//@@@UAZ
    /*@@@HPA*/VkShaderEXT* /*@@@USD*/out_pShaders = pShaders->GetHandlePointer();//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CreateShadersEXT(in_device, createInfoCount, /*@@@AZI*/in_pCreateInfos, /*@@@AZI*/in_pAllocator, /*@@@USD*/out_pShaders)/*@@@ABC*/;
    CheckResult("vkCreateShadersEXT", returnValue, replay_result, call_info);
    AddHandles<ShaderEXTInfo>(device, pShaders->GetPointer(), pShaders->GetLength(), /*@@@USD*/out_pShaders, createInfoCount, &VulkanObjectInfoTable::AddShaderEXTInfo);//@@@UPQ
}

void VulkanReplayConsumer::Process_vkDestroyShaderEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            shader,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkShaderEXT in_shader = /*@@@QKJ*/MapHandle<ShaderEXTInfo>(shader, &VulkanObjectInfoTable::GetShaderEXTInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyShaderEXT(in_device, in_shader, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(shader, &VulkanObjectInfoTable::RemoveShaderEXTInfo);
}

void VulkanReplayConsumer::Process_vkGetShaderBinaryDataEXT(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            shader,
    PointerDecoder<size_t>*                     pDataSize,
    PointerDecoder<uint8_t>*                    pData)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkShaderEXT in_shader = /*@@@QKJ*/MapHandle<ShaderEXTInfo>(shader, &VulkanObjectInfoTable::GetShaderEXTInfo);
    /*@@@HPA*/size_t* /*@@@USD*/out_pDataSize = pDataSize->IsNull() ? nullptr : pDataSize->AllocateOutputData(1, GetOutputArrayCount<size_t, ShaderEXTInfo>("vkGetShaderBinaryDataEXT", returnValue, shader, kShaderEXTArrayGetShaderBinaryDataEXT, pDataSize, pData, &VulkanObjectInfoTable::GetShaderEXTInfo));
    /*@@@HPA*/void* /*@@@USD*/out_pData = pData->IsNull() ? nullptr : pData->AllocateOutputData(*/*@@@USD*/out_pDataSize);//@@@EJH//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetShaderBinaryDataEXT(in_device, in_shader, /*@@@USD*/out_pDataSize, /*@@@USD*/out_pData)/*@@@ABC*/;
    CheckResult("vkGetShaderBinaryDataEXT", returnValue, replay_result, call_info);
    if (pData->IsNull()) { SetOutputArrayCount<ShaderEXTInfo>(shader, kShaderEXTArrayGetShaderBinaryDataEXT, */*@@@USD*/out_pDataSize, &VulkanObjectInfoTable::GetShaderEXTInfo); }
}

void VulkanReplayConsumer::Process_vkCmdBindShadersEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    stageCount,
    PointerDecoder<VkShaderStageFlagBits>*      pStages,
    HandlePointerDecoder<VkShaderEXT>*          pShaders)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkShaderStageFlagBits* /*@@@AZI*/in_pStages = /*@@@HUY*/pStages->GetPointer();
    /*@@@HPA*/const VkShaderEXT* /*@@@AZI*/in_pShaders = /*@@@EDO*/MapHandles<ShaderEXTInfo>(pShaders, stageCount, &VulkanObjectInfoTable::GetShaderEXTInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBindShadersEXT(in_commandBuffer, stageCount, /*@@@AZI*/in_pStages, /*@@@AZI*/in_pShaders)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBindShadersEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBindShadersEXTHandles(in_commandBuffer, stageCount, in_pShaders);

    }
}

void VulkanReplayConsumer::Process_vkGetFramebufferTilePropertiesQCOM(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            framebuffer,
    PointerDecoder<uint32_t>*                   pPropertiesCount,
    StructPointerDecoder<Decoded_VkTilePropertiesQCOM>/*@@@PLQ*/* pProperties)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkFramebuffer in_framebuffer = /*@@@QKJ*/MapHandle<FramebufferInfo>(framebuffer, &VulkanObjectInfoTable::GetFramebufferInfo);
    /*@@@HPA*/uint32_t* /*@@@USD*/out_pPropertiesCount = pPropertiesCount->IsNull() ? nullptr : pPropertiesCount->AllocateOutputData(1, GetOutputArrayCount<uint32_t, FramebufferInfo>("vkGetFramebufferTilePropertiesQCOM", returnValue, framebuffer, kFramebufferArrayGetFramebufferTilePropertiesQCOM, pPropertiesCount, pProperties, &VulkanObjectInfoTable::GetFramebufferInfo));
    /*@@@HPA*/VkTilePropertiesQCOM* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(*/*@@@USD*/out_pPropertiesCount, VkTilePropertiesQCOM{ VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM, nullptr }); /*@@@FFA*/  /*@@@DRW*///@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetFramebufferTilePropertiesQCOM(in_device, in_framebuffer, /*@@@USD*/out_pPropertiesCount, /*@@@USD*/out_pProperties)/*@@@ABC*/;
    CheckResult("vkGetFramebufferTilePropertiesQCOM", returnValue, replay_result, call_info);
    if (pProperties->IsNull()) { SetOutputArrayCount<FramebufferInfo>(framebuffer, kFramebufferArrayGetFramebufferTilePropertiesQCOM, */*@@@USD*/out_pPropertiesCount, &VulkanObjectInfoTable::GetFramebufferInfo); }
}

void VulkanReplayConsumer::Process_vkGetDynamicRenderingTilePropertiesQCOM(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkRenderingInfo>/*@@@PLQ*/* pRenderingInfo,
    StructPointerDecoder<Decoded_VkTilePropertiesQCOM>/*@@@PLQ*/* pProperties)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkRenderingInfo* /*@@@AZI*/in_pRenderingInfo = /*@@@HUY*/pRenderingInfo->GetPointer();
    MapStructHandles(pRenderingInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/VkTilePropertiesQCOM* /*@@@USD*/out_pProperties = pProperties->IsNull() ? nullptr : pProperties->AllocateOutputData(1, { VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM, nullptr });
    InitializeOutputStructPNext(pProperties);//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetDynamicRenderingTilePropertiesQCOM(in_device, /*@@@AZI*/in_pRenderingInfo, /*@@@USD*/out_pProperties)/*@@@ABC*/;
    CheckResult("vkGetDynamicRenderingTilePropertiesQCOM", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkSetLatencySleepModeNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    StructPointerDecoder<Decoded_VkLatencySleepModeInfoNV>* pSleepModeInfo)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkSetLatencySleepModeNV for offscreen.");
        return;
    }
    VkDevice in_device = MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSwapchainKHR in_swapchain = MapHandle<SwapchainKHRInfo>(swapchain, &VulkanObjectInfoTable::GetSwapchainKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id)->surface_creation_skipped) { return; }
    const VkLatencySleepModeInfoNV* in_pSleepModeInfo = pSleepModeInfo->GetPointer();

    VkResult replay_result = GetDeviceTable(in_device)->SetLatencySleepModeNV(in_device, in_swapchain, in_pSleepModeInfo);
    CheckResult("vkSetLatencySleepModeNV", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkLatencySleepNV(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    StructPointerDecoder<Decoded_VkLatencySleepInfoNV>* pSleepInfo)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkLatencySleepNV for offscreen.");
        return;
    }
    VkDevice in_device = MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSwapchainKHR in_swapchain = MapHandle<SwapchainKHRInfo>(swapchain, &VulkanObjectInfoTable::GetSwapchainKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id)->surface_creation_skipped) { return; }
    const VkLatencySleepInfoNV* in_pSleepInfo = pSleepInfo->GetPointer();
    MapStructHandles(pSleepInfo->GetMetaStructPointer(), GetObjectInfoTable());

    VkResult replay_result = GetDeviceTable(in_device)->LatencySleepNV(in_device, in_swapchain, in_pSleepInfo);
    CheckResult("vkLatencySleepNV", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkSetLatencyMarkerNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    StructPointerDecoder<Decoded_VkSetLatencyMarkerInfoNV>* pLatencyMarkerInfo)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkSetLatencyMarkerNV for offscreen.");
        return;
    }
    VkDevice in_device = MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSwapchainKHR in_swapchain = MapHandle<SwapchainKHRInfo>(swapchain, &VulkanObjectInfoTable::GetSwapchainKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id)->surface_creation_skipped) { return; }
    const VkSetLatencyMarkerInfoNV* in_pLatencyMarkerInfo = pLatencyMarkerInfo->GetPointer();

    GetDeviceTable(in_device)->SetLatencyMarkerNV(in_device, in_swapchain, in_pLatencyMarkerInfo);
}

void VulkanReplayConsumer::Process_vkGetLatencyTimingsNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            swapchain,
    StructPointerDecoder<Decoded_VkGetLatencyMarkerInfoNV>* pLatencyMarkerInfo)
{
    if (options_.swapchain_option == util::SwapchainOption::kOffscreen)
    {
        GFXRECON_LOG_DEBUG("Skip vkGetLatencyTimingsNV for offscreen.");
        return;
    }
    VkDevice in_device = MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkSwapchainKHR in_swapchain = MapHandle<SwapchainKHRInfo>(swapchain, &VulkanObjectInfoTable::GetSwapchainKHRInfo);
    if (GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id) == nullptr || GetObjectInfoTable().GetSurfaceKHRInfo(GetObjectInfoTable().GetSwapchainKHRInfo(swapchain)->surface_id)->surface_creation_skipped) { return; }
    VkGetLatencyMarkerInfoNV* out_pLatencyMarkerInfo = pLatencyMarkerInfo->IsNull() ? nullptr : pLatencyMarkerInfo->AllocateOutputData(1, { VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV, nullptr });
    InitializeOutputStructPNext(pLatencyMarkerInfo);

    GetDeviceTable(in_device)->GetLatencyTimingsNV(in_device, in_swapchain, out_pLatencyMarkerInfo);
}

void VulkanReplayConsumer::Process_vkQueueNotifyOutOfBandNV(
    const ApiCallInfo&                          call_info,
    format::HandleId                            queue,
    StructPointerDecoder<Decoded_VkOutOfBandQueueTypeInfoNV>* pQueueTypeInfo)
{
    VkQueue in_queue = MapHandle<QueueInfo>(queue, &VulkanObjectInfoTable::GetQueueInfo);
    const VkOutOfBandQueueTypeInfoNV* in_pQueueTypeInfo = pQueueTypeInfo->GetPointer();

    GetDeviceTable(in_queue)->QueueNotifyOutOfBandNV(in_queue, in_pQueueTypeInfo);
}

struct vkCmdSetAttachmentFeedbackLoopEnableEXT_DRSaveStruct {
    VkCommandBuffer commandBuffer;
    //@@@VBTVkCommandBuffer commandBuffer;
    VkImageAspectFlags aspectMask;
    //@@@VBTVkImageAspectFlags aspectMask;
};

void VulkanReplayConsumer::Process_vkCmdSetAttachmentFeedbackLoopEnableEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    VkImageAspectFlags                          aspectMask)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetAttachmentFeedbackLoopEnableEXT(in_commandBuffer, aspectMask)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetAttachmentFeedbackLoopEnableEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCreateAccelerationStructureKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkAccelerationStructureCreateInfoKHR>/*@@@PLQ*/* pCreateInfo,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator,
    HandlePointerDecoder<VkAccelerationStructureKHR>* pAccelerationStructure)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pCreateInfo->GetMetaStructPointer(), GetObjectInfoTable());
    if (!pAccelerationStructure->IsNull()) { pAccelerationStructure->SetHandleLength(1); }//@@@HET
    AccelerationStructureKHRInfo handle_info;
    pAccelerationStructure->SetConsumerData(0, &handle_info);//@@@DFK
    VkResult replay_result = OverrideCreateAccelerationStructureKHR(GetDeviceTable(in_device->handle)->CreateAccelerationStructureKHR, returnValue, in_device, pCreateInfo, pAllocator, pAccelerationStructure)/*@@@HNM*/;
    CheckResult("vkCreateAccelerationStructureKHR", returnValue, replay_result, call_info);
    AddHandle<AccelerationStructureKHRInfo>(device, pAccelerationStructure->GetPointer(), pAccelerationStructure->GetHandlePointer(), std::move(handle_info), &VulkanObjectInfoTable::AddAccelerationStructureKHRInfo);
}

void VulkanReplayConsumer::Process_vkDestroyAccelerationStructureKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    format::HandleId                            accelerationStructure,
    StructPointerDecoder<Decoded_VkAllocationCallbacks>/*@@@PLQ*/* pAllocator)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkAccelerationStructureKHR in_accelerationStructure = /*@@@QKJ*/MapHandle<AccelerationStructureKHRInfo>(accelerationStructure, &VulkanObjectInfoTable::GetAccelerationStructureKHRInfo);
    /*@@@HPA*/const VkAllocationCallbacks* /*@@@AZI*/in_pAllocator = /*@@@USX*/GetAllocationCallbacks(pAllocator);//@@@DFK
    GetDeviceTable(in_device)->DestroyAccelerationStructureKHR(in_device, in_accelerationStructure, /*@@@AZI*/in_pAllocator)/*@@@ABC*/;//@@@HQA
    RemoveHandle(accelerationStructure, &VulkanObjectInfoTable::RemoveAccelerationStructureKHRInfo);
}

void VulkanReplayConsumer::Process_vkCmdBuildAccelerationStructuresKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    infoCount,
    StructPointerDecoder<Decoded_VkAccelerationStructureBuildGeometryInfoKHR>/*@@@PLQ*/* pInfos,
    StructPointerDecoder<Decoded_VkAccelerationStructureBuildRangeInfoKHR*>/*@@@EHI*/* ppBuildRangeInfos)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkAccelerationStructureBuildGeometryInfoKHR* /*@@@AZI*/in_pInfos = /*@@@HUY*/pInfos->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pInfos->GetMetaStructPointer(), pInfos->GetLength(), GetObjectInfoTable());
    /*@@@HPA*/const VkAccelerationStructureBuildRangeInfoKHR* const* /*@@@AZI*/in_ppBuildRangeInfos = /*@@@HUY*/ppBuildRangeInfos->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBuildAccelerationStructuresKHR(in_commandBuffer, infoCount, /*@@@AZI*/in_pInfos, /*@@@AZI*/in_ppBuildRangeInfos)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBuildAccelerationStructuresKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBuildAccelerationStructuresKHRHandles(in_commandBuffer, infoCount, in_pInfos);

    }
}

void VulkanReplayConsumer::Process_vkCmdBuildAccelerationStructuresIndirectKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    infoCount,
    StructPointerDecoder<Decoded_VkAccelerationStructureBuildGeometryInfoKHR>/*@@@PLQ*/* pInfos,
    PointerDecoder<VkDeviceAddress>*            pIndirectDeviceAddresses,
    PointerDecoder<uint32_t>*                   pIndirectStrides,
    PointerDecoder<uint32_t*>*                  ppMaxPrimitiveCounts)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkAccelerationStructureBuildGeometryInfoKHR* /*@@@AZI*/in_pInfos = /*@@@HUY*/pInfos->GetPointer();
    /*@@@HWC*/MapStructArrayHandles(pInfos->GetMetaStructPointer(), pInfos->GetLength(), GetObjectInfoTable());
    /*@@@HPA*/const VkDeviceAddress* /*@@@AZI*/in_pIndirectDeviceAddresses = /*@@@HUY*/pIndirectDeviceAddresses->GetPointer();
    /*@@@HPA*/const uint32_t* /*@@@AZI*/in_pIndirectStrides = /*@@@HUY*/pIndirectStrides->GetPointer();
    /*@@@HPA*/const uint32_t* const* /*@@@AZI*/in_ppMaxPrimitiveCounts = /*@@@HUY*/ppMaxPrimitiveCounts->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdBuildAccelerationStructuresIndirectKHR(in_commandBuffer, infoCount, /*@@@AZI*/in_pInfos, /*@@@AZI*/in_pIndirectDeviceAddresses, /*@@@AZI*/in_pIndirectStrides, /*@@@AZI*/in_ppMaxPrimitiveCounts)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdBuildAccelerationStructuresIndirectKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdBuildAccelerationStructuresIndirectKHRHandles(in_commandBuffer, infoCount, in_pInfos);

    }
}

void VulkanReplayConsumer::Process_vkCopyAccelerationStructureToMemoryKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            deferredOperation,
    StructPointerDecoder<Decoded_VkCopyAccelerationStructureToMemoryInfoKHR>/*@@@PLQ*/* pInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDeferredOperationKHR in_deferredOperation = /*@@@QKJ*/MapHandle<DeferredOperationKHRInfo>(deferredOperation, &VulkanObjectInfoTable::GetDeferredOperationKHRInfo);
    /*@@@HPA*/const VkCopyAccelerationStructureToMemoryInfoKHR* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CopyAccelerationStructureToMemoryKHR(in_device, in_deferredOperation, /*@@@AZI*/in_pInfo)/*@@@ABC*/;
    CheckResult("vkCopyAccelerationStructureToMemoryKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCopyMemoryToAccelerationStructureKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            deferredOperation,
    StructPointerDecoder<Decoded_VkCopyMemoryToAccelerationStructureInfoKHR>/*@@@PLQ*/* pInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkDeferredOperationKHR in_deferredOperation = /*@@@QKJ*/MapHandle<DeferredOperationKHRInfo>(deferredOperation, &VulkanObjectInfoTable::GetDeferredOperationKHRInfo);
    /*@@@HPA*/const VkCopyMemoryToAccelerationStructureInfoKHR* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->CopyMemoryToAccelerationStructureKHR(in_device, in_deferredOperation, /*@@@AZI*/in_pInfo)/*@@@ABC*/;
    CheckResult("vkCopyMemoryToAccelerationStructureKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkWriteAccelerationStructuresPropertiesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    uint32_t                                    accelerationStructureCount,
    HandlePointerDecoder<VkAccelerationStructureKHR>* pAccelerationStructures,
    VkQueryType                                 queryType,
    size_t                                      dataSize,
    PointerDecoder<uint8_t>*                    pData,
    size_t                                      stride)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkAccelerationStructureKHR* /*@@@AZI*/in_pAccelerationStructures = /*@@@EDO*/MapHandles<AccelerationStructureKHRInfo>(pAccelerationStructures, accelerationStructureCount, &VulkanObjectInfoTable::GetAccelerationStructureKHRInfo);
    /*@@@HPA*/void* /*@@@USD*/out_pData = pData->IsNull() ? nullptr : pData->AllocateOutputData(dataSize);//@@@EJH//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->WriteAccelerationStructuresPropertiesKHR(in_device, accelerationStructureCount, /*@@@AZI*/in_pAccelerationStructures, queryType, dataSize, /*@@@USD*/out_pData, stride)/*@@@ABC*/;
    CheckResult("vkWriteAccelerationStructuresPropertiesKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdCopyAccelerationStructureKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCopyAccelerationStructureInfoKHR>/*@@@PLQ*/* pInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCopyAccelerationStructureInfoKHR* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyAccelerationStructureKHR(in_commandBuffer, /*@@@AZI*/in_pInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyAccelerationStructureKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyAccelerationStructureKHRHandles(in_commandBuffer, in_pInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyAccelerationStructureToMemoryKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCopyAccelerationStructureToMemoryInfoKHR>/*@@@PLQ*/* pInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCopyAccelerationStructureToMemoryInfoKHR* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyAccelerationStructureToMemoryKHR(in_commandBuffer, /*@@@AZI*/in_pInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyAccelerationStructureToMemoryKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyAccelerationStructureToMemoryKHRHandles(in_commandBuffer, in_pInfo);

    }
}

void VulkanReplayConsumer::Process_vkCmdCopyMemoryToAccelerationStructureKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkCopyMemoryToAccelerationStructureInfoKHR>/*@@@PLQ*/* pInfo)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkCopyMemoryToAccelerationStructureInfoKHR* /*@@@AZI*/in_pInfo = /*@@@HUY*/pInfo->GetPointer();
    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdCopyMemoryToAccelerationStructureKHR(in_commandBuffer, /*@@@AZI*/in_pInfo)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdCopyMemoryToAccelerationStructureKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdCopyMemoryToAccelerationStructureKHRHandles(in_commandBuffer, in_pInfo);

    }
}

void VulkanReplayConsumer::Process_vkGetAccelerationStructureDeviceAddressKHR(
    const ApiCallInfo&                          call_info,
    VkDeviceAddress                             returnValue,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkAccelerationStructureDeviceAddressInfoKHR>/*@@@PLQ*/* pInfo)
{
    auto in_device = GetObjectInfoTable().GetDeviceInfo(device);

    MapStructHandles(pInfo->GetMetaStructPointer(), GetObjectInfoTable());//@@@DFK
    OverrideGetAccelerationStructureDeviceAddressKHR(GetDeviceTable(in_device->handle)->GetAccelerationStructureDeviceAddressKHR, in_device, pInfo)/*@@@PKQ*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdWriteAccelerationStructuresPropertiesKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    accelerationStructureCount,
    HandlePointerDecoder<VkAccelerationStructureKHR>* pAccelerationStructures,
    VkQueryType                                 queryType,
    format::HandleId                            queryPool,
    uint32_t                                    firstQuery)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkAccelerationStructureKHR* /*@@@AZI*/in_pAccelerationStructures = /*@@@EDO*/MapHandles<AccelerationStructureKHRInfo>(pAccelerationStructures, accelerationStructureCount, &VulkanObjectInfoTable::GetAccelerationStructureKHRInfo);
    VkQueryPool in_queryPool = /*@@@QKJ*/MapHandle<QueryPoolInfo>(queryPool, &VulkanObjectInfoTable::GetQueryPoolInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdWriteAccelerationStructuresPropertiesKHR(in_commandBuffer, accelerationStructureCount, /*@@@AZI*/in_pAccelerationStructures, queryType, in_queryPool, firstQuery)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdWriteAccelerationStructuresPropertiesKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdWriteAccelerationStructuresPropertiesKHRHandles(in_commandBuffer, accelerationStructureCount, in_pAccelerationStructures, in_queryPool);

    }
}

void VulkanReplayConsumer::Process_vkGetDeviceAccelerationStructureCompatibilityKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    StructPointerDecoder<Decoded_VkAccelerationStructureVersionInfoKHR>/*@@@PLQ*/* pVersionInfo,
    PointerDecoder<VkAccelerationStructureCompatibilityKHR>* pCompatibility)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkAccelerationStructureVersionInfoKHR* /*@@@AZI*/in_pVersionInfo = /*@@@HUY*/pVersionInfo->GetPointer();
    /*@@@HPA*/VkAccelerationStructureCompatibilityKHR* /*@@@USD*/out_pCompatibility = pCompatibility->IsNull() ? nullptr : pCompatibility->AllocateOutputData(1, static_cast<VkAccelerationStructureCompatibilityKHR>(0));//@@@DFK
    GetDeviceTable(in_device)->GetDeviceAccelerationStructureCompatibilityKHR(in_device, /*@@@AZI*/in_pVersionInfo, /*@@@USD*/out_pCompatibility)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkGetAccelerationStructureBuildSizesKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            device,
    VkAccelerationStructureBuildTypeKHR         buildType,
    StructPointerDecoder<Decoded_VkAccelerationStructureBuildGeometryInfoKHR>/*@@@PLQ*/* pBuildInfo,
    PointerDecoder<uint32_t>*                   pMaxPrimitiveCounts,
    StructPointerDecoder<Decoded_VkAccelerationStructureBuildSizesInfoKHR>/*@@@PLQ*/* pSizeInfo)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    /*@@@HPA*/const VkAccelerationStructureBuildGeometryInfoKHR* /*@@@AZI*/in_pBuildInfo = /*@@@HUY*/pBuildInfo->GetPointer();
    MapStructHandles(pBuildInfo->GetMetaStructPointer(), GetObjectInfoTable());
    /*@@@HPA*/const uint32_t* /*@@@AZI*/in_pMaxPrimitiveCounts = /*@@@HUY*/pMaxPrimitiveCounts->GetPointer();
    /*@@@HPA*/VkAccelerationStructureBuildSizesInfoKHR* /*@@@USD*/out_pSizeInfo = pSizeInfo->IsNull() ? nullptr : pSizeInfo->AllocateOutputData(1, { VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR, nullptr });
    InitializeOutputStructPNext(pSizeInfo);//@@@DFK
    GetDeviceTable(in_device)->GetAccelerationStructureBuildSizesKHR(in_device, buildType, /*@@@AZI*/in_pBuildInfo, /*@@@AZI*/in_pMaxPrimitiveCounts, /*@@@USD*/out_pSizeInfo)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdTraceRaysKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkStridedDeviceAddressRegionKHR>/*@@@PLQ*/* pRaygenShaderBindingTable,
    StructPointerDecoder<Decoded_VkStridedDeviceAddressRegionKHR>/*@@@PLQ*/* pMissShaderBindingTable,
    StructPointerDecoder<Decoded_VkStridedDeviceAddressRegionKHR>/*@@@PLQ*/* pHitShaderBindingTable,
    StructPointerDecoder<Decoded_VkStridedDeviceAddressRegionKHR>/*@@@PLQ*/* pCallableShaderBindingTable,
    uint32_t                                    width,
    uint32_t                                    height,
    uint32_t                                    depth)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkStridedDeviceAddressRegionKHR* /*@@@AZI*/in_pRaygenShaderBindingTable = /*@@@HUY*/pRaygenShaderBindingTable->GetPointer();
    /*@@@HPA*/const VkStridedDeviceAddressRegionKHR* /*@@@AZI*/in_pMissShaderBindingTable = /*@@@HUY*/pMissShaderBindingTable->GetPointer();
    /*@@@HPA*/const VkStridedDeviceAddressRegionKHR* /*@@@AZI*/in_pHitShaderBindingTable = /*@@@HUY*/pHitShaderBindingTable->GetPointer();
    /*@@@HPA*/const VkStridedDeviceAddressRegionKHR* /*@@@AZI*/in_pCallableShaderBindingTable = /*@@@HUY*/pCallableShaderBindingTable->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdTraceRaysKHR(in_commandBuffer, /*@@@AZI*/in_pRaygenShaderBindingTable, /*@@@AZI*/in_pMissShaderBindingTable, /*@@@AZI*/in_pHitShaderBindingTable, /*@@@AZI*/in_pCallableShaderBindingTable, width, height, depth)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdTraceRaysKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkGetRayTracingCaptureReplayShaderGroupHandlesKHR(
    const ApiCallInfo&                          call_info,
    VkResult                                    returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    uint32_t                                    firstGroup,
    uint32_t                                    groupCount,
    size_t                                      dataSize,
    PointerDecoder<uint8_t>*                    pData)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPipeline in_pipeline = /*@@@QKJ*/MapHandle<PipelineInfo>(pipeline, &VulkanObjectInfoTable::GetPipelineInfo);
    /*@@@HPA*/void* /*@@@USD*/out_pData = pData->IsNull() ? nullptr : pData->AllocateOutputData(dataSize);//@@@EJH//@@@DFK
    VkResult replay_result = GetDeviceTable(in_device)->GetRayTracingCaptureReplayShaderGroupHandlesKHR(in_device, in_pipeline, firstGroup, groupCount, dataSize, /*@@@USD*/out_pData)/*@@@ABC*/;
    CheckResult("vkGetRayTracingCaptureReplayShaderGroupHandlesKHR", returnValue, replay_result, call_info);
}

void VulkanReplayConsumer::Process_vkCmdTraceRaysIndirectKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    StructPointerDecoder<Decoded_VkStridedDeviceAddressRegionKHR>/*@@@PLQ*/* pRaygenShaderBindingTable,
    StructPointerDecoder<Decoded_VkStridedDeviceAddressRegionKHR>/*@@@PLQ*/* pMissShaderBindingTable,
    StructPointerDecoder<Decoded_VkStridedDeviceAddressRegionKHR>/*@@@PLQ*/* pHitShaderBindingTable,
    StructPointerDecoder<Decoded_VkStridedDeviceAddressRegionKHR>/*@@@PLQ*/* pCallableShaderBindingTable,
    VkDeviceAddress                             indirectDeviceAddress)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    /*@@@HPA*/const VkStridedDeviceAddressRegionKHR* /*@@@AZI*/in_pRaygenShaderBindingTable = /*@@@HUY*/pRaygenShaderBindingTable->GetPointer();
    /*@@@HPA*/const VkStridedDeviceAddressRegionKHR* /*@@@AZI*/in_pMissShaderBindingTable = /*@@@HUY*/pMissShaderBindingTable->GetPointer();
    /*@@@HPA*/const VkStridedDeviceAddressRegionKHR* /*@@@AZI*/in_pHitShaderBindingTable = /*@@@HUY*/pHitShaderBindingTable->GetPointer();
    /*@@@HPA*/const VkStridedDeviceAddressRegionKHR* /*@@@AZI*/in_pCallableShaderBindingTable = /*@@@HUY*/pCallableShaderBindingTable->GetPointer();//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdTraceRaysIndirectKHR(in_commandBuffer, /*@@@AZI*/in_pRaygenShaderBindingTable, /*@@@AZI*/in_pMissShaderBindingTable, /*@@@AZI*/in_pHitShaderBindingTable, /*@@@AZI*/in_pCallableShaderBindingTable, indirectDeviceAddress)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdTraceRaysIndirectKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkGetRayTracingShaderGroupStackSizeKHR(
    const ApiCallInfo&                          call_info,
    VkDeviceSize                                returnValue,
    format::HandleId                            device,
    format::HandleId                            pipeline,
    uint32_t                                    group,
    VkShaderGroupShaderKHR                      groupShader)
{
    VkDevice in_device = /*@@@QKJ*/MapHandle<DeviceInfo>(device, &VulkanObjectInfoTable::GetDeviceInfo);
    VkPipeline in_pipeline = /*@@@QKJ*/MapHandle<PipelineInfo>(pipeline, &VulkanObjectInfoTable::GetPipelineInfo);//@@@DFK
    GetDeviceTable(in_device)->GetRayTracingShaderGroupStackSizeKHR(in_device, in_pipeline, group, groupShader)/*@@@ABC*/;//@@@HQA
}

void VulkanReplayConsumer::Process_vkCmdSetRayTracingPipelineStackSizeKHR(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    pipelineStackSize)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdSetRayTracingPipelineStackSizeKHR(in_commandBuffer, pipelineStackSize)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdSetRayTracingPipelineStackSizeKHR;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdDrawMeshTasksEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    uint32_t                                    groupCountX,
    uint32_t                                    groupCountY,
    uint32_t                                    groupCountZ)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawMeshTasksEXT(in_commandBuffer, groupCountX, groupCountY, groupCountZ)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawMeshTasksEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
    }
}

void VulkanReplayConsumer::Process_vkCmdDrawMeshTasksIndirectEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    uint32_t                                    drawCount,
    uint32_t                                    stride)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawMeshTasksIndirectEXT(in_commandBuffer, in_buffer, offset, drawCount, stride)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawMeshTasksIndirectEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDrawMeshTasksIndirectEXTHandles(in_commandBuffer, in_buffer);

    }
}

void VulkanReplayConsumer::Process_vkCmdDrawMeshTasksIndirectCountEXT(
    const ApiCallInfo&                          call_info,
    format::HandleId                            commandBuffer,
    format::HandleId                            buffer,
    VkDeviceSize                                offset,
    format::HandleId                            countBuffer,
    VkDeviceSize                                countBufferOffset,
    uint32_t                                    maxDrawCount,
    uint32_t                                    stride)
{
    VkCommandBuffer in_commandBuffer = /*@@@QKJ*/MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);
    VkBuffer in_buffer = /*@@@QKJ*/MapHandle<BufferInfo>(buffer, &VulkanObjectInfoTable::GetBufferInfo);
    VkBuffer in_countBuffer = /*@@@QKJ*/MapHandle<BufferInfo>(countBuffer, &VulkanObjectInfoTable::GetBufferInfo);//@@@DFK
#if TESTCODE
    if (g_savingCommandBuffer != commandBuffer)
#endif
        GetDeviceTable(in_commandBuffer)->CmdDrawMeshTasksIndirectCountEXT(in_commandBuffer, in_buffer, offset, in_countBuffer, countBufferOffset, maxDrawCount, stride)/*@@@ABC*/;//@@@HQA

    {
        VkCommandBuffer in_commandBuffer = MapHandle<CommandBufferInfo>(commandBuffer, &VulkanObjectInfoTable::GetCommandBufferInfo);

        //@@@ECH Save this command if we are currently saving commands
        //       TODO: should reset clear the current command buffer??
        //       TODO: What should we do when we encounter the draw command that is to trigger the resource dump??
        if (g_savingCommandBuffer == commandBuffer)
        {
            //@@@AWP TODO: Can this be made into a function? It would reduce code size for all the replay funcs.
            CmdBuffApiCall s;
            s.apiCall = format::ApiCall_vkCmdDrawMeshTasksIndirectCountEXT;
            s.thread_id = call_info.thread_id;
            s.parameter_buffer_data.resize(call_info.parameter_buffer_size);
            s.parameter_buffer_size = call_info.parameter_buffer_size;
            memcpy(s.parameter_buffer_data.data(), call_info.parameter_buffer_data, call_info.parameter_buffer_size);
            s.decoder = call_info.decoder;
            savedDRCmdBuff.push_back(s);
        }
        //@@@XZP Log all handles associated with command buffers
        TrackDRCmdDrawMeshTasksIndirectCountEXTHandles(in_commandBuffer, in_buffer, in_countBuffer);

    }
}

static void InitializeOutputStructPNextImpl(const VkBaseInStructure* in_pnext, VkBaseOutStructure* output_struct)
{
    while(in_pnext)
    {
        switch(in_pnext->sType)
        {
            case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBufferMemoryBarrier>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageMemoryBarrier>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_BARRIER:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryBarrier>());
                break;
            }
            case VK_STRUCTURE_TYPE_APPLICATION_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkApplicationInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkInstanceCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceQueueCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_SUBMIT_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSubmitInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMappedMemoryRange>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryAllocateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_BIND_SPARSE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBindSparseInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_FENCE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkFenceCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSemaphoreCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_EVENT_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkEventCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkQueryPoolCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBufferCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBufferViewCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageViewCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkShaderModuleCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineCacheCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineShaderStageCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkComputePipelineCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineVertexInputStateCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineInputAssemblyStateCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineTessellationStateCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineViewportStateCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineRasterizationStateCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineMultisampleStateCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineDepthStencilStateCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineColorBlendStateCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineDynamicStateCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkGraphicsPipelineCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineLayoutCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSamplerCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyDescriptorSet>());
                break;
            }
            case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDescriptorPoolCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDescriptorSetAllocateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDescriptorSetLayoutCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkWriteDescriptorSet>());
                break;
            }
            case VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkFramebufferCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCommandPoolCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCommandBufferAllocateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCommandBufferInheritanceInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCommandBufferBeginInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassBeginInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceSubgroupProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBindBufferMemoryInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBindImageMemoryInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevice16BitStorageFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryDedicatedRequirements>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryDedicatedAllocateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryAllocateFlagsInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceGroupRenderPassBeginInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceGroupCommandBufferBeginInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceGroupSubmitInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceGroupBindSparseInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_DEVICE_GROUP_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBindBufferMemoryDeviceGroupInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_DEVICE_GROUP_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBindImageMemoryDeviceGroupInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceGroupProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceGroupDeviceCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBufferMemoryRequirementsInfo2>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageMemoryRequirementsInfo2>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageSparseMemoryRequirementsInfo2>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryRequirements2>());
                break;
            }
            case VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSparseImageMemoryRequirements2>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFeatures2>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceProperties2>());
                break;
            }
            case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkFormatProperties2>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageFormatProperties2>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceImageFormatInfo2>());
                break;
            }
            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkQueueFamilyProperties2>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMemoryProperties2>());
                break;
            }
            case VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSparseImageFormatProperties2>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceSparseImageFormatInfo2>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_POINT_CLIPPING_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePointClippingProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_INPUT_ATTACHMENT_ASPECT_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassInputAttachmentAspectCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_VIEW_USAGE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageViewUsageCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_DOMAIN_ORIGIN_STATE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineTessellationDomainOriginStateCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassMultiviewCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMultiviewFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMultiviewProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVariablePointersFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceProtectedMemoryFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceProtectedMemoryProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_QUEUE_INFO_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceQueueInfo2>());
                break;
            }
            case VK_STRUCTURE_TYPE_PROTECTED_SUBMIT_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkProtectedSubmitInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSamplerYcbcrConversionCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSamplerYcbcrConversionInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_BIND_IMAGE_PLANE_MEMORY_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBindImagePlaneMemoryInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_PLANE_MEMORY_REQUIREMENTS_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImagePlaneMemoryRequirementsInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceSamplerYcbcrConversionFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_IMAGE_FORMAT_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSamplerYcbcrConversionImageFormatProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDescriptorUpdateTemplateCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExternalImageFormatInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExternalImageFormatProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExternalBufferInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExternalBufferProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceIDProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExternalMemoryImageCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExternalMemoryBufferCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExportMemoryAllocateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExternalFenceInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExternalFenceProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExportFenceCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExportSemaphoreCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExternalSemaphoreInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExternalSemaphoreProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_3_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMaintenance3Properties>());
                break;
            }
            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_SUPPORT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDescriptorSetLayoutSupport>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderDrawParametersFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVulkan11Features>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVulkan11Properties>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVulkan12Features>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVulkan12Properties>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_FORMAT_LIST_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageFormatListCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAttachmentDescription2>());
                break;
            }
            case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAttachmentReference2>());
                break;
            }
            case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSubpassDescription2>());
                break;
            }
            case VK_STRUCTURE_TYPE_SUBPASS_DEPENDENCY_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSubpassDependency2>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassCreateInfo2>());
                break;
            }
            case VK_STRUCTURE_TYPE_SUBPASS_BEGIN_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSubpassBeginInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_SUBPASS_END_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSubpassEndInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevice8BitStorageFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRIVER_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDriverProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderAtomicInt64Features>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderFloat16Int8Features>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FLOAT_CONTROLS_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFloatControlsProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_BINDING_FLAGS_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDescriptorSetLayoutBindingFlagsCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDescriptorIndexingFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDescriptorIndexingProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_ALLOCATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDescriptorSetVariableDescriptorCountAllocateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_VARIABLE_DESCRIPTOR_COUNT_LAYOUT_SUPPORT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDescriptorSetVariableDescriptorCountLayoutSupport>());
                break;
            }
            case VK_STRUCTURE_TYPE_SUBPASS_DESCRIPTION_DEPTH_STENCIL_RESOLVE:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSubpassDescriptionDepthStencilResolve>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_STENCIL_RESOLVE_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDepthStencilResolveProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceScalarBlockLayoutFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_STENCIL_USAGE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageStencilUsageCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSamplerReductionModeCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceSamplerFilterMinmaxProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVulkanMemoryModelFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceImagelessFramebufferFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENT_IMAGE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkFramebufferAttachmentImageInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_FRAMEBUFFER_ATTACHMENTS_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkFramebufferAttachmentsCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_ATTACHMENT_BEGIN_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassAttachmentBeginInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_ATTACHMENT_REFERENCE_STENCIL_LAYOUT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAttachmentReferenceStencilLayout>());
                break;
            }
            case VK_STRUCTURE_TYPE_ATTACHMENT_DESCRIPTION_STENCIL_LAYOUT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAttachmentDescriptionStencilLayout>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceHostQueryResetFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceTimelineSemaphoreFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceTimelineSemaphoreProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_SEMAPHORE_TYPE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSemaphoreTypeCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_TIMELINE_SEMAPHORE_SUBMIT_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkTimelineSemaphoreSubmitInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_SEMAPHORE_WAIT_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSemaphoreWaitInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_SEMAPHORE_SIGNAL_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSemaphoreSignalInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceBufferDeviceAddressFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBufferDeviceAddressInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_BUFFER_OPAQUE_CAPTURE_ADDRESS_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBufferOpaqueCaptureAddressCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_OPAQUE_CAPTURE_ADDRESS_ALLOCATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryOpaqueCaptureAddressAllocateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OPAQUE_CAPTURE_ADDRESS_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceMemoryOpaqueCaptureAddressInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVulkan13Features>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVulkan13Properties>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_CREATION_FEEDBACK_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineCreationFeedbackCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderTerminateInvocationFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TOOL_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceToolProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePrivateDataFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_PRIVATE_DATA_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDevicePrivateDataCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PRIVATE_DATA_SLOT_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPrivateDataSlotCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePipelineCreationCacheControlFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_BARRIER_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryBarrier2>());
                break;
            }
            case VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBufferMemoryBarrier2>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageMemoryBarrier2>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEPENDENCY_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDependencyInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_SEMAPHORE_SUBMIT_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSemaphoreSubmitInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_SUBMIT_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCommandBufferSubmitInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_SUBMIT_INFO_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSubmitInfo2>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceSynchronization2Features>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceImageRobustnessFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_BUFFER_COPY_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBufferCopy2>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_BUFFER_INFO_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyBufferInfo2>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_COPY_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageCopy2>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_IMAGE_INFO_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyImageInfo2>());
                break;
            }
            case VK_STRUCTURE_TYPE_BUFFER_IMAGE_COPY_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBufferImageCopy2>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_BUFFER_TO_IMAGE_INFO_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyBufferToImageInfo2>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_BUFFER_INFO_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyImageToBufferInfo2>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_BLIT_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageBlit2>());
                break;
            }
            case VK_STRUCTURE_TYPE_BLIT_IMAGE_INFO_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBlitImageInfo2>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_RESOLVE_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageResolve2>());
                break;
            }
            case VK_STRUCTURE_TYPE_RESOLVE_IMAGE_INFO_2:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkResolveImageInfo2>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceSubgroupSizeControlFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceSubgroupSizeControlProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_REQUIRED_SUBGROUP_SIZE_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineShaderStageRequiredSubgroupSizeCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceInlineUniformBlockFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceInlineUniformBlockProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_INLINE_UNIFORM_BLOCK:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkWriteDescriptorSetInlineUniformBlock>());
                break;
            }
            case VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_INLINE_UNIFORM_BLOCK_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDescriptorPoolInlineUniformBlockCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceTextureCompressionASTCHDRFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderingAttachmentInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDERING_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderingInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_RENDERING_CREATE_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineRenderingCreateInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDynamicRenderingFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDERING_INFO:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCommandBufferInheritanceRenderingInfo>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderIntegerDotProductFeatures>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderIntegerDotProductProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceTexelBufferAlignmentProperties>());
                break;
            }
            case VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_3:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkFormatProperties3>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMaintenance4Features>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_PROPERTIES:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMaintenance4Properties>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_BUFFER_MEMORY_REQUIREMENTS:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceBufferMemoryRequirements>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_IMAGE_MEMORY_REQUIREMENTS:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceImageMemoryRequirements>());
                break;
            }
            case VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSwapchainCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PRESENT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPresentInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageSwapchainCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBindImageMemorySwapchainInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAcquireNextImageInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceGroupPresentCapabilitiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceGroupPresentInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceGroupSwapchainCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDisplayModeCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDisplaySurfaceCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDisplayPresentInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkXlibSurfaceCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkXcbSurfaceCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkWaylandSurfaceCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAndroidSurfaceCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkWin32SurfaceCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_QUERY_RESULT_STATUS_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkQueueFamilyQueryResultStatusPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_VIDEO_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkQueueFamilyVideoPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_PROFILE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoProfileInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_PROFILE_LIST_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoProfileListInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_CAPABILITIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoCapabilitiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_FORMAT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVideoFormatInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_FORMAT_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoFormatPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_PICTURE_RESOURCE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoPictureResourceInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_REFERENCE_SLOT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoReferenceSlotInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_SESSION_MEMORY_REQUIREMENTS_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoSessionMemoryRequirementsKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_BIND_VIDEO_SESSION_MEMORY_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBindVideoSessionMemoryInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_SESSION_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoSessionCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoSessionParametersCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_SESSION_PARAMETERS_UPDATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoSessionParametersUpdateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_BEGIN_CODING_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoBeginCodingInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_END_CODING_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEndCodingInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_CODING_CONTROL_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoCodingControlInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_CAPABILITIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeCapabilitiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_USAGE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeUsageInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_CAPABILITIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH264CapabilitiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_QUALITY_LEVEL_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH264QualityLevelPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH264SessionCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH264SessionParametersAddInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH264SessionParametersCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_GET_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH264SessionParametersGetInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_SESSION_PARAMETERS_FEEDBACK_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH264SessionParametersFeedbackInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_NALU_SLICE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH264NaluSliceInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PICTURE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH264PictureInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_DPB_SLOT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH264DpbSlotInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_PROFILE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH264ProfileInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH264RateControlInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_RATE_CONTROL_LAYER_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH264RateControlLayerInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H264_GOP_REMAINING_FRAME_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH264GopRemainingFrameInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_CAPABILITIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH265CapabilitiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH265SessionCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_QUALITY_LEVEL_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH265QualityLevelPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH265SessionParametersAddInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH265SessionParametersCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_GET_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH265SessionParametersGetInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_SESSION_PARAMETERS_FEEDBACK_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH265SessionParametersFeedbackInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_NALU_SLICE_SEGMENT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH265NaluSliceSegmentInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PICTURE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH265PictureInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_DPB_SLOT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH265DpbSlotInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_PROFILE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH265ProfileInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH265RateControlInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_RATE_CONTROL_LAYER_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH265RateControlLayerInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_H265_GOP_REMAINING_FRAME_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeH265GopRemainingFrameInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PROFILE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeH264ProfileInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_CAPABILITIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeH264CapabilitiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_ADD_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeH264SessionParametersAddInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeH264SessionParametersCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_PICTURE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeH264PictureInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H264_DPB_SLOT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeH264DpbSlotInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderingFragmentShadingRateAttachmentInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDERING_FRAGMENT_DENSITY_MAP_ATTACHMENT_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderingFragmentDensityMapAttachmentInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_ATTACHMENT_SAMPLE_COUNT_INFO_AMD:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAttachmentSampleCountInfoAMD>());
                break;
            }
            case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_ATTRIBUTES_INFO_NVX:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMultiviewPerViewAttributesInfoNVX>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImportMemoryWin32HandleInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExportMemoryWin32HandleInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryWin32HandlePropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryGetWin32HandleInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImportMemoryFdInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryFdPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryGetFdInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkWin32KeyedMutexAcquireReleaseInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImportSemaphoreWin32HandleInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExportSemaphoreWin32HandleInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkD3D12FenceSubmitInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSemaphoreGetWin32HandleInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImportSemaphoreFdInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSemaphoreGetFdInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePushDescriptorPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPresentRegionsKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSharedPresentSurfaceCapabilitiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImportFenceWin32HandleInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExportFenceWin32HandleInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkFenceGetWin32HandleInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImportFenceFdInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkFenceGetFdInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePerformanceQueryFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePerformanceQueryPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPerformanceCounterKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PERFORMANCE_COUNTER_DESCRIPTION_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPerformanceCounterDescriptionKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkQueryPoolPerformanceCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACQUIRE_PROFILING_LOCK_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAcquireProfilingLockInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PERFORMANCE_QUERY_SUBMIT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPerformanceQuerySubmitInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceSurfaceInfo2KHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSurfaceCapabilities2KHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSurfaceFormat2KHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_DISPLAY_PROPERTIES_2_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDisplayProperties2KHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_DISPLAY_PLANE_PROPERTIES_2_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDisplayPlaneProperties2KHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_DISPLAY_MODE_PROPERTIES_2_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDisplayModeProperties2KHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_DISPLAY_PLANE_INFO_2_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDisplayPlaneInfo2KHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_DISPLAY_PLANE_CAPABILITIES_2_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDisplayPlaneCapabilities2KHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePortabilitySubsetFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PORTABILITY_SUBSET_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePortabilitySubsetPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderClockFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PROFILE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeH265ProfileInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_CAPABILITIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeH265CapabilitiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_ADD_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeH265SessionParametersAddInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeH265SessionParametersCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_PICTURE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeH265PictureInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_H265_DPB_SLOT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeH265DpbSlotInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_QUEUE_GLOBAL_PRIORITY_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceQueueGlobalPriorityCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_GLOBAL_PRIORITY_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkQueueFamilyGlobalPriorityPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_FRAGMENT_SHADING_RATE_ATTACHMENT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkFragmentShadingRateAttachmentInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_STATE_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineFragmentShadingRateStateCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFragmentShadingRatePropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFragmentShadingRateKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDERING_ATTACHMENT_LOCATION_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderingAttachmentLocationInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDERING_INPUT_ATTACHMENT_INDEX_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderingInputAttachmentIndexInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_QUAD_CONTROL_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderQuadControlFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_SURFACE_PROTECTED_CAPABILITIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSurfaceProtectedCapabilitiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_WAIT_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePresentWaitFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_EXECUTABLE_PROPERTIES_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineExecutablePropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineExecutableInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_STATISTIC_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineExecutableStatisticKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_EXECUTABLE_INTERNAL_REPRESENTATION_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineExecutableInternalRepresentationKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_MAP_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryMapInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_UNMAP_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryUnmapInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_LIBRARY_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineLibraryCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PRESENT_ID_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPresentIdKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_ID_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePresentIdFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_CAPABILITIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeCapabilitiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_QUERY_POOL_VIDEO_ENCODE_FEEDBACK_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkQueryPoolVideoEncodeFeedbackCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_USAGE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeUsageInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_LAYER_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeRateControlLayerInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_RATE_CONTROL_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeRateControlInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeQualityLevelPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_QUALITY_LEVEL_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeQualityLevelInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_GET_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeSessionParametersGetInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_ENCODE_SESSION_PARAMETERS_FEEDBACK_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoEncodeSessionParametersFeedbackInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_2_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkQueueFamilyCheckpointProperties2NV>());
                break;
            }
            case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_2_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCheckpointData2NV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_BARYCENTRIC_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_UNIFORM_CONTROL_FLOW_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_WORKGROUP_MEMORY_EXPLICIT_LAYOUT_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MAINTENANCE_1_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MAXIMAL_RECONVERGENCE_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMaintenance5FeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMaintenance5PropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDERING_AREA_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderingAreaInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_SUBRESOURCE_2_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageSubresource2KHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_IMAGE_SUBRESOURCE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceImageSubresourceInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_SUBRESOURCE_LAYOUT_2_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSubresourceLayout2KHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_CREATE_FLAGS_2_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineCreateFlags2CreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_BUFFER_USAGE_FLAGS_2_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBufferUsageFlags2CreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_POSITION_FETCH_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCooperativeMatrixPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceCooperativeMatrixFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceCooperativeMatrixPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PROFILE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeAV1ProfileInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_CAPABILITIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeAV1CapabilitiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_SESSION_PARAMETERS_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeAV1SessionParametersCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_PICTURE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeAV1PictureInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_DECODE_AV1_DPB_SLOT_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoDecodeAV1DpbSlotInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VIDEO_MAINTENANCE_1_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVideoMaintenance1FeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_VIDEO_INLINE_QUERY_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVideoInlineQueryInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_DIVISOR_STATE_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineVertexInputDivisorStateCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderFloatControls2FeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceIndexTypeUint8FeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceLineRasterizationFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceLineRasterizationPropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_LINE_STATE_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineRasterizationLineStateCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_CALIBRATED_TIMESTAMP_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCalibratedTimestampInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderExpectAssumeFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMaintenance6FeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMaintenance6PropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_BIND_MEMORY_STATUS_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBindMemoryStatusKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_SETS_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBindDescriptorSetsInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PUSH_CONSTANTS_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPushConstantsInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPushDescriptorSetInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PUSH_DESCRIPTOR_SET_WITH_TEMPLATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPushDescriptorSetWithTemplateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_SET_DESCRIPTOR_BUFFER_OFFSETS_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSetDescriptorBufferOffsetsInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_BIND_DESCRIPTOR_BUFFER_EMBEDDED_SAMPLERS_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBindDescriptorBufferEmbeddedSamplersInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDebugReportCallbackCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineRasterizationStateRasterizationOrderAMD>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDebugMarkerObjectNameInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDebugMarkerObjectTagInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDebugMarkerMarkerInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDedicatedAllocationImageCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDedicatedAllocationBufferCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDedicatedAllocationMemoryAllocateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceTransformFeedbackFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TRANSFORM_FEEDBACK_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceTransformFeedbackPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_STREAM_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineRasterizationStateStreamCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_VIEW_HANDLE_INFO_NVX:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageViewHandleInfoNVX>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_VIEW_ADDRESS_PROPERTIES_NVX:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageViewAddressPropertiesNVX>());
                break;
            }
            case VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkTextureLODGatherFormatPropertiesAMD>());
                break;
            }
            case VK_STRUCTURE_TYPE_STREAM_DESCRIPTOR_SURFACE_CREATE_INFO_GGP:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkStreamDescriptorSurfaceCreateInfoGGP>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CORNER_SAMPLED_IMAGE_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceCornerSampledImageFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExternalMemoryImageCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExportMemoryAllocateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImportMemoryWin32HandleInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExportMemoryWin32HandleInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkWin32KeyedMutexAcquireReleaseInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkValidationFlagsEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkViSurfaceCreateInfoNN>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_VIEW_ASTC_DECODE_MODE_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageViewASTCDecodeModeEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceASTCDecodeFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePipelineRobustnessFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePipelineRobustnessPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_ROBUSTNESS_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineRobustnessCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_CONDITIONAL_RENDERING_BEGIN_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkConditionalRenderingBeginInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONDITIONAL_RENDERING_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceConditionalRenderingFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_CONDITIONAL_RENDERING_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCommandBufferInheritanceConditionalRenderingInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineViewportWScalingStateCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSurfaceCapabilities2EXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDisplayPowerInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceEventInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDisplayEventInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSwapchainCounterCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPresentTimesInfoGOOGLE>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineViewportSwizzleStateCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDiscardRectanglePropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineDiscardRectangleStateCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CONSERVATIVE_RASTERIZATION_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceConservativeRasterizationPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_CONSERVATIVE_STATE_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineRasterizationConservativeStateCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDepthClipEnableFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_DEPTH_CLIP_STATE_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineRasterizationDepthClipStateCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_HDR_METADATA_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkHdrMetadataEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RELAXED_LINE_RASTERIZATION_FEATURES_IMG:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG>());
                break;
            }
            case VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkIOSSurfaceCreateInfoMVK>());
                break;
            }
            case VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMacOSSurfaceCreateInfoMVK>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEBUG_UTILS_LABEL_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDebugUtilsLabelEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_NAME_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDebugUtilsObjectNameInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CALLBACK_DATA_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDebugUtilsMessengerCallbackDataEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEBUG_UTILS_MESSENGER_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDebugUtilsMessengerCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEBUG_UTILS_OBJECT_TAG_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDebugUtilsObjectTagInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_USAGE_ANDROID:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAndroidHardwareBufferUsageANDROID>());
                break;
            }
            case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_PROPERTIES_ANDROID:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAndroidHardwareBufferPropertiesANDROID>());
                break;
            }
            case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_ANDROID:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAndroidHardwareBufferFormatPropertiesANDROID>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMPORT_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImportAndroidHardwareBufferInfoANDROID>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_GET_ANDROID_HARDWARE_BUFFER_INFO_ANDROID:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryGetAndroidHardwareBufferInfoANDROID>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXTERNAL_FORMAT_ANDROID:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExternalFormatANDROID>());
                break;
            }
            case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_PROPERTIES_2_ANDROID:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAndroidHardwareBufferFormatProperties2ANDROID>());
                break;
            }
            case VK_STRUCTURE_TYPE_SAMPLE_LOCATIONS_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSampleLocationsInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_SAMPLE_LOCATIONS_BEGIN_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassSampleLocationsBeginInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_SAMPLE_LOCATIONS_STATE_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineSampleLocationsStateCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLE_LOCATIONS_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceSampleLocationsPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_MULTISAMPLE_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMultisamplePropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineColorBlendAdvancedStateCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineCoverageToColorStateCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineCoverageModulationStateCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_PROPERTIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderSMBuiltinsPropertiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SM_BUILTINS_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDrmFormatModifierPropertiesListEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_DRM_FORMAT_MODIFIER_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceImageDrmFormatModifierInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_LIST_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageDrmFormatModifierListCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_EXPLICIT_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageDrmFormatModifierExplicitCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_DRM_FORMAT_MODIFIER_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageDrmFormatModifierPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DRM_FORMAT_MODIFIER_PROPERTIES_LIST_2_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDrmFormatModifierPropertiesList2EXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_VALIDATION_CACHE_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkValidationCacheCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SHADER_MODULE_VALIDATION_CACHE_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkShaderModuleValidationCacheCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SHADING_RATE_IMAGE_STATE_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineViewportShadingRateImageStateCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShadingRateImageFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADING_RATE_IMAGE_PROPERTIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShadingRateImagePropertiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_COARSE_SAMPLE_ORDER_STATE_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineViewportCoarseSampleOrderStateCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRayTracingShaderGroupCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRayTracingPipelineCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_GEOMETRY_TRIANGLES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkGeometryTrianglesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_GEOMETRY_AABB_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkGeometryAABBNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_GEOMETRY_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkGeometryNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_BIND_ACCELERATION_STRUCTURE_MEMORY_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBindAccelerationStructureMemoryInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkWriteDescriptorSetAccelerationStructureNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MEMORY_REQUIREMENTS_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureMemoryRequirementsInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PROPERTIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRayTracingPropertiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_REPRESENTATIVE_FRAGMENT_TEST_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_REPRESENTATIVE_FRAGMENT_TEST_STATE_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineRepresentativeFragmentTestStateCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_IMAGE_FORMAT_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceImageViewImageFormatInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_FILTER_CUBIC_IMAGE_VIEW_IMAGE_FORMAT_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkFilterCubicImageViewImageFormatPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_HOST_POINTER_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImportMemoryHostPointerInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_HOST_POINTER_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryHostPointerPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_HOST_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExternalMemoryHostPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_COMPILER_CONTROL_CREATE_INFO_AMD:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineCompilerControlCreateInfoAMD>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_AMD:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderCorePropertiesAMD>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_MEMORY_OVERALLOCATION_CREATE_INFO_AMD:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceMemoryOverallocationCreateInfoAMD>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PRESENT_FRAME_TOKEN_GGP:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPresentFrameTokenGGP>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COMPUTE_SHADER_DERIVATIVES_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceComputeShaderDerivativesFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMeshShaderFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMeshShaderPropertiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_FOOTPRINT_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderImageFootprintFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_EXCLUSIVE_SCISSOR_STATE_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineViewportExclusiveScissorStateCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXCLUSIVE_SCISSOR_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExclusiveScissorFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_QUEUE_FAMILY_CHECKPOINT_PROPERTIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkQueueFamilyCheckpointPropertiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_CHECKPOINT_DATA_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCheckpointDataNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_FUNCTIONS_2_FEATURES_INTEL:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>());
                break;
            }
            case VK_STRUCTURE_TYPE_INITIALIZE_PERFORMANCE_API_INFO_INTEL:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkInitializePerformanceApiInfoINTEL>());
                break;
            }
            case VK_STRUCTURE_TYPE_QUERY_POOL_PERFORMANCE_QUERY_CREATE_INFO_INTEL:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkQueryPoolPerformanceQueryCreateInfoINTEL>());
                break;
            }
            case VK_STRUCTURE_TYPE_PERFORMANCE_MARKER_INFO_INTEL:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPerformanceMarkerInfoINTEL>());
                break;
            }
            case VK_STRUCTURE_TYPE_PERFORMANCE_STREAM_MARKER_INFO_INTEL:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPerformanceStreamMarkerInfoINTEL>());
                break;
            }
            case VK_STRUCTURE_TYPE_PERFORMANCE_OVERRIDE_INFO_INTEL:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPerformanceOverrideInfoINTEL>());
                break;
            }
            case VK_STRUCTURE_TYPE_PERFORMANCE_CONFIGURATION_ACQUIRE_INFO_INTEL:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPerformanceConfigurationAcquireInfoINTEL>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PCI_BUS_INFO_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePCIBusInfoPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DISPLAY_NATIVE_HDR_SURFACE_CAPABILITIES_AMD:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDisplayNativeHdrSurfaceCapabilitiesAMD>());
                break;
            }
            case VK_STRUCTURE_TYPE_SWAPCHAIN_DISPLAY_NATIVE_HDR_CREATE_INFO_AMD:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSwapchainDisplayNativeHdrCreateInfoAMD>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGEPIPE_SURFACE_CREATE_INFO_FUCHSIA:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImagePipeSurfaceCreateInfoFUCHSIA>());
                break;
            }
            case VK_STRUCTURE_TYPE_METAL_SURFACE_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMetalSurfaceCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFragmentDensityMapPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_FRAGMENT_DENSITY_MAP_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassFragmentDensityMapCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_2_AMD:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderCoreProperties2AMD>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COHERENT_MEMORY_FEATURES_AMD:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceCoherentMemoryFeaturesAMD>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_BUDGET_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMemoryBudgetPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PRIORITY_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMemoryPriorityFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_PRIORITY_ALLOCATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryPriorityAllocateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEDICATED_ALLOCATION_IMAGE_ALIASING_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_BUFFER_DEVICE_ADDRESS_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBufferDeviceAddressCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_VALIDATION_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkValidationFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_COOPERATIVE_MATRIX_PROPERTIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCooperativeMatrixPropertiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceCooperativeMatrixFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COOPERATIVE_MATRIX_PROPERTIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceCooperativeMatrixPropertiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COVERAGE_REDUCTION_MODE_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceCoverageReductionModeFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_REDUCTION_STATE_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineCoverageReductionStateCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_FRAMEBUFFER_MIXED_SAMPLES_COMBINATION_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkFramebufferMixedSamplesCombinationNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceProvokingVertexFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROVOKING_VERTEX_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceProvokingVertexPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_PROVOKING_VERTEX_STATE_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineRasterizationProvokingVertexStateCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSurfaceFullScreenExclusiveInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_FULL_SCREEN_EXCLUSIVE_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSurfaceCapabilitiesFullScreenExclusiveEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SURFACE_FULL_SCREEN_EXCLUSIVE_WIN32_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSurfaceFullScreenExclusiveWin32InfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_HEADLESS_SURFACE_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkHeadlessSurfaceCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceHostImageCopyFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceHostImageCopyPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_TO_IMAGE_COPY_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryToImageCopyEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_TO_MEMORY_COPY_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageToMemoryCopyEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_IMAGE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyMemoryToImageInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_MEMORY_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyImageToMemoryInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_IMAGE_TO_IMAGE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyImageToImageInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_HOST_IMAGE_LAYOUT_TRANSITION_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkHostImageLayoutTransitionInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SUBRESOURCE_HOST_MEMCPY_SIZE_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSubresourceHostMemcpySizeEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_HOST_IMAGE_COPY_DEVICE_PERFORMANCE_QUERY_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkHostImageCopyDevicePerformanceQueryEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMapMemoryPlacedFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAP_MEMORY_PLACED_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMapMemoryPlacedPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_MAP_PLACED_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryMapPlacedInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_2_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSurfacePresentModeEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SURFACE_PRESENT_SCALING_CAPABILITIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSurfacePresentScalingCapabilitiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SURFACE_PRESENT_MODE_COMPATIBILITY_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSurfacePresentModeCompatibilityEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SWAPCHAIN_MAINTENANCE_1_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_FENCE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSwapchainPresentFenceInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODES_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSwapchainPresentModesCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_MODE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSwapchainPresentModeInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_SCALING_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSwapchainPresentScalingCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_RELEASE_SWAPCHAIN_IMAGES_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkReleaseSwapchainImagesInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_PROPERTIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_GRAPHICS_SHADER_GROUP_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkGraphicsShaderGroupCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_SHADER_GROUPS_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkGraphicsPipelineShaderGroupsCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_TOKEN_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkIndirectCommandsLayoutTokenNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkIndirectCommandsLayoutCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkGeneratedCommandsInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_GENERATED_COMMANDS_MEMORY_REQUIREMENTS_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkGeneratedCommandsMemoryRequirementsInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INHERITED_VIEWPORT_SCISSOR_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceInheritedViewportScissorFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_VIEWPORT_SCISSOR_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCommandBufferInheritanceViewportScissorInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_TRANSFORM_BEGIN_INFO_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassTransformBeginInfoQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_RENDER_PASS_TRANSFORM_INFO_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCommandBufferInheritanceRenderPassTransformInfoQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_BIAS_CONTROL_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDepthBiasControlFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEPTH_BIAS_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDepthBiasInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEPTH_BIAS_REPRESENTATION_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDepthBiasRepresentationInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_MEMORY_REPORT_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_MEMORY_REPORT_CALLBACK_DATA_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceMemoryReportCallbackDataEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_DEVICE_MEMORY_REPORT_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceDeviceMemoryReportCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRobustness2FeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRobustness2PropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SAMPLER_CUSTOM_BORDER_COLOR_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSamplerCustomBorderColorCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceCustomBorderColorPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceCustomBorderColorFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRESENT_BARRIER_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePresentBarrierFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_PRESENT_BARRIER_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSurfaceCapabilitiesPresentBarrierNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_SWAPCHAIN_PRESENT_BARRIER_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSwapchainPresentBarrierCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DIAGNOSTICS_CONFIG_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDiagnosticsConfigFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_DIAGNOSTICS_CONFIG_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceDiagnosticsConfigCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_QUERY_LOW_LATENCY_SUPPORT_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkQueryLowLatencySupportNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GRAPHICS_PIPELINE_LIBRARY_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_LIBRARY_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkGraphicsPipelineLibraryCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EARLY_AND_LATE_FRAGMENT_TESTS_FEATURES_AMD:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_ENUMS_PROPERTIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_FRAGMENT_SHADING_RATE_ENUM_STATE_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineFragmentShadingRateEnumStateCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_MOTION_TRIANGLES_DATA_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureGeometryMotionTrianglesDataNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_MOTION_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureMotionInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_MOTION_BLUR_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRayTracingMotionBlurFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_2_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFragmentDensityMap2PropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_COMMAND_TRANSFORM_INFO_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyCommandTransformInfoQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceImageCompressionControlFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_CONTROL_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageCompressionControlEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_COMPRESSION_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageCompressionPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_LAYOUT_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevice4444FormatsFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FAULT_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFaultFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_FAULT_COUNTS_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceFaultCountsEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_FAULT_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceFaultInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RASTERIZATION_ORDER_ATTACHMENT_ACCESS_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RGBA10X6_FORMATS_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DIRECTFB_SURFACE_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDirectFBSurfaceCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MUTABLE_DESCRIPTOR_TYPE_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_MUTABLE_DESCRIPTOR_TYPE_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMutableDescriptorTypeCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_VERTEX_INPUT_BINDING_DESCRIPTION_2_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVertexInputBindingDescription2EXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_VERTEX_INPUT_ATTRIBUTE_DESCRIPTION_2_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkVertexInputAttributeDescription2EXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DRM_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDrmPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ADDRESS_BINDING_REPORT_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceAddressBindingReportFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_ADDRESS_BINDING_CALLBACK_DATA_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceAddressBindingCallbackDataEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_CONTROL_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDepthClipControlFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_DEPTH_CLIP_CONTROL_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineViewportDepthClipControlCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVE_TOPOLOGY_LIST_RESTART_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMPORT_MEMORY_ZIRCON_HANDLE_INFO_FUCHSIA:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImportMemoryZirconHandleInfoFUCHSIA>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_ZIRCON_HANDLE_PROPERTIES_FUCHSIA:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryZirconHandlePropertiesFUCHSIA>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_GET_ZIRCON_HANDLE_INFO_FUCHSIA:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryGetZirconHandleInfoFUCHSIA>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_ZIRCON_HANDLE_INFO_FUCHSIA:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImportSemaphoreZirconHandleInfoFUCHSIA>());
                break;
            }
            case VK_STRUCTURE_TYPE_SEMAPHORE_GET_ZIRCON_HANDLE_INFO_FUCHSIA:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSemaphoreGetZirconHandleInfoFUCHSIA>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INVOCATION_MASK_FEATURES_HUAWEI:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>());
                break;
            }
            case VK_STRUCTURE_TYPE_MEMORY_GET_REMOTE_ADDRESS_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMemoryGetRemoteAddressInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_MEMORY_RDMA_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAME_BOUNDARY_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFrameBoundaryFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_FRAME_BOUNDARY_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkFrameBoundaryEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SUBPASS_RESOLVE_PERFORMANCE_QUERY_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSubpassResolvePerformanceQueryEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_MULTISAMPLED_RENDER_TO_SINGLE_SAMPLED_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMultisampledRenderToSingleSampledInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SCREEN_SURFACE_CREATE_INFO_QNX:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkScreenSurfaceCreateInfoQNX>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceColorWriteEnableFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_COLOR_WRITE_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineColorWriteCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIMITIVES_GENERATED_QUERY_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_VIEW_MIN_LOD_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceImageViewMinLodFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_VIEW_MIN_LOD_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageViewMinLodCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMultiDrawFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTI_DRAW_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMultiDrawPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_2D_VIEW_OF_3D_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderTileImageFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TILE_IMAGE_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderTileImagePropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_MICROMAP_BUILD_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMicromapBuildInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_MICROMAP_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMicromapCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceOpacityMicromapFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPACITY_MICROMAP_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceOpacityMicromapPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_MICROMAP_VERSION_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMicromapVersionInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_MICROMAP_TO_MEMORY_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyMicromapToMemoryInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_MICROMAP_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyMemoryToMicromapInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_MICROMAP_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyMicromapInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_MICROMAP_BUILD_SIZES_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMicromapBuildSizesInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_OPACITY_MICROMAP_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureTrianglesOpacityMicromapEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDisplacementMicromapFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISPLACEMENT_MICROMAP_PROPERTIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDisplacementMicromapPropertiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_TRIANGLES_DISPLACEMENT_MICROMAP_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureTrianglesDisplacementMicromapNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_FEATURES_HUAWEI:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_PROPERTIES_HUAWEI:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CLUSTER_CULLING_SHADER_VRS_FEATURES_HUAWEI:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BORDER_COLOR_SWIZZLE_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceBorderColorSwizzleFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SAMPLER_BORDER_COLOR_COMPONENT_MAPPING_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSamplerBorderColorComponentMappingCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PAGEABLE_DEVICE_LOCAL_MEMORY_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_PROPERTIES_ARM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderCorePropertiesARM>());
                break;
            }
            case VK_STRUCTURE_TYPE_DEVICE_QUEUE_SHADER_CORE_CONTROL_CREATE_INFO_ARM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDeviceQueueShaderCoreControlCreateInfoARM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_FEATURES_ARM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceSchedulingControlsFeaturesARM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCHEDULING_CONTROLS_PROPERTIES_ARM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceSchedulingControlsPropertiesARM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_SLICED_VIEW_OF_3D_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_VIEW_SLICED_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageViewSlicedCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_SET_HOST_MAPPING_FEATURES_VALVE:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE>());
                break;
            }
            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_BINDING_REFERENCE_VALVE:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDescriptorSetBindingReferenceVALVE>());
                break;
            }
            case VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_HOST_MAPPING_INFO_VALVE:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDescriptorSetLayoutHostMappingInfoVALVE>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLAMP_ZERO_ONE_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDepthClampZeroOneFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NON_SEAMLESS_CUBE_MAP_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_FEATURES_ARM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRenderPassStripedFeaturesARM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RENDER_PASS_STRIPED_PROPERTIES_ARM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRenderPassStripedPropertiesARM>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_INFO_ARM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassStripeInfoARM>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_BEGIN_INFO_ARM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassStripeBeginInfoARM>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_STRIPE_SUBMIT_INFO_ARM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassStripeSubmitInfoARM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_FEATURES_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_DENSITY_MAP_OFFSET_PROPERTIES_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_SUBPASS_FRAGMENT_DENSITY_MAP_OFFSET_END_INFO_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSubpassFragmentDensityMapOffsetEndInfoQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEVICE_GENERATED_COMMANDS_COMPUTE_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_INDIRECT_BUFFER_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkComputePipelineIndirectBufferInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_INDIRECT_DEVICE_ADDRESS_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineIndirectDeviceAddressInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINEAR_COLOR_ATTACHMENT_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceLinearColorAttachmentFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_COMPRESSION_CONTROL_SWAPCHAIN_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_IMAGE_VIEW_SAMPLE_WEIGHT_CREATE_INFO_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkImageViewSampleWeightCreateInfoQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_FEATURES_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceImageProcessingFeaturesQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_PROPERTIES_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceImageProcessingPropertiesQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceNestedCommandBufferFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_NESTED_COMMAND_BUFFER_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceNestedCommandBufferPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_ACQUIRE_UNMODIFIED_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkExternalMemoryAcquireUnmodifiedEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExtendedDynamicState3FeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_3_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExtendedDynamicState3PropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBPASS_MERGE_FEEDBACK_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_CONTROL_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassCreationControlEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_CREATION_FEEDBACK_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassCreationFeedbackCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_RENDER_PASS_SUBPASS_FEEDBACK_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRenderPassSubpassFeedbackCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_INFO_LUNARG:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDirectDriverLoadingInfoLUNARG>());
                break;
            }
            case VK_STRUCTURE_TYPE_DIRECT_DRIVER_LOADING_LIST_LUNARG:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkDirectDriverLoadingListLUNARG>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_MODULE_IDENTIFIER_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_MODULE_IDENTIFIER_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPipelineShaderStageModuleIdentifierCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SHADER_MODULE_IDENTIFIER_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkShaderModuleIdentifierEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceOpticalFlowFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_OPTICAL_FLOW_PROPERTIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceOpticalFlowPropertiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkOpticalFlowImageFormatInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_OPTICAL_FLOW_IMAGE_FORMAT_PROPERTIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkOpticalFlowImageFormatPropertiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkOpticalFlowSessionCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_OPTICAL_FLOW_SESSION_CREATE_PRIVATE_DATA_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkOpticalFlowSessionCreatePrivateDataInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_OPTICAL_FLOW_EXECUTE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkOpticalFlowExecuteInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LEGACY_DITHERING_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceLegacyDitheringFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePipelineProtectedAccessFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_FEATURES_ANDROID:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExternalFormatResolveFeaturesANDROID>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FORMAT_RESOLVE_PROPERTIES_ANDROID:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExternalFormatResolvePropertiesANDROID>());
                break;
            }
            case VK_STRUCTURE_TYPE_ANDROID_HARDWARE_BUFFER_FORMAT_RESOLVE_PROPERTIES_ANDROID:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAndroidHardwareBufferFormatResolvePropertiesANDROID>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderObjectFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_OBJECT_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderObjectPropertiesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_SHADER_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkShaderCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TILE_PROPERTIES_FEATURES_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceTilePropertiesFeaturesQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_TILE_PROPERTIES_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkTilePropertiesQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_AMIGO_PROFILING_FEATURES_SEC:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceAmigoProfilingFeaturesSEC>());
                break;
            }
            case VK_STRUCTURE_TYPE_AMIGO_PROFILING_SUBMIT_INFO_SEC:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAmigoProfilingSubmitInfoSEC>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_VIEWPORTS_FEATURES_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_PROPERTIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_INVOCATION_REORDER_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_SPARSE_ADDRESS_SPACE_PROPERTIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_LAYER_SETTINGS_CREATE_INFO_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkLayerSettingsCreateInfoEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_FEATURES_ARM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CORE_BUILTINS_PROPERTIES_ARM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_LIBRARY_GROUP_HANDLES_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_UNUSED_ATTACHMENTS_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_LATENCY_SLEEP_MODE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkLatencySleepModeInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_LATENCY_SLEEP_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkLatencySleepInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_SET_LATENCY_MARKER_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSetLatencyMarkerInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_LATENCY_TIMINGS_FRAME_REPORT_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkLatencyTimingsFrameReportNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_GET_LATENCY_MARKER_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkGetLatencyMarkerInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_LATENCY_SUBMISSION_PRESENT_ID_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkLatencySubmissionPresentIdNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_SWAPCHAIN_LATENCY_CREATE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSwapchainLatencyCreateInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_OUT_OF_BAND_QUEUE_TYPE_INFO_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkOutOfBandQueueTypeInfoNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_LATENCY_SURFACE_CAPABILITIES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkLatencySurfaceCapabilitiesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_RENDER_AREAS_FEATURES_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_MULTIVIEW_PER_VIEW_RENDER_AREAS_RENDER_PASS_BEGIN_INFO_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PER_STAGE_DESCRIPTOR_SET_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDevicePerStageDescriptorSetFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_FEATURES_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceImageProcessing2FeaturesQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_PROCESSING_2_PROPERTIES_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceImageProcessing2PropertiesQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_SAMPLER_BLOCK_MATCH_WINDOW_CREATE_INFO_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSamplerBlockMatchWindowCreateInfoQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_WEIGHTS_FEATURES_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceCubicWeightsFeaturesQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_SAMPLER_CUBIC_WEIGHTS_CREATE_INFO_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSamplerCubicWeightsCreateInfoQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_BLIT_IMAGE_CUBIC_WEIGHTS_INFO_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkBlitImageCubicWeightsInfoQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_DEGAMMA_FEATURES_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceYcbcrDegammaFeaturesQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_SAMPLER_YCBCR_CONVERSION_YCBCR_DEGAMMA_CREATE_INFO_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUBIC_CLAMP_FEATURES_QCOM:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceCubicClampFeaturesQCOM>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ATTACHMENT_FEEDBACK_LOOP_DYNAMIC_STATE_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LAYERED_DRIVER_PROPERTIES_MSFT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceLayeredDriverPropertiesMSFT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_POOL_OVERALLOCATION_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAW_ACCESS_CHAINS_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRawAccessChainsFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT16_VECTOR_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_VALIDATION_FEATURES_NV:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRayTracingValidationFeaturesNV>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_TRIANGLES_DATA_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureGeometryTrianglesDataKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_AABBS_DATA_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureGeometryAabbsDataKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_INSTANCES_DATA_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureGeometryInstancesDataKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_GEOMETRY_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureGeometryKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_GEOMETRY_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureBuildGeometryInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET_ACCELERATION_STRUCTURE_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkWriteDescriptorSetAccelerationStructureKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceAccelerationStructureFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ACCELERATION_STRUCTURE_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceAccelerationStructurePropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_DEVICE_ADDRESS_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureDeviceAddressInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_VERSION_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureVersionInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_TO_MEMORY_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyAccelerationStructureToMemoryInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_MEMORY_TO_ACCELERATION_STRUCTURE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyMemoryToAccelerationStructureInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_COPY_ACCELERATION_STRUCTURE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkCopyAccelerationStructureInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_ACCELERATION_STRUCTURE_BUILD_SIZES_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkAccelerationStructureBuildSizesInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_RAY_TRACING_SHADER_GROUP_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRayTracingShaderGroupCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_INTERFACE_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRayTracingPipelineInterfaceCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_RAY_TRACING_PIPELINE_CREATE_INFO_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkRayTracingPipelineCreateInfoKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRayTracingPipelineFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_TRACING_PIPELINE_PROPERTIES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRayTracingPipelinePropertiesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_RAY_QUERY_FEATURES_KHR:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceRayQueryFeaturesKHR>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_FEATURES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMeshShaderFeaturesEXT>());
                break;
            }
            case VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MESH_SHADER_PROPERTIES_EXT:
            {
                output_struct->pNext = reinterpret_cast<VkBaseOutStructure*>(DecodeAllocator::Allocate<VkPhysicalDeviceMeshShaderPropertiesEXT>());
                break;
            }
            default:
                break;
        }
        output_struct = output_struct->pNext;
        output_struct->sType = in_pnext->sType;
        in_pnext = in_pnext->pNext;
    }
}

template <typename T>
void InitializeOutputStructPNext(StructPointerDecoder<T> *decoder)/*@@@IYQ*/
{
    if(decoder->IsNull()) return;
    size_t len = decoder->GetOutputLength();
    auto input = decoder->GetPointer();
    auto output = decoder->GetOutputPointer();
    for( size_t i = 0 ; i < len; ++i )
    {
        const auto* in_pnext = reinterpret_cast<const VkBaseInStructure*>(input[i].pNext);
        if( in_pnext == nullptr ) continue;
        auto* output_struct = reinterpret_cast<VkBaseOutStructure*>(&output[i]);
        InitializeOutputStructPNextImpl(in_pnext, output_struct);
    }
}

GFXRECON_END_NAMESPACE(decode)
GFXRECON_END_NAMESPACE(gfxrecon)
