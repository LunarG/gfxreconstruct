/*
** Copyright (c) 2021-2023 LunarG, Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to
** deal in the Software without restriction, including without limitation the
** rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
** sell copies of the Software, and to permit persons to whom the Software is
** furnished to do so, subject to the following conditions:
**
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
** FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
** IN THE SOFTWARE.
*/

/*
** This file is generated from dx12_wrapper_body_generator.py.
**
*/

#include "generated/generated_dx12_struct_wrappers.h"
#include "generated/generated_dx12_wrappers.h"

#include "encode/custom_dx12_api_call_encoders.h"
#include "encode/custom_dx12_struct_unwrappers.h"
#include "encode/custom_dx12_wrapper_commands.h"
#include "encode/d3d12_capture_manager.h"
#include "encode/d3d12_dispatch_table.h"
#include "encode/dx12_object_wrapper_util.h"
#include "encode/dxgi_dispatch_table.h"
#include "encode/dx12_rv_annotation_util.h"
#include "decode/dx12_enum_util.h"
#include "generated/generated_dx12_api_call_encoders.h"
#include "generated/generated_dx12_struct_unwrappers.h"
#include "generated/generated_dx12_wrapper_creators.h"
#include "util/defines.h"

#include <dxgiformat.h>
#include <d3d12.h>
#include <d3dcommon.h>
#include <d3d12sdklayers.h>
#include <d3d11.h>
#include <d3d11_1.h>
#include <d3d11_2.h>
#include <d3d11_3.h>
#include <d3d11_4.h>
#include <d3d11on12.h>
#include <dxgi.h>
#include <dxgi1_2.h>
#include <dxgi1_3.h>
#include <dxgi1_4.h>
#include <dxgi1_5.h>
#include <dxgi1_6.h>
#include <dxgicommon.h>
#include <dxgitype.h>
#include <Unknwnbase.h>
#include <guiddef.h>
#include <windef.h>
#include <minwinbase.h>

GFXRECON_BEGIN_NAMESPACE(gfxrecon)
GFXRECON_BEGIN_NAMESPACE(encode)

ID3D12RootSignature_Wrapper::ObjectMap ID3D12RootSignature_Wrapper::object_map_;
std::mutex ID3D12RootSignature_Wrapper::object_map_lock_;
ID3D12RootSignatureDeserializer_Wrapper::ObjectMap ID3D12RootSignatureDeserializer_Wrapper::object_map_;
std::mutex ID3D12RootSignatureDeserializer_Wrapper::object_map_lock_;
ID3D12VersionedRootSignatureDeserializer_Wrapper::ObjectMap ID3D12VersionedRootSignatureDeserializer_Wrapper::object_map_;
std::mutex ID3D12VersionedRootSignatureDeserializer_Wrapper::object_map_lock_;
ID3D12CommandAllocator_Wrapper::ObjectMap ID3D12CommandAllocator_Wrapper::object_map_;
std::mutex ID3D12CommandAllocator_Wrapper::object_map_lock_;
ID3D12Fence_Wrapper::ObjectMap ID3D12Fence_Wrapper::object_map_;
std::mutex ID3D12Fence_Wrapper::object_map_lock_;
ID3D12PipelineState_Wrapper::ObjectMap ID3D12PipelineState_Wrapper::object_map_;
std::mutex ID3D12PipelineState_Wrapper::object_map_lock_;
ID3D12DescriptorHeap_Wrapper::ObjectMap ID3D12DescriptorHeap_Wrapper::object_map_;
std::mutex ID3D12DescriptorHeap_Wrapper::object_map_lock_;
ID3D12QueryHeap_Wrapper::ObjectMap ID3D12QueryHeap_Wrapper::object_map_;
std::mutex ID3D12QueryHeap_Wrapper::object_map_lock_;
ID3D12CommandSignature_Wrapper::ObjectMap ID3D12CommandSignature_Wrapper::object_map_;
std::mutex ID3D12CommandSignature_Wrapper::object_map_lock_;
ID3D12CommandQueue_Wrapper::ObjectMap ID3D12CommandQueue_Wrapper::object_map_;
std::mutex ID3D12CommandQueue_Wrapper::object_map_lock_;
ID3D12PipelineLibrary_Wrapper::ObjectMap ID3D12PipelineLibrary_Wrapper::object_map_;
std::mutex ID3D12PipelineLibrary_Wrapper::object_map_lock_;
ID3D12LifetimeOwner_Wrapper::ObjectMap ID3D12LifetimeOwner_Wrapper::object_map_;
std::mutex ID3D12LifetimeOwner_Wrapper::object_map_lock_;
ID3D12SwapChainAssistant_Wrapper::ObjectMap ID3D12SwapChainAssistant_Wrapper::object_map_;
std::mutex ID3D12SwapChainAssistant_Wrapper::object_map_lock_;
ID3D12LifetimeTracker_Wrapper::ObjectMap ID3D12LifetimeTracker_Wrapper::object_map_;
std::mutex ID3D12LifetimeTracker_Wrapper::object_map_lock_;
ID3D12StateObject_Wrapper::ObjectMap ID3D12StateObject_Wrapper::object_map_;
std::mutex ID3D12StateObject_Wrapper::object_map_lock_;
ID3D12StateObjectProperties_Wrapper::ObjectMap ID3D12StateObjectProperties_Wrapper::object_map_;
std::mutex ID3D12StateObjectProperties_Wrapper::object_map_lock_;
ID3D12WorkGraphProperties_Wrapper::ObjectMap ID3D12WorkGraphProperties_Wrapper::object_map_;
std::mutex ID3D12WorkGraphProperties_Wrapper::object_map_lock_;
ID3D12DeviceRemovedExtendedDataSettings_Wrapper::ObjectMap ID3D12DeviceRemovedExtendedDataSettings_Wrapper::object_map_;
std::mutex ID3D12DeviceRemovedExtendedDataSettings_Wrapper::object_map_lock_;
ID3D12DeviceRemovedExtendedData_Wrapper::ObjectMap ID3D12DeviceRemovedExtendedData_Wrapper::object_map_;
std::mutex ID3D12DeviceRemovedExtendedData_Wrapper::object_map_lock_;
ID3D12ProtectedResourceSession_Wrapper::ObjectMap ID3D12ProtectedResourceSession_Wrapper::object_map_;
std::mutex ID3D12ProtectedResourceSession_Wrapper::object_map_lock_;
ID3D12Resource_Wrapper::ObjectMap ID3D12Resource_Wrapper::object_map_;
std::mutex ID3D12Resource_Wrapper::object_map_lock_;
ID3D12Heap_Wrapper::ObjectMap ID3D12Heap_Wrapper::object_map_;
std::mutex ID3D12Heap_Wrapper::object_map_lock_;
ID3D12MetaCommand_Wrapper::ObjectMap ID3D12MetaCommand_Wrapper::object_map_;
std::mutex ID3D12MetaCommand_Wrapper::object_map_lock_;
ID3D12ShaderCacheSession_Wrapper::ObjectMap ID3D12ShaderCacheSession_Wrapper::object_map_;
std::mutex ID3D12ShaderCacheSession_Wrapper::object_map_lock_;
ID3D12Device_Wrapper::ObjectMap ID3D12Device_Wrapper::object_map_;
std::mutex ID3D12Device_Wrapper::object_map_lock_;
ID3D12VirtualizationGuestDevice_Wrapper::ObjectMap ID3D12VirtualizationGuestDevice_Wrapper::object_map_;
std::mutex ID3D12VirtualizationGuestDevice_Wrapper::object_map_lock_;
ID3D12Tools_Wrapper::ObjectMap ID3D12Tools_Wrapper::object_map_;
std::mutex ID3D12Tools_Wrapper::object_map_lock_;
ID3D12PageableTools_Wrapper::ObjectMap ID3D12PageableTools_Wrapper::object_map_;
std::mutex ID3D12PageableTools_Wrapper::object_map_lock_;
ID3D12DeviceTools_Wrapper::ObjectMap ID3D12DeviceTools_Wrapper::object_map_;
std::mutex ID3D12DeviceTools_Wrapper::object_map_lock_;
ID3D12SDKConfiguration_Wrapper::ObjectMap ID3D12SDKConfiguration_Wrapper::object_map_;
std::mutex ID3D12SDKConfiguration_Wrapper::object_map_lock_;
ID3D12DeviceFactory_Wrapper::ObjectMap ID3D12DeviceFactory_Wrapper::object_map_;
std::mutex ID3D12DeviceFactory_Wrapper::object_map_lock_;
ID3D12DeviceConfiguration_Wrapper::ObjectMap ID3D12DeviceConfiguration_Wrapper::object_map_;
std::mutex ID3D12DeviceConfiguration_Wrapper::object_map_lock_;
ID3D12CommandList_Wrapper::ObjectMap ID3D12CommandList_Wrapper::object_map_;
std::mutex ID3D12CommandList_Wrapper::object_map_lock_;
ID3D12DSRDeviceFactory_Wrapper::ObjectMap ID3D12DSRDeviceFactory_Wrapper::object_map_;
std::mutex ID3D12DSRDeviceFactory_Wrapper::object_map_lock_;
ID3D12GBVDiagnostics_Wrapper::ObjectMap ID3D12GBVDiagnostics_Wrapper::object_map_;
std::mutex ID3D12GBVDiagnostics_Wrapper::object_map_lock_;
ID3D10Blob_Wrapper::ObjectMap ID3D10Blob_Wrapper::object_map_;
std::mutex ID3D10Blob_Wrapper::object_map_lock_;
ID3DDestructionNotifier_Wrapper::ObjectMap ID3DDestructionNotifier_Wrapper::object_map_;
std::mutex ID3DDestructionNotifier_Wrapper::object_map_lock_;
ID3D12Debug1_Wrapper::ObjectMap ID3D12Debug1_Wrapper::object_map_;
std::mutex ID3D12Debug1_Wrapper::object_map_lock_;
ID3D12Debug2_Wrapper::ObjectMap ID3D12Debug2_Wrapper::object_map_;
std::mutex ID3D12Debug2_Wrapper::object_map_lock_;
ID3D12Debug_Wrapper::ObjectMap ID3D12Debug_Wrapper::object_map_;
std::mutex ID3D12Debug_Wrapper::object_map_lock_;
ID3D12DebugDevice1_Wrapper::ObjectMap ID3D12DebugDevice1_Wrapper::object_map_;
std::mutex ID3D12DebugDevice1_Wrapper::object_map_lock_;
ID3D12DebugDevice_Wrapper::ObjectMap ID3D12DebugDevice_Wrapper::object_map_;
std::mutex ID3D12DebugDevice_Wrapper::object_map_lock_;
ID3D12DebugCommandQueue_Wrapper::ObjectMap ID3D12DebugCommandQueue_Wrapper::object_map_;
std::mutex ID3D12DebugCommandQueue_Wrapper::object_map_lock_;
ID3D12DebugCommandList1_Wrapper::ObjectMap ID3D12DebugCommandList1_Wrapper::object_map_;
std::mutex ID3D12DebugCommandList1_Wrapper::object_map_lock_;
ID3D12DebugCommandList_Wrapper::ObjectMap ID3D12DebugCommandList_Wrapper::object_map_;
std::mutex ID3D12DebugCommandList_Wrapper::object_map_lock_;
ID3D12SharingContract_Wrapper::ObjectMap ID3D12SharingContract_Wrapper::object_map_;
std::mutex ID3D12SharingContract_Wrapper::object_map_lock_;
ID3D12ManualWriteTrackingResource_Wrapper::ObjectMap ID3D12ManualWriteTrackingResource_Wrapper::object_map_;
std::mutex ID3D12ManualWriteTrackingResource_Wrapper::object_map_lock_;
ID3D12InfoQueue_Wrapper::ObjectMap ID3D12InfoQueue_Wrapper::object_map_;
std::mutex ID3D12InfoQueue_Wrapper::object_map_lock_;
ID3D11DepthStencilState_Wrapper::ObjectMap ID3D11DepthStencilState_Wrapper::object_map_;
std::mutex ID3D11DepthStencilState_Wrapper::object_map_lock_;
ID3D11Buffer_Wrapper::ObjectMap ID3D11Buffer_Wrapper::object_map_;
std::mutex ID3D11Buffer_Wrapper::object_map_lock_;
ID3D11Texture1D_Wrapper::ObjectMap ID3D11Texture1D_Wrapper::object_map_;
std::mutex ID3D11Texture1D_Wrapper::object_map_lock_;
ID3D11DepthStencilView_Wrapper::ObjectMap ID3D11DepthStencilView_Wrapper::object_map_;
std::mutex ID3D11DepthStencilView_Wrapper::object_map_lock_;
ID3D11VertexShader_Wrapper::ObjectMap ID3D11VertexShader_Wrapper::object_map_;
std::mutex ID3D11VertexShader_Wrapper::object_map_lock_;
ID3D11HullShader_Wrapper::ObjectMap ID3D11HullShader_Wrapper::object_map_;
std::mutex ID3D11HullShader_Wrapper::object_map_lock_;
ID3D11DomainShader_Wrapper::ObjectMap ID3D11DomainShader_Wrapper::object_map_;
std::mutex ID3D11DomainShader_Wrapper::object_map_lock_;
ID3D11GeometryShader_Wrapper::ObjectMap ID3D11GeometryShader_Wrapper::object_map_;
std::mutex ID3D11GeometryShader_Wrapper::object_map_lock_;
ID3D11PixelShader_Wrapper::ObjectMap ID3D11PixelShader_Wrapper::object_map_;
std::mutex ID3D11PixelShader_Wrapper::object_map_lock_;
ID3D11ComputeShader_Wrapper::ObjectMap ID3D11ComputeShader_Wrapper::object_map_;
std::mutex ID3D11ComputeShader_Wrapper::object_map_lock_;
ID3D11InputLayout_Wrapper::ObjectMap ID3D11InputLayout_Wrapper::object_map_;
std::mutex ID3D11InputLayout_Wrapper::object_map_lock_;
ID3D11SamplerState_Wrapper::ObjectMap ID3D11SamplerState_Wrapper::object_map_;
std::mutex ID3D11SamplerState_Wrapper::object_map_lock_;
ID3D11Predicate_Wrapper::ObjectMap ID3D11Predicate_Wrapper::object_map_;
std::mutex ID3D11Predicate_Wrapper::object_map_lock_;
ID3D11Counter_Wrapper::ObjectMap ID3D11Counter_Wrapper::object_map_;
std::mutex ID3D11Counter_Wrapper::object_map_lock_;
ID3D11ClassInstance_Wrapper::ObjectMap ID3D11ClassInstance_Wrapper::object_map_;
std::mutex ID3D11ClassInstance_Wrapper::object_map_lock_;
ID3D11ClassLinkage_Wrapper::ObjectMap ID3D11ClassLinkage_Wrapper::object_map_;
std::mutex ID3D11ClassLinkage_Wrapper::object_map_lock_;
ID3D11CommandList_Wrapper::ObjectMap ID3D11CommandList_Wrapper::object_map_;
std::mutex ID3D11CommandList_Wrapper::object_map_lock_;
ID3D11VideoDecoder_Wrapper::ObjectMap ID3D11VideoDecoder_Wrapper::object_map_;
std::mutex ID3D11VideoDecoder_Wrapper::object_map_lock_;
ID3D11VideoProcessor_Wrapper::ObjectMap ID3D11VideoProcessor_Wrapper::object_map_;
std::mutex ID3D11VideoProcessor_Wrapper::object_map_lock_;
ID3D11AuthenticatedChannel_Wrapper::ObjectMap ID3D11AuthenticatedChannel_Wrapper::object_map_;
std::mutex ID3D11AuthenticatedChannel_Wrapper::object_map_lock_;
ID3D11CryptoSession_Wrapper::ObjectMap ID3D11CryptoSession_Wrapper::object_map_;
std::mutex ID3D11CryptoSession_Wrapper::object_map_lock_;
ID3D11VideoDecoderOutputView_Wrapper::ObjectMap ID3D11VideoDecoderOutputView_Wrapper::object_map_;
std::mutex ID3D11VideoDecoderOutputView_Wrapper::object_map_lock_;
ID3D11VideoProcessorInputView_Wrapper::ObjectMap ID3D11VideoProcessorInputView_Wrapper::object_map_;
std::mutex ID3D11VideoProcessorInputView_Wrapper::object_map_lock_;
ID3D11VideoProcessorOutputView_Wrapper::ObjectMap ID3D11VideoProcessorOutputView_Wrapper::object_map_;
std::mutex ID3D11VideoProcessorOutputView_Wrapper::object_map_lock_;
ID3D11BlendState_Wrapper::ObjectMap ID3D11BlendState_Wrapper::object_map_;
std::mutex ID3D11BlendState_Wrapper::object_map_lock_;
ID3DDeviceContextState_Wrapper::ObjectMap ID3DDeviceContextState_Wrapper::object_map_;
std::mutex ID3DDeviceContextState_Wrapper::object_map_lock_;
ID3D11VideoProcessorEnumerator_Wrapper::ObjectMap ID3D11VideoProcessorEnumerator_Wrapper::object_map_;
std::mutex ID3D11VideoProcessorEnumerator_Wrapper::object_map_lock_;
ID3DUserDefinedAnnotation_Wrapper::ObjectMap ID3DUserDefinedAnnotation_Wrapper::object_map_;
std::mutex ID3DUserDefinedAnnotation_Wrapper::object_map_lock_;
ID3D11Texture2D_Wrapper::ObjectMap ID3D11Texture2D_Wrapper::object_map_;
std::mutex ID3D11Texture2D_Wrapper::object_map_lock_;
ID3D11Texture3D_Wrapper::ObjectMap ID3D11Texture3D_Wrapper::object_map_;
std::mutex ID3D11Texture3D_Wrapper::object_map_lock_;
ID3D11RasterizerState_Wrapper::ObjectMap ID3D11RasterizerState_Wrapper::object_map_;
std::mutex ID3D11RasterizerState_Wrapper::object_map_lock_;
ID3D11ShaderResourceView_Wrapper::ObjectMap ID3D11ShaderResourceView_Wrapper::object_map_;
std::mutex ID3D11ShaderResourceView_Wrapper::object_map_lock_;
ID3D11RenderTargetView_Wrapper::ObjectMap ID3D11RenderTargetView_Wrapper::object_map_;
std::mutex ID3D11RenderTargetView_Wrapper::object_map_lock_;
ID3D11UnorderedAccessView_Wrapper::ObjectMap ID3D11UnorderedAccessView_Wrapper::object_map_;
std::mutex ID3D11UnorderedAccessView_Wrapper::object_map_lock_;
ID3D11Query_Wrapper::ObjectMap ID3D11Query_Wrapper::object_map_;
std::mutex ID3D11Query_Wrapper::object_map_lock_;
ID3D11Fence_Wrapper::ObjectMap ID3D11Fence_Wrapper::object_map_;
std::mutex ID3D11Fence_Wrapper::object_map_lock_;
ID3D11DeviceContext_Wrapper::ObjectMap ID3D11DeviceContext_Wrapper::object_map_;
std::mutex ID3D11DeviceContext_Wrapper::object_map_lock_;
ID3D11Device_Wrapper::ObjectMap ID3D11Device_Wrapper::object_map_;
std::mutex ID3D11Device_Wrapper::object_map_lock_;
ID3D11Multithread_Wrapper::ObjectMap ID3D11Multithread_Wrapper::object_map_;
std::mutex ID3D11Multithread_Wrapper::object_map_lock_;
ID3D11VideoDevice_Wrapper::ObjectMap ID3D11VideoDevice_Wrapper::object_map_;
std::mutex ID3D11VideoDevice_Wrapper::object_map_lock_;
ID3D11VideoContext_Wrapper::ObjectMap ID3D11VideoContext_Wrapper::object_map_;
std::mutex ID3D11VideoContext_Wrapper::object_map_lock_;
ID3D11On12Device_Wrapper::ObjectMap ID3D11On12Device_Wrapper::object_map_;
std::mutex ID3D11On12Device_Wrapper::object_map_lock_;
IDXGIKeyedMutex_Wrapper::ObjectMap IDXGIKeyedMutex_Wrapper::object_map_;
std::mutex IDXGIKeyedMutex_Wrapper::object_map_lock_;
IDXGIDisplayControl_Wrapper::ObjectMap IDXGIDisplayControl_Wrapper::object_map_;
std::mutex IDXGIDisplayControl_Wrapper::object_map_lock_;
IDXGIOutputDuplication_Wrapper::ObjectMap IDXGIOutputDuplication_Wrapper::object_map_;
std::mutex IDXGIOutputDuplication_Wrapper::object_map_lock_;
IDXGISurface_Wrapper::ObjectMap IDXGISurface_Wrapper::object_map_;
std::mutex IDXGISurface_Wrapper::object_map_lock_;
IDXGIResource_Wrapper::ObjectMap IDXGIResource_Wrapper::object_map_;
std::mutex IDXGIResource_Wrapper::object_map_lock_;
IDXGIDecodeSwapChain_Wrapper::ObjectMap IDXGIDecodeSwapChain_Wrapper::object_map_;
std::mutex IDXGIDecodeSwapChain_Wrapper::object_map_lock_;
IDXGIFactoryMedia_Wrapper::ObjectMap IDXGIFactoryMedia_Wrapper::object_map_;
std::mutex IDXGIFactoryMedia_Wrapper::object_map_lock_;
IDXGISwapChainMedia_Wrapper::ObjectMap IDXGISwapChainMedia_Wrapper::object_map_;
std::mutex IDXGISwapChainMedia_Wrapper::object_map_lock_;
IDXGISwapChain_Wrapper::ObjectMap IDXGISwapChain_Wrapper::object_map_;
std::mutex IDXGISwapChain_Wrapper::object_map_lock_;
IDXGIDevice_Wrapper::ObjectMap IDXGIDevice_Wrapper::object_map_;
std::mutex IDXGIDevice_Wrapper::object_map_lock_;
IDXGIAdapter_Wrapper::ObjectMap IDXGIAdapter_Wrapper::object_map_;
std::mutex IDXGIAdapter_Wrapper::object_map_lock_;
IDXGIOutput_Wrapper::ObjectMap IDXGIOutput_Wrapper::object_map_;
std::mutex IDXGIOutput_Wrapper::object_map_lock_;
IDXGIFactory_Wrapper::ObjectMap IDXGIFactory_Wrapper::object_map_;
std::mutex IDXGIFactory_Wrapper::object_map_lock_;

/*
** This part is generated from dxgiformat.h in Windows SDK: 10.0.20348.0
**
*/


/*
** This part is generated from d3d12.h in Windows SDK: 10.0.20348.0
**
*/

HRESULT WINAPI D3D12SerializeRootSignature(
    const D3D12_ROOT_SIGNATURE_DESC* pRootSignature,
    D3D_ROOT_SIGNATURE_VERSION Version,
    ID3DBlob** ppBlob,
    ID3DBlob** ppErrorBlob)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_D3D12SerializeRootSignature>::Dispatch(
            manager,
            pRootSignature,
            Version,
            ppBlob,
            ppErrorBlob);

        result = manager->GetD3D12DispatchTable().D3D12SerializeRootSignature(
            pRootSignature,
            Version,
            ppBlob,
            ppErrorBlob);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D10Blob, reinterpret_cast<void**>(ppBlob), nullptr);
            WrapObject(IID_ID3D10Blob, reinterpret_cast<void**>(ppErrorBlob), nullptr);
        }

        Encode_D3D12SerializeRootSignature(
            result,
            pRootSignature,
            Version,
            ppBlob,
            ppErrorBlob);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_D3D12SerializeRootSignature>::Dispatch(
            manager,
            result,
            pRootSignature,
            Version,
            ppBlob,
            ppErrorBlob);
    }
    else
    {
        result = manager->GetD3D12DispatchTable().D3D12SerializeRootSignature(
            pRootSignature,
            Version,
            ppBlob,
            ppErrorBlob);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT WINAPI D3D12CreateRootSignatureDeserializer(
    LPCVOID pSrcData,
    SIZE_T SrcDataSizeInBytes,
    REFIID pRootSignatureDeserializerInterface,
    void** ppRootSignatureDeserializer)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_D3D12CreateRootSignatureDeserializer>::Dispatch(
            manager,
            pSrcData,
            SrcDataSizeInBytes,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);

        result = manager->GetD3D12DispatchTable().D3D12CreateRootSignatureDeserializer(
            pSrcData,
            SrcDataSizeInBytes,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);

        if (SUCCEEDED(result))
        {
            WrapObject(pRootSignatureDeserializerInterface, ppRootSignatureDeserializer, nullptr);
        }

        Encode_D3D12CreateRootSignatureDeserializer(
            result,
            pSrcData,
            SrcDataSizeInBytes,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_D3D12CreateRootSignatureDeserializer>::Dispatch(
            manager,
            result,
            pSrcData,
            SrcDataSizeInBytes,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);
    }
    else
    {
        result = manager->GetD3D12DispatchTable().D3D12CreateRootSignatureDeserializer(
            pSrcData,
            SrcDataSizeInBytes,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT WINAPI D3D12SerializeVersionedRootSignature(
    const D3D12_VERSIONED_ROOT_SIGNATURE_DESC* pRootSignature,
    ID3DBlob** ppBlob,
    ID3DBlob** ppErrorBlob)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_D3D12SerializeVersionedRootSignature>::Dispatch(
            manager,
            pRootSignature,
            ppBlob,
            ppErrorBlob);

        result = D3D12CaptureManager::Get()->OverrideD3D12SerializeVersionedRootSignature(
            pRootSignature,
            ppBlob,
            ppErrorBlob);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D10Blob, reinterpret_cast<void**>(ppBlob), nullptr);
            WrapObject(IID_ID3D10Blob, reinterpret_cast<void**>(ppErrorBlob), nullptr);
        }

        Encode_D3D12SerializeVersionedRootSignature(
            result,
            pRootSignature,
            ppBlob,
            ppErrorBlob);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_D3D12SerializeVersionedRootSignature>::Dispatch(
            manager,
            result,
            pRootSignature,
            ppBlob,
            ppErrorBlob);
    }
    else
    {
        result = manager->GetD3D12DispatchTable().D3D12SerializeVersionedRootSignature(
            pRootSignature,
            ppBlob,
            ppErrorBlob);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT WINAPI D3D12CreateVersionedRootSignatureDeserializer(
    LPCVOID pSrcData,
    SIZE_T SrcDataSizeInBytes,
    REFIID pRootSignatureDeserializerInterface,
    void** ppRootSignatureDeserializer)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_D3D12CreateVersionedRootSignatureDeserializer>::Dispatch(
            manager,
            pSrcData,
            SrcDataSizeInBytes,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);

        result = manager->GetD3D12DispatchTable().D3D12CreateVersionedRootSignatureDeserializer(
            pSrcData,
            SrcDataSizeInBytes,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);

        if (SUCCEEDED(result))
        {
            WrapObject(pRootSignatureDeserializerInterface, ppRootSignatureDeserializer, nullptr);
        }

        Encode_D3D12CreateVersionedRootSignatureDeserializer(
            result,
            pSrcData,
            SrcDataSizeInBytes,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_D3D12CreateVersionedRootSignatureDeserializer>::Dispatch(
            manager,
            result,
            pSrcData,
            SrcDataSizeInBytes,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);
    }
    else
    {
        result = manager->GetD3D12DispatchTable().D3D12CreateVersionedRootSignatureDeserializer(
            pSrcData,
            SrcDataSizeInBytes,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT WINAPI D3D12CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary(
    LPCVOID pSrcData,
    SIZE_T SrcDataSizeInBytes,
    LPCWSTR RootSignatureSubobjectName,
    REFIID pRootSignatureDeserializerInterface,
    void** ppRootSignatureDeserializer)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_D3D12CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary>::Dispatch(
            manager,
            pSrcData,
            SrcDataSizeInBytes,
            RootSignatureSubobjectName,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);

        result = D3D12CaptureManager::Get()->OverrideD3D12CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary(
            pSrcData,
            SrcDataSizeInBytes,
            RootSignatureSubobjectName,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);

        if (SUCCEEDED(result))
        {
            WrapObject(pRootSignatureDeserializerInterface, ppRootSignatureDeserializer, nullptr);
        }

        Encode_D3D12CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary(
            result,
            pSrcData,
            SrcDataSizeInBytes,
            RootSignatureSubobjectName,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_D3D12CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary>::Dispatch(
            manager,
            result,
            pSrcData,
            SrcDataSizeInBytes,
            RootSignatureSubobjectName,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);
    }
    else
    {
        result = manager->GetD3D12DispatchTable().D3D12CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary(
            pSrcData,
            SrcDataSizeInBytes,
            RootSignatureSubobjectName,
            pRootSignatureDeserializerInterface,
            ppRootSignatureDeserializer);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT WINAPI D3D12CreateDevice(
    IUnknown* pAdapter,
    D3D_FEATURE_LEVEL MinimumFeatureLevel,
    REFIID riid,
    void** ppDevice)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_D3D12CreateDevice>::Dispatch(
            manager,
            pAdapter,
            MinimumFeatureLevel,
            riid,
            ppDevice);

        result = manager->GetD3D12DispatchTable().D3D12CreateDevice(
            encode::GetWrappedObject<IUnknown>(pAdapter),
            MinimumFeatureLevel,
            riid,
            ppDevice);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppDevice, nullptr);
        }

        Encode_D3D12CreateDevice(
            result,
            pAdapter,
            MinimumFeatureLevel,
            riid,
            ppDevice);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_D3D12CreateDevice>::Dispatch(
            manager,
            result,
            pAdapter,
            MinimumFeatureLevel,
            riid,
            ppDevice);
    }
    else
    {
        result = manager->GetD3D12DispatchTable().D3D12CreateDevice(
            pAdapter,
            MinimumFeatureLevel,
            riid,
            ppDevice);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT WINAPI D3D12GetDebugInterface(
    REFIID riid,
    void** ppvDebug)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_D3D12GetDebugInterface>::Dispatch(
            manager,
            riid,
            ppvDebug);

        result = manager->GetD3D12DispatchTable().D3D12GetDebugInterface(
            riid,
            ppvDebug);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvDebug, nullptr);
        }

        Encode_D3D12GetDebugInterface(
            result,
            riid,
            ppvDebug);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_D3D12GetDebugInterface>::Dispatch(
            manager,
            result,
            riid,
            ppvDebug);
    }
    else
    {
        result = manager->GetD3D12DispatchTable().D3D12GetDebugInterface(
            riid,
            ppvDebug);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT WINAPI D3D12EnableExperimentalFeatures(
    UINT NumFeatures,
    const IID* pIIDs,
    void* pConfigurationStructs,
    UINT* pConfigurationStructSizes)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_D3D12EnableExperimentalFeatures>::Dispatch(
            manager,
            NumFeatures,
            pIIDs,
            pConfigurationStructs,
            pConfigurationStructSizes);

        result = manager->GetD3D12DispatchTable().D3D12EnableExperimentalFeatures(
            NumFeatures,
            pIIDs,
            pConfigurationStructs,
            pConfigurationStructSizes);

        Encode_D3D12EnableExperimentalFeatures(
            result,
            NumFeatures,
            pIIDs,
            pConfigurationStructs,
            pConfigurationStructSizes);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_D3D12EnableExperimentalFeatures>::Dispatch(
            manager,
            result,
            NumFeatures,
            pIIDs,
            pConfigurationStructs,
            pConfigurationStructSizes);
    }
    else
    {
        result = manager->GetD3D12DispatchTable().D3D12EnableExperimentalFeatures(
            NumFeatures,
            pIIDs,
            pConfigurationStructs,
            pConfigurationStructSizes);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT WINAPI D3D12GetInterface(
    REFCLSID rclsid,
    REFIID riid,
    void** ppvDebug)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_D3D12GetInterface>::Dispatch(
            manager,
            rclsid,
            riid,
            ppvDebug);

        result = manager->GetD3D12DispatchTable().D3D12GetInterface(
            rclsid,
            riid,
            ppvDebug);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvDebug, nullptr);
        }

        Encode_D3D12GetInterface(
            result,
            rclsid,
            riid,
            ppvDebug);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_D3D12GetInterface>::Dispatch(
            manager,
            result,
            rclsid,
            riid,
            ppvDebug);
    }
    else
    {
        result = manager->GetD3D12DispatchTable().D3D12GetInterface(
            rclsid,
            riid,
            ppvDebug);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Object_Wrapper::ID3D12Object_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Object_Wrapper::GetPrivateData(
    REFGUID guid,
    UINT* pDataSize,
    void* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Object_GetPrivateData>::Dispatch(
            manager,
            this,
            guid,
            pDataSize,
            pData);

        result = GetWrappedObjectAs<ID3D12Object>()->GetPrivateData(
            guid,
            pDataSize,
            pData);

        Encode_ID3D12Object_GetPrivateData(
            this,
            result,
            guid,
            pDataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Object_GetPrivateData>::Dispatch(
            manager,
            this,
            result,
            guid,
            pDataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Object>()->GetPrivateData(
            guid,
            pDataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Object_Wrapper::SetPrivateData(
    REFGUID guid,
    UINT DataSize,
    const void* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Object_SetPrivateData>::Dispatch(
            manager,
            this,
            guid,
            DataSize,
            pData);

        result = GetWrappedObjectAs<ID3D12Object>()->SetPrivateData(
            guid,
            DataSize,
            pData);

        Encode_ID3D12Object_SetPrivateData(
            this,
            result,
            guid,
            DataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Object_SetPrivateData>::Dispatch(
            manager,
            this,
            result,
            guid,
            DataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Object>()->SetPrivateData(
            guid,
            DataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Object_Wrapper::SetPrivateDataInterface(
    REFGUID guid,
    const IUnknown* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Object_SetPrivateDataInterface>::Dispatch(
            manager,
            this,
            guid,
            pData);

        result = GetWrappedObjectAs<ID3D12Object>()->SetPrivateDataInterface(
            guid,
            encode::GetWrappedObject<IUnknown>(pData));

        Encode_ID3D12Object_SetPrivateDataInterface(
            this,
            result,
            guid,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Object_SetPrivateDataInterface>::Dispatch(
            manager,
            this,
            result,
            guid,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Object>()->SetPrivateDataInterface(
            guid,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Object_Wrapper::SetName(
    LPCWSTR Name)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Object_SetName>::Dispatch(
            manager,
            this,
            Name);

        result = GetWrappedObjectAs<ID3D12Object>()->SetName(
            Name);

        Encode_ID3D12Object_SetName(
            this,
            result,
            Name);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Object_SetName>::Dispatch(
            manager,
            this,
            result,
            Name);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Object>()->SetName(
            Name);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DeviceChild_Wrapper::ID3D12DeviceChild_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Object_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceChild_Wrapper::GetDevice(
    REFIID riid,
    void** ppvDevice)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceChild_GetDevice>::Dispatch(
            manager,
            this,
            riid,
            ppvDevice);

        result = GetWrappedObjectAs<ID3D12DeviceChild>()->GetDevice(
            riid,
            ppvDevice);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvDevice, nullptr);
        }

        Encode_ID3D12DeviceChild_GetDevice(
            this,
            result,
            riid,
            ppvDevice);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceChild_GetDevice>::Dispatch(
            manager,
            this,
            result,
            riid,
            ppvDevice);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceChild>()->GetDevice(
            riid,
            ppvDevice);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12RootSignature_Wrapper::ID3D12RootSignature_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12RootSignatureInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12RootSignature_Wrapper::~ID3D12RootSignature_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12RootSignature>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12RootSignature_Wrapper* ID3D12RootSignature_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12RootSignature_Wrapper>(object, object_map_, object_map_lock_);
}

ID3D12RootSignatureDeserializer_Wrapper::ID3D12RootSignatureDeserializer_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12RootSignatureDeserializerInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12RootSignatureDeserializer_Wrapper::~ID3D12RootSignatureDeserializer_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12RootSignatureDeserializer>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12RootSignatureDeserializer_Wrapper* ID3D12RootSignatureDeserializer_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12RootSignatureDeserializer_Wrapper>(object, object_map_, object_map_lock_);
}

const D3D12_ROOT_SIGNATURE_DESC* STDMETHODCALLTYPE ID3D12RootSignatureDeserializer_Wrapper::GetRootSignatureDesc()
{
    const D3D12_ROOT_SIGNATURE_DESC* result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12RootSignatureDeserializer_GetRootSignatureDesc>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12RootSignatureDeserializer>()->GetRootSignatureDesc();

        Encode_ID3D12RootSignatureDeserializer_GetRootSignatureDesc(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12RootSignatureDeserializer_GetRootSignatureDesc>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12RootSignatureDeserializer>()->GetRootSignatureDesc();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12VersionedRootSignatureDeserializer_Wrapper::ID3D12VersionedRootSignatureDeserializer_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12VersionedRootSignatureDeserializerInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12VersionedRootSignatureDeserializer_Wrapper::~ID3D12VersionedRootSignatureDeserializer_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12VersionedRootSignatureDeserializer>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12VersionedRootSignatureDeserializer_Wrapper* ID3D12VersionedRootSignatureDeserializer_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12VersionedRootSignatureDeserializer_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12VersionedRootSignatureDeserializer_Wrapper::GetRootSignatureDescAtVersion(
    D3D_ROOT_SIGNATURE_VERSION convertToVersion,
    const D3D12_VERSIONED_ROOT_SIGNATURE_DESC** ppDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12VersionedRootSignatureDeserializer_GetRootSignatureDescAtVersion>::Dispatch(
            manager,
            this,
            convertToVersion,
            ppDesc);

        result = GetWrappedObjectAs<ID3D12VersionedRootSignatureDeserializer>()->GetRootSignatureDescAtVersion(
            convertToVersion,
            ppDesc);

        Encode_ID3D12VersionedRootSignatureDeserializer_GetRootSignatureDescAtVersion(
            this,
            result,
            convertToVersion,
            ppDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12VersionedRootSignatureDeserializer_GetRootSignatureDescAtVersion>::Dispatch(
            manager,
            this,
            result,
            convertToVersion,
            ppDesc);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12VersionedRootSignatureDeserializer>()->GetRootSignatureDescAtVersion(
            convertToVersion,
            ppDesc);
    }

    manager->DecrementCallScope();

    return result;
}

const D3D12_VERSIONED_ROOT_SIGNATURE_DESC* STDMETHODCALLTYPE ID3D12VersionedRootSignatureDeserializer_Wrapper::GetUnconvertedRootSignatureDesc()
{
    const D3D12_VERSIONED_ROOT_SIGNATURE_DESC* result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12VersionedRootSignatureDeserializer_GetUnconvertedRootSignatureDesc>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12VersionedRootSignatureDeserializer>()->GetUnconvertedRootSignatureDesc();

        Encode_ID3D12VersionedRootSignatureDeserializer_GetUnconvertedRootSignatureDesc(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12VersionedRootSignatureDeserializer_GetUnconvertedRootSignatureDesc>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12VersionedRootSignatureDeserializer>()->GetUnconvertedRootSignatureDesc();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Pageable_Wrapper::ID3D12Pageable_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DeviceChild_Wrapper(riid, object, resources, destructor)
{
}

ID3D12Heap_Wrapper::ID3D12Heap_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Pageable_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12HeapInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12Heap_Wrapper::~ID3D12Heap_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12Heap>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12Heap_Wrapper* ID3D12Heap_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12Heap_Wrapper>(object, object_map_, object_map_lock_);
}

D3D12_HEAP_DESC STDMETHODCALLTYPE ID3D12Heap_Wrapper::GetDesc()
{
    D3D12_HEAP_DESC result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Heap_GetDesc>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12Heap>()->GetDesc();

        Encode_ID3D12Heap_GetDesc(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Heap_GetDesc>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Heap>()->GetDesc();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Resource_Wrapper::ID3D12Resource_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Pageable_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12ResourceInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12Resource_Wrapper::~ID3D12Resource_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12Resource>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12Resource_Wrapper* ID3D12Resource_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12Resource_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12Resource_Wrapper::Map(
    UINT Subresource,
    const D3D12_RANGE* pReadRange,
    void** ppData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Resource_Map>::Dispatch(
            manager,
            this,
            Subresource,
            pReadRange,
            ppData);

        result = GetWrappedObjectAs<ID3D12Resource>()->Map(
            Subresource,
            pReadRange,
            ppData);

        Encode_ID3D12Resource_Map(
            this,
            result,
            Subresource,
            pReadRange,
            ppData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Resource_Map>::Dispatch(
            manager,
            this,
            result,
            Subresource,
            pReadRange,
            ppData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Resource>()->Map(
            Subresource,
            pReadRange,
            ppData);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12Resource_Wrapper::Unmap(
    UINT Subresource,
    const D3D12_RANGE* pWrittenRange)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Resource_Unmap>::Dispatch(
            manager,
            this,
            Subresource,
            pWrittenRange);

        GetWrappedObjectAs<ID3D12Resource>()->Unmap(
            Subresource,
            pWrittenRange);

        Encode_ID3D12Resource_Unmap(
            this,
            Subresource,
            pWrittenRange);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Resource_Unmap>::Dispatch(
            manager,
            this,
            Subresource,
            pWrittenRange);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Resource>()->Unmap(
            Subresource,
            pWrittenRange);
    }

    manager->DecrementCallScope();
}

D3D12_RESOURCE_DESC STDMETHODCALLTYPE ID3D12Resource_Wrapper::GetDesc()
{
    D3D12_RESOURCE_DESC result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Resource_GetDesc>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12Resource>()->GetDesc();

        Encode_ID3D12Resource_GetDesc(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Resource_GetDesc>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Resource>()->GetDesc();
    }

    manager->DecrementCallScope();

    return result;
}

D3D12_GPU_VIRTUAL_ADDRESS STDMETHODCALLTYPE ID3D12Resource_Wrapper::GetGPUVirtualAddress()
{
    D3D12_GPU_VIRTUAL_ADDRESS result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Resource_GetGPUVirtualAddress>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12Resource>()->GetGPUVirtualAddress();

        Encode_ID3D12Resource_GetGPUVirtualAddress(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Resource_GetGPUVirtualAddress>::Dispatch(
            manager,
            this,
            result);

        RvAnnotationUtil::AddRvAnnotation(&result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Resource>()->GetGPUVirtualAddress();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Resource_Wrapper::WriteToSubresource(
    UINT DstSubresource,
    const D3D12_BOX* pDstBox,
    const void* pSrcData,
    UINT SrcRowPitch,
    UINT SrcDepthPitch)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Resource_WriteToSubresource>::Dispatch(
            manager,
            this,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);

        result = GetWrappedObjectAs<ID3D12Resource>()->WriteToSubresource(
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);

        Encode_ID3D12Resource_WriteToSubresource(
            this,
            result,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Resource_WriteToSubresource>::Dispatch(
            manager,
            this,
            result,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Resource>()->WriteToSubresource(
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Resource_Wrapper::ReadFromSubresource(
    void* pDstData,
    UINT DstRowPitch,
    UINT DstDepthPitch,
    UINT SrcSubresource,
    const D3D12_BOX* pSrcBox)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Resource_ReadFromSubresource>::Dispatch(
            manager,
            this,
            pDstData,
            DstRowPitch,
            DstDepthPitch,
            SrcSubresource,
            pSrcBox);

        result = GetWrappedObjectAs<ID3D12Resource>()->ReadFromSubresource(
            pDstData,
            DstRowPitch,
            DstDepthPitch,
            SrcSubresource,
            pSrcBox);

        Encode_ID3D12Resource_ReadFromSubresource(
            this,
            result,
            pDstData,
            DstRowPitch,
            DstDepthPitch,
            SrcSubresource,
            pSrcBox);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Resource_ReadFromSubresource>::Dispatch(
            manager,
            this,
            result,
            pDstData,
            DstRowPitch,
            DstDepthPitch,
            SrcSubresource,
            pSrcBox);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Resource>()->ReadFromSubresource(
            pDstData,
            DstRowPitch,
            DstDepthPitch,
            SrcSubresource,
            pSrcBox);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Resource_Wrapper::GetHeapProperties(
    D3D12_HEAP_PROPERTIES* pHeapProperties,
    D3D12_HEAP_FLAGS* pHeapFlags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Resource_GetHeapProperties>::Dispatch(
            manager,
            this,
            pHeapProperties,
            pHeapFlags);

        result = GetWrappedObjectAs<ID3D12Resource>()->GetHeapProperties(
            pHeapProperties,
            pHeapFlags);

        Encode_ID3D12Resource_GetHeapProperties(
            this,
            result,
            pHeapProperties,
            pHeapFlags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Resource_GetHeapProperties>::Dispatch(
            manager,
            this,
            result,
            pHeapProperties,
            pHeapFlags);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Resource>()->GetHeapProperties(
            pHeapProperties,
            pHeapFlags);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12CommandAllocator_Wrapper::ID3D12CommandAllocator_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Pageable_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12CommandAllocatorInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12CommandAllocator_Wrapper::~ID3D12CommandAllocator_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12CommandAllocator>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12CommandAllocator_Wrapper* ID3D12CommandAllocator_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12CommandAllocator_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12CommandAllocator_Wrapper::Reset()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12CommandAllocator_Reset>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12CommandAllocator>()->Reset();

        Encode_ID3D12CommandAllocator_Reset(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12CommandAllocator_Reset>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12CommandAllocator>()->Reset();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Fence_Wrapper::ID3D12Fence_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Pageable_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12FenceInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12Fence_Wrapper::~ID3D12Fence_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12Fence>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12Fence_Wrapper* ID3D12Fence_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12Fence_Wrapper>(object, object_map_, object_map_lock_);
}

UINT64 STDMETHODCALLTYPE ID3D12Fence_Wrapper::GetCompletedValue()
{
    UINT64 result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Fence_GetCompletedValue>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12Fence>()->GetCompletedValue();

        Encode_ID3D12Fence_GetCompletedValue(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Fence_GetCompletedValue>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Fence>()->GetCompletedValue();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Fence_Wrapper::SetEventOnCompletion(
    UINT64 Value,
    HANDLE hEvent)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Fence_SetEventOnCompletion>::Dispatch(
            manager,
            this,
            Value,
            hEvent);

        result = GetWrappedObjectAs<ID3D12Fence>()->SetEventOnCompletion(
            Value,
            hEvent);

        Encode_ID3D12Fence_SetEventOnCompletion(
            this,
            result,
            Value,
            hEvent);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Fence_SetEventOnCompletion>::Dispatch(
            manager,
            this,
            result,
            Value,
            hEvent);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Fence>()->SetEventOnCompletion(
            Value,
            hEvent);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Fence_Wrapper::Signal(
    UINT64 Value)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Fence_Signal>::Dispatch(
            manager,
            this,
            Value);

        result = GetWrappedObjectAs<ID3D12Fence>()->Signal(
            Value);

        Encode_ID3D12Fence_Signal(
            this,
            result,
            Value);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Fence_Signal>::Dispatch(
            manager,
            this,
            result,
            Value);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Fence>()->Signal(
            Value);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Fence1_Wrapper::ID3D12Fence1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Fence_Wrapper(riid, object, resources, destructor)
{
}

D3D12_FENCE_FLAGS STDMETHODCALLTYPE ID3D12Fence1_Wrapper::GetCreationFlags()
{
    D3D12_FENCE_FLAGS result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Fence1_GetCreationFlags>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12Fence1>()->GetCreationFlags();

        Encode_ID3D12Fence1_GetCreationFlags(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Fence1_GetCreationFlags>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Fence1>()->GetCreationFlags();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12PipelineState_Wrapper::ID3D12PipelineState_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Pageable_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12PipelineStateInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12PipelineState_Wrapper::~ID3D12PipelineState_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12PipelineState>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12PipelineState_Wrapper* ID3D12PipelineState_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12PipelineState_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12PipelineState_Wrapper::GetCachedBlob(
    ID3DBlob** ppBlob)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12PipelineState_GetCachedBlob>::Dispatch(
            manager,
            this,
            ppBlob);

        result = GetWrappedObjectAs<ID3D12PipelineState>()->GetCachedBlob(
            ppBlob);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D10Blob, reinterpret_cast<void**>(ppBlob), nullptr);
        }

        Encode_ID3D12PipelineState_GetCachedBlob(
            this,
            result,
            ppBlob);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12PipelineState_GetCachedBlob>::Dispatch(
            manager,
            this,
            result,
            ppBlob);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12PipelineState>()->GetCachedBlob(
            ppBlob);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DescriptorHeap_Wrapper::ID3D12DescriptorHeap_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Pageable_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12DescriptorHeapInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12DescriptorHeap_Wrapper::~ID3D12DescriptorHeap_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12DescriptorHeap>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12DescriptorHeap_Wrapper* ID3D12DescriptorHeap_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12DescriptorHeap_Wrapper>(object, object_map_, object_map_lock_);
}

D3D12_DESCRIPTOR_HEAP_DESC STDMETHODCALLTYPE ID3D12DescriptorHeap_Wrapper::GetDesc()
{
    D3D12_DESCRIPTOR_HEAP_DESC result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DescriptorHeap_GetDesc>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12DescriptorHeap>()->GetDesc();

        Encode_ID3D12DescriptorHeap_GetDesc(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DescriptorHeap_GetDesc>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DescriptorHeap>()->GetDesc();
    }

    manager->DecrementCallScope();

    return result;
}

D3D12_CPU_DESCRIPTOR_HANDLE STDMETHODCALLTYPE ID3D12DescriptorHeap_Wrapper::GetCPUDescriptorHandleForHeapStart()
{
    D3D12_CPU_DESCRIPTOR_HANDLE result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DescriptorHeap_GetCPUDescriptorHandleForHeapStart>::Dispatch(
            manager,
            this);

        result = D3D12CaptureManager::Get()->OverrideID3D12DescriptorHeap_GetCPUDescriptorHandleForHeapStart(
            this
);

        Encode_ID3D12DescriptorHeap_GetCPUDescriptorHandleForHeapStart(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DescriptorHeap_GetCPUDescriptorHandleForHeapStart>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DescriptorHeap>()->GetCPUDescriptorHandleForHeapStart();
    }

    manager->DecrementCallScope();

    return result;
}

D3D12_GPU_DESCRIPTOR_HANDLE STDMETHODCALLTYPE ID3D12DescriptorHeap_Wrapper::GetGPUDescriptorHandleForHeapStart()
{
    D3D12_GPU_DESCRIPTOR_HANDLE result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DescriptorHeap_GetGPUDescriptorHandleForHeapStart>::Dispatch(
            manager,
            this);

        result = D3D12CaptureManager::Get()->OverrideID3D12DescriptorHeap_GetGPUDescriptorHandleForHeapStart(
            this
);

        Encode_ID3D12DescriptorHeap_GetGPUDescriptorHandleForHeapStart(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DescriptorHeap_GetGPUDescriptorHandleForHeapStart>::Dispatch(
            manager,
            this,
            result);

        RvAnnotationUtil::AddRvAnnotation(&result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DescriptorHeap>()->GetGPUDescriptorHandleForHeapStart();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12QueryHeap_Wrapper::ID3D12QueryHeap_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Pageable_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12QueryHeapInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12QueryHeap_Wrapper::~ID3D12QueryHeap_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12QueryHeap>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12QueryHeap_Wrapper* ID3D12QueryHeap_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12QueryHeap_Wrapper>(object, object_map_, object_map_lock_);
}

ID3D12CommandSignature_Wrapper::ID3D12CommandSignature_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Pageable_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12CommandSignatureInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12CommandSignature_Wrapper::~ID3D12CommandSignature_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12CommandSignature>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12CommandSignature_Wrapper* ID3D12CommandSignature_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12CommandSignature_Wrapper>(object, object_map_, object_map_lock_);
}

ID3D12CommandList_Wrapper::ID3D12CommandList_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12CommandListInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12CommandList_Wrapper::~ID3D12CommandList_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12CommandList>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12CommandList_Wrapper* ID3D12CommandList_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12CommandList_Wrapper>(object, object_map_, object_map_lock_);
}

D3D12_COMMAND_LIST_TYPE STDMETHODCALLTYPE ID3D12CommandList_Wrapper::GetType()
{
    D3D12_COMMAND_LIST_TYPE result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12CommandList_GetType>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12CommandList>()->GetType();

        Encode_ID3D12CommandList_GetType(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12CommandList_GetType>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12CommandList>()->GetType();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12GraphicsCommandList_Wrapper::ID3D12GraphicsCommandList_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12CommandList_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::Close()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_Close>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12GraphicsCommandList>()->Close();

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_Close);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                HRESULT result_trim_draw_calls = wrapper->Close();
                if (result != result_trim_draw_calls)
                {
                    GFXRECON_LOG_WARNING("Splitting commandlists of ID3D12GraphicsCommandList::Close get different results: %s and %s",
                        decode::enumutil::GetResultValueString(result).c_str(),
                        decode::enumutil::GetResultValueString(result_trim_draw_calls).c_str());
                }
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_Close(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_Close>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12GraphicsCommandList>()->Close();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::Reset(
    ID3D12CommandAllocator* pAllocator,
    ID3D12PipelineState* pInitialState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_Reset>::Dispatch(
            manager,
            this,
            pAllocator,
            pInitialState);

        result = D3D12CaptureManager::Get()->OverrideID3D12GraphicsCommandList_Reset(
            this,
            pAllocator,
            pInitialState);

        Encode_ID3D12GraphicsCommandList_Reset(
            this,
            result,
            pAllocator,
            pInitialState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_Reset>::Dispatch(
            manager,
            this,
            result,
            pAllocator,
            pInitialState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12GraphicsCommandList>()->Reset(
            pAllocator,
            pInitialState);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::ClearState(
    ID3D12PipelineState* pPipelineState)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ClearState>::Dispatch(
            manager,
            this,
            pPipelineState);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ClearState(
            encode::GetWrappedObject<ID3D12PipelineState>(pPipelineState));

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_ClearState);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->ClearState(
                    pPipelineState);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_ClearState(
            this,
            pPipelineState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ClearState>::Dispatch(
            manager,
            this,
            pPipelineState);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ClearState(
            pPipelineState);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::DrawInstanced(
    UINT VertexCountPerInstance,
    UINT InstanceCount,
    UINT StartVertexLocation,
    UINT StartInstanceLocation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_DrawInstanced>::Dispatch(
            manager,
            this,
            VertexCountPerInstance,
            InstanceCount,
            StartVertexLocation,
            StartInstanceLocation);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->DrawInstanced(
            VertexCountPerInstance,
            InstanceCount,
            StartVertexLocation,
            StartInstanceLocation);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_DrawInstanced);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->DrawInstanced(
                    VertexCountPerInstance,
                    InstanceCount,
                    StartVertexLocation,
                    StartInstanceLocation);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_DrawInstanced(
            this,
            VertexCountPerInstance,
            InstanceCount,
            StartVertexLocation,
            StartInstanceLocation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_DrawInstanced>::Dispatch(
            manager,
            this,
            VertexCountPerInstance,
            InstanceCount,
            StartVertexLocation,
            StartInstanceLocation);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->DrawInstanced(
            VertexCountPerInstance,
            InstanceCount,
            StartVertexLocation,
            StartInstanceLocation);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::DrawIndexedInstanced(
    UINT IndexCountPerInstance,
    UINT InstanceCount,
    UINT StartIndexLocation,
    INT BaseVertexLocation,
    UINT StartInstanceLocation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_DrawIndexedInstanced>::Dispatch(
            manager,
            this,
            IndexCountPerInstance,
            InstanceCount,
            StartIndexLocation,
            BaseVertexLocation,
            StartInstanceLocation);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->DrawIndexedInstanced(
            IndexCountPerInstance,
            InstanceCount,
            StartIndexLocation,
            BaseVertexLocation,
            StartInstanceLocation);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_DrawIndexedInstanced);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->DrawIndexedInstanced(
                    IndexCountPerInstance,
                    InstanceCount,
                    StartIndexLocation,
                    BaseVertexLocation,
                    StartInstanceLocation);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_DrawIndexedInstanced(
            this,
            IndexCountPerInstance,
            InstanceCount,
            StartIndexLocation,
            BaseVertexLocation,
            StartInstanceLocation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_DrawIndexedInstanced>::Dispatch(
            manager,
            this,
            IndexCountPerInstance,
            InstanceCount,
            StartIndexLocation,
            BaseVertexLocation,
            StartInstanceLocation);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->DrawIndexedInstanced(
            IndexCountPerInstance,
            InstanceCount,
            StartIndexLocation,
            BaseVertexLocation,
            StartInstanceLocation);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::Dispatch(
    UINT ThreadGroupCountX,
    UINT ThreadGroupCountY,
    UINT ThreadGroupCountZ)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_Dispatch>::Dispatch(
            manager,
            this,
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->Dispatch(
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_Dispatch);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->Dispatch(
                    ThreadGroupCountX,
                    ThreadGroupCountY,
                    ThreadGroupCountZ);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_Dispatch(
            this,
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_Dispatch>::Dispatch(
            manager,
            this,
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->Dispatch(
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::CopyBufferRegion(
    ID3D12Resource* pDstBuffer,
    UINT64 DstOffset,
    ID3D12Resource* pSrcBuffer,
    UINT64 SrcOffset,
    UINT64 NumBytes)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_CopyBufferRegion>::Dispatch(
            manager,
            this,
            pDstBuffer,
            DstOffset,
            pSrcBuffer,
            SrcOffset,
            NumBytes);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->CopyBufferRegion(
            encode::GetWrappedObject<ID3D12Resource>(pDstBuffer),
            DstOffset,
            encode::GetWrappedObject<ID3D12Resource>(pSrcBuffer),
            SrcOffset,
            NumBytes);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_CopyBufferRegion);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->CopyBufferRegion(
                    pDstBuffer,
                    DstOffset,
                    pSrcBuffer,
                    SrcOffset,
                    NumBytes);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_CopyBufferRegion(
            this,
            pDstBuffer,
            DstOffset,
            pSrcBuffer,
            SrcOffset,
            NumBytes);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_CopyBufferRegion>::Dispatch(
            manager,
            this,
            pDstBuffer,
            DstOffset,
            pSrcBuffer,
            SrcOffset,
            NumBytes);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->CopyBufferRegion(
            pDstBuffer,
            DstOffset,
            pSrcBuffer,
            SrcOffset,
            NumBytes);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::CopyTextureRegion(
    const D3D12_TEXTURE_COPY_LOCATION* pDst,
    UINT DstX,
    UINT DstY,
    UINT DstZ,
    const D3D12_TEXTURE_COPY_LOCATION* pSrc,
    const D3D12_BOX* pSrcBox)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_CopyTextureRegion>::Dispatch(
            manager,
            this,
            pDst,
            DstX,
            DstY,
            DstZ,
            pSrc,
            pSrcBox);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->CopyTextureRegion(
            UnwrapStructPtrObjects(pDst, unwrap_memory),
            DstX,
            DstY,
            DstZ,
            UnwrapStructPtrObjects(pSrc, unwrap_memory),
            pSrcBox);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_CopyTextureRegion);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->CopyTextureRegion(
                    pDst,
                    DstX,
                    DstY,
                    DstZ,
                    pSrc,
                    pSrcBox);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_CopyTextureRegion(
            this,
            pDst,
            DstX,
            DstY,
            DstZ,
            pSrc,
            pSrcBox);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_CopyTextureRegion>::Dispatch(
            manager,
            this,
            pDst,
            DstX,
            DstY,
            DstZ,
            pSrc,
            pSrcBox);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->CopyTextureRegion(
            pDst,
            DstX,
            DstY,
            DstZ,
            pSrc,
            pSrcBox);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::CopyResource(
    ID3D12Resource* pDstResource,
    ID3D12Resource* pSrcResource)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_CopyResource>::Dispatch(
            manager,
            this,
            pDstResource,
            pSrcResource);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->CopyResource(
            encode::GetWrappedObject<ID3D12Resource>(pDstResource),
            encode::GetWrappedObject<ID3D12Resource>(pSrcResource));

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_CopyResource);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->CopyResource(
                    pDstResource,
                    pSrcResource);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_CopyResource(
            this,
            pDstResource,
            pSrcResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_CopyResource>::Dispatch(
            manager,
            this,
            pDstResource,
            pSrcResource);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->CopyResource(
            pDstResource,
            pSrcResource);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::CopyTiles(
    ID3D12Resource* pTiledResource,
    const D3D12_TILED_RESOURCE_COORDINATE* pTileRegionStartCoordinate,
    const D3D12_TILE_REGION_SIZE* pTileRegionSize,
    ID3D12Resource* pBuffer,
    UINT64 BufferStartOffsetInBytes,
    D3D12_TILE_COPY_FLAGS Flags)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_CopyTiles>::Dispatch(
            manager,
            this,
            pTiledResource,
            pTileRegionStartCoordinate,
            pTileRegionSize,
            pBuffer,
            BufferStartOffsetInBytes,
            Flags);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->CopyTiles(
            encode::GetWrappedObject<ID3D12Resource>(pTiledResource),
            pTileRegionStartCoordinate,
            pTileRegionSize,
            encode::GetWrappedObject<ID3D12Resource>(pBuffer),
            BufferStartOffsetInBytes,
            Flags);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_CopyTiles);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->CopyTiles(
                    pTiledResource,
                    pTileRegionStartCoordinate,
                    pTileRegionSize,
                    pBuffer,
                    BufferStartOffsetInBytes,
                    Flags);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_CopyTiles(
            this,
            pTiledResource,
            pTileRegionStartCoordinate,
            pTileRegionSize,
            pBuffer,
            BufferStartOffsetInBytes,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_CopyTiles>::Dispatch(
            manager,
            this,
            pTiledResource,
            pTileRegionStartCoordinate,
            pTileRegionSize,
            pBuffer,
            BufferStartOffsetInBytes,
            Flags);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->CopyTiles(
            pTiledResource,
            pTileRegionStartCoordinate,
            pTileRegionSize,
            pBuffer,
            BufferStartOffsetInBytes,
            Flags);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::ResolveSubresource(
    ID3D12Resource* pDstResource,
    UINT DstSubresource,
    ID3D12Resource* pSrcResource,
    UINT SrcSubresource,
    DXGI_FORMAT Format)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ResolveSubresource>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            pSrcResource,
            SrcSubresource,
            Format);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ResolveSubresource(
            encode::GetWrappedObject<ID3D12Resource>(pDstResource),
            DstSubresource,
            encode::GetWrappedObject<ID3D12Resource>(pSrcResource),
            SrcSubresource,
            Format);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_ResolveSubresource);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->ResolveSubresource(
                    pDstResource,
                    DstSubresource,
                    pSrcResource,
                    SrcSubresource,
                    Format);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_ResolveSubresource(
            this,
            pDstResource,
            DstSubresource,
            pSrcResource,
            SrcSubresource,
            Format);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ResolveSubresource>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            pSrcResource,
            SrcSubresource,
            Format);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ResolveSubresource(
            pDstResource,
            DstSubresource,
            pSrcResource,
            SrcSubresource,
            Format);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::IASetPrimitiveTopology(
    D3D12_PRIMITIVE_TOPOLOGY PrimitiveTopology)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_IASetPrimitiveTopology>::Dispatch(
            manager,
            this,
            PrimitiveTopology);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->IASetPrimitiveTopology(
            PrimitiveTopology);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_IASetPrimitiveTopology);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->IASetPrimitiveTopology(
                    PrimitiveTopology);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_IASetPrimitiveTopology(
            this,
            PrimitiveTopology);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_IASetPrimitiveTopology>::Dispatch(
            manager,
            this,
            PrimitiveTopology);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->IASetPrimitiveTopology(
            PrimitiveTopology);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::RSSetViewports(
    UINT NumViewports,
    const D3D12_VIEWPORT* pViewports)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_RSSetViewports>::Dispatch(
            manager,
            this,
            NumViewports,
            pViewports);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->RSSetViewports(
            NumViewports,
            pViewports);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_RSSetViewports);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->RSSetViewports(
                    NumViewports,
                    pViewports);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_RSSetViewports(
            this,
            NumViewports,
            pViewports);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_RSSetViewports>::Dispatch(
            manager,
            this,
            NumViewports,
            pViewports);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->RSSetViewports(
            NumViewports,
            pViewports);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::RSSetScissorRects(
    UINT NumRects,
    const D3D12_RECT* pRects)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_RSSetScissorRects>::Dispatch(
            manager,
            this,
            NumRects,
            pRects);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->RSSetScissorRects(
            NumRects,
            pRects);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_RSSetScissorRects);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->RSSetScissorRects(
                    NumRects,
                    pRects);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_RSSetScissorRects(
            this,
            NumRects,
            pRects);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_RSSetScissorRects>::Dispatch(
            manager,
            this,
            NumRects,
            pRects);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->RSSetScissorRects(
            NumRects,
            pRects);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::OMSetBlendFactor(
    const FLOAT BlendFactor [4])
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_OMSetBlendFactor>::Dispatch(
            manager,
            this,
            BlendFactor);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->OMSetBlendFactor(
            BlendFactor);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_OMSetBlendFactor);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->OMSetBlendFactor(
                    BlendFactor);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_OMSetBlendFactor(
            this,
            BlendFactor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_OMSetBlendFactor>::Dispatch(
            manager,
            this,
            BlendFactor);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->OMSetBlendFactor(
            BlendFactor);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::OMSetStencilRef(
    UINT StencilRef)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_OMSetStencilRef>::Dispatch(
            manager,
            this,
            StencilRef);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->OMSetStencilRef(
            StencilRef);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_OMSetStencilRef);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->OMSetStencilRef(
                    StencilRef);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_OMSetStencilRef(
            this,
            StencilRef);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_OMSetStencilRef>::Dispatch(
            manager,
            this,
            StencilRef);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->OMSetStencilRef(
            StencilRef);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetPipelineState(
    ID3D12PipelineState* pPipelineState)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetPipelineState>::Dispatch(
            manager,
            this,
            pPipelineState);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetPipelineState(
            encode::GetWrappedObject<ID3D12PipelineState>(pPipelineState));

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetPipelineState);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetPipelineState(
                    pPipelineState);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetPipelineState(
            this,
            pPipelineState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetPipelineState>::Dispatch(
            manager,
            this,
            pPipelineState);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetPipelineState(
            pPipelineState);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::ResourceBarrier(
    UINT NumBarriers,
    const D3D12_RESOURCE_BARRIER* pBarriers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ResourceBarrier>::Dispatch(
            manager,
            this,
            NumBarriers,
            pBarriers);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ResourceBarrier(
            NumBarriers,
            UnwrapStructArrayObjects(pBarriers, NumBarriers, unwrap_memory));

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_ResourceBarrier);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->ResourceBarrier(
                    NumBarriers,
                    pBarriers);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_ResourceBarrier(
            this,
            NumBarriers,
            pBarriers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ResourceBarrier>::Dispatch(
            manager,
            this,
            NumBarriers,
            pBarriers);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ResourceBarrier(
            NumBarriers,
            pBarriers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::ExecuteBundle(
    ID3D12GraphicsCommandList* pCommandList)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ExecuteBundle>::Dispatch(
            manager,
            this,
            pCommandList);

        D3D12CaptureManager::Get()->OverrideID3D12GraphicsCommandList_ExecuteBundle(
            this,
            pCommandList);

        Encode_ID3D12GraphicsCommandList_ExecuteBundle(
            this,
            pCommandList);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ExecuteBundle>::Dispatch(
            manager,
            this,
            pCommandList);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ExecuteBundle(
            pCommandList);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetDescriptorHeaps(
    UINT NumDescriptorHeaps,
    ID3D12DescriptorHeap* const* ppDescriptorHeaps)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetDescriptorHeaps>::Dispatch(
            manager,
            this,
            NumDescriptorHeaps,
            ppDescriptorHeaps);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetDescriptorHeaps(
            NumDescriptorHeaps,
            UnwrapObjects<ID3D12DescriptorHeap>(ppDescriptorHeaps, NumDescriptorHeaps, unwrap_memory));

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetDescriptorHeaps);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetDescriptorHeaps(
                    NumDescriptorHeaps,
                    ppDescriptorHeaps);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetDescriptorHeaps(
            this,
            NumDescriptorHeaps,
            ppDescriptorHeaps);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetDescriptorHeaps>::Dispatch(
            manager,
            this,
            NumDescriptorHeaps,
            ppDescriptorHeaps);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetDescriptorHeaps(
            NumDescriptorHeaps,
            ppDescriptorHeaps);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetComputeRootSignature(
    ID3D12RootSignature* pRootSignature)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetComputeRootSignature>::Dispatch(
            manager,
            this,
            pRootSignature);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetComputeRootSignature(
            encode::GetWrappedObject<ID3D12RootSignature>(pRootSignature));

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetComputeRootSignature);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetComputeRootSignature(
                    pRootSignature);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetComputeRootSignature(
            this,
            pRootSignature);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetComputeRootSignature>::Dispatch(
            manager,
            this,
            pRootSignature);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetComputeRootSignature(
            pRootSignature);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetGraphicsRootSignature(
    ID3D12RootSignature* pRootSignature)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootSignature>::Dispatch(
            manager,
            this,
            pRootSignature);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetGraphicsRootSignature(
            encode::GetWrappedObject<ID3D12RootSignature>(pRootSignature));

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootSignature);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetGraphicsRootSignature(
                    pRootSignature);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetGraphicsRootSignature(
            this,
            pRootSignature);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootSignature>::Dispatch(
            manager,
            this,
            pRootSignature);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetGraphicsRootSignature(
            pRootSignature);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetComputeRootDescriptorTable(
    UINT RootParameterIndex,
    D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        RvAnnotationUtil::RemoveRvAnnotation(BaseDescriptor);

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetComputeRootDescriptorTable>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BaseDescriptor);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetComputeRootDescriptorTable(
            RootParameterIndex,
            BaseDescriptor);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetComputeRootDescriptorTable);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetComputeRootDescriptorTable(
                    RootParameterIndex,
                    BaseDescriptor);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetComputeRootDescriptorTable(
            this,
            RootParameterIndex,
            BaseDescriptor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetComputeRootDescriptorTable>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BaseDescriptor);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetComputeRootDescriptorTable(
            RootParameterIndex,
            BaseDescriptor);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetGraphicsRootDescriptorTable(
    UINT RootParameterIndex,
    D3D12_GPU_DESCRIPTOR_HANDLE BaseDescriptor)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        RvAnnotationUtil::RemoveRvAnnotation(BaseDescriptor);

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootDescriptorTable>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BaseDescriptor);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetGraphicsRootDescriptorTable(
            RootParameterIndex,
            BaseDescriptor);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootDescriptorTable);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetGraphicsRootDescriptorTable(
                    RootParameterIndex,
                    BaseDescriptor);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetGraphicsRootDescriptorTable(
            this,
            RootParameterIndex,
            BaseDescriptor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootDescriptorTable>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BaseDescriptor);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetGraphicsRootDescriptorTable(
            RootParameterIndex,
            BaseDescriptor);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetComputeRoot32BitConstant(
    UINT RootParameterIndex,
    UINT SrcData,
    UINT DestOffsetIn32BitValues)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetComputeRoot32BitConstant>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            SrcData,
            DestOffsetIn32BitValues);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetComputeRoot32BitConstant(
            RootParameterIndex,
            SrcData,
            DestOffsetIn32BitValues);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetComputeRoot32BitConstant);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetComputeRoot32BitConstant(
                    RootParameterIndex,
                    SrcData,
                    DestOffsetIn32BitValues);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetComputeRoot32BitConstant(
            this,
            RootParameterIndex,
            SrcData,
            DestOffsetIn32BitValues);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetComputeRoot32BitConstant>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            SrcData,
            DestOffsetIn32BitValues);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetComputeRoot32BitConstant(
            RootParameterIndex,
            SrcData,
            DestOffsetIn32BitValues);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetGraphicsRoot32BitConstant(
    UINT RootParameterIndex,
    UINT SrcData,
    UINT DestOffsetIn32BitValues)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstant>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            SrcData,
            DestOffsetIn32BitValues);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetGraphicsRoot32BitConstant(
            RootParameterIndex,
            SrcData,
            DestOffsetIn32BitValues);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstant);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetGraphicsRoot32BitConstant(
                    RootParameterIndex,
                    SrcData,
                    DestOffsetIn32BitValues);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstant(
            this,
            RootParameterIndex,
            SrcData,
            DestOffsetIn32BitValues);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstant>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            SrcData,
            DestOffsetIn32BitValues);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetGraphicsRoot32BitConstant(
            RootParameterIndex,
            SrcData,
            DestOffsetIn32BitValues);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetComputeRoot32BitConstants(
    UINT RootParameterIndex,
    UINT Num32BitValuesToSet,
    const void* pSrcData,
    UINT DestOffsetIn32BitValues)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetComputeRoot32BitConstants>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            Num32BitValuesToSet,
            pSrcData,
            DestOffsetIn32BitValues);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetComputeRoot32BitConstants(
            RootParameterIndex,
            Num32BitValuesToSet,
            pSrcData,
            DestOffsetIn32BitValues);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetComputeRoot32BitConstants);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetComputeRoot32BitConstants(
                    RootParameterIndex,
                    Num32BitValuesToSet,
                    pSrcData,
                    DestOffsetIn32BitValues);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetComputeRoot32BitConstants(
            this,
            RootParameterIndex,
            Num32BitValuesToSet,
            pSrcData,
            DestOffsetIn32BitValues);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetComputeRoot32BitConstants>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            Num32BitValuesToSet,
            pSrcData,
            DestOffsetIn32BitValues);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetComputeRoot32BitConstants(
            RootParameterIndex,
            Num32BitValuesToSet,
            pSrcData,
            DestOffsetIn32BitValues);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetGraphicsRoot32BitConstants(
    UINT RootParameterIndex,
    UINT Num32BitValuesToSet,
    const void* pSrcData,
    UINT DestOffsetIn32BitValues)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstants>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            Num32BitValuesToSet,
            pSrcData,
            DestOffsetIn32BitValues);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetGraphicsRoot32BitConstants(
            RootParameterIndex,
            Num32BitValuesToSet,
            pSrcData,
            DestOffsetIn32BitValues);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstants);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetGraphicsRoot32BitConstants(
                    RootParameterIndex,
                    Num32BitValuesToSet,
                    pSrcData,
                    DestOffsetIn32BitValues);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstants(
            this,
            RootParameterIndex,
            Num32BitValuesToSet,
            pSrcData,
            DestOffsetIn32BitValues);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRoot32BitConstants>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            Num32BitValuesToSet,
            pSrcData,
            DestOffsetIn32BitValues);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetGraphicsRoot32BitConstants(
            RootParameterIndex,
            Num32BitValuesToSet,
            pSrcData,
            DestOffsetIn32BitValues);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetComputeRootConstantBufferView(
    UINT RootParameterIndex,
    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        RvAnnotationUtil::RemoveRvAnnotation(BufferLocation);

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetComputeRootConstantBufferView>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BufferLocation);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetComputeRootConstantBufferView(
            RootParameterIndex,
            BufferLocation);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetComputeRootConstantBufferView);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetComputeRootConstantBufferView(
                    RootParameterIndex,
                    BufferLocation);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetComputeRootConstantBufferView(
            this,
            RootParameterIndex,
            BufferLocation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetComputeRootConstantBufferView>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BufferLocation);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetComputeRootConstantBufferView(
            RootParameterIndex,
            BufferLocation);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetGraphicsRootConstantBufferView(
    UINT RootParameterIndex,
    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        RvAnnotationUtil::RemoveRvAnnotation(BufferLocation);

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootConstantBufferView>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BufferLocation);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetGraphicsRootConstantBufferView(
            RootParameterIndex,
            BufferLocation);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootConstantBufferView);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetGraphicsRootConstantBufferView(
                    RootParameterIndex,
                    BufferLocation);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetGraphicsRootConstantBufferView(
            this,
            RootParameterIndex,
            BufferLocation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootConstantBufferView>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BufferLocation);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetGraphicsRootConstantBufferView(
            RootParameterIndex,
            BufferLocation);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetComputeRootShaderResourceView(
    UINT RootParameterIndex,
    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        RvAnnotationUtil::RemoveRvAnnotation(BufferLocation);

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetComputeRootShaderResourceView>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BufferLocation);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetComputeRootShaderResourceView(
            RootParameterIndex,
            BufferLocation);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetComputeRootShaderResourceView);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetComputeRootShaderResourceView(
                    RootParameterIndex,
                    BufferLocation);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetComputeRootShaderResourceView(
            this,
            RootParameterIndex,
            BufferLocation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetComputeRootShaderResourceView>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BufferLocation);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetComputeRootShaderResourceView(
            RootParameterIndex,
            BufferLocation);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetGraphicsRootShaderResourceView(
    UINT RootParameterIndex,
    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        RvAnnotationUtil::RemoveRvAnnotation(BufferLocation);

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootShaderResourceView>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BufferLocation);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetGraphicsRootShaderResourceView(
            RootParameterIndex,
            BufferLocation);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootShaderResourceView);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetGraphicsRootShaderResourceView(
                    RootParameterIndex,
                    BufferLocation);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetGraphicsRootShaderResourceView(
            this,
            RootParameterIndex,
            BufferLocation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootShaderResourceView>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BufferLocation);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetGraphicsRootShaderResourceView(
            RootParameterIndex,
            BufferLocation);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetComputeRootUnorderedAccessView(
    UINT RootParameterIndex,
    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        RvAnnotationUtil::RemoveRvAnnotation(BufferLocation);

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetComputeRootUnorderedAccessView>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BufferLocation);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetComputeRootUnorderedAccessView(
            RootParameterIndex,
            BufferLocation);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetComputeRootUnorderedAccessView);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetComputeRootUnorderedAccessView(
                    RootParameterIndex,
                    BufferLocation);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetComputeRootUnorderedAccessView(
            this,
            RootParameterIndex,
            BufferLocation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetComputeRootUnorderedAccessView>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BufferLocation);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetComputeRootUnorderedAccessView(
            RootParameterIndex,
            BufferLocation);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetGraphicsRootUnorderedAccessView(
    UINT RootParameterIndex,
    D3D12_GPU_VIRTUAL_ADDRESS BufferLocation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        RvAnnotationUtil::RemoveRvAnnotation(BufferLocation);

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootUnorderedAccessView>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BufferLocation);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetGraphicsRootUnorderedAccessView(
            RootParameterIndex,
            BufferLocation);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootUnorderedAccessView);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetGraphicsRootUnorderedAccessView(
                    RootParameterIndex,
                    BufferLocation);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetGraphicsRootUnorderedAccessView(
            this,
            RootParameterIndex,
            BufferLocation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetGraphicsRootUnorderedAccessView>::Dispatch(
            manager,
            this,
            RootParameterIndex,
            BufferLocation);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetGraphicsRootUnorderedAccessView(
            RootParameterIndex,
            BufferLocation);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::IASetIndexBuffer(
    const D3D12_INDEX_BUFFER_VIEW* pView)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        std::unique_ptr<D3D12_INDEX_BUFFER_VIEW> pView_unannotated = nullptr;
        if((manager->IsAnnotated() == true) && (pView != nullptr))
        {
            pView_unannotated = RvAnnotationUtil::RemoveStructRvAnnotations(pView);
            pView = pView_unannotated.get();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_IASetIndexBuffer>::Dispatch(
            manager,
            this,
            pView);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->IASetIndexBuffer(
            pView);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_IASetIndexBuffer);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->IASetIndexBuffer(
                    pView);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_IASetIndexBuffer(
            this,
            pView);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_IASetIndexBuffer>::Dispatch(
            manager,
            this,
            pView);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->IASetIndexBuffer(
            pView);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::IASetVertexBuffers(
    UINT StartSlot,
    UINT NumViews,
    const D3D12_VERTEX_BUFFER_VIEW* pViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        std::unique_ptr<D3D12_VERTEX_BUFFER_VIEW[]> pViews_unannotated = nullptr;
        if((manager->IsAnnotated() == true) && (NumViews != 0) && (pViews != nullptr))
        {
            pViews_unannotated = RvAnnotationUtil::RemoveStructArrayRvAnnotations(pViews, NumViews);
            pViews = pViews_unannotated.get();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_IASetVertexBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            pViews);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->IASetVertexBuffers(
            StartSlot,
            NumViews,
            pViews);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_IASetVertexBuffers);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->IASetVertexBuffers(
                    StartSlot,
                    NumViews,
                    pViews);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_IASetVertexBuffers(
            this,
            StartSlot,
            NumViews,
            pViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_IASetVertexBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            pViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->IASetVertexBuffers(
            StartSlot,
            NumViews,
            pViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SOSetTargets(
    UINT StartSlot,
    UINT NumViews,
    const D3D12_STREAM_OUTPUT_BUFFER_VIEW* pViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        std::unique_ptr<D3D12_STREAM_OUTPUT_BUFFER_VIEW[]> pViews_unannotated = nullptr;
        if((manager->IsAnnotated() == true) && (NumViews != 0) && (pViews != nullptr))
        {
            pViews_unannotated = RvAnnotationUtil::RemoveStructArrayRvAnnotations(pViews, NumViews);
            pViews = pViews_unannotated.get();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SOSetTargets>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            pViews);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SOSetTargets(
            StartSlot,
            NumViews,
            pViews);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SOSetTargets);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SOSetTargets(
                    StartSlot,
                    NumViews,
                    pViews);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SOSetTargets(
            this,
            StartSlot,
            NumViews,
            pViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SOSetTargets>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            pViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SOSetTargets(
            StartSlot,
            NumViews,
            pViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::OMSetRenderTargets(
    UINT NumRenderTargetDescriptors,
    const D3D12_CPU_DESCRIPTOR_HANDLE* pRenderTargetDescriptors,
    BOOL RTsSingleHandleToDescriptorRange,
    const D3D12_CPU_DESCRIPTOR_HANDLE* pDepthStencilDescriptor)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_OMSetRenderTargets>::Dispatch(
            manager,
            this,
            NumRenderTargetDescriptors,
            pRenderTargetDescriptors,
            RTsSingleHandleToDescriptorRange,
            pDepthStencilDescriptor);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->OMSetRenderTargets(
            NumRenderTargetDescriptors,
            UnwrapStructArrayObjects(pRenderTargetDescriptors, (NumRenderTargetDescriptors ? (RTsSingleHandleToDescriptorRange ? 1 : NumRenderTargetDescriptors) : 0), unwrap_memory),
            RTsSingleHandleToDescriptorRange,
            UnwrapStructPtrObjects(pDepthStencilDescriptor, unwrap_memory));

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_OMSetRenderTargets);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->OMSetRenderTargets(
                    NumRenderTargetDescriptors,
                    pRenderTargetDescriptors,
                    RTsSingleHandleToDescriptorRange,
                    pDepthStencilDescriptor);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_OMSetRenderTargets(
            this,
            NumRenderTargetDescriptors,
            pRenderTargetDescriptors,
            RTsSingleHandleToDescriptorRange,
            pDepthStencilDescriptor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_OMSetRenderTargets>::Dispatch(
            manager,
            this,
            NumRenderTargetDescriptors,
            pRenderTargetDescriptors,
            RTsSingleHandleToDescriptorRange,
            pDepthStencilDescriptor);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->OMSetRenderTargets(
            NumRenderTargetDescriptors,
            pRenderTargetDescriptors,
            RTsSingleHandleToDescriptorRange,
            pDepthStencilDescriptor);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::ClearDepthStencilView(
    D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilView,
    D3D12_CLEAR_FLAGS ClearFlags,
    FLOAT Depth,
    UINT8 Stencil,
    UINT NumRects,
    const D3D12_RECT* pRects)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ClearDepthStencilView>::Dispatch(
            manager,
            this,
            DepthStencilView,
            ClearFlags,
            Depth,
            Stencil,
            NumRects,
            pRects);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ClearDepthStencilView(
            *UnwrapStructPtrObjects(&DepthStencilView, unwrap_memory),
            ClearFlags,
            Depth,
            Stencil,
            NumRects,
            pRects);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_ClearDepthStencilView);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->ClearDepthStencilView(
                    DepthStencilView,
                    ClearFlags,
                    Depth,
                    Stencil,
                    NumRects,
                    pRects);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_ClearDepthStencilView(
            this,
            DepthStencilView,
            ClearFlags,
            Depth,
            Stencil,
            NumRects,
            pRects);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ClearDepthStencilView>::Dispatch(
            manager,
            this,
            DepthStencilView,
            ClearFlags,
            Depth,
            Stencil,
            NumRects,
            pRects);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ClearDepthStencilView(
            DepthStencilView,
            ClearFlags,
            Depth,
            Stencil,
            NumRects,
            pRects);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::ClearRenderTargetView(
    D3D12_CPU_DESCRIPTOR_HANDLE RenderTargetView,
    const FLOAT ColorRGBA [4],
    UINT NumRects,
    const D3D12_RECT* pRects)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ClearRenderTargetView>::Dispatch(
            manager,
            this,
            RenderTargetView,
            ColorRGBA,
            NumRects,
            pRects);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ClearRenderTargetView(
            *UnwrapStructPtrObjects(&RenderTargetView, unwrap_memory),
            ColorRGBA,
            NumRects,
            pRects);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_ClearRenderTargetView);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->ClearRenderTargetView(
                    RenderTargetView,
                    ColorRGBA,
                    NumRects,
                    pRects);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_ClearRenderTargetView(
            this,
            RenderTargetView,
            ColorRGBA,
            NumRects,
            pRects);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ClearRenderTargetView>::Dispatch(
            manager,
            this,
            RenderTargetView,
            ColorRGBA,
            NumRects,
            pRects);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ClearRenderTargetView(
            RenderTargetView,
            ColorRGBA,
            NumRects,
            pRects);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::ClearUnorderedAccessViewUint(
    D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
    D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
    ID3D12Resource* pResource,
    const UINT Values [4],
    UINT NumRects,
    const D3D12_RECT* pRects)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        RvAnnotationUtil::RemoveRvAnnotation(ViewGPUHandleInCurrentHeap);

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ClearUnorderedAccessViewUint>::Dispatch(
            manager,
            this,
            ViewGPUHandleInCurrentHeap,
            ViewCPUHandle,
            pResource,
            Values,
            NumRects,
            pRects);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ClearUnorderedAccessViewUint(
            ViewGPUHandleInCurrentHeap,
            *UnwrapStructPtrObjects(&ViewCPUHandle, unwrap_memory),
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            Values,
            NumRects,
            pRects);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_ClearUnorderedAccessViewUint);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->ClearUnorderedAccessViewUint(
                    ViewGPUHandleInCurrentHeap,
                    ViewCPUHandle,
                    pResource,
                    Values,
                    NumRects,
                    pRects);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_ClearUnorderedAccessViewUint(
            this,
            ViewGPUHandleInCurrentHeap,
            ViewCPUHandle,
            pResource,
            Values,
            NumRects,
            pRects);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ClearUnorderedAccessViewUint>::Dispatch(
            manager,
            this,
            ViewGPUHandleInCurrentHeap,
            ViewCPUHandle,
            pResource,
            Values,
            NumRects,
            pRects);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ClearUnorderedAccessViewUint(
            ViewGPUHandleInCurrentHeap,
            ViewCPUHandle,
            pResource,
            Values,
            NumRects,
            pRects);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::ClearUnorderedAccessViewFloat(
    D3D12_GPU_DESCRIPTOR_HANDLE ViewGPUHandleInCurrentHeap,
    D3D12_CPU_DESCRIPTOR_HANDLE ViewCPUHandle,
    ID3D12Resource* pResource,
    const FLOAT Values [4],
    UINT NumRects,
    const D3D12_RECT* pRects)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        RvAnnotationUtil::RemoveRvAnnotation(ViewGPUHandleInCurrentHeap);

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ClearUnorderedAccessViewFloat>::Dispatch(
            manager,
            this,
            ViewGPUHandleInCurrentHeap,
            ViewCPUHandle,
            pResource,
            Values,
            NumRects,
            pRects);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ClearUnorderedAccessViewFloat(
            ViewGPUHandleInCurrentHeap,
            *UnwrapStructPtrObjects(&ViewCPUHandle, unwrap_memory),
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            Values,
            NumRects,
            pRects);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_ClearUnorderedAccessViewFloat);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->ClearUnorderedAccessViewFloat(
                    ViewGPUHandleInCurrentHeap,
                    ViewCPUHandle,
                    pResource,
                    Values,
                    NumRects,
                    pRects);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_ClearUnorderedAccessViewFloat(
            this,
            ViewGPUHandleInCurrentHeap,
            ViewCPUHandle,
            pResource,
            Values,
            NumRects,
            pRects);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ClearUnorderedAccessViewFloat>::Dispatch(
            manager,
            this,
            ViewGPUHandleInCurrentHeap,
            ViewCPUHandle,
            pResource,
            Values,
            NumRects,
            pRects);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ClearUnorderedAccessViewFloat(
            ViewGPUHandleInCurrentHeap,
            ViewCPUHandle,
            pResource,
            Values,
            NumRects,
            pRects);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::DiscardResource(
    ID3D12Resource* pResource,
    const D3D12_DISCARD_REGION* pRegion)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_DiscardResource>::Dispatch(
            manager,
            this,
            pResource,
            pRegion);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->DiscardResource(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            pRegion);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_DiscardResource);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->DiscardResource(
                    pResource,
                    pRegion);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_DiscardResource(
            this,
            pResource,
            pRegion);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_DiscardResource>::Dispatch(
            manager,
            this,
            pResource,
            pRegion);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->DiscardResource(
            pResource,
            pRegion);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::BeginQuery(
    ID3D12QueryHeap* pQueryHeap,
    D3D12_QUERY_TYPE Type,
    UINT Index)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_BeginQuery>::Dispatch(
            manager,
            this,
            pQueryHeap,
            Type,
            Index);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->BeginQuery(
            encode::GetWrappedObject<ID3D12QueryHeap>(pQueryHeap),
            Type,
            Index);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_BeginQuery);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->BeginQuery(
                    pQueryHeap,
                    Type,
                    Index);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_BeginQuery(
            this,
            pQueryHeap,
            Type,
            Index);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_BeginQuery>::Dispatch(
            manager,
            this,
            pQueryHeap,
            Type,
            Index);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->BeginQuery(
            pQueryHeap,
            Type,
            Index);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::EndQuery(
    ID3D12QueryHeap* pQueryHeap,
    D3D12_QUERY_TYPE Type,
    UINT Index)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_EndQuery>::Dispatch(
            manager,
            this,
            pQueryHeap,
            Type,
            Index);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->EndQuery(
            encode::GetWrappedObject<ID3D12QueryHeap>(pQueryHeap),
            Type,
            Index);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_EndQuery);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->EndQuery(
                    pQueryHeap,
                    Type,
                    Index);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_EndQuery(
            this,
            pQueryHeap,
            Type,
            Index);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_EndQuery>::Dispatch(
            manager,
            this,
            pQueryHeap,
            Type,
            Index);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->EndQuery(
            pQueryHeap,
            Type,
            Index);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::ResolveQueryData(
    ID3D12QueryHeap* pQueryHeap,
    D3D12_QUERY_TYPE Type,
    UINT StartIndex,
    UINT NumQueries,
    ID3D12Resource* pDestinationBuffer,
    UINT64 AlignedDestinationBufferOffset)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ResolveQueryData>::Dispatch(
            manager,
            this,
            pQueryHeap,
            Type,
            StartIndex,
            NumQueries,
            pDestinationBuffer,
            AlignedDestinationBufferOffset);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ResolveQueryData(
            encode::GetWrappedObject<ID3D12QueryHeap>(pQueryHeap),
            Type,
            StartIndex,
            NumQueries,
            encode::GetWrappedObject<ID3D12Resource>(pDestinationBuffer),
            AlignedDestinationBufferOffset);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_ResolveQueryData);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->ResolveQueryData(
                    pQueryHeap,
                    Type,
                    StartIndex,
                    NumQueries,
                    pDestinationBuffer,
                    AlignedDestinationBufferOffset);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_ResolveQueryData(
            this,
            pQueryHeap,
            Type,
            StartIndex,
            NumQueries,
            pDestinationBuffer,
            AlignedDestinationBufferOffset);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ResolveQueryData>::Dispatch(
            manager,
            this,
            pQueryHeap,
            Type,
            StartIndex,
            NumQueries,
            pDestinationBuffer,
            AlignedDestinationBufferOffset);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ResolveQueryData(
            pQueryHeap,
            Type,
            StartIndex,
            NumQueries,
            pDestinationBuffer,
            AlignedDestinationBufferOffset);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetPredication(
    ID3D12Resource* pBuffer,
    UINT64 AlignedBufferOffset,
    D3D12_PREDICATION_OP Operation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetPredication>::Dispatch(
            manager,
            this,
            pBuffer,
            AlignedBufferOffset,
            Operation);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetPredication(
            encode::GetWrappedObject<ID3D12Resource>(pBuffer),
            AlignedBufferOffset,
            Operation);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetPredication);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetPredication(
                    pBuffer,
                    AlignedBufferOffset,
                    Operation);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetPredication(
            this,
            pBuffer,
            AlignedBufferOffset,
            Operation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetPredication>::Dispatch(
            manager,
            this,
            pBuffer,
            AlignedBufferOffset,
            Operation);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetPredication(
            pBuffer,
            AlignedBufferOffset,
            Operation);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::SetMarker(
    UINT Metadata,
    const void* pData,
    UINT Size)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetMarker>::Dispatch(
            manager,
            this,
            Metadata,
            pData,
            Size);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetMarker(
            Metadata,
            pData,
            Size);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_SetMarker);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->SetMarker(
                    Metadata,
                    pData,
                    Size);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_SetMarker(
            this,
            Metadata,
            pData,
            Size);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_SetMarker>::Dispatch(
            manager,
            this,
            Metadata,
            pData,
            Size);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->SetMarker(
            Metadata,
            pData,
            Size);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::BeginEvent(
    UINT Metadata,
    const void* pData,
    UINT Size)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_BeginEvent>::Dispatch(
            manager,
            this,
            Metadata,
            pData,
            Size);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->BeginEvent(
            Metadata,
            pData,
            Size);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_BeginEvent);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->BeginEvent(
                    Metadata,
                    pData,
                    Size);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_BeginEvent(
            this,
            Metadata,
            pData,
            Size);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_BeginEvent>::Dispatch(
            manager,
            this,
            Metadata,
            pData,
            Size);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->BeginEvent(
            Metadata,
            pData,
            Size);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::EndEvent()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_EndEvent>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->EndEvent();

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_EndEvent);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->EndEvent();
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_EndEvent(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_EndEvent>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->EndEvent();
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList_Wrapper::ExecuteIndirect(
    ID3D12CommandSignature* pCommandSignature,
    UINT MaxCommandCount,
    ID3D12Resource* pArgumentBuffer,
    UINT64 ArgumentBufferOffset,
    ID3D12Resource* pCountBuffer,
    UINT64 CountBufferOffset)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ExecuteIndirect>::Dispatch(
            manager,
            this,
            pCommandSignature,
            MaxCommandCount,
            pArgumentBuffer,
            ArgumentBufferOffset,
            pCountBuffer,
            CountBufferOffset);

        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ExecuteIndirect(
            encode::GetWrappedObject<ID3D12CommandSignature>(pCommandSignature),
            MaxCommandCount,
            encode::GetWrappedObject<ID3D12Resource>(pArgumentBuffer),
            ArgumentBufferOffset,
            encode::GetWrappedObject<ID3D12Resource>(pCountBuffer),
            CountBufferOffset);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList_ExecuteIndirect);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                wrapper->ExecuteIndirect(
                    pCommandSignature,
                    MaxCommandCount,
                    pArgumentBuffer,
                    ArgumentBufferOffset,
                    pCountBuffer,
                    CountBufferOffset);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList_ExecuteIndirect(
            this,
            pCommandSignature,
            MaxCommandCount,
            pArgumentBuffer,
            ArgumentBufferOffset,
            pCountBuffer,
            CountBufferOffset);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList_ExecuteIndirect>::Dispatch(
            manager,
            this,
            pCommandSignature,
            MaxCommandCount,
            pArgumentBuffer,
            ArgumentBufferOffset,
            pCountBuffer,
            CountBufferOffset);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList>()->ExecuteIndirect(
            pCommandSignature,
            MaxCommandCount,
            pArgumentBuffer,
            ArgumentBufferOffset,
            pCountBuffer,
            CountBufferOffset);
    }

    manager->DecrementCallScope();
}

ID3D12GraphicsCommandList1_Wrapper::ID3D12GraphicsCommandList1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12GraphicsCommandList_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList1_Wrapper::AtomicCopyBufferUINT(
    ID3D12Resource* pDstBuffer,
    UINT64 DstOffset,
    ID3D12Resource* pSrcBuffer,
    UINT64 SrcOffset,
    UINT Dependencies,
    ID3D12Resource* const* ppDependentResources,
    const D3D12_SUBRESOURCE_RANGE_UINT64* pDependentSubresourceRanges)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList1_AtomicCopyBufferUINT>::Dispatch(
            manager,
            this,
            pDstBuffer,
            DstOffset,
            pSrcBuffer,
            SrcOffset,
            Dependencies,
            ppDependentResources,
            pDependentSubresourceRanges);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12GraphicsCommandList1>()->AtomicCopyBufferUINT(
            encode::GetWrappedObject<ID3D12Resource>(pDstBuffer),
            DstOffset,
            encode::GetWrappedObject<ID3D12Resource>(pSrcBuffer),
            SrcOffset,
            Dependencies,
            UnwrapObjects<ID3D12Resource>(ppDependentResources, Dependencies, unwrap_memory),
            pDependentSubresourceRanges);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList1_AtomicCopyBufferUINT);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList1_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->AtomicCopyBufferUINT(
                    pDstBuffer,
                    DstOffset,
                    pSrcBuffer,
                    SrcOffset,
                    Dependencies,
                    ppDependentResources,
                    pDependentSubresourceRanges);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList1_AtomicCopyBufferUINT(
            this,
            pDstBuffer,
            DstOffset,
            pSrcBuffer,
            SrcOffset,
            Dependencies,
            ppDependentResources,
            pDependentSubresourceRanges);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList1_AtomicCopyBufferUINT>::Dispatch(
            manager,
            this,
            pDstBuffer,
            DstOffset,
            pSrcBuffer,
            SrcOffset,
            Dependencies,
            ppDependentResources,
            pDependentSubresourceRanges);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList1>()->AtomicCopyBufferUINT(
            pDstBuffer,
            DstOffset,
            pSrcBuffer,
            SrcOffset,
            Dependencies,
            ppDependentResources,
            pDependentSubresourceRanges);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList1_Wrapper::AtomicCopyBufferUINT64(
    ID3D12Resource* pDstBuffer,
    UINT64 DstOffset,
    ID3D12Resource* pSrcBuffer,
    UINT64 SrcOffset,
    UINT Dependencies,
    ID3D12Resource* const* ppDependentResources,
    const D3D12_SUBRESOURCE_RANGE_UINT64* pDependentSubresourceRanges)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList1_AtomicCopyBufferUINT64>::Dispatch(
            manager,
            this,
            pDstBuffer,
            DstOffset,
            pSrcBuffer,
            SrcOffset,
            Dependencies,
            ppDependentResources,
            pDependentSubresourceRanges);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12GraphicsCommandList1>()->AtomicCopyBufferUINT64(
            encode::GetWrappedObject<ID3D12Resource>(pDstBuffer),
            DstOffset,
            encode::GetWrappedObject<ID3D12Resource>(pSrcBuffer),
            SrcOffset,
            Dependencies,
            UnwrapObjects<ID3D12Resource>(ppDependentResources, Dependencies, unwrap_memory),
            pDependentSubresourceRanges);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList1_AtomicCopyBufferUINT64);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList1_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->AtomicCopyBufferUINT64(
                    pDstBuffer,
                    DstOffset,
                    pSrcBuffer,
                    SrcOffset,
                    Dependencies,
                    ppDependentResources,
                    pDependentSubresourceRanges);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList1_AtomicCopyBufferUINT64(
            this,
            pDstBuffer,
            DstOffset,
            pSrcBuffer,
            SrcOffset,
            Dependencies,
            ppDependentResources,
            pDependentSubresourceRanges);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList1_AtomicCopyBufferUINT64>::Dispatch(
            manager,
            this,
            pDstBuffer,
            DstOffset,
            pSrcBuffer,
            SrcOffset,
            Dependencies,
            ppDependentResources,
            pDependentSubresourceRanges);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList1>()->AtomicCopyBufferUINT64(
            pDstBuffer,
            DstOffset,
            pSrcBuffer,
            SrcOffset,
            Dependencies,
            ppDependentResources,
            pDependentSubresourceRanges);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList1_Wrapper::OMSetDepthBounds(
    FLOAT Min,
    FLOAT Max)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList1_OMSetDepthBounds>::Dispatch(
            manager,
            this,
            Min,
            Max);

        GetWrappedObjectAs<ID3D12GraphicsCommandList1>()->OMSetDepthBounds(
            Min,
            Max);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList1_OMSetDepthBounds);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList1_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->OMSetDepthBounds(
                    Min,
                    Max);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList1_OMSetDepthBounds(
            this,
            Min,
            Max);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList1_OMSetDepthBounds>::Dispatch(
            manager,
            this,
            Min,
            Max);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList1>()->OMSetDepthBounds(
            Min,
            Max);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList1_Wrapper::SetSamplePositions(
    UINT NumSamplesPerPixel,
    UINT NumPixels,
    D3D12_SAMPLE_POSITION* pSamplePositions)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList1_SetSamplePositions>::Dispatch(
            manager,
            this,
            NumSamplesPerPixel,
            NumPixels,
            pSamplePositions);

        GetWrappedObjectAs<ID3D12GraphicsCommandList1>()->SetSamplePositions(
            NumSamplesPerPixel,
            NumPixels,
            pSamplePositions);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList1_SetSamplePositions);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList1_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->SetSamplePositions(
                    NumSamplesPerPixel,
                    NumPixels,
                    pSamplePositions);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList1_SetSamplePositions(
            this,
            NumSamplesPerPixel,
            NumPixels,
            pSamplePositions);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList1_SetSamplePositions>::Dispatch(
            manager,
            this,
            NumSamplesPerPixel,
            NumPixels,
            pSamplePositions);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList1>()->SetSamplePositions(
            NumSamplesPerPixel,
            NumPixels,
            pSamplePositions);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList1_Wrapper::ResolveSubresourceRegion(
    ID3D12Resource* pDstResource,
    UINT DstSubresource,
    UINT DstX,
    UINT DstY,
    ID3D12Resource* pSrcResource,
    UINT SrcSubresource,
    D3D12_RECT* pSrcRect,
    DXGI_FORMAT Format,
    D3D12_RESOLVE_MODE ResolveMode)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList1_ResolveSubresourceRegion>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            DstX,
            DstY,
            pSrcResource,
            SrcSubresource,
            pSrcRect,
            Format,
            ResolveMode);

        GetWrappedObjectAs<ID3D12GraphicsCommandList1>()->ResolveSubresourceRegion(
            encode::GetWrappedObject<ID3D12Resource>(pDstResource),
            DstSubresource,
            DstX,
            DstY,
            encode::GetWrappedObject<ID3D12Resource>(pSrcResource),
            SrcSubresource,
            pSrcRect,
            Format,
            ResolveMode);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList1_ResolveSubresourceRegion);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList1_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->ResolveSubresourceRegion(
                    pDstResource,
                    DstSubresource,
                    DstX,
                    DstY,
                    pSrcResource,
                    SrcSubresource,
                    pSrcRect,
                    Format,
                    ResolveMode);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList1_ResolveSubresourceRegion(
            this,
            pDstResource,
            DstSubresource,
            DstX,
            DstY,
            pSrcResource,
            SrcSubresource,
            pSrcRect,
            Format,
            ResolveMode);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList1_ResolveSubresourceRegion>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            DstX,
            DstY,
            pSrcResource,
            SrcSubresource,
            pSrcRect,
            Format,
            ResolveMode);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList1>()->ResolveSubresourceRegion(
            pDstResource,
            DstSubresource,
            DstX,
            DstY,
            pSrcResource,
            SrcSubresource,
            pSrcRect,
            Format,
            ResolveMode);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList1_Wrapper::SetViewInstanceMask(
    UINT Mask)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList1_SetViewInstanceMask>::Dispatch(
            manager,
            this,
            Mask);

        GetWrappedObjectAs<ID3D12GraphicsCommandList1>()->SetViewInstanceMask(
            Mask);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList1_SetViewInstanceMask);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList1_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->SetViewInstanceMask(
                    Mask);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList1_SetViewInstanceMask(
            this,
            Mask);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList1_SetViewInstanceMask>::Dispatch(
            manager,
            this,
            Mask);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList1>()->SetViewInstanceMask(
            Mask);
    }

    manager->DecrementCallScope();
}

ID3D12GraphicsCommandList2_Wrapper::ID3D12GraphicsCommandList2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12GraphicsCommandList1_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList2_Wrapper::WriteBufferImmediate(
    UINT Count,
    const D3D12_WRITEBUFFERIMMEDIATE_PARAMETER* pParams,
    const D3D12_WRITEBUFFERIMMEDIATE_MODE* pModes)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        std::unique_ptr<D3D12_WRITEBUFFERIMMEDIATE_PARAMETER[]> pParams_unannotated = nullptr;
        if((manager->IsAnnotated() == true) && (Count != 0) && (pParams != nullptr))
        {
            pParams_unannotated = RvAnnotationUtil::RemoveStructArrayRvAnnotations(pParams, Count);
            pParams = pParams_unannotated.get();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList2_WriteBufferImmediate>::Dispatch(
            manager,
            this,
            Count,
            pParams,
            pModes);

        GetWrappedObjectAs<ID3D12GraphicsCommandList2>()->WriteBufferImmediate(
            Count,
            pParams,
            pModes);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList2_WriteBufferImmediate);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList2_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->WriteBufferImmediate(
                    Count,
                    pParams,
                    pModes);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList2_WriteBufferImmediate(
            this,
            Count,
            pParams,
            pModes);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList2_WriteBufferImmediate>::Dispatch(
            manager,
            this,
            Count,
            pParams,
            pModes);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList2>()->WriteBufferImmediate(
            Count,
            pParams,
            pModes);
    }

    manager->DecrementCallScope();
}

ID3D12CommandQueue_Wrapper::ID3D12CommandQueue_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Pageable_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12CommandQueueInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12CommandQueue_Wrapper::~ID3D12CommandQueue_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12CommandQueue>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12CommandQueue_Wrapper* ID3D12CommandQueue_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12CommandQueue_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D12CommandQueue_Wrapper::UpdateTileMappings(
    ID3D12Resource* pResource,
    UINT NumResourceRegions,
    const D3D12_TILED_RESOURCE_COORDINATE* pResourceRegionStartCoordinates,
    const D3D12_TILE_REGION_SIZE* pResourceRegionSizes,
    ID3D12Heap* pHeap,
    UINT NumRanges,
    const D3D12_TILE_RANGE_FLAGS* pRangeFlags,
    const UINT* pHeapRangeStartOffsets,
    const UINT* pRangeTileCounts,
    D3D12_TILE_MAPPING_FLAGS Flags)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_UpdateTileMappings>::Dispatch(
            manager,
            this,
            pResource,
            NumResourceRegions,
            pResourceRegionStartCoordinates,
            pResourceRegionSizes,
            pHeap,
            NumRanges,
            pRangeFlags,
            pHeapRangeStartOffsets,
            pRangeTileCounts,
            Flags);

        GetWrappedObjectAs<ID3D12CommandQueue>()->UpdateTileMappings(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            NumResourceRegions,
            pResourceRegionStartCoordinates,
            pResourceRegionSizes,
            encode::GetWrappedObject<ID3D12Heap>(pHeap),
            NumRanges,
            pRangeFlags,
            pHeapRangeStartOffsets,
            pRangeTileCounts,
            Flags);

        Encode_ID3D12CommandQueue_UpdateTileMappings(
            this,
            pResource,
            NumResourceRegions,
            pResourceRegionStartCoordinates,
            pResourceRegionSizes,
            pHeap,
            NumRanges,
            pRangeFlags,
            pHeapRangeStartOffsets,
            pRangeTileCounts,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_UpdateTileMappings>::Dispatch(
            manager,
            this,
            pResource,
            NumResourceRegions,
            pResourceRegionStartCoordinates,
            pResourceRegionSizes,
            pHeap,
            NumRanges,
            pRangeFlags,
            pHeapRangeStartOffsets,
            pRangeTileCounts,
            Flags);
    }
    else
    {
        GetWrappedObjectAs<ID3D12CommandQueue>()->UpdateTileMappings(
            pResource,
            NumResourceRegions,
            pResourceRegionStartCoordinates,
            pResourceRegionSizes,
            pHeap,
            NumRanges,
            pRangeFlags,
            pHeapRangeStartOffsets,
            pRangeTileCounts,
            Flags);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12CommandQueue_Wrapper::CopyTileMappings(
    ID3D12Resource* pDstResource,
    const D3D12_TILED_RESOURCE_COORDINATE* pDstRegionStartCoordinate,
    ID3D12Resource* pSrcResource,
    const D3D12_TILED_RESOURCE_COORDINATE* pSrcRegionStartCoordinate,
    const D3D12_TILE_REGION_SIZE* pRegionSize,
    D3D12_TILE_MAPPING_FLAGS Flags)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_CopyTileMappings>::Dispatch(
            manager,
            this,
            pDstResource,
            pDstRegionStartCoordinate,
            pSrcResource,
            pSrcRegionStartCoordinate,
            pRegionSize,
            Flags);

        GetWrappedObjectAs<ID3D12CommandQueue>()->CopyTileMappings(
            encode::GetWrappedObject<ID3D12Resource>(pDstResource),
            pDstRegionStartCoordinate,
            encode::GetWrappedObject<ID3D12Resource>(pSrcResource),
            pSrcRegionStartCoordinate,
            pRegionSize,
            Flags);

        Encode_ID3D12CommandQueue_CopyTileMappings(
            this,
            pDstResource,
            pDstRegionStartCoordinate,
            pSrcResource,
            pSrcRegionStartCoordinate,
            pRegionSize,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_CopyTileMappings>::Dispatch(
            manager,
            this,
            pDstResource,
            pDstRegionStartCoordinate,
            pSrcResource,
            pSrcRegionStartCoordinate,
            pRegionSize,
            Flags);
    }
    else
    {
        GetWrappedObjectAs<ID3D12CommandQueue>()->CopyTileMappings(
            pDstResource,
            pDstRegionStartCoordinate,
            pSrcResource,
            pSrcRegionStartCoordinate,
            pRegionSize,
            Flags);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12CommandQueue_Wrapper::ExecuteCommandLists(
    UINT NumCommandLists,
    ID3D12CommandList* const* ppCommandLists)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_ExecuteCommandLists>::Dispatch(
            manager,
            shared_api_call_lock,
            this,
            NumCommandLists,
            ppCommandLists);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        D3D12CaptureManager::Get()->OverrideID3D12CommandQueue_ExecuteCommandLists(
            shared_api_call_lock,
            this,
            NumCommandLists,
            ppCommandLists);

        Encode_ID3D12CommandQueue_ExecuteCommandLists(
            this,
            NumCommandLists,
            ppCommandLists);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_ExecuteCommandLists>::Dispatch(
            manager,
            shared_api_call_lock,
            this,
            NumCommandLists,
            ppCommandLists);
    }
    else
    {
        GetWrappedObjectAs<ID3D12CommandQueue>()->ExecuteCommandLists(
            NumCommandLists,
            ppCommandLists);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12CommandQueue_Wrapper::SetMarker(
    UINT Metadata,
    const void* pData,
    UINT Size)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_SetMarker>::Dispatch(
            manager,
            this,
            Metadata,
            pData,
            Size);

        GetWrappedObjectAs<ID3D12CommandQueue>()->SetMarker(
            Metadata,
            pData,
            Size);

        Encode_ID3D12CommandQueue_SetMarker(
            this,
            Metadata,
            pData,
            Size);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_SetMarker>::Dispatch(
            manager,
            this,
            Metadata,
            pData,
            Size);
    }
    else
    {
        GetWrappedObjectAs<ID3D12CommandQueue>()->SetMarker(
            Metadata,
            pData,
            Size);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12CommandQueue_Wrapper::BeginEvent(
    UINT Metadata,
    const void* pData,
    UINT Size)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_BeginEvent>::Dispatch(
            manager,
            this,
            Metadata,
            pData,
            Size);

        GetWrappedObjectAs<ID3D12CommandQueue>()->BeginEvent(
            Metadata,
            pData,
            Size);

        Encode_ID3D12CommandQueue_BeginEvent(
            this,
            Metadata,
            pData,
            Size);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_BeginEvent>::Dispatch(
            manager,
            this,
            Metadata,
            pData,
            Size);
    }
    else
    {
        GetWrappedObjectAs<ID3D12CommandQueue>()->BeginEvent(
            Metadata,
            pData,
            Size);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12CommandQueue_Wrapper::EndEvent()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_EndEvent>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12CommandQueue>()->EndEvent();

        Encode_ID3D12CommandQueue_EndEvent(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_EndEvent>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12CommandQueue>()->EndEvent();
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D12CommandQueue_Wrapper::Signal(
    ID3D12Fence* pFence,
    UINT64 Value)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_Signal>::Dispatch(
            manager,
            this,
            pFence,
            Value);

        result = GetWrappedObjectAs<ID3D12CommandQueue>()->Signal(
            encode::GetWrappedObject<ID3D12Fence>(pFence),
            Value);

        Encode_ID3D12CommandQueue_Signal(
            this,
            result,
            pFence,
            Value);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_Signal>::Dispatch(
            manager,
            this,
            result,
            pFence,
            Value);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12CommandQueue>()->Signal(
            pFence,
            Value);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12CommandQueue_Wrapper::Wait(
    ID3D12Fence* pFence,
    UINT64 Value)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_Wait>::Dispatch(
            manager,
            this,
            pFence,
            Value);

        result = GetWrappedObjectAs<ID3D12CommandQueue>()->Wait(
            encode::GetWrappedObject<ID3D12Fence>(pFence),
            Value);

        Encode_ID3D12CommandQueue_Wait(
            this,
            result,
            pFence,
            Value);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_Wait>::Dispatch(
            manager,
            this,
            result,
            pFence,
            Value);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12CommandQueue>()->Wait(
            pFence,
            Value);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12CommandQueue_Wrapper::GetTimestampFrequency(
    UINT64* pFrequency)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_GetTimestampFrequency>::Dispatch(
            manager,
            this,
            pFrequency);

        result = GetWrappedObjectAs<ID3D12CommandQueue>()->GetTimestampFrequency(
            pFrequency);

        Encode_ID3D12CommandQueue_GetTimestampFrequency(
            this,
            result,
            pFrequency);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_GetTimestampFrequency>::Dispatch(
            manager,
            this,
            result,
            pFrequency);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12CommandQueue>()->GetTimestampFrequency(
            pFrequency);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12CommandQueue_Wrapper::GetClockCalibration(
    UINT64* pGpuTimestamp,
    UINT64* pCpuTimestamp)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_GetClockCalibration>::Dispatch(
            manager,
            this,
            pGpuTimestamp,
            pCpuTimestamp);

        result = GetWrappedObjectAs<ID3D12CommandQueue>()->GetClockCalibration(
            pGpuTimestamp,
            pCpuTimestamp);

        Encode_ID3D12CommandQueue_GetClockCalibration(
            this,
            result,
            pGpuTimestamp,
            pCpuTimestamp);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_GetClockCalibration>::Dispatch(
            manager,
            this,
            result,
            pGpuTimestamp,
            pCpuTimestamp);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12CommandQueue>()->GetClockCalibration(
            pGpuTimestamp,
            pCpuTimestamp);
    }

    manager->DecrementCallScope();

    return result;
}

D3D12_COMMAND_QUEUE_DESC STDMETHODCALLTYPE ID3D12CommandQueue_Wrapper::GetDesc()
{
    D3D12_COMMAND_QUEUE_DESC result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_GetDesc>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12CommandQueue>()->GetDesc();

        Encode_ID3D12CommandQueue_GetDesc(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12CommandQueue_GetDesc>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12CommandQueue>()->GetDesc();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Device_Wrapper::ID3D12Device_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Object_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12DeviceInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12Device_Wrapper::~ID3D12Device_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12Device>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12Device_Wrapper* ID3D12Device_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12Device_Wrapper>(object, object_map_, object_map_lock_);
}

UINT STDMETHODCALLTYPE ID3D12Device_Wrapper::GetNodeCount()
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_GetNodeCount>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12Device>()->GetNodeCount();

        Encode_ID3D12Device_GetNodeCount(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_GetNodeCount>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->GetNodeCount();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateCommandQueue(
    const D3D12_COMMAND_QUEUE_DESC* pDesc,
    REFIID riid,
    void** ppCommandQueue)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateCommandQueue>::Dispatch(
            manager,
            this,
            pDesc,
            riid,
            ppCommandQueue);

        result = GetWrappedObjectAs<ID3D12Device>()->CreateCommandQueue(
            pDesc,
            riid,
            ppCommandQueue);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppCommandQueue, nullptr);
        }

        Encode_ID3D12Device_CreateCommandQueue(
            this,
            result,
            pDesc,
            riid,
            ppCommandQueue);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateCommandQueue>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            riid,
            ppCommandQueue);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreateCommandQueue(
            pDesc,
            riid,
            ppCommandQueue);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateCommandAllocator(
    D3D12_COMMAND_LIST_TYPE type,
    REFIID riid,
    void** ppCommandAllocator)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateCommandAllocator>::Dispatch(
            manager,
            this,
            type,
            riid,
            ppCommandAllocator);

        result = GetWrappedObjectAs<ID3D12Device>()->CreateCommandAllocator(
            type,
            riid,
            ppCommandAllocator);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppCommandAllocator, nullptr);
        }

        Encode_ID3D12Device_CreateCommandAllocator(
            this,
            result,
            type,
            riid,
            ppCommandAllocator);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateCommandAllocator>::Dispatch(
            manager,
            this,
            result,
            type,
            riid,
            ppCommandAllocator);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreateCommandAllocator(
            type,
            riid,
            ppCommandAllocator);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateGraphicsPipelineState(
    const D3D12_GRAPHICS_PIPELINE_STATE_DESC* pDesc,
    REFIID riid,
    void** ppPipelineState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateGraphicsPipelineState>::Dispatch(
            manager,
            this,
            pDesc,
            riid,
            ppPipelineState);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<ID3D12Device>()->CreateGraphicsPipelineState(
            UnwrapStructPtrObjects(pDesc, unwrap_memory),
            riid,
            ppPipelineState);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppPipelineState, nullptr);
        }

        Encode_ID3D12Device_CreateGraphicsPipelineState(
            this,
            result,
            pDesc,
            riid,
            ppPipelineState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateGraphicsPipelineState>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            riid,
            ppPipelineState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreateGraphicsPipelineState(
            pDesc,
            riid,
            ppPipelineState);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateComputePipelineState(
    const D3D12_COMPUTE_PIPELINE_STATE_DESC* pDesc,
    REFIID riid,
    void** ppPipelineState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateComputePipelineState>::Dispatch(
            manager,
            this,
            pDesc,
            riid,
            ppPipelineState);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<ID3D12Device>()->CreateComputePipelineState(
            UnwrapStructPtrObjects(pDesc, unwrap_memory),
            riid,
            ppPipelineState);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppPipelineState, nullptr);
        }

        Encode_ID3D12Device_CreateComputePipelineState(
            this,
            result,
            pDesc,
            riid,
            ppPipelineState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateComputePipelineState>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            riid,
            ppPipelineState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreateComputePipelineState(
            pDesc,
            riid,
            ppPipelineState);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateCommandList(
    UINT nodeMask,
    D3D12_COMMAND_LIST_TYPE type,
    ID3D12CommandAllocator* pCommandAllocator,
    ID3D12PipelineState* pInitialState,
    REFIID riid,
    void** ppCommandList)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateCommandList>::Dispatch(
            manager,
            this,
            nodeMask,
            type,
            pCommandAllocator,
            pInitialState,
            riid,
            ppCommandList);

        result = GetWrappedObjectAs<ID3D12Device>()->CreateCommandList(
            nodeMask,
            type,
            encode::GetWrappedObject<ID3D12CommandAllocator>(pCommandAllocator),
            encode::GetWrappedObject<ID3D12PipelineState>(pInitialState),
            riid,
            ppCommandList);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppCommandList, nullptr);
        }

        Encode_ID3D12Device_CreateCommandList(
            this,
            result,
            nodeMask,
            type,
            pCommandAllocator,
            pInitialState,
            riid,
            ppCommandList);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateCommandList>::Dispatch(
            manager,
            this,
            result,
            nodeMask,
            type,
            pCommandAllocator,
            pInitialState,
            riid,
            ppCommandList);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreateCommandList(
            nodeMask,
            type,
            pCommandAllocator,
            pInitialState,
            riid,
            ppCommandList);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CheckFeatureSupport(
    D3D12_FEATURE Feature,
    void* pFeatureSupportData,
    UINT FeatureSupportDataSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CheckFeatureSupport>::Dispatch(
            manager,
            this,
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);

        result = D3D12CaptureManager::Get()->OverrideID3D12Device_CheckFeatureSupport(
            this,
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);

        Encode_ID3D12Device_CheckFeatureSupport(
            this,
            result,
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CheckFeatureSupport>::Dispatch(
            manager,
            this,
            result,
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CheckFeatureSupport(
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateDescriptorHeap(
    const D3D12_DESCRIPTOR_HEAP_DESC* pDescriptorHeapDesc,
    REFIID riid,
    void** ppvHeap)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateDescriptorHeap>::Dispatch(
            manager,
            this,
            pDescriptorHeapDesc,
            riid,
            ppvHeap);

        result = GetWrappedObjectAs<ID3D12Device>()->CreateDescriptorHeap(
            pDescriptorHeapDesc,
            riid,
            ppvHeap);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvHeap, nullptr);
        }

        Encode_ID3D12Device_CreateDescriptorHeap(
            this,
            result,
            pDescriptorHeapDesc,
            riid,
            ppvHeap);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateDescriptorHeap>::Dispatch(
            manager,
            this,
            result,
            pDescriptorHeapDesc,
            riid,
            ppvHeap);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreateDescriptorHeap(
            pDescriptorHeapDesc,
            riid,
            ppvHeap);
    }

    manager->DecrementCallScope();

    return result;
}

UINT STDMETHODCALLTYPE ID3D12Device_Wrapper::GetDescriptorHandleIncrementSize(
    D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapType)
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_GetDescriptorHandleIncrementSize>::Dispatch(
            manager,
            this,
            DescriptorHeapType);

        result = GetWrappedObjectAs<ID3D12Device>()->GetDescriptorHandleIncrementSize(
            DescriptorHeapType);

        Encode_ID3D12Device_GetDescriptorHandleIncrementSize(
            this,
            result,
            DescriptorHeapType);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_GetDescriptorHandleIncrementSize>::Dispatch(
            manager,
            this,
            result,
            DescriptorHeapType);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->GetDescriptorHandleIncrementSize(
            DescriptorHeapType);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateRootSignature(
    UINT nodeMask,
    const void* pBlobWithRootSignature,
    SIZE_T blobLengthInBytes,
    REFIID riid,
    void** ppvRootSignature)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateRootSignature>::Dispatch(
            manager,
            this,
            nodeMask,
            pBlobWithRootSignature,
            blobLengthInBytes,
            riid,
            ppvRootSignature);

        result = GetWrappedObjectAs<ID3D12Device>()->CreateRootSignature(
            nodeMask,
            pBlobWithRootSignature,
            blobLengthInBytes,
            riid,
            ppvRootSignature);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvRootSignature, nullptr);
        }

        Encode_ID3D12Device_CreateRootSignature(
            this,
            result,
            nodeMask,
            pBlobWithRootSignature,
            blobLengthInBytes,
            riid,
            ppvRootSignature);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateRootSignature>::Dispatch(
            manager,
            this,
            result,
            nodeMask,
            pBlobWithRootSignature,
            blobLengthInBytes,
            riid,
            ppvRootSignature);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreateRootSignature(
            nodeMask,
            pBlobWithRootSignature,
            blobLengthInBytes,
            riid,
            ppvRootSignature);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateConstantBufferView(
    const D3D12_CONSTANT_BUFFER_VIEW_DESC* pDesc,
    D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        std::unique_ptr<D3D12_CONSTANT_BUFFER_VIEW_DESC> pDesc_unannotated = nullptr;
        if((manager->IsAnnotated() == true) && (pDesc != nullptr))
        {
            pDesc_unannotated = RvAnnotationUtil::RemoveStructRvAnnotations(pDesc);
            pDesc = pDesc_unannotated.get();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateConstantBufferView>::Dispatch(
            manager,
            this,
            pDesc,
            DestDescriptor);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12Device>()->CreateConstantBufferView(
            pDesc,
            *UnwrapStructPtrObjects(&DestDescriptor, unwrap_memory));

        Encode_ID3D12Device_CreateConstantBufferView(
            this,
            pDesc,
            DestDescriptor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateConstantBufferView>::Dispatch(
            manager,
            this,
            pDesc,
            DestDescriptor);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device>()->CreateConstantBufferView(
            pDesc,
            DestDescriptor);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateShaderResourceView(
    ID3D12Resource* pResource,
    const D3D12_SHADER_RESOURCE_VIEW_DESC* pDesc,
    D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        std::unique_ptr<D3D12_SHADER_RESOURCE_VIEW_DESC> pDesc_unannotated = nullptr;
        if((manager->IsAnnotated() == true) && (pDesc != nullptr))
        {
            pDesc_unannotated = RvAnnotationUtil::RemoveStructRvAnnotations(pDesc);
            pDesc = pDesc_unannotated.get();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateShaderResourceView>::Dispatch(
            manager,
            this,
            pResource,
            pDesc,
            DestDescriptor);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12Device>()->CreateShaderResourceView(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            pDesc,
            *UnwrapStructPtrObjects(&DestDescriptor, unwrap_memory));

        Encode_ID3D12Device_CreateShaderResourceView(
            this,
            pResource,
            pDesc,
            DestDescriptor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateShaderResourceView>::Dispatch(
            manager,
            this,
            pResource,
            pDesc,
            DestDescriptor);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device>()->CreateShaderResourceView(
            pResource,
            pDesc,
            DestDescriptor);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateUnorderedAccessView(
    ID3D12Resource* pResource,
    ID3D12Resource* pCounterResource,
    const D3D12_UNORDERED_ACCESS_VIEW_DESC* pDesc,
    D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateUnorderedAccessView>::Dispatch(
            manager,
            this,
            pResource,
            pCounterResource,
            pDesc,
            DestDescriptor);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12Device>()->CreateUnorderedAccessView(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            encode::GetWrappedObject<ID3D12Resource>(pCounterResource),
            pDesc,
            *UnwrapStructPtrObjects(&DestDescriptor, unwrap_memory));

        Encode_ID3D12Device_CreateUnorderedAccessView(
            this,
            pResource,
            pCounterResource,
            pDesc,
            DestDescriptor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateUnorderedAccessView>::Dispatch(
            manager,
            this,
            pResource,
            pCounterResource,
            pDesc,
            DestDescriptor);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device>()->CreateUnorderedAccessView(
            pResource,
            pCounterResource,
            pDesc,
            DestDescriptor);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateRenderTargetView(
    ID3D12Resource* pResource,
    const D3D12_RENDER_TARGET_VIEW_DESC* pDesc,
    D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateRenderTargetView>::Dispatch(
            manager,
            this,
            pResource,
            pDesc,
            DestDescriptor);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12Device>()->CreateRenderTargetView(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            pDesc,
            *UnwrapStructPtrObjects(&DestDescriptor, unwrap_memory));

        Encode_ID3D12Device_CreateRenderTargetView(
            this,
            pResource,
            pDesc,
            DestDescriptor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateRenderTargetView>::Dispatch(
            manager,
            this,
            pResource,
            pDesc,
            DestDescriptor);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device>()->CreateRenderTargetView(
            pResource,
            pDesc,
            DestDescriptor);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateDepthStencilView(
    ID3D12Resource* pResource,
    const D3D12_DEPTH_STENCIL_VIEW_DESC* pDesc,
    D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateDepthStencilView>::Dispatch(
            manager,
            this,
            pResource,
            pDesc,
            DestDescriptor);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12Device>()->CreateDepthStencilView(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            pDesc,
            *UnwrapStructPtrObjects(&DestDescriptor, unwrap_memory));

        Encode_ID3D12Device_CreateDepthStencilView(
            this,
            pResource,
            pDesc,
            DestDescriptor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateDepthStencilView>::Dispatch(
            manager,
            this,
            pResource,
            pDesc,
            DestDescriptor);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device>()->CreateDepthStencilView(
            pResource,
            pDesc,
            DestDescriptor);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateSampler(
    const D3D12_SAMPLER_DESC* pDesc,
    D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateSampler>::Dispatch(
            manager,
            this,
            pDesc,
            DestDescriptor);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12Device>()->CreateSampler(
            pDesc,
            *UnwrapStructPtrObjects(&DestDescriptor, unwrap_memory));

        Encode_ID3D12Device_CreateSampler(
            this,
            pDesc,
            DestDescriptor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateSampler>::Dispatch(
            manager,
            this,
            pDesc,
            DestDescriptor);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device>()->CreateSampler(
            pDesc,
            DestDescriptor);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12Device_Wrapper::CopyDescriptors(
    UINT NumDestDescriptorRanges,
    const D3D12_CPU_DESCRIPTOR_HANDLE* pDestDescriptorRangeStarts,
    const UINT* pDestDescriptorRangeSizes,
    UINT NumSrcDescriptorRanges,
    const D3D12_CPU_DESCRIPTOR_HANDLE* pSrcDescriptorRangeStarts,
    const UINT* pSrcDescriptorRangeSizes,
    D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CopyDescriptors>::Dispatch(
            manager,
            this,
            NumDestDescriptorRanges,
            pDestDescriptorRangeStarts,
            pDestDescriptorRangeSizes,
            NumSrcDescriptorRanges,
            pSrcDescriptorRangeStarts,
            pSrcDescriptorRangeSizes,
            DescriptorHeapsType);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12Device>()->CopyDescriptors(
            NumDestDescriptorRanges,
            UnwrapStructArrayObjects(pDestDescriptorRangeStarts, NumDestDescriptorRanges, unwrap_memory),
            pDestDescriptorRangeSizes,
            NumSrcDescriptorRanges,
            UnwrapStructArrayObjects(pSrcDescriptorRangeStarts, NumSrcDescriptorRanges, unwrap_memory),
            pSrcDescriptorRangeSizes,
            DescriptorHeapsType);

        Encode_ID3D12Device_CopyDescriptors(
            this,
            NumDestDescriptorRanges,
            pDestDescriptorRangeStarts,
            pDestDescriptorRangeSizes,
            NumSrcDescriptorRanges,
            pSrcDescriptorRangeStarts,
            pSrcDescriptorRangeSizes,
            DescriptorHeapsType);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CopyDescriptors>::Dispatch(
            manager,
            this,
            NumDestDescriptorRanges,
            pDestDescriptorRangeStarts,
            pDestDescriptorRangeSizes,
            NumSrcDescriptorRanges,
            pSrcDescriptorRangeStarts,
            pSrcDescriptorRangeSizes,
            DescriptorHeapsType);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device>()->CopyDescriptors(
            NumDestDescriptorRanges,
            pDestDescriptorRangeStarts,
            pDestDescriptorRangeSizes,
            NumSrcDescriptorRanges,
            pSrcDescriptorRangeStarts,
            pSrcDescriptorRangeSizes,
            DescriptorHeapsType);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12Device_Wrapper::CopyDescriptorsSimple(
    UINT NumDescriptors,
    D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptorRangeStart,
    D3D12_CPU_DESCRIPTOR_HANDLE SrcDescriptorRangeStart,
    D3D12_DESCRIPTOR_HEAP_TYPE DescriptorHeapsType)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CopyDescriptorsSimple>::Dispatch(
            manager,
            this,
            NumDescriptors,
            DestDescriptorRangeStart,
            SrcDescriptorRangeStart,
            DescriptorHeapsType);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12Device>()->CopyDescriptorsSimple(
            NumDescriptors,
            *UnwrapStructPtrObjects(&DestDescriptorRangeStart, unwrap_memory),
            *UnwrapStructPtrObjects(&SrcDescriptorRangeStart, unwrap_memory),
            DescriptorHeapsType);

        Encode_ID3D12Device_CopyDescriptorsSimple(
            this,
            NumDescriptors,
            DestDescriptorRangeStart,
            SrcDescriptorRangeStart,
            DescriptorHeapsType);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CopyDescriptorsSimple>::Dispatch(
            manager,
            this,
            NumDescriptors,
            DestDescriptorRangeStart,
            SrcDescriptorRangeStart,
            DescriptorHeapsType);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device>()->CopyDescriptorsSimple(
            NumDescriptors,
            DestDescriptorRangeStart,
            SrcDescriptorRangeStart,
            DescriptorHeapsType);
    }

    manager->DecrementCallScope();
}

D3D12_RESOURCE_ALLOCATION_INFO STDMETHODCALLTYPE ID3D12Device_Wrapper::GetResourceAllocationInfo(
    UINT visibleMask,
    UINT numResourceDescs,
    const D3D12_RESOURCE_DESC* pResourceDescs)
{
    D3D12_RESOURCE_ALLOCATION_INFO result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_GetResourceAllocationInfo>::Dispatch(
            manager,
            this,
            visibleMask,
            numResourceDescs,
            pResourceDescs);

        result = GetWrappedObjectAs<ID3D12Device>()->GetResourceAllocationInfo(
            visibleMask,
            numResourceDescs,
            pResourceDescs);

        Encode_ID3D12Device_GetResourceAllocationInfo(
            this,
            result,
            visibleMask,
            numResourceDescs,
            pResourceDescs);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_GetResourceAllocationInfo>::Dispatch(
            manager,
            this,
            result,
            visibleMask,
            numResourceDescs,
            pResourceDescs);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->GetResourceAllocationInfo(
            visibleMask,
            numResourceDescs,
            pResourceDescs);
    }

    manager->DecrementCallScope();

    return result;
}

D3D12_HEAP_PROPERTIES STDMETHODCALLTYPE ID3D12Device_Wrapper::GetCustomHeapProperties(
    UINT nodeMask,
    D3D12_HEAP_TYPE heapType)
{
    D3D12_HEAP_PROPERTIES result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_GetCustomHeapProperties>::Dispatch(
            manager,
            this,
            nodeMask,
            heapType);

        result = GetWrappedObjectAs<ID3D12Device>()->GetCustomHeapProperties(
            nodeMask,
            heapType);

        Encode_ID3D12Device_GetCustomHeapProperties(
            this,
            result,
            nodeMask,
            heapType);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_GetCustomHeapProperties>::Dispatch(
            manager,
            this,
            result,
            nodeMask,
            heapType);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->GetCustomHeapProperties(
            nodeMask,
            heapType);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateCommittedResource(
    const D3D12_HEAP_PROPERTIES* pHeapProperties,
    D3D12_HEAP_FLAGS HeapFlags,
    const D3D12_RESOURCE_DESC* pDesc,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE* pOptimizedClearValue,
    REFIID riidResource,
    void** ppvResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateCommittedResource>::Dispatch(
            manager,
            this,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            riidResource,
            ppvResource);

        result = D3D12CaptureManager::Get()->OverrideID3D12Device_CreateCommittedResource(
            this,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            riidResource,
            ppvResource);

        if (SUCCEEDED(result))
        {
            WrapObject(riidResource, ppvResource, nullptr);
        }

        Encode_ID3D12Device_CreateCommittedResource(
            this,
            result,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            riidResource,
            ppvResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateCommittedResource>::Dispatch(
            manager,
            this,
            result,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            riidResource,
            ppvResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreateCommittedResource(
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            riidResource,
            ppvResource);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateHeap(
    const D3D12_HEAP_DESC* pDesc,
    REFIID riid,
    void** ppvHeap)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateHeap>::Dispatch(
            manager,
            this,
            pDesc,
            riid,
            ppvHeap);

        result = D3D12CaptureManager::Get()->OverrideID3D12Device_CreateHeap(
            this,
            pDesc,
            riid,
            ppvHeap);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvHeap, nullptr);
        }

        Encode_ID3D12Device_CreateHeap(
            this,
            result,
            pDesc,
            riid,
            ppvHeap);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateHeap>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            riid,
            ppvHeap);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreateHeap(
            pDesc,
            riid,
            ppvHeap);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreatePlacedResource(
    ID3D12Heap* pHeap,
    UINT64 HeapOffset,
    const D3D12_RESOURCE_DESC* pDesc,
    D3D12_RESOURCE_STATES InitialState,
    const D3D12_CLEAR_VALUE* pOptimizedClearValue,
    REFIID riid,
    void** ppvResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreatePlacedResource>::Dispatch(
            manager,
            this,
            pHeap,
            HeapOffset,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);

        result = GetWrappedObjectAs<ID3D12Device>()->CreatePlacedResource(
            encode::GetWrappedObject<ID3D12Heap>(pHeap),
            HeapOffset,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvResource, nullptr);
        }

        Encode_ID3D12Device_CreatePlacedResource(
            this,
            result,
            pHeap,
            HeapOffset,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreatePlacedResource>::Dispatch(
            manager,
            this,
            result,
            pHeap,
            HeapOffset,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreatePlacedResource(
            pHeap,
            HeapOffset,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateReservedResource(
    const D3D12_RESOURCE_DESC* pDesc,
    D3D12_RESOURCE_STATES InitialState,
    const D3D12_CLEAR_VALUE* pOptimizedClearValue,
    REFIID riid,
    void** ppvResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateReservedResource>::Dispatch(
            manager,
            this,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);

        result = GetWrappedObjectAs<ID3D12Device>()->CreateReservedResource(
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvResource, nullptr);
        }

        Encode_ID3D12Device_CreateReservedResource(
            this,
            result,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateReservedResource>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreateReservedResource(
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateSharedHandle(
    ID3D12DeviceChild* pObject,
    const SECURITY_ATTRIBUTES* pAttributes,
    DWORD Access,
    LPCWSTR Name,
    HANDLE* pHandle)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateSharedHandle>::Dispatch(
            manager,
            this,
            pObject,
            pAttributes,
            Access,
            Name,
            pHandle);

        result = GetWrappedObjectAs<ID3D12Device>()->CreateSharedHandle(
            encode::GetWrappedObject<ID3D12DeviceChild>(pObject),
            pAttributes,
            Access,
            Name,
            pHandle);

        Encode_ID3D12Device_CreateSharedHandle(
            this,
            result,
            pObject,
            pAttributes,
            Access,
            Name,
            pHandle);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateSharedHandle>::Dispatch(
            manager,
            this,
            result,
            pObject,
            pAttributes,
            Access,
            Name,
            pHandle);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreateSharedHandle(
            pObject,
            pAttributes,
            Access,
            Name,
            pHandle);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::OpenSharedHandle(
    HANDLE NTHandle,
    REFIID riid,
    void** ppvObj)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_OpenSharedHandle>::Dispatch(
            manager,
            this,
            NTHandle,
            riid,
            ppvObj);

        result = GetWrappedObjectAs<ID3D12Device>()->OpenSharedHandle(
            NTHandle,
            riid,
            ppvObj);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvObj, nullptr);
        }

        Encode_ID3D12Device_OpenSharedHandle(
            this,
            result,
            NTHandle,
            riid,
            ppvObj);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_OpenSharedHandle>::Dispatch(
            manager,
            this,
            result,
            NTHandle,
            riid,
            ppvObj);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->OpenSharedHandle(
            NTHandle,
            riid,
            ppvObj);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::OpenSharedHandleByName(
    LPCWSTR Name,
    DWORD Access,
    HANDLE* pNTHandle)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_OpenSharedHandleByName>::Dispatch(
            manager,
            this,
            Name,
            Access,
            pNTHandle);

        result = GetWrappedObjectAs<ID3D12Device>()->OpenSharedHandleByName(
            Name,
            Access,
            pNTHandle);

        Encode_ID3D12Device_OpenSharedHandleByName(
            this,
            result,
            Name,
            Access,
            pNTHandle);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_OpenSharedHandleByName>::Dispatch(
            manager,
            this,
            result,
            Name,
            Access,
            pNTHandle);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->OpenSharedHandleByName(
            Name,
            Access,
            pNTHandle);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::MakeResident(
    UINT NumObjects,
    ID3D12Pageable* const* ppObjects)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_MakeResident>::Dispatch(
            manager,
            this,
            NumObjects,
            ppObjects);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<ID3D12Device>()->MakeResident(
            NumObjects,
            UnwrapObjects<ID3D12Pageable>(ppObjects, NumObjects, unwrap_memory));

        Encode_ID3D12Device_MakeResident(
            this,
            result,
            NumObjects,
            ppObjects);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_MakeResident>::Dispatch(
            manager,
            this,
            result,
            NumObjects,
            ppObjects);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->MakeResident(
            NumObjects,
            ppObjects);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::Evict(
    UINT NumObjects,
    ID3D12Pageable* const* ppObjects)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_Evict>::Dispatch(
            manager,
            this,
            NumObjects,
            ppObjects);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<ID3D12Device>()->Evict(
            NumObjects,
            UnwrapObjects<ID3D12Pageable>(ppObjects, NumObjects, unwrap_memory));

        Encode_ID3D12Device_Evict(
            this,
            result,
            NumObjects,
            ppObjects);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_Evict>::Dispatch(
            manager,
            this,
            result,
            NumObjects,
            ppObjects);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->Evict(
            NumObjects,
            ppObjects);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateFence(
    UINT64 InitialValue,
    D3D12_FENCE_FLAGS Flags,
    REFIID riid,
    void** ppFence)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateFence>::Dispatch(
            manager,
            this,
            InitialValue,
            Flags,
            riid,
            ppFence);

        result = GetWrappedObjectAs<ID3D12Device>()->CreateFence(
            InitialValue,
            Flags,
            riid,
            ppFence);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppFence, nullptr);
        }

        Encode_ID3D12Device_CreateFence(
            this,
            result,
            InitialValue,
            Flags,
            riid,
            ppFence);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateFence>::Dispatch(
            manager,
            this,
            result,
            InitialValue,
            Flags,
            riid,
            ppFence);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreateFence(
            InitialValue,
            Flags,
            riid,
            ppFence);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::GetDeviceRemovedReason()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_GetDeviceRemovedReason>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12Device>()->GetDeviceRemovedReason();

        Encode_ID3D12Device_GetDeviceRemovedReason(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_GetDeviceRemovedReason>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->GetDeviceRemovedReason();
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12Device_Wrapper::GetCopyableFootprints(
    const D3D12_RESOURCE_DESC* pResourceDesc,
    UINT FirstSubresource,
    UINT NumSubresources,
    UINT64 BaseOffset,
    D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts,
    UINT* pNumRows,
    UINT64* pRowSizeInBytes,
    UINT64* pTotalBytes)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_GetCopyableFootprints>::Dispatch(
            manager,
            this,
            pResourceDesc,
            FirstSubresource,
            NumSubresources,
            BaseOffset,
            pLayouts,
            pNumRows,
            pRowSizeInBytes,
            pTotalBytes);

        GetWrappedObjectAs<ID3D12Device>()->GetCopyableFootprints(
            pResourceDesc,
            FirstSubresource,
            NumSubresources,
            BaseOffset,
            pLayouts,
            pNumRows,
            pRowSizeInBytes,
            pTotalBytes);

        Encode_ID3D12Device_GetCopyableFootprints(
            this,
            pResourceDesc,
            FirstSubresource,
            NumSubresources,
            BaseOffset,
            pLayouts,
            pNumRows,
            pRowSizeInBytes,
            pTotalBytes);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_GetCopyableFootprints>::Dispatch(
            manager,
            this,
            pResourceDesc,
            FirstSubresource,
            NumSubresources,
            BaseOffset,
            pLayouts,
            pNumRows,
            pRowSizeInBytes,
            pTotalBytes);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device>()->GetCopyableFootprints(
            pResourceDesc,
            FirstSubresource,
            NumSubresources,
            BaseOffset,
            pLayouts,
            pNumRows,
            pRowSizeInBytes,
            pTotalBytes);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateQueryHeap(
    const D3D12_QUERY_HEAP_DESC* pDesc,
    REFIID riid,
    void** ppvHeap)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateQueryHeap>::Dispatch(
            manager,
            this,
            pDesc,
            riid,
            ppvHeap);

        result = GetWrappedObjectAs<ID3D12Device>()->CreateQueryHeap(
            pDesc,
            riid,
            ppvHeap);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvHeap, nullptr);
        }

        Encode_ID3D12Device_CreateQueryHeap(
            this,
            result,
            pDesc,
            riid,
            ppvHeap);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateQueryHeap>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            riid,
            ppvHeap);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreateQueryHeap(
            pDesc,
            riid,
            ppvHeap);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::SetStablePowerState(
    BOOL Enable)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_SetStablePowerState>::Dispatch(
            manager,
            this,
            Enable);

        result = GetWrappedObjectAs<ID3D12Device>()->SetStablePowerState(
            Enable);

        Encode_ID3D12Device_SetStablePowerState(
            this,
            result,
            Enable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_SetStablePowerState>::Dispatch(
            manager,
            this,
            result,
            Enable);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->SetStablePowerState(
            Enable);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device_Wrapper::CreateCommandSignature(
    const D3D12_COMMAND_SIGNATURE_DESC* pDesc,
    ID3D12RootSignature* pRootSignature,
    REFIID riid,
    void** ppvCommandSignature)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_CreateCommandSignature>::Dispatch(
            manager,
            this,
            pDesc,
            pRootSignature,
            riid,
            ppvCommandSignature);

        result = GetWrappedObjectAs<ID3D12Device>()->CreateCommandSignature(
            pDesc,
            encode::GetWrappedObject<ID3D12RootSignature>(pRootSignature),
            riid,
            ppvCommandSignature);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvCommandSignature, nullptr);
        }

        Encode_ID3D12Device_CreateCommandSignature(
            this,
            result,
            pDesc,
            pRootSignature,
            riid,
            ppvCommandSignature);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_CreateCommandSignature>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            pRootSignature,
            riid,
            ppvCommandSignature);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->CreateCommandSignature(
            pDesc,
            pRootSignature,
            riid,
            ppvCommandSignature);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12Device_Wrapper::GetResourceTiling(
    ID3D12Resource* pTiledResource,
    UINT* pNumTilesForEntireResource,
    D3D12_PACKED_MIP_INFO* pPackedMipDesc,
    D3D12_TILE_SHAPE* pStandardTileShapeForNonPackedMips,
    UINT* pNumSubresourceTilings,
    UINT FirstSubresourceTilingToGet,
    D3D12_SUBRESOURCE_TILING* pSubresourceTilingsForNonPackedMips)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_GetResourceTiling>::Dispatch(
            manager,
            this,
            pTiledResource,
            pNumTilesForEntireResource,
            pPackedMipDesc,
            pStandardTileShapeForNonPackedMips,
            pNumSubresourceTilings,
            FirstSubresourceTilingToGet,
            pSubresourceTilingsForNonPackedMips);

        GetWrappedObjectAs<ID3D12Device>()->GetResourceTiling(
            encode::GetWrappedObject<ID3D12Resource>(pTiledResource),
            pNumTilesForEntireResource,
            pPackedMipDesc,
            pStandardTileShapeForNonPackedMips,
            pNumSubresourceTilings,
            FirstSubresourceTilingToGet,
            pSubresourceTilingsForNonPackedMips);

        Encode_ID3D12Device_GetResourceTiling(
            this,
            pTiledResource,
            pNumTilesForEntireResource,
            pPackedMipDesc,
            pStandardTileShapeForNonPackedMips,
            pNumSubresourceTilings,
            FirstSubresourceTilingToGet,
            pSubresourceTilingsForNonPackedMips);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_GetResourceTiling>::Dispatch(
            manager,
            this,
            pTiledResource,
            pNumTilesForEntireResource,
            pPackedMipDesc,
            pStandardTileShapeForNonPackedMips,
            pNumSubresourceTilings,
            FirstSubresourceTilingToGet,
            pSubresourceTilingsForNonPackedMips);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device>()->GetResourceTiling(
            pTiledResource,
            pNumTilesForEntireResource,
            pPackedMipDesc,
            pStandardTileShapeForNonPackedMips,
            pNumSubresourceTilings,
            FirstSubresourceTilingToGet,
            pSubresourceTilingsForNonPackedMips);
    }

    manager->DecrementCallScope();
}

LUID STDMETHODCALLTYPE ID3D12Device_Wrapper::GetAdapterLuid()
{
    LUID result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device_GetAdapterLuid>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12Device>()->GetAdapterLuid();

        Encode_ID3D12Device_GetAdapterLuid(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device_GetAdapterLuid>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device>()->GetAdapterLuid();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12PipelineLibrary_Wrapper::ID3D12PipelineLibrary_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12PipelineLibraryInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12PipelineLibrary_Wrapper::~ID3D12PipelineLibrary_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12PipelineLibrary>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12PipelineLibrary_Wrapper* ID3D12PipelineLibrary_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12PipelineLibrary_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12PipelineLibrary_Wrapper::StorePipeline(
    LPCWSTR pName,
    ID3D12PipelineState* pPipeline)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12PipelineLibrary_StorePipeline>::Dispatch(
            manager,
            this,
            pName,
            pPipeline);

        result = GetWrappedObjectAs<ID3D12PipelineLibrary>()->StorePipeline(
            pName,
            encode::GetWrappedObject<ID3D12PipelineState>(pPipeline));

        Encode_ID3D12PipelineLibrary_StorePipeline(
            this,
            result,
            pName,
            pPipeline);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12PipelineLibrary_StorePipeline>::Dispatch(
            manager,
            this,
            result,
            pName,
            pPipeline);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12PipelineLibrary>()->StorePipeline(
            pName,
            pPipeline);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12PipelineLibrary_Wrapper::LoadGraphicsPipeline(
    LPCWSTR pName,
    const D3D12_GRAPHICS_PIPELINE_STATE_DESC* pDesc,
    REFIID riid,
    void** ppPipelineState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12PipelineLibrary_LoadGraphicsPipeline>::Dispatch(
            manager,
            this,
            pName,
            pDesc,
            riid,
            ppPipelineState);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = D3D12CaptureManager::Get()->OverrideID3D12PipelineLibrary_LoadGraphicsPipeline(
            this,
            pName,
            pDesc,
            riid,
            ppPipelineState);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppPipelineState, nullptr);
        }

        Encode_ID3D12PipelineLibrary_LoadGraphicsPipeline(
            this,
            result,
            pName,
            pDesc,
            riid,
            ppPipelineState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12PipelineLibrary_LoadGraphicsPipeline>::Dispatch(
            manager,
            this,
            result,
            pName,
            pDesc,
            riid,
            ppPipelineState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12PipelineLibrary>()->LoadGraphicsPipeline(
            pName,
            pDesc,
            riid,
            ppPipelineState);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12PipelineLibrary_Wrapper::LoadComputePipeline(
    LPCWSTR pName,
    const D3D12_COMPUTE_PIPELINE_STATE_DESC* pDesc,
    REFIID riid,
    void** ppPipelineState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12PipelineLibrary_LoadComputePipeline>::Dispatch(
            manager,
            this,
            pName,
            pDesc,
            riid,
            ppPipelineState);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = D3D12CaptureManager::Get()->OverrideID3D12PipelineLibrary_LoadComputePipeline(
            this,
            pName,
            pDesc,
            riid,
            ppPipelineState);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppPipelineState, nullptr);
        }

        Encode_ID3D12PipelineLibrary_LoadComputePipeline(
            this,
            result,
            pName,
            pDesc,
            riid,
            ppPipelineState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12PipelineLibrary_LoadComputePipeline>::Dispatch(
            manager,
            this,
            result,
            pName,
            pDesc,
            riid,
            ppPipelineState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12PipelineLibrary>()->LoadComputePipeline(
            pName,
            pDesc,
            riid,
            ppPipelineState);
    }

    manager->DecrementCallScope();

    return result;
}

SIZE_T STDMETHODCALLTYPE ID3D12PipelineLibrary_Wrapper::GetSerializedSize()
{
    SIZE_T result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12PipelineLibrary_GetSerializedSize>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12PipelineLibrary>()->GetSerializedSize();

        Encode_ID3D12PipelineLibrary_GetSerializedSize(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12PipelineLibrary_GetSerializedSize>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12PipelineLibrary>()->GetSerializedSize();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12PipelineLibrary_Wrapper::Serialize(
    void* pData,
    SIZE_T DataSizeInBytes)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12PipelineLibrary_Serialize>::Dispatch(
            manager,
            this,
            pData,
            DataSizeInBytes);

        result = GetWrappedObjectAs<ID3D12PipelineLibrary>()->Serialize(
            pData,
            DataSizeInBytes);

        Encode_ID3D12PipelineLibrary_Serialize(
            this,
            result,
            pData,
            DataSizeInBytes);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12PipelineLibrary_Serialize>::Dispatch(
            manager,
            this,
            result,
            pData,
            DataSizeInBytes);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12PipelineLibrary>()->Serialize(
            pData,
            DataSizeInBytes);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12PipelineLibrary1_Wrapper::ID3D12PipelineLibrary1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12PipelineLibrary_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12PipelineLibrary1_Wrapper::LoadPipeline(
    LPCWSTR pName,
    const D3D12_PIPELINE_STATE_STREAM_DESC* pDesc,
    REFIID riid,
    void** ppPipelineState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12PipelineLibrary1_LoadPipeline>::Dispatch(
            manager,
            this,
            pName,
            pDesc,
            riid,
            ppPipelineState);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = D3D12CaptureManager::Get()->OverrideID3D12PipelineLibrary1_LoadPipeline(
            this,
            pName,
            pDesc,
            riid,
            ppPipelineState);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppPipelineState, nullptr);
        }

        Encode_ID3D12PipelineLibrary1_LoadPipeline(
            this,
            result,
            pName,
            pDesc,
            riid,
            ppPipelineState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12PipelineLibrary1_LoadPipeline>::Dispatch(
            manager,
            this,
            result,
            pName,
            pDesc,
            riid,
            ppPipelineState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12PipelineLibrary1>()->LoadPipeline(
            pName,
            pDesc,
            riid,
            ppPipelineState);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Device1_Wrapper::ID3D12Device1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Device_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Device1_Wrapper::CreatePipelineLibrary(
    const void* pLibraryBlob,
    SIZE_T BlobLength,
    REFIID riid,
    void** ppPipelineLibrary)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device1_CreatePipelineLibrary>::Dispatch(
            manager,
            this,
            pLibraryBlob,
            BlobLength,
            riid,
            ppPipelineLibrary);

        result = D3D12CaptureManager::Get()->OverrideID3D12Device1_CreatePipelineLibrary(
            this,
            pLibraryBlob,
            BlobLength,
            riid,
            ppPipelineLibrary);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppPipelineLibrary, nullptr);
        }

        Encode_ID3D12Device1_CreatePipelineLibrary(
            this,
            result,
            pLibraryBlob,
            BlobLength,
            riid,
            ppPipelineLibrary);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device1_CreatePipelineLibrary>::Dispatch(
            manager,
            this,
            result,
            pLibraryBlob,
            BlobLength,
            riid,
            ppPipelineLibrary);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device1>()->CreatePipelineLibrary(
            pLibraryBlob,
            BlobLength,
            riid,
            ppPipelineLibrary);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device1_Wrapper::SetEventOnMultipleFenceCompletion(
    ID3D12Fence* const* ppFences,
    const UINT64* pFenceValues,
    UINT NumFences,
    D3D12_MULTIPLE_FENCE_WAIT_FLAGS Flags,
    HANDLE hEvent)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device1_SetEventOnMultipleFenceCompletion>::Dispatch(
            manager,
            this,
            ppFences,
            pFenceValues,
            NumFences,
            Flags,
            hEvent);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<ID3D12Device1>()->SetEventOnMultipleFenceCompletion(
            UnwrapObjects<ID3D12Fence>(ppFences, NumFences, unwrap_memory),
            pFenceValues,
            NumFences,
            Flags,
            hEvent);

        Encode_ID3D12Device1_SetEventOnMultipleFenceCompletion(
            this,
            result,
            ppFences,
            pFenceValues,
            NumFences,
            Flags,
            hEvent);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device1_SetEventOnMultipleFenceCompletion>::Dispatch(
            manager,
            this,
            result,
            ppFences,
            pFenceValues,
            NumFences,
            Flags,
            hEvent);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device1>()->SetEventOnMultipleFenceCompletion(
            ppFences,
            pFenceValues,
            NumFences,
            Flags,
            hEvent);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device1_Wrapper::SetResidencyPriority(
    UINT NumObjects,
    ID3D12Pageable* const* ppObjects,
    const D3D12_RESIDENCY_PRIORITY* pPriorities)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device1_SetResidencyPriority>::Dispatch(
            manager,
            this,
            NumObjects,
            ppObjects,
            pPriorities);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<ID3D12Device1>()->SetResidencyPriority(
            NumObjects,
            UnwrapObjects<ID3D12Pageable>(ppObjects, NumObjects, unwrap_memory),
            pPriorities);

        Encode_ID3D12Device1_SetResidencyPriority(
            this,
            result,
            NumObjects,
            ppObjects,
            pPriorities);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device1_SetResidencyPriority>::Dispatch(
            manager,
            this,
            result,
            NumObjects,
            ppObjects,
            pPriorities);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device1>()->SetResidencyPriority(
            NumObjects,
            ppObjects,
            pPriorities);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Device2_Wrapper::ID3D12Device2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Device1_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Device2_Wrapper::CreatePipelineState(
    const D3D12_PIPELINE_STATE_STREAM_DESC* pDesc,
    REFIID riid,
    void** ppPipelineState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device2_CreatePipelineState>::Dispatch(
            manager,
            this,
            pDesc,
            riid,
            ppPipelineState);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<ID3D12Device2>()->CreatePipelineState(
            UnwrapStructPtrObjects(pDesc, unwrap_memory),
            riid,
            ppPipelineState);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppPipelineState, nullptr);
        }

        Encode_ID3D12Device2_CreatePipelineState(
            this,
            result,
            pDesc,
            riid,
            ppPipelineState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device2_CreatePipelineState>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            riid,
            ppPipelineState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device2>()->CreatePipelineState(
            pDesc,
            riid,
            ppPipelineState);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Device3_Wrapper::ID3D12Device3_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Device2_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Device3_Wrapper::OpenExistingHeapFromAddress(
    const void* pAddress,
    REFIID riid,
    void** ppvHeap)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device3_OpenExistingHeapFromAddress>::Dispatch(
            manager,
            this,
            pAddress,
            riid,
            ppvHeap);

        result = GetWrappedObjectAs<ID3D12Device3>()->OpenExistingHeapFromAddress(
            pAddress,
            riid,
            ppvHeap);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvHeap, nullptr);
        }

        Encode_ID3D12Device3_OpenExistingHeapFromAddress(
            this,
            result,
            pAddress,
            riid,
            ppvHeap);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device3_OpenExistingHeapFromAddress>::Dispatch(
            manager,
            this,
            result,
            pAddress,
            riid,
            ppvHeap);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device3>()->OpenExistingHeapFromAddress(
            pAddress,
            riid,
            ppvHeap);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device3_Wrapper::OpenExistingHeapFromFileMapping(
    HANDLE hFileMapping,
    REFIID riid,
    void** ppvHeap)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device3_OpenExistingHeapFromFileMapping>::Dispatch(
            manager,
            this,
            hFileMapping,
            riid,
            ppvHeap);

        result = GetWrappedObjectAs<ID3D12Device3>()->OpenExistingHeapFromFileMapping(
            hFileMapping,
            riid,
            ppvHeap);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvHeap, nullptr);
        }

        Encode_ID3D12Device3_OpenExistingHeapFromFileMapping(
            this,
            result,
            hFileMapping,
            riid,
            ppvHeap);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device3_OpenExistingHeapFromFileMapping>::Dispatch(
            manager,
            this,
            result,
            hFileMapping,
            riid,
            ppvHeap);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device3>()->OpenExistingHeapFromFileMapping(
            hFileMapping,
            riid,
            ppvHeap);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device3_Wrapper::EnqueueMakeResident(
    D3D12_RESIDENCY_FLAGS Flags,
    UINT NumObjects,
    ID3D12Pageable* const* ppObjects,
    ID3D12Fence* pFenceToSignal,
    UINT64 FenceValueToSignal)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device3_EnqueueMakeResident>::Dispatch(
            manager,
            this,
            Flags,
            NumObjects,
            ppObjects,
            pFenceToSignal,
            FenceValueToSignal);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<ID3D12Device3>()->EnqueueMakeResident(
            Flags,
            NumObjects,
            UnwrapObjects<ID3D12Pageable>(ppObjects, NumObjects, unwrap_memory),
            encode::GetWrappedObject<ID3D12Fence>(pFenceToSignal),
            FenceValueToSignal);

        Encode_ID3D12Device3_EnqueueMakeResident(
            this,
            result,
            Flags,
            NumObjects,
            ppObjects,
            pFenceToSignal,
            FenceValueToSignal);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device3_EnqueueMakeResident>::Dispatch(
            manager,
            this,
            result,
            Flags,
            NumObjects,
            ppObjects,
            pFenceToSignal,
            FenceValueToSignal);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device3>()->EnqueueMakeResident(
            Flags,
            NumObjects,
            ppObjects,
            pFenceToSignal,
            FenceValueToSignal);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12ProtectedSession_Wrapper::ID3D12ProtectedSession_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DeviceChild_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12ProtectedSession_Wrapper::GetStatusFence(
    REFIID riid,
    void** ppFence)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12ProtectedSession_GetStatusFence>::Dispatch(
            manager,
            this,
            riid,
            ppFence);

        result = GetWrappedObjectAs<ID3D12ProtectedSession>()->GetStatusFence(
            riid,
            ppFence);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppFence, nullptr);
        }

        Encode_ID3D12ProtectedSession_GetStatusFence(
            this,
            result,
            riid,
            ppFence);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12ProtectedSession_GetStatusFence>::Dispatch(
            manager,
            this,
            result,
            riid,
            ppFence);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12ProtectedSession>()->GetStatusFence(
            riid,
            ppFence);
    }

    manager->DecrementCallScope();

    return result;
}

D3D12_PROTECTED_SESSION_STATUS STDMETHODCALLTYPE ID3D12ProtectedSession_Wrapper::GetSessionStatus()
{
    D3D12_PROTECTED_SESSION_STATUS result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12ProtectedSession_GetSessionStatus>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12ProtectedSession>()->GetSessionStatus();

        Encode_ID3D12ProtectedSession_GetSessionStatus(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12ProtectedSession_GetSessionStatus>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12ProtectedSession>()->GetSessionStatus();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12ProtectedResourceSession_Wrapper::ID3D12ProtectedResourceSession_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12ProtectedSession_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12ProtectedResourceSessionInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12ProtectedResourceSession_Wrapper::~ID3D12ProtectedResourceSession_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12ProtectedResourceSession>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12ProtectedResourceSession_Wrapper* ID3D12ProtectedResourceSession_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12ProtectedResourceSession_Wrapper>(object, object_map_, object_map_lock_);
}

D3D12_PROTECTED_RESOURCE_SESSION_DESC STDMETHODCALLTYPE ID3D12ProtectedResourceSession_Wrapper::GetDesc()
{
    D3D12_PROTECTED_RESOURCE_SESSION_DESC result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12ProtectedResourceSession_GetDesc>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12ProtectedResourceSession>()->GetDesc();

        Encode_ID3D12ProtectedResourceSession_GetDesc(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12ProtectedResourceSession_GetDesc>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12ProtectedResourceSession>()->GetDesc();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Device4_Wrapper::ID3D12Device4_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Device3_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Device4_Wrapper::CreateCommandList1(
    UINT nodeMask,
    D3D12_COMMAND_LIST_TYPE type,
    D3D12_COMMAND_LIST_FLAGS flags,
    REFIID riid,
    void** ppCommandList)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device4_CreateCommandList1>::Dispatch(
            manager,
            this,
            nodeMask,
            type,
            flags,
            riid,
            ppCommandList);

        result = GetWrappedObjectAs<ID3D12Device4>()->CreateCommandList1(
            nodeMask,
            type,
            flags,
            riid,
            ppCommandList);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppCommandList, nullptr);
        }

        Encode_ID3D12Device4_CreateCommandList1(
            this,
            result,
            nodeMask,
            type,
            flags,
            riid,
            ppCommandList);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device4_CreateCommandList1>::Dispatch(
            manager,
            this,
            result,
            nodeMask,
            type,
            flags,
            riid,
            ppCommandList);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device4>()->CreateCommandList1(
            nodeMask,
            type,
            flags,
            riid,
            ppCommandList);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device4_Wrapper::CreateProtectedResourceSession(
    const D3D12_PROTECTED_RESOURCE_SESSION_DESC* pDesc,
    REFIID riid,
    void** ppSession)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device4_CreateProtectedResourceSession>::Dispatch(
            manager,
            this,
            pDesc,
            riid,
            ppSession);

        result = GetWrappedObjectAs<ID3D12Device4>()->CreateProtectedResourceSession(
            pDesc,
            riid,
            ppSession);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppSession, nullptr);
        }

        Encode_ID3D12Device4_CreateProtectedResourceSession(
            this,
            result,
            pDesc,
            riid,
            ppSession);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device4_CreateProtectedResourceSession>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            riid,
            ppSession);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device4>()->CreateProtectedResourceSession(
            pDesc,
            riid,
            ppSession);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device4_Wrapper::CreateCommittedResource1(
    const D3D12_HEAP_PROPERTIES* pHeapProperties,
    D3D12_HEAP_FLAGS HeapFlags,
    const D3D12_RESOURCE_DESC* pDesc,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE* pOptimizedClearValue,
    ID3D12ProtectedResourceSession* pProtectedSession,
    REFIID riidResource,
    void** ppvResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device4_CreateCommittedResource1>::Dispatch(
            manager,
            this,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            pProtectedSession,
            riidResource,
            ppvResource);

        result = D3D12CaptureManager::Get()->OverrideID3D12Device_CreateCommittedResource1(
            this,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            pProtectedSession,
            riidResource,
            ppvResource);

        if (SUCCEEDED(result))
        {
            WrapObject(riidResource, ppvResource, nullptr);
        }

        Encode_ID3D12Device4_CreateCommittedResource1(
            this,
            result,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            pProtectedSession,
            riidResource,
            ppvResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device4_CreateCommittedResource1>::Dispatch(
            manager,
            this,
            result,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            pProtectedSession,
            riidResource,
            ppvResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device4>()->CreateCommittedResource1(
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            pProtectedSession,
            riidResource,
            ppvResource);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device4_Wrapper::CreateHeap1(
    const D3D12_HEAP_DESC* pDesc,
    ID3D12ProtectedResourceSession* pProtectedSession,
    REFIID riid,
    void** ppvHeap)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device4_CreateHeap1>::Dispatch(
            manager,
            this,
            pDesc,
            pProtectedSession,
            riid,
            ppvHeap);

        result = D3D12CaptureManager::Get()->OverrideID3D12Device_CreateHeap1(
            this,
            pDesc,
            pProtectedSession,
            riid,
            ppvHeap);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvHeap, nullptr);
        }

        Encode_ID3D12Device4_CreateHeap1(
            this,
            result,
            pDesc,
            pProtectedSession,
            riid,
            ppvHeap);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device4_CreateHeap1>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            pProtectedSession,
            riid,
            ppvHeap);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device4>()->CreateHeap1(
            pDesc,
            pProtectedSession,
            riid,
            ppvHeap);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device4_Wrapper::CreateReservedResource1(
    const D3D12_RESOURCE_DESC* pDesc,
    D3D12_RESOURCE_STATES InitialState,
    const D3D12_CLEAR_VALUE* pOptimizedClearValue,
    ID3D12ProtectedResourceSession* pProtectedSession,
    REFIID riid,
    void** ppvResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device4_CreateReservedResource1>::Dispatch(
            manager,
            this,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            pProtectedSession,
            riid,
            ppvResource);

        result = GetWrappedObjectAs<ID3D12Device4>()->CreateReservedResource1(
            pDesc,
            InitialState,
            pOptimizedClearValue,
            encode::GetWrappedObject<ID3D12ProtectedResourceSession>(pProtectedSession),
            riid,
            ppvResource);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvResource, nullptr);
        }

        Encode_ID3D12Device4_CreateReservedResource1(
            this,
            result,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            pProtectedSession,
            riid,
            ppvResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device4_CreateReservedResource1>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            pProtectedSession,
            riid,
            ppvResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device4>()->CreateReservedResource1(
            pDesc,
            InitialState,
            pOptimizedClearValue,
            pProtectedSession,
            riid,
            ppvResource);
    }

    manager->DecrementCallScope();

    return result;
}

D3D12_RESOURCE_ALLOCATION_INFO STDMETHODCALLTYPE ID3D12Device4_Wrapper::GetResourceAllocationInfo1(
    UINT visibleMask,
    UINT numResourceDescs,
    const D3D12_RESOURCE_DESC* pResourceDescs,
    D3D12_RESOURCE_ALLOCATION_INFO1* pResourceAllocationInfo1)
{
    D3D12_RESOURCE_ALLOCATION_INFO result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device4_GetResourceAllocationInfo1>::Dispatch(
            manager,
            this,
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pResourceAllocationInfo1);

        result = GetWrappedObjectAs<ID3D12Device4>()->GetResourceAllocationInfo1(
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pResourceAllocationInfo1);

        Encode_ID3D12Device4_GetResourceAllocationInfo1(
            this,
            result,
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pResourceAllocationInfo1);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device4_GetResourceAllocationInfo1>::Dispatch(
            manager,
            this,
            result,
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pResourceAllocationInfo1);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device4>()->GetResourceAllocationInfo1(
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pResourceAllocationInfo1);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12LifetimeOwner_Wrapper::ID3D12LifetimeOwner_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12LifetimeOwnerInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12LifetimeOwner_Wrapper::~ID3D12LifetimeOwner_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12LifetimeOwner>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12LifetimeOwner_Wrapper* ID3D12LifetimeOwner_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12LifetimeOwner_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D12LifetimeOwner_Wrapper::LifetimeStateUpdated(
    D3D12_LIFETIME_STATE NewState)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12LifetimeOwner_LifetimeStateUpdated>::Dispatch(
            manager,
            this,
            NewState);

        GetWrappedObjectAs<ID3D12LifetimeOwner>()->LifetimeStateUpdated(
            NewState);

        Encode_ID3D12LifetimeOwner_LifetimeStateUpdated(
            this,
            NewState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12LifetimeOwner_LifetimeStateUpdated>::Dispatch(
            manager,
            this,
            NewState);
    }
    else
    {
        GetWrappedObjectAs<ID3D12LifetimeOwner>()->LifetimeStateUpdated(
            NewState);
    }

    manager->DecrementCallScope();
}

ID3D12SwapChainAssistant_Wrapper::ID3D12SwapChainAssistant_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12SwapChainAssistantInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12SwapChainAssistant_Wrapper::~ID3D12SwapChainAssistant_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12SwapChainAssistant>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12SwapChainAssistant_Wrapper* ID3D12SwapChainAssistant_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12SwapChainAssistant_Wrapper>(object, object_map_, object_map_lock_);
}

LUID STDMETHODCALLTYPE ID3D12SwapChainAssistant_Wrapper::GetLUID()
{
    LUID result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12SwapChainAssistant_GetLUID>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12SwapChainAssistant>()->GetLUID();

        Encode_ID3D12SwapChainAssistant_GetLUID(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12SwapChainAssistant_GetLUID>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12SwapChainAssistant>()->GetLUID();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12SwapChainAssistant_Wrapper::GetSwapChainObject(
    REFIID riid,
    void** ppv)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12SwapChainAssistant_GetSwapChainObject>::Dispatch(
            manager,
            this,
            riid,
            ppv);

        result = GetWrappedObjectAs<ID3D12SwapChainAssistant>()->GetSwapChainObject(
            riid,
            ppv);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppv, nullptr);
        }

        Encode_ID3D12SwapChainAssistant_GetSwapChainObject(
            this,
            result,
            riid,
            ppv);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12SwapChainAssistant_GetSwapChainObject>::Dispatch(
            manager,
            this,
            result,
            riid,
            ppv);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12SwapChainAssistant>()->GetSwapChainObject(
            riid,
            ppv);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12SwapChainAssistant_Wrapper::GetCurrentResourceAndCommandQueue(
    REFIID riidResource,
    void** ppvResource,
    REFIID riidQueue,
    void** ppvQueue)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12SwapChainAssistant_GetCurrentResourceAndCommandQueue>::Dispatch(
            manager,
            this,
            riidResource,
            ppvResource,
            riidQueue,
            ppvQueue);

        result = GetWrappedObjectAs<ID3D12SwapChainAssistant>()->GetCurrentResourceAndCommandQueue(
            riidResource,
            ppvResource,
            riidQueue,
            ppvQueue);

        if (SUCCEEDED(result))
        {
            WrapObject(riidResource, ppvResource, nullptr);
            WrapObject(riidQueue, ppvQueue, nullptr);
        }

        Encode_ID3D12SwapChainAssistant_GetCurrentResourceAndCommandQueue(
            this,
            result,
            riidResource,
            ppvResource,
            riidQueue,
            ppvQueue);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12SwapChainAssistant_GetCurrentResourceAndCommandQueue>::Dispatch(
            manager,
            this,
            result,
            riidResource,
            ppvResource,
            riidQueue,
            ppvQueue);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12SwapChainAssistant>()->GetCurrentResourceAndCommandQueue(
            riidResource,
            ppvResource,
            riidQueue,
            ppvQueue);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12SwapChainAssistant_Wrapper::InsertImplicitSync()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12SwapChainAssistant_InsertImplicitSync>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12SwapChainAssistant>()->InsertImplicitSync();

        Encode_ID3D12SwapChainAssistant_InsertImplicitSync(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12SwapChainAssistant_InsertImplicitSync>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12SwapChainAssistant>()->InsertImplicitSync();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12LifetimeTracker_Wrapper::ID3D12LifetimeTracker_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12LifetimeTrackerInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12LifetimeTracker_Wrapper::~ID3D12LifetimeTracker_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12LifetimeTracker>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12LifetimeTracker_Wrapper* ID3D12LifetimeTracker_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12LifetimeTracker_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12LifetimeTracker_Wrapper::DestroyOwnedObject(
    ID3D12DeviceChild* pObject)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12LifetimeTracker_DestroyOwnedObject>::Dispatch(
            manager,
            this,
            pObject);

        result = GetWrappedObjectAs<ID3D12LifetimeTracker>()->DestroyOwnedObject(
            encode::GetWrappedObject<ID3D12DeviceChild>(pObject));

        Encode_ID3D12LifetimeTracker_DestroyOwnedObject(
            this,
            result,
            pObject);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12LifetimeTracker_DestroyOwnedObject>::Dispatch(
            manager,
            this,
            result,
            pObject);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12LifetimeTracker>()->DestroyOwnedObject(
            pObject);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12StateObject_Wrapper::ID3D12StateObject_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Pageable_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12StateObjectInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12StateObject_Wrapper::~ID3D12StateObject_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12StateObject>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12StateObject_Wrapper* ID3D12StateObject_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12StateObject_Wrapper>(object, object_map_, object_map_lock_);
}

ID3D12StateObjectProperties_Wrapper::ID3D12StateObjectProperties_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12StateObjectPropertiesInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12StateObjectProperties_Wrapper::~ID3D12StateObjectProperties_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12StateObjectProperties>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12StateObjectProperties_Wrapper* ID3D12StateObjectProperties_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12StateObjectProperties_Wrapper>(object, object_map_, object_map_lock_);
}

void* STDMETHODCALLTYPE ID3D12StateObjectProperties_Wrapper::GetShaderIdentifier(
    LPCWSTR pExportName)
{
    void* result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12StateObjectProperties_GetShaderIdentifier>::Dispatch(
            manager,
            this,
            pExportName);

        result = GetWrappedObjectAs<ID3D12StateObjectProperties>()->GetShaderIdentifier(
            pExportName);

        Encode_ID3D12StateObjectProperties_GetShaderIdentifier(
            this,
            result,
            pExportName);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12StateObjectProperties_GetShaderIdentifier>::Dispatch(
            manager,
            this,
            result,
            pExportName);

        RvAnnotationUtil::AddRvAnnotation(&result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12StateObjectProperties>()->GetShaderIdentifier(
            pExportName);
    }

    manager->DecrementCallScope();

    return result;
}

UINT64 STDMETHODCALLTYPE ID3D12StateObjectProperties_Wrapper::GetShaderStackSize(
    LPCWSTR pExportName)
{
    UINT64 result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12StateObjectProperties_GetShaderStackSize>::Dispatch(
            manager,
            this,
            pExportName);

        result = GetWrappedObjectAs<ID3D12StateObjectProperties>()->GetShaderStackSize(
            pExportName);

        Encode_ID3D12StateObjectProperties_GetShaderStackSize(
            this,
            result,
            pExportName);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12StateObjectProperties_GetShaderStackSize>::Dispatch(
            manager,
            this,
            result,
            pExportName);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12StateObjectProperties>()->GetShaderStackSize(
            pExportName);
    }

    manager->DecrementCallScope();

    return result;
}

UINT64 STDMETHODCALLTYPE ID3D12StateObjectProperties_Wrapper::GetPipelineStackSize()
{
    UINT64 result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12StateObjectProperties_GetPipelineStackSize>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12StateObjectProperties>()->GetPipelineStackSize();

        Encode_ID3D12StateObjectProperties_GetPipelineStackSize(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12StateObjectProperties_GetPipelineStackSize>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12StateObjectProperties>()->GetPipelineStackSize();
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12StateObjectProperties_Wrapper::SetPipelineStackSize(
    UINT64 PipelineStackSizeInBytes)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12StateObjectProperties_SetPipelineStackSize>::Dispatch(
            manager,
            this,
            PipelineStackSizeInBytes);

        GetWrappedObjectAs<ID3D12StateObjectProperties>()->SetPipelineStackSize(
            PipelineStackSizeInBytes);

        Encode_ID3D12StateObjectProperties_SetPipelineStackSize(
            this,
            PipelineStackSizeInBytes);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12StateObjectProperties_SetPipelineStackSize>::Dispatch(
            manager,
            this,
            PipelineStackSizeInBytes);
    }
    else
    {
        GetWrappedObjectAs<ID3D12StateObjectProperties>()->SetPipelineStackSize(
            PipelineStackSizeInBytes);
    }

    manager->DecrementCallScope();
}

ID3D12StateObjectProperties1_Wrapper::ID3D12StateObjectProperties1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12StateObjectProperties_Wrapper(riid, object, resources, destructor)
{
}

D3D12_PROGRAM_IDENTIFIER STDMETHODCALLTYPE ID3D12StateObjectProperties1_Wrapper::GetProgramIdentifier(
    LPCWSTR pProgramName)
{
    D3D12_PROGRAM_IDENTIFIER result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12StateObjectProperties1_GetProgramIdentifier>::Dispatch(
            manager,
            this,
            pProgramName);

        result = GetWrappedObjectAs<ID3D12StateObjectProperties1>()->GetProgramIdentifier(
            pProgramName);

        Encode_ID3D12StateObjectProperties1_GetProgramIdentifier(
            this,
            result,
            pProgramName);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12StateObjectProperties1_GetProgramIdentifier>::Dispatch(
            manager,
            this,
            result,
            pProgramName);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12StateObjectProperties1>()->GetProgramIdentifier(
            pProgramName);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12WorkGraphProperties_Wrapper::ID3D12WorkGraphProperties_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12WorkGraphPropertiesInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12WorkGraphProperties_Wrapper::~ID3D12WorkGraphProperties_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12WorkGraphProperties>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12WorkGraphProperties_Wrapper* ID3D12WorkGraphProperties_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12WorkGraphProperties_Wrapper>(object, object_map_, object_map_lock_);
}

UINT STDMETHODCALLTYPE ID3D12WorkGraphProperties_Wrapper::GetNumWorkGraphs()
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetNumWorkGraphs>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetNumWorkGraphs();

        Encode_ID3D12WorkGraphProperties_GetNumWorkGraphs(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetNumWorkGraphs>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetNumWorkGraphs();
    }

    manager->DecrementCallScope();

    return result;
}

LPCWSTR STDMETHODCALLTYPE ID3D12WorkGraphProperties_Wrapper::GetProgramName(
    UINT WorkGraphIndex)
{
    LPCWSTR result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetProgramName>::Dispatch(
            manager,
            this,
            WorkGraphIndex);

        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetProgramName(
            WorkGraphIndex);

        Encode_ID3D12WorkGraphProperties_GetProgramName(
            this,
            result,
            WorkGraphIndex);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetProgramName>::Dispatch(
            manager,
            this,
            result,
            WorkGraphIndex);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetProgramName(
            WorkGraphIndex);
    }

    manager->DecrementCallScope();

    return result;
}

UINT STDMETHODCALLTYPE ID3D12WorkGraphProperties_Wrapper::GetWorkGraphIndex(
    LPCWSTR pProgramName)
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetWorkGraphIndex>::Dispatch(
            manager,
            this,
            pProgramName);

        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetWorkGraphIndex(
            pProgramName);

        Encode_ID3D12WorkGraphProperties_GetWorkGraphIndex(
            this,
            result,
            pProgramName);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetWorkGraphIndex>::Dispatch(
            manager,
            this,
            result,
            pProgramName);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetWorkGraphIndex(
            pProgramName);
    }

    manager->DecrementCallScope();

    return result;
}

UINT STDMETHODCALLTYPE ID3D12WorkGraphProperties_Wrapper::GetNumNodes(
    UINT WorkGraphIndex)
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetNumNodes>::Dispatch(
            manager,
            this,
            WorkGraphIndex);

        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetNumNodes(
            WorkGraphIndex);

        Encode_ID3D12WorkGraphProperties_GetNumNodes(
            this,
            result,
            WorkGraphIndex);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetNumNodes>::Dispatch(
            manager,
            this,
            result,
            WorkGraphIndex);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetNumNodes(
            WorkGraphIndex);
    }

    manager->DecrementCallScope();

    return result;
}

D3D12_NODE_ID STDMETHODCALLTYPE ID3D12WorkGraphProperties_Wrapper::GetNodeID(
    UINT WorkGraphIndex,
    UINT NodeIndex)
{
    D3D12_NODE_ID result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetNodeID>::Dispatch(
            manager,
            this,
            WorkGraphIndex,
            NodeIndex);

        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetNodeID(
            WorkGraphIndex,
            NodeIndex);

        Encode_ID3D12WorkGraphProperties_GetNodeID(
            this,
            result,
            WorkGraphIndex,
            NodeIndex);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetNodeID>::Dispatch(
            manager,
            this,
            result,
            WorkGraphIndex,
            NodeIndex);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetNodeID(
            WorkGraphIndex,
            NodeIndex);
    }

    manager->DecrementCallScope();

    return result;
}

UINT STDMETHODCALLTYPE ID3D12WorkGraphProperties_Wrapper::GetNodeIndex(
    UINT WorkGraphIndex,
    D3D12_NODE_ID NodeID)
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetNodeIndex>::Dispatch(
            manager,
            this,
            WorkGraphIndex,
            NodeID);

        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetNodeIndex(
            WorkGraphIndex,
            NodeID);

        Encode_ID3D12WorkGraphProperties_GetNodeIndex(
            this,
            result,
            WorkGraphIndex,
            NodeID);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetNodeIndex>::Dispatch(
            manager,
            this,
            result,
            WorkGraphIndex,
            NodeID);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetNodeIndex(
            WorkGraphIndex,
            NodeID);
    }

    manager->DecrementCallScope();

    return result;
}

UINT STDMETHODCALLTYPE ID3D12WorkGraphProperties_Wrapper::GetNodeLocalRootArgumentsTableIndex(
    UINT WorkGraphIndex,
    UINT NodeIndex)
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetNodeLocalRootArgumentsTableIndex>::Dispatch(
            manager,
            this,
            WorkGraphIndex,
            NodeIndex);

        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetNodeLocalRootArgumentsTableIndex(
            WorkGraphIndex,
            NodeIndex);

        Encode_ID3D12WorkGraphProperties_GetNodeLocalRootArgumentsTableIndex(
            this,
            result,
            WorkGraphIndex,
            NodeIndex);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetNodeLocalRootArgumentsTableIndex>::Dispatch(
            manager,
            this,
            result,
            WorkGraphIndex,
            NodeIndex);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetNodeLocalRootArgumentsTableIndex(
            WorkGraphIndex,
            NodeIndex);
    }

    manager->DecrementCallScope();

    return result;
}

UINT STDMETHODCALLTYPE ID3D12WorkGraphProperties_Wrapper::GetNumEntrypoints(
    UINT WorkGraphIndex)
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetNumEntrypoints>::Dispatch(
            manager,
            this,
            WorkGraphIndex);

        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetNumEntrypoints(
            WorkGraphIndex);

        Encode_ID3D12WorkGraphProperties_GetNumEntrypoints(
            this,
            result,
            WorkGraphIndex);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetNumEntrypoints>::Dispatch(
            manager,
            this,
            result,
            WorkGraphIndex);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetNumEntrypoints(
            WorkGraphIndex);
    }

    manager->DecrementCallScope();

    return result;
}

D3D12_NODE_ID STDMETHODCALLTYPE ID3D12WorkGraphProperties_Wrapper::GetEntrypointID(
    UINT WorkGraphIndex,
    UINT EntrypointIndex)
{
    D3D12_NODE_ID result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetEntrypointID>::Dispatch(
            manager,
            this,
            WorkGraphIndex,
            EntrypointIndex);

        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetEntrypointID(
            WorkGraphIndex,
            EntrypointIndex);

        Encode_ID3D12WorkGraphProperties_GetEntrypointID(
            this,
            result,
            WorkGraphIndex,
            EntrypointIndex);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetEntrypointID>::Dispatch(
            manager,
            this,
            result,
            WorkGraphIndex,
            EntrypointIndex);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetEntrypointID(
            WorkGraphIndex,
            EntrypointIndex);
    }

    manager->DecrementCallScope();

    return result;
}

UINT STDMETHODCALLTYPE ID3D12WorkGraphProperties_Wrapper::GetEntrypointIndex(
    UINT WorkGraphIndex,
    D3D12_NODE_ID NodeID)
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetEntrypointIndex>::Dispatch(
            manager,
            this,
            WorkGraphIndex,
            NodeID);

        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetEntrypointIndex(
            WorkGraphIndex,
            NodeID);

        Encode_ID3D12WorkGraphProperties_GetEntrypointIndex(
            this,
            result,
            WorkGraphIndex,
            NodeID);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetEntrypointIndex>::Dispatch(
            manager,
            this,
            result,
            WorkGraphIndex,
            NodeID);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetEntrypointIndex(
            WorkGraphIndex,
            NodeID);
    }

    manager->DecrementCallScope();

    return result;
}

UINT STDMETHODCALLTYPE ID3D12WorkGraphProperties_Wrapper::GetEntrypointRecordSizeInBytes(
    UINT WorkGraphIndex,
    UINT EntrypointIndex)
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetEntrypointRecordSizeInBytes>::Dispatch(
            manager,
            this,
            WorkGraphIndex,
            EntrypointIndex);

        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetEntrypointRecordSizeInBytes(
            WorkGraphIndex,
            EntrypointIndex);

        Encode_ID3D12WorkGraphProperties_GetEntrypointRecordSizeInBytes(
            this,
            result,
            WorkGraphIndex,
            EntrypointIndex);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetEntrypointRecordSizeInBytes>::Dispatch(
            manager,
            this,
            result,
            WorkGraphIndex,
            EntrypointIndex);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetEntrypointRecordSizeInBytes(
            WorkGraphIndex,
            EntrypointIndex);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12WorkGraphProperties_Wrapper::GetWorkGraphMemoryRequirements(
    UINT WorkGraphIndex,
    D3D12_WORK_GRAPH_MEMORY_REQUIREMENTS* pWorkGraphMemoryRequirements)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetWorkGraphMemoryRequirements>::Dispatch(
            manager,
            this,
            WorkGraphIndex,
            pWorkGraphMemoryRequirements);

        GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetWorkGraphMemoryRequirements(
            WorkGraphIndex,
            pWorkGraphMemoryRequirements);

        Encode_ID3D12WorkGraphProperties_GetWorkGraphMemoryRequirements(
            this,
            WorkGraphIndex,
            pWorkGraphMemoryRequirements);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetWorkGraphMemoryRequirements>::Dispatch(
            manager,
            this,
            WorkGraphIndex,
            pWorkGraphMemoryRequirements);
    }
    else
    {
        GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetWorkGraphMemoryRequirements(
            WorkGraphIndex,
            pWorkGraphMemoryRequirements);
    }

    manager->DecrementCallScope();
}

UINT STDMETHODCALLTYPE ID3D12WorkGraphProperties_Wrapper::GetEntrypointRecordAlignmentInBytes(
    UINT WorkGraphIndex,
    UINT EntrypointIndex)
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetEntrypointRecordAlignmentInBytes>::Dispatch(
            manager,
            this,
            WorkGraphIndex,
            EntrypointIndex);

        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetEntrypointRecordAlignmentInBytes(
            WorkGraphIndex,
            EntrypointIndex);

        Encode_ID3D12WorkGraphProperties_GetEntrypointRecordAlignmentInBytes(
            this,
            result,
            WorkGraphIndex,
            EntrypointIndex);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12WorkGraphProperties_GetEntrypointRecordAlignmentInBytes>::Dispatch(
            manager,
            this,
            result,
            WorkGraphIndex,
            EntrypointIndex);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12WorkGraphProperties>()->GetEntrypointRecordAlignmentInBytes(
            WorkGraphIndex,
            EntrypointIndex);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Device5_Wrapper::ID3D12Device5_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Device4_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Device5_Wrapper::CreateLifetimeTracker(
    ID3D12LifetimeOwner* pOwner,
    REFIID riid,
    void** ppvTracker)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device5_CreateLifetimeTracker>::Dispatch(
            manager,
            this,
            pOwner,
            riid,
            ppvTracker);

        result = GetWrappedObjectAs<ID3D12Device5>()->CreateLifetimeTracker(
            encode::GetWrappedObject<ID3D12LifetimeOwner>(pOwner),
            riid,
            ppvTracker);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvTracker, nullptr);
        }

        Encode_ID3D12Device5_CreateLifetimeTracker(
            this,
            result,
            pOwner,
            riid,
            ppvTracker);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device5_CreateLifetimeTracker>::Dispatch(
            manager,
            this,
            result,
            pOwner,
            riid,
            ppvTracker);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device5>()->CreateLifetimeTracker(
            pOwner,
            riid,
            ppvTracker);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12Device5_Wrapper::RemoveDevice()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device5_RemoveDevice>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12Device5>()->RemoveDevice();

        Encode_ID3D12Device5_RemoveDevice(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device5_RemoveDevice>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device5>()->RemoveDevice();
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D12Device5_Wrapper::EnumerateMetaCommands(
    UINT* pNumMetaCommands,
    D3D12_META_COMMAND_DESC* pDescs)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device5_EnumerateMetaCommands>::Dispatch(
            manager,
            this,
            pNumMetaCommands,
            pDescs);

        result = GetWrappedObjectAs<ID3D12Device5>()->EnumerateMetaCommands(
            pNumMetaCommands,
            pDescs);

        Encode_ID3D12Device5_EnumerateMetaCommands(
            this,
            result,
            pNumMetaCommands,
            pDescs);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device5_EnumerateMetaCommands>::Dispatch(
            manager,
            this,
            result,
            pNumMetaCommands,
            pDescs);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device5>()->EnumerateMetaCommands(
            pNumMetaCommands,
            pDescs);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device5_Wrapper::EnumerateMetaCommandParameters(
    REFGUID CommandId,
    D3D12_META_COMMAND_PARAMETER_STAGE Stage,
    UINT* pTotalStructureSizeInBytes,
    UINT* pParameterCount,
    D3D12_META_COMMAND_PARAMETER_DESC* pParameterDescs)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device5_EnumerateMetaCommandParameters>::Dispatch(
            manager,
            this,
            CommandId,
            Stage,
            pTotalStructureSizeInBytes,
            pParameterCount,
            pParameterDescs);

        result = GetWrappedObjectAs<ID3D12Device5>()->EnumerateMetaCommandParameters(
            CommandId,
            Stage,
            pTotalStructureSizeInBytes,
            pParameterCount,
            pParameterDescs);

        Encode_ID3D12Device5_EnumerateMetaCommandParameters(
            this,
            result,
            CommandId,
            Stage,
            pTotalStructureSizeInBytes,
            pParameterCount,
            pParameterDescs);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device5_EnumerateMetaCommandParameters>::Dispatch(
            manager,
            this,
            result,
            CommandId,
            Stage,
            pTotalStructureSizeInBytes,
            pParameterCount,
            pParameterDescs);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device5>()->EnumerateMetaCommandParameters(
            CommandId,
            Stage,
            pTotalStructureSizeInBytes,
            pParameterCount,
            pParameterDescs);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device5_Wrapper::CreateMetaCommand(
    REFGUID CommandId,
    UINT NodeMask,
    const void* pCreationParametersData,
    SIZE_T CreationParametersDataSizeInBytes,
    REFIID riid,
    void** ppMetaCommand)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device5_CreateMetaCommand>::Dispatch(
            manager,
            this,
            CommandId,
            NodeMask,
            pCreationParametersData,
            CreationParametersDataSizeInBytes,
            riid,
            ppMetaCommand);

        result = GetWrappedObjectAs<ID3D12Device5>()->CreateMetaCommand(
            CommandId,
            NodeMask,
            pCreationParametersData,
            CreationParametersDataSizeInBytes,
            riid,
            ppMetaCommand);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppMetaCommand, nullptr);
        }

        Encode_ID3D12Device5_CreateMetaCommand(
            this,
            result,
            CommandId,
            NodeMask,
            pCreationParametersData,
            CreationParametersDataSizeInBytes,
            riid,
            ppMetaCommand);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device5_CreateMetaCommand>::Dispatch(
            manager,
            this,
            result,
            CommandId,
            NodeMask,
            pCreationParametersData,
            CreationParametersDataSizeInBytes,
            riid,
            ppMetaCommand);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device5>()->CreateMetaCommand(
            CommandId,
            NodeMask,
            pCreationParametersData,
            CreationParametersDataSizeInBytes,
            riid,
            ppMetaCommand);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device5_Wrapper::CreateStateObject(
    const D3D12_STATE_OBJECT_DESC* pDesc,
    REFIID riid,
    void** ppStateObject)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device5_CreateStateObject>::Dispatch(
            manager,
            this,
            pDesc,
            riid,
            ppStateObject);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<ID3D12Device5>()->CreateStateObject(
            UnwrapStructPtrObjects(pDesc, unwrap_memory),
            riid,
            ppStateObject);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppStateObject, nullptr);
        }

        Encode_ID3D12Device5_CreateStateObject(
            this,
            result,
            pDesc,
            riid,
            ppStateObject);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device5_CreateStateObject>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            riid,
            ppStateObject);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device5>()->CreateStateObject(
            pDesc,
            riid,
            ppStateObject);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12Device5_Wrapper::GetRaytracingAccelerationStructurePrebuildInfo(
    const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS* pDesc,
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_PREBUILD_INFO* pInfo)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        std::unique_ptr<D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_INPUTS> pDesc_unannotated = nullptr;
        std::unique_ptr<D3D12_RAYTRACING_GEOMETRY_DESC[]> pDesc_dependency = nullptr;
        if((manager->IsAnnotated() == true) && (pDesc != nullptr))
        {
            pDesc_unannotated = RvAnnotationUtil::RemoveStructRvAnnotations(pDesc, pDesc_dependency);
            pDesc = pDesc_unannotated.get();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device5_GetRaytracingAccelerationStructurePrebuildInfo>::Dispatch(
            manager,
            this,
            pDesc,
            pInfo);

        D3D12CaptureManager::Get()->OverrideGetRaytracingAccelerationStructurePrebuildInfo(
            this,
            pDesc,
            pInfo);

        Encode_ID3D12Device5_GetRaytracingAccelerationStructurePrebuildInfo(
            this,
            pDesc,
            pInfo);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device5_GetRaytracingAccelerationStructurePrebuildInfo>::Dispatch(
            manager,
            this,
            pDesc,
            pInfo);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device5>()->GetRaytracingAccelerationStructurePrebuildInfo(
            pDesc,
            pInfo);
    }

    manager->DecrementCallScope();
}

D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS STDMETHODCALLTYPE ID3D12Device5_Wrapper::CheckDriverMatchingIdentifier(
    D3D12_SERIALIZED_DATA_TYPE SerializedDataType,
    const D3D12_SERIALIZED_DATA_DRIVER_MATCHING_IDENTIFIER* pIdentifierToCheck)
{
    D3D12_DRIVER_MATCHING_IDENTIFIER_STATUS result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device5_CheckDriverMatchingIdentifier>::Dispatch(
            manager,
            this,
            SerializedDataType,
            pIdentifierToCheck);

        result = GetWrappedObjectAs<ID3D12Device5>()->CheckDriverMatchingIdentifier(
            SerializedDataType,
            pIdentifierToCheck);

        Encode_ID3D12Device5_CheckDriverMatchingIdentifier(
            this,
            result,
            SerializedDataType,
            pIdentifierToCheck);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device5_CheckDriverMatchingIdentifier>::Dispatch(
            manager,
            this,
            result,
            SerializedDataType,
            pIdentifierToCheck);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device5>()->CheckDriverMatchingIdentifier(
            SerializedDataType,
            pIdentifierToCheck);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DeviceRemovedExtendedDataSettings_Wrapper::ID3D12DeviceRemovedExtendedDataSettings_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12DeviceRemovedExtendedDataSettingsInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12DeviceRemovedExtendedDataSettings_Wrapper::~ID3D12DeviceRemovedExtendedDataSettings_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12DeviceRemovedExtendedDataSettings>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12DeviceRemovedExtendedDataSettings_Wrapper* ID3D12DeviceRemovedExtendedDataSettings_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12DeviceRemovedExtendedDataSettings_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D12DeviceRemovedExtendedDataSettings_Wrapper::SetAutoBreadcrumbsEnablement(
    D3D12_DRED_ENABLEMENT Enablement)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedDataSettings_SetAutoBreadcrumbsEnablement>::Dispatch(
            manager,
            this,
            Enablement);

        GetWrappedObjectAs<ID3D12DeviceRemovedExtendedDataSettings>()->SetAutoBreadcrumbsEnablement(
            Enablement);

        Encode_ID3D12DeviceRemovedExtendedDataSettings_SetAutoBreadcrumbsEnablement(
            this,
            Enablement);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedDataSettings_SetAutoBreadcrumbsEnablement>::Dispatch(
            manager,
            this,
            Enablement);
    }
    else
    {
        GetWrappedObjectAs<ID3D12DeviceRemovedExtendedDataSettings>()->SetAutoBreadcrumbsEnablement(
            Enablement);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12DeviceRemovedExtendedDataSettings_Wrapper::SetPageFaultEnablement(
    D3D12_DRED_ENABLEMENT Enablement)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedDataSettings_SetPageFaultEnablement>::Dispatch(
            manager,
            this,
            Enablement);

        GetWrappedObjectAs<ID3D12DeviceRemovedExtendedDataSettings>()->SetPageFaultEnablement(
            Enablement);

        Encode_ID3D12DeviceRemovedExtendedDataSettings_SetPageFaultEnablement(
            this,
            Enablement);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedDataSettings_SetPageFaultEnablement>::Dispatch(
            manager,
            this,
            Enablement);
    }
    else
    {
        GetWrappedObjectAs<ID3D12DeviceRemovedExtendedDataSettings>()->SetPageFaultEnablement(
            Enablement);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12DeviceRemovedExtendedDataSettings_Wrapper::SetWatsonDumpEnablement(
    D3D12_DRED_ENABLEMENT Enablement)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedDataSettings_SetWatsonDumpEnablement>::Dispatch(
            manager,
            this,
            Enablement);

        GetWrappedObjectAs<ID3D12DeviceRemovedExtendedDataSettings>()->SetWatsonDumpEnablement(
            Enablement);

        Encode_ID3D12DeviceRemovedExtendedDataSettings_SetWatsonDumpEnablement(
            this,
            Enablement);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedDataSettings_SetWatsonDumpEnablement>::Dispatch(
            manager,
            this,
            Enablement);
    }
    else
    {
        GetWrappedObjectAs<ID3D12DeviceRemovedExtendedDataSettings>()->SetWatsonDumpEnablement(
            Enablement);
    }

    manager->DecrementCallScope();
}

ID3D12DeviceRemovedExtendedDataSettings1_Wrapper::ID3D12DeviceRemovedExtendedDataSettings1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DeviceRemovedExtendedDataSettings_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12DeviceRemovedExtendedDataSettings1_Wrapper::SetBreadcrumbContextEnablement(
    D3D12_DRED_ENABLEMENT Enablement)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedDataSettings1_SetBreadcrumbContextEnablement>::Dispatch(
            manager,
            this,
            Enablement);

        GetWrappedObjectAs<ID3D12DeviceRemovedExtendedDataSettings1>()->SetBreadcrumbContextEnablement(
            Enablement);

        Encode_ID3D12DeviceRemovedExtendedDataSettings1_SetBreadcrumbContextEnablement(
            this,
            Enablement);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedDataSettings1_SetBreadcrumbContextEnablement>::Dispatch(
            manager,
            this,
            Enablement);
    }
    else
    {
        GetWrappedObjectAs<ID3D12DeviceRemovedExtendedDataSettings1>()->SetBreadcrumbContextEnablement(
            Enablement);
    }

    manager->DecrementCallScope();
}

ID3D12DeviceRemovedExtendedDataSettings2_Wrapper::ID3D12DeviceRemovedExtendedDataSettings2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DeviceRemovedExtendedDataSettings1_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12DeviceRemovedExtendedDataSettings2_Wrapper::UseMarkersOnlyAutoBreadcrumbs(
    BOOL MarkersOnly)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedDataSettings2_UseMarkersOnlyAutoBreadcrumbs>::Dispatch(
            manager,
            this,
            MarkersOnly);

        GetWrappedObjectAs<ID3D12DeviceRemovedExtendedDataSettings2>()->UseMarkersOnlyAutoBreadcrumbs(
            MarkersOnly);

        Encode_ID3D12DeviceRemovedExtendedDataSettings2_UseMarkersOnlyAutoBreadcrumbs(
            this,
            MarkersOnly);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedDataSettings2_UseMarkersOnlyAutoBreadcrumbs>::Dispatch(
            manager,
            this,
            MarkersOnly);
    }
    else
    {
        GetWrappedObjectAs<ID3D12DeviceRemovedExtendedDataSettings2>()->UseMarkersOnlyAutoBreadcrumbs(
            MarkersOnly);
    }

    manager->DecrementCallScope();
}

ID3D12DeviceRemovedExtendedData_Wrapper::ID3D12DeviceRemovedExtendedData_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12DeviceRemovedExtendedDataInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12DeviceRemovedExtendedData_Wrapper::~ID3D12DeviceRemovedExtendedData_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12DeviceRemovedExtendedData>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12DeviceRemovedExtendedData_Wrapper* ID3D12DeviceRemovedExtendedData_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12DeviceRemovedExtendedData_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceRemovedExtendedData_Wrapper::GetAutoBreadcrumbsOutput(
    D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT* pOutput)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedData_GetAutoBreadcrumbsOutput>::Dispatch(
            manager,
            this,
            pOutput);

        result = GetWrappedObjectAs<ID3D12DeviceRemovedExtendedData>()->GetAutoBreadcrumbsOutput(
            pOutput);

        if (SUCCEEDED(result))
        {
            WrapStruct(pOutput);
        }

        Encode_ID3D12DeviceRemovedExtendedData_GetAutoBreadcrumbsOutput(
            this,
            result,
            pOutput);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedData_GetAutoBreadcrumbsOutput>::Dispatch(
            manager,
            this,
            result,
            pOutput);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceRemovedExtendedData>()->GetAutoBreadcrumbsOutput(
            pOutput);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceRemovedExtendedData_Wrapper::GetPageFaultAllocationOutput(
    D3D12_DRED_PAGE_FAULT_OUTPUT* pOutput)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedData_GetPageFaultAllocationOutput>::Dispatch(
            manager,
            this,
            pOutput);

        result = GetWrappedObjectAs<ID3D12DeviceRemovedExtendedData>()->GetPageFaultAllocationOutput(
            pOutput);

        Encode_ID3D12DeviceRemovedExtendedData_GetPageFaultAllocationOutput(
            this,
            result,
            pOutput);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedData_GetPageFaultAllocationOutput>::Dispatch(
            manager,
            this,
            result,
            pOutput);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceRemovedExtendedData>()->GetPageFaultAllocationOutput(
            pOutput);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DeviceRemovedExtendedData1_Wrapper::ID3D12DeviceRemovedExtendedData1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DeviceRemovedExtendedData_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceRemovedExtendedData1_Wrapper::GetAutoBreadcrumbsOutput1(
    D3D12_DRED_AUTO_BREADCRUMBS_OUTPUT1* pOutput)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedData1_GetAutoBreadcrumbsOutput1>::Dispatch(
            manager,
            this,
            pOutput);

        result = GetWrappedObjectAs<ID3D12DeviceRemovedExtendedData1>()->GetAutoBreadcrumbsOutput1(
            pOutput);

        if (SUCCEEDED(result))
        {
            WrapStruct(pOutput);
        }

        Encode_ID3D12DeviceRemovedExtendedData1_GetAutoBreadcrumbsOutput1(
            this,
            result,
            pOutput);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedData1_GetAutoBreadcrumbsOutput1>::Dispatch(
            manager,
            this,
            result,
            pOutput);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceRemovedExtendedData1>()->GetAutoBreadcrumbsOutput1(
            pOutput);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceRemovedExtendedData1_Wrapper::GetPageFaultAllocationOutput1(
    D3D12_DRED_PAGE_FAULT_OUTPUT1* pOutput)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedData1_GetPageFaultAllocationOutput1>::Dispatch(
            manager,
            this,
            pOutput);

        result = GetWrappedObjectAs<ID3D12DeviceRemovedExtendedData1>()->GetPageFaultAllocationOutput1(
            pOutput);

        if (SUCCEEDED(result))
        {
            WrapStruct(pOutput);
        }

        Encode_ID3D12DeviceRemovedExtendedData1_GetPageFaultAllocationOutput1(
            this,
            result,
            pOutput);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedData1_GetPageFaultAllocationOutput1>::Dispatch(
            manager,
            this,
            result,
            pOutput);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceRemovedExtendedData1>()->GetPageFaultAllocationOutput1(
            pOutput);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DeviceRemovedExtendedData2_Wrapper::ID3D12DeviceRemovedExtendedData2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DeviceRemovedExtendedData1_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceRemovedExtendedData2_Wrapper::GetPageFaultAllocationOutput2(
    D3D12_DRED_PAGE_FAULT_OUTPUT2* pOutput)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedData2_GetPageFaultAllocationOutput2>::Dispatch(
            manager,
            this,
            pOutput);

        result = GetWrappedObjectAs<ID3D12DeviceRemovedExtendedData2>()->GetPageFaultAllocationOutput2(
            pOutput);

        if (SUCCEEDED(result))
        {
            WrapStruct(pOutput);
        }

        Encode_ID3D12DeviceRemovedExtendedData2_GetPageFaultAllocationOutput2(
            this,
            result,
            pOutput);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedData2_GetPageFaultAllocationOutput2>::Dispatch(
            manager,
            this,
            result,
            pOutput);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceRemovedExtendedData2>()->GetPageFaultAllocationOutput2(
            pOutput);
    }

    manager->DecrementCallScope();

    return result;
}

D3D12_DRED_DEVICE_STATE STDMETHODCALLTYPE ID3D12DeviceRemovedExtendedData2_Wrapper::GetDeviceState()
{
    D3D12_DRED_DEVICE_STATE result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedData2_GetDeviceState>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12DeviceRemovedExtendedData2>()->GetDeviceState();

        Encode_ID3D12DeviceRemovedExtendedData2_GetDeviceState(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceRemovedExtendedData2_GetDeviceState>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceRemovedExtendedData2>()->GetDeviceState();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Device6_Wrapper::ID3D12Device6_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Device5_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Device6_Wrapper::SetBackgroundProcessingMode(
    D3D12_BACKGROUND_PROCESSING_MODE Mode,
    D3D12_MEASUREMENTS_ACTION MeasurementsAction,
    HANDLE hEventToSignalUponCompletion,
    BOOL* pbFurtherMeasurementsDesired)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device6_SetBackgroundProcessingMode>::Dispatch(
            manager,
            this,
            Mode,
            MeasurementsAction,
            hEventToSignalUponCompletion,
            pbFurtherMeasurementsDesired);

        result = GetWrappedObjectAs<ID3D12Device6>()->SetBackgroundProcessingMode(
            Mode,
            MeasurementsAction,
            hEventToSignalUponCompletion,
            pbFurtherMeasurementsDesired);

        Encode_ID3D12Device6_SetBackgroundProcessingMode(
            this,
            result,
            Mode,
            MeasurementsAction,
            hEventToSignalUponCompletion,
            pbFurtherMeasurementsDesired);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device6_SetBackgroundProcessingMode>::Dispatch(
            manager,
            this,
            result,
            Mode,
            MeasurementsAction,
            hEventToSignalUponCompletion,
            pbFurtherMeasurementsDesired);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device6>()->SetBackgroundProcessingMode(
            Mode,
            MeasurementsAction,
            hEventToSignalUponCompletion,
            pbFurtherMeasurementsDesired);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12ProtectedResourceSession1_Wrapper::ID3D12ProtectedResourceSession1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12ProtectedResourceSession_Wrapper(riid, object, resources, destructor)
{
}

D3D12_PROTECTED_RESOURCE_SESSION_DESC1 STDMETHODCALLTYPE ID3D12ProtectedResourceSession1_Wrapper::GetDesc1()
{
    D3D12_PROTECTED_RESOURCE_SESSION_DESC1 result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12ProtectedResourceSession1_GetDesc1>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12ProtectedResourceSession1>()->GetDesc1();

        Encode_ID3D12ProtectedResourceSession1_GetDesc1(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12ProtectedResourceSession1_GetDesc1>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12ProtectedResourceSession1>()->GetDesc1();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Device7_Wrapper::ID3D12Device7_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Device6_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Device7_Wrapper::AddToStateObject(
    const D3D12_STATE_OBJECT_DESC* pAddition,
    ID3D12StateObject* pStateObjectToGrowFrom,
    REFIID riid,
    void** ppNewStateObject)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device7_AddToStateObject>::Dispatch(
            manager,
            this,
            pAddition,
            pStateObjectToGrowFrom,
            riid,
            ppNewStateObject);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<ID3D12Device7>()->AddToStateObject(
            UnwrapStructPtrObjects(pAddition, unwrap_memory),
            encode::GetWrappedObject<ID3D12StateObject>(pStateObjectToGrowFrom),
            riid,
            ppNewStateObject);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppNewStateObject, nullptr);
        }

        Encode_ID3D12Device7_AddToStateObject(
            this,
            result,
            pAddition,
            pStateObjectToGrowFrom,
            riid,
            ppNewStateObject);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device7_AddToStateObject>::Dispatch(
            manager,
            this,
            result,
            pAddition,
            pStateObjectToGrowFrom,
            riid,
            ppNewStateObject);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device7>()->AddToStateObject(
            pAddition,
            pStateObjectToGrowFrom,
            riid,
            ppNewStateObject);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device7_Wrapper::CreateProtectedResourceSession1(
    const D3D12_PROTECTED_RESOURCE_SESSION_DESC1* pDesc,
    REFIID riid,
    void** ppSession)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device7_CreateProtectedResourceSession1>::Dispatch(
            manager,
            this,
            pDesc,
            riid,
            ppSession);

        result = GetWrappedObjectAs<ID3D12Device7>()->CreateProtectedResourceSession1(
            pDesc,
            riid,
            ppSession);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppSession, nullptr);
        }

        Encode_ID3D12Device7_CreateProtectedResourceSession1(
            this,
            result,
            pDesc,
            riid,
            ppSession);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device7_CreateProtectedResourceSession1>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            riid,
            ppSession);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device7>()->CreateProtectedResourceSession1(
            pDesc,
            riid,
            ppSession);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Device8_Wrapper::ID3D12Device8_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Device7_Wrapper(riid, object, resources, destructor)
{
}

D3D12_RESOURCE_ALLOCATION_INFO STDMETHODCALLTYPE ID3D12Device8_Wrapper::GetResourceAllocationInfo2(
    UINT visibleMask,
    UINT numResourceDescs,
    const D3D12_RESOURCE_DESC1* pResourceDescs,
    D3D12_RESOURCE_ALLOCATION_INFO1* pResourceAllocationInfo1)
{
    D3D12_RESOURCE_ALLOCATION_INFO result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device8_GetResourceAllocationInfo2>::Dispatch(
            manager,
            this,
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pResourceAllocationInfo1);

        result = GetWrappedObjectAs<ID3D12Device8>()->GetResourceAllocationInfo2(
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pResourceAllocationInfo1);

        Encode_ID3D12Device8_GetResourceAllocationInfo2(
            this,
            result,
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pResourceAllocationInfo1);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device8_GetResourceAllocationInfo2>::Dispatch(
            manager,
            this,
            result,
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pResourceAllocationInfo1);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device8>()->GetResourceAllocationInfo2(
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pResourceAllocationInfo1);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device8_Wrapper::CreateCommittedResource2(
    const D3D12_HEAP_PROPERTIES* pHeapProperties,
    D3D12_HEAP_FLAGS HeapFlags,
    const D3D12_RESOURCE_DESC1* pDesc,
    D3D12_RESOURCE_STATES InitialResourceState,
    const D3D12_CLEAR_VALUE* pOptimizedClearValue,
    ID3D12ProtectedResourceSession* pProtectedSession,
    REFIID riidResource,
    void** ppvResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device8_CreateCommittedResource2>::Dispatch(
            manager,
            this,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            pProtectedSession,
            riidResource,
            ppvResource);

        result = D3D12CaptureManager::Get()->OverrideID3D12Device_CreateCommittedResource2(
            this,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            pProtectedSession,
            riidResource,
            ppvResource);

        if (SUCCEEDED(result))
        {
            WrapObject(riidResource, ppvResource, nullptr);
        }

        Encode_ID3D12Device8_CreateCommittedResource2(
            this,
            result,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            pProtectedSession,
            riidResource,
            ppvResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device8_CreateCommittedResource2>::Dispatch(
            manager,
            this,
            result,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            pProtectedSession,
            riidResource,
            ppvResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device8>()->CreateCommittedResource2(
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialResourceState,
            pOptimizedClearValue,
            pProtectedSession,
            riidResource,
            ppvResource);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device8_Wrapper::CreatePlacedResource1(
    ID3D12Heap* pHeap,
    UINT64 HeapOffset,
    const D3D12_RESOURCE_DESC1* pDesc,
    D3D12_RESOURCE_STATES InitialState,
    const D3D12_CLEAR_VALUE* pOptimizedClearValue,
    REFIID riid,
    void** ppvResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device8_CreatePlacedResource1>::Dispatch(
            manager,
            this,
            pHeap,
            HeapOffset,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);

        result = GetWrappedObjectAs<ID3D12Device8>()->CreatePlacedResource1(
            encode::GetWrappedObject<ID3D12Heap>(pHeap),
            HeapOffset,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvResource, nullptr);
        }

        Encode_ID3D12Device8_CreatePlacedResource1(
            this,
            result,
            pHeap,
            HeapOffset,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device8_CreatePlacedResource1>::Dispatch(
            manager,
            this,
            result,
            pHeap,
            HeapOffset,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device8>()->CreatePlacedResource1(
            pHeap,
            HeapOffset,
            pDesc,
            InitialState,
            pOptimizedClearValue,
            riid,
            ppvResource);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12Device8_Wrapper::CreateSamplerFeedbackUnorderedAccessView(
    ID3D12Resource* pTargetedResource,
    ID3D12Resource* pFeedbackResource,
    D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device8_CreateSamplerFeedbackUnorderedAccessView>::Dispatch(
            manager,
            this,
            pTargetedResource,
            pFeedbackResource,
            DestDescriptor);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12Device8>()->CreateSamplerFeedbackUnorderedAccessView(
            encode::GetWrappedObject<ID3D12Resource>(pTargetedResource),
            encode::GetWrappedObject<ID3D12Resource>(pFeedbackResource),
            *UnwrapStructPtrObjects(&DestDescriptor, unwrap_memory));

        Encode_ID3D12Device8_CreateSamplerFeedbackUnorderedAccessView(
            this,
            pTargetedResource,
            pFeedbackResource,
            DestDescriptor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device8_CreateSamplerFeedbackUnorderedAccessView>::Dispatch(
            manager,
            this,
            pTargetedResource,
            pFeedbackResource,
            DestDescriptor);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device8>()->CreateSamplerFeedbackUnorderedAccessView(
            pTargetedResource,
            pFeedbackResource,
            DestDescriptor);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12Device8_Wrapper::GetCopyableFootprints1(
    const D3D12_RESOURCE_DESC1* pResourceDesc,
    UINT FirstSubresource,
    UINT NumSubresources,
    UINT64 BaseOffset,
    D3D12_PLACED_SUBRESOURCE_FOOTPRINT* pLayouts,
    UINT* pNumRows,
    UINT64* pRowSizeInBytes,
    UINT64* pTotalBytes)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device8_GetCopyableFootprints1>::Dispatch(
            manager,
            this,
            pResourceDesc,
            FirstSubresource,
            NumSubresources,
            BaseOffset,
            pLayouts,
            pNumRows,
            pRowSizeInBytes,
            pTotalBytes);

        GetWrappedObjectAs<ID3D12Device8>()->GetCopyableFootprints1(
            pResourceDesc,
            FirstSubresource,
            NumSubresources,
            BaseOffset,
            pLayouts,
            pNumRows,
            pRowSizeInBytes,
            pTotalBytes);

        Encode_ID3D12Device8_GetCopyableFootprints1(
            this,
            pResourceDesc,
            FirstSubresource,
            NumSubresources,
            BaseOffset,
            pLayouts,
            pNumRows,
            pRowSizeInBytes,
            pTotalBytes);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device8_GetCopyableFootprints1>::Dispatch(
            manager,
            this,
            pResourceDesc,
            FirstSubresource,
            NumSubresources,
            BaseOffset,
            pLayouts,
            pNumRows,
            pRowSizeInBytes,
            pTotalBytes);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device8>()->GetCopyableFootprints1(
            pResourceDesc,
            FirstSubresource,
            NumSubresources,
            BaseOffset,
            pLayouts,
            pNumRows,
            pRowSizeInBytes,
            pTotalBytes);
    }

    manager->DecrementCallScope();
}

ID3D12Resource1_Wrapper::ID3D12Resource1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Resource_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Resource1_Wrapper::GetProtectedResourceSession(
    REFIID riid,
    void** ppProtectedSession)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Resource1_GetProtectedResourceSession>::Dispatch(
            manager,
            this,
            riid,
            ppProtectedSession);

        result = GetWrappedObjectAs<ID3D12Resource1>()->GetProtectedResourceSession(
            riid,
            ppProtectedSession);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppProtectedSession, nullptr);
        }

        Encode_ID3D12Resource1_GetProtectedResourceSession(
            this,
            result,
            riid,
            ppProtectedSession);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Resource1_GetProtectedResourceSession>::Dispatch(
            manager,
            this,
            result,
            riid,
            ppProtectedSession);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Resource1>()->GetProtectedResourceSession(
            riid,
            ppProtectedSession);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Resource2_Wrapper::ID3D12Resource2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Resource1_Wrapper(riid, object, resources, destructor)
{
}

D3D12_RESOURCE_DESC1 STDMETHODCALLTYPE ID3D12Resource2_Wrapper::GetDesc1()
{
    D3D12_RESOURCE_DESC1 result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Resource2_GetDesc1>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12Resource2>()->GetDesc1();

        Encode_ID3D12Resource2_GetDesc1(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Resource2_GetDesc1>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Resource2>()->GetDesc1();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Heap1_Wrapper::ID3D12Heap1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Heap_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Heap1_Wrapper::GetProtectedResourceSession(
    REFIID riid,
    void** ppProtectedSession)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Heap1_GetProtectedResourceSession>::Dispatch(
            manager,
            this,
            riid,
            ppProtectedSession);

        result = GetWrappedObjectAs<ID3D12Heap1>()->GetProtectedResourceSession(
            riid,
            ppProtectedSession);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppProtectedSession, nullptr);
        }

        Encode_ID3D12Heap1_GetProtectedResourceSession(
            this,
            result,
            riid,
            ppProtectedSession);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Heap1_GetProtectedResourceSession>::Dispatch(
            manager,
            this,
            result,
            riid,
            ppProtectedSession);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Heap1>()->GetProtectedResourceSession(
            riid,
            ppProtectedSession);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12GraphicsCommandList3_Wrapper::ID3D12GraphicsCommandList3_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12GraphicsCommandList2_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList3_Wrapper::SetProtectedResourceSession(
    ID3D12ProtectedResourceSession* pProtectedResourceSession)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList3_SetProtectedResourceSession>::Dispatch(
            manager,
            this,
            pProtectedResourceSession);

        GetWrappedObjectAs<ID3D12GraphicsCommandList3>()->SetProtectedResourceSession(
            encode::GetWrappedObject<ID3D12ProtectedResourceSession>(pProtectedResourceSession));

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList3_SetProtectedResourceSession);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList3_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->SetProtectedResourceSession(
                    pProtectedResourceSession);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList3_SetProtectedResourceSession(
            this,
            pProtectedResourceSession);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList3_SetProtectedResourceSession>::Dispatch(
            manager,
            this,
            pProtectedResourceSession);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList3>()->SetProtectedResourceSession(
            pProtectedResourceSession);
    }

    manager->DecrementCallScope();
}

ID3D12MetaCommand_Wrapper::ID3D12MetaCommand_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Pageable_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12MetaCommandInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12MetaCommand_Wrapper::~ID3D12MetaCommand_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12MetaCommand>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12MetaCommand_Wrapper* ID3D12MetaCommand_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12MetaCommand_Wrapper>(object, object_map_, object_map_lock_);
}

UINT64 STDMETHODCALLTYPE ID3D12MetaCommand_Wrapper::GetRequiredParameterResourceSize(
    D3D12_META_COMMAND_PARAMETER_STAGE Stage,
    UINT ParameterIndex)
{
    UINT64 result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12MetaCommand_GetRequiredParameterResourceSize>::Dispatch(
            manager,
            this,
            Stage,
            ParameterIndex);

        result = GetWrappedObjectAs<ID3D12MetaCommand>()->GetRequiredParameterResourceSize(
            Stage,
            ParameterIndex);

        Encode_ID3D12MetaCommand_GetRequiredParameterResourceSize(
            this,
            result,
            Stage,
            ParameterIndex);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12MetaCommand_GetRequiredParameterResourceSize>::Dispatch(
            manager,
            this,
            result,
            Stage,
            ParameterIndex);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12MetaCommand>()->GetRequiredParameterResourceSize(
            Stage,
            ParameterIndex);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12GraphicsCommandList4_Wrapper::ID3D12GraphicsCommandList4_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12GraphicsCommandList3_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList4_Wrapper::BeginRenderPass(
    UINT NumRenderTargets,
    const D3D12_RENDER_PASS_RENDER_TARGET_DESC* pRenderTargets,
    const D3D12_RENDER_PASS_DEPTH_STENCIL_DESC* pDepthStencil,
    D3D12_RENDER_PASS_FLAGS Flags)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_BeginRenderPass>::Dispatch(
            manager,
            this,
            NumRenderTargets,
            pRenderTargets,
            pDepthStencil,
            Flags);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        D3D12CaptureManager::Get()->OverrideID3D12GraphicsCommandList4_BeginRenderPass(
            this,
            NumRenderTargets,
            pRenderTargets,
            pDepthStencil,
            Flags);

        Encode_ID3D12GraphicsCommandList4_BeginRenderPass(
            this,
            NumRenderTargets,
            pRenderTargets,
            pDepthStencil,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_BeginRenderPass>::Dispatch(
            manager,
            this,
            NumRenderTargets,
            pRenderTargets,
            pDepthStencil,
            Flags);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->BeginRenderPass(
            NumRenderTargets,
            pRenderTargets,
            pDepthStencil,
            Flags);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList4_Wrapper::EndRenderPass()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_EndRenderPass>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->EndRenderPass();

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList4_EndRenderPass);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList4_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->EndRenderPass();
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList4_EndRenderPass(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_EndRenderPass>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->EndRenderPass();
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList4_Wrapper::InitializeMetaCommand(
    ID3D12MetaCommand* pMetaCommand,
    const void* pInitializationParametersData,
    SIZE_T InitializationParametersDataSizeInBytes)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_InitializeMetaCommand>::Dispatch(
            manager,
            this,
            pMetaCommand,
            pInitializationParametersData,
            InitializationParametersDataSizeInBytes);

        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->InitializeMetaCommand(
            encode::GetWrappedObject<ID3D12MetaCommand>(pMetaCommand),
            pInitializationParametersData,
            InitializationParametersDataSizeInBytes);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList4_InitializeMetaCommand);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList4_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->InitializeMetaCommand(
                    pMetaCommand,
                    pInitializationParametersData,
                    InitializationParametersDataSizeInBytes);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList4_InitializeMetaCommand(
            this,
            pMetaCommand,
            pInitializationParametersData,
            InitializationParametersDataSizeInBytes);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_InitializeMetaCommand>::Dispatch(
            manager,
            this,
            pMetaCommand,
            pInitializationParametersData,
            InitializationParametersDataSizeInBytes);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->InitializeMetaCommand(
            pMetaCommand,
            pInitializationParametersData,
            InitializationParametersDataSizeInBytes);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList4_Wrapper::ExecuteMetaCommand(
    ID3D12MetaCommand* pMetaCommand,
    const void* pExecutionParametersData,
    SIZE_T ExecutionParametersDataSizeInBytes)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_ExecuteMetaCommand>::Dispatch(
            manager,
            this,
            pMetaCommand,
            pExecutionParametersData,
            ExecutionParametersDataSizeInBytes);

        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->ExecuteMetaCommand(
            encode::GetWrappedObject<ID3D12MetaCommand>(pMetaCommand),
            pExecutionParametersData,
            ExecutionParametersDataSizeInBytes);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList4_ExecuteMetaCommand);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList4_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->ExecuteMetaCommand(
                    pMetaCommand,
                    pExecutionParametersData,
                    ExecutionParametersDataSizeInBytes);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList4_ExecuteMetaCommand(
            this,
            pMetaCommand,
            pExecutionParametersData,
            ExecutionParametersDataSizeInBytes);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_ExecuteMetaCommand>::Dispatch(
            manager,
            this,
            pMetaCommand,
            pExecutionParametersData,
            ExecutionParametersDataSizeInBytes);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->ExecuteMetaCommand(
            pMetaCommand,
            pExecutionParametersData,
            ExecutionParametersDataSizeInBytes);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList4_Wrapper::BuildRaytracingAccelerationStructure(
    const D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC* pDesc,
    UINT NumPostbuildInfoDescs,
    const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC* pPostbuildInfoDescs)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        std::unique_ptr<D3D12_BUILD_RAYTRACING_ACCELERATION_STRUCTURE_DESC> pDesc_unannotated = nullptr;
        std::unique_ptr<D3D12_RAYTRACING_GEOMETRY_DESC[]> pDesc_dependency = nullptr;
        if((manager->IsAnnotated() == true) && (pDesc != nullptr))
        {
            pDesc_unannotated = RvAnnotationUtil::RemoveStructRvAnnotations(pDesc, pDesc_dependency);
            pDesc = pDesc_unannotated.get();
        }

        std::unique_ptr<D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC[]> pPostbuildInfoDescs_unannotated = nullptr;
        if((manager->IsAnnotated() == true) && (NumPostbuildInfoDescs != 0) && (pPostbuildInfoDescs != nullptr))
        {
            pPostbuildInfoDescs_unannotated = RvAnnotationUtil::RemoveStructArrayRvAnnotations(pPostbuildInfoDescs, NumPostbuildInfoDescs);
            pPostbuildInfoDescs = pPostbuildInfoDescs_unannotated.get();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_BuildRaytracingAccelerationStructure>::Dispatch(
            manager,
            this,
            pDesc,
            NumPostbuildInfoDescs,
            pPostbuildInfoDescs);

        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->BuildRaytracingAccelerationStructure(
            pDesc,
            NumPostbuildInfoDescs,
            pPostbuildInfoDescs);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList4_BuildRaytracingAccelerationStructure);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList4_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->BuildRaytracingAccelerationStructure(
                    pDesc,
                    NumPostbuildInfoDescs,
                    pPostbuildInfoDescs);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList4_BuildRaytracingAccelerationStructure(
            this,
            pDesc,
            NumPostbuildInfoDescs,
            pPostbuildInfoDescs);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_BuildRaytracingAccelerationStructure>::Dispatch(
            manager,
            this,
            pDesc,
            NumPostbuildInfoDescs,
            pPostbuildInfoDescs);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->BuildRaytracingAccelerationStructure(
            pDesc,
            NumPostbuildInfoDescs,
            pPostbuildInfoDescs);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList4_Wrapper::EmitRaytracingAccelerationStructurePostbuildInfo(
    const D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC* pDesc,
    UINT NumSourceAccelerationStructures,
    const D3D12_GPU_VIRTUAL_ADDRESS* pSourceAccelerationStructureData)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        std::unique_ptr<D3D12_RAYTRACING_ACCELERATION_STRUCTURE_POSTBUILD_INFO_DESC> pDesc_unannotated = nullptr;
        if((manager->IsAnnotated() == true) && (pDesc != nullptr))
        {
            pDesc_unannotated = RvAnnotationUtil::RemoveStructRvAnnotations(pDesc);
            pDesc = pDesc_unannotated.get();
        }

        std::unique_ptr<D3D12_GPU_VIRTUAL_ADDRESS[]> pSourceAccelerationStructureData_unannotated = nullptr;
        if((manager->IsAnnotated() == true) && (NumSourceAccelerationStructures != 0) && (pSourceAccelerationStructureData != nullptr))
        {
            pSourceAccelerationStructureData_unannotated = RvAnnotationUtil::RemoveStructArrayRvAnnotations(pSourceAccelerationStructureData, NumSourceAccelerationStructures);
            pSourceAccelerationStructureData = pSourceAccelerationStructureData_unannotated.get();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_EmitRaytracingAccelerationStructurePostbuildInfo>::Dispatch(
            manager,
            this,
            pDesc,
            NumSourceAccelerationStructures,
            pSourceAccelerationStructureData);

        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->EmitRaytracingAccelerationStructurePostbuildInfo(
            pDesc,
            NumSourceAccelerationStructures,
            pSourceAccelerationStructureData);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList4_EmitRaytracingAccelerationStructurePostbuildInfo);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList4_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->EmitRaytracingAccelerationStructurePostbuildInfo(
                    pDesc,
                    NumSourceAccelerationStructures,
                    pSourceAccelerationStructureData);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList4_EmitRaytracingAccelerationStructurePostbuildInfo(
            this,
            pDesc,
            NumSourceAccelerationStructures,
            pSourceAccelerationStructureData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_EmitRaytracingAccelerationStructurePostbuildInfo>::Dispatch(
            manager,
            this,
            pDesc,
            NumSourceAccelerationStructures,
            pSourceAccelerationStructureData);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->EmitRaytracingAccelerationStructurePostbuildInfo(
            pDesc,
            NumSourceAccelerationStructures,
            pSourceAccelerationStructureData);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList4_Wrapper::CopyRaytracingAccelerationStructure(
    D3D12_GPU_VIRTUAL_ADDRESS DestAccelerationStructureData,
    D3D12_GPU_VIRTUAL_ADDRESS SourceAccelerationStructureData,
    D3D12_RAYTRACING_ACCELERATION_STRUCTURE_COPY_MODE Mode)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        RvAnnotationUtil::RemoveRvAnnotation(DestAccelerationStructureData);

        RvAnnotationUtil::RemoveRvAnnotation(SourceAccelerationStructureData);

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_CopyRaytracingAccelerationStructure>::Dispatch(
            manager,
            this,
            DestAccelerationStructureData,
            SourceAccelerationStructureData,
            Mode);

        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->CopyRaytracingAccelerationStructure(
            DestAccelerationStructureData,
            SourceAccelerationStructureData,
            Mode);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList4_CopyRaytracingAccelerationStructure);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList4_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->CopyRaytracingAccelerationStructure(
                    DestAccelerationStructureData,
                    SourceAccelerationStructureData,
                    Mode);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList4_CopyRaytracingAccelerationStructure(
            this,
            DestAccelerationStructureData,
            SourceAccelerationStructureData,
            Mode);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_CopyRaytracingAccelerationStructure>::Dispatch(
            manager,
            this,
            DestAccelerationStructureData,
            SourceAccelerationStructureData,
            Mode);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->CopyRaytracingAccelerationStructure(
            DestAccelerationStructureData,
            SourceAccelerationStructureData,
            Mode);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList4_Wrapper::SetPipelineState1(
    ID3D12StateObject* pStateObject)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_SetPipelineState1>::Dispatch(
            manager,
            this,
            pStateObject);

        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->SetPipelineState1(
            encode::GetWrappedObject<ID3D12StateObject>(pStateObject));

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList4_SetPipelineState1);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList4_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->SetPipelineState1(
                    pStateObject);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList4_SetPipelineState1(
            this,
            pStateObject);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_SetPipelineState1>::Dispatch(
            manager,
            this,
            pStateObject);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->SetPipelineState1(
            pStateObject);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList4_Wrapper::DispatchRays(
    const D3D12_DISPATCH_RAYS_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        std::unique_ptr<D3D12_DISPATCH_RAYS_DESC> pDesc_unannotated = nullptr;
        if((manager->IsAnnotated() == true) && (pDesc != nullptr))
        {
            pDesc_unannotated = RvAnnotationUtil::RemoveStructRvAnnotations(pDesc);
            pDesc = pDesc_unannotated.get();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_DispatchRays>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->DispatchRays(
            pDesc);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList4_DispatchRays);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList4_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->DispatchRays(
                    pDesc);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList4_DispatchRays(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList4_DispatchRays>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList4>()->DispatchRays(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D12ShaderCacheSession_Wrapper::ID3D12ShaderCacheSession_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12ShaderCacheSessionInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12ShaderCacheSession_Wrapper::~ID3D12ShaderCacheSession_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12ShaderCacheSession>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12ShaderCacheSession_Wrapper* ID3D12ShaderCacheSession_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12ShaderCacheSession_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12ShaderCacheSession_Wrapper::FindValue(
    const void* pKey,
    UINT KeySize,
    void* pValue,
    UINT* pValueSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12ShaderCacheSession_FindValue>::Dispatch(
            manager,
            this,
            pKey,
            KeySize,
            pValue,
            pValueSize);

        result = GetWrappedObjectAs<ID3D12ShaderCacheSession>()->FindValue(
            pKey,
            KeySize,
            pValue,
            pValueSize);

        Encode_ID3D12ShaderCacheSession_FindValue(
            this,
            result,
            pKey,
            KeySize,
            pValue,
            pValueSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12ShaderCacheSession_FindValue>::Dispatch(
            manager,
            this,
            result,
            pKey,
            KeySize,
            pValue,
            pValueSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12ShaderCacheSession>()->FindValue(
            pKey,
            KeySize,
            pValue,
            pValueSize);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12ShaderCacheSession_Wrapper::StoreValue(
    const void* pKey,
    UINT KeySize,
    const void* pValue,
    UINT ValueSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12ShaderCacheSession_StoreValue>::Dispatch(
            manager,
            this,
            pKey,
            KeySize,
            pValue,
            ValueSize);

        result = GetWrappedObjectAs<ID3D12ShaderCacheSession>()->StoreValue(
            pKey,
            KeySize,
            pValue,
            ValueSize);

        Encode_ID3D12ShaderCacheSession_StoreValue(
            this,
            result,
            pKey,
            KeySize,
            pValue,
            ValueSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12ShaderCacheSession_StoreValue>::Dispatch(
            manager,
            this,
            result,
            pKey,
            KeySize,
            pValue,
            ValueSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12ShaderCacheSession>()->StoreValue(
            pKey,
            KeySize,
            pValue,
            ValueSize);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12ShaderCacheSession_Wrapper::SetDeleteOnDestroy()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12ShaderCacheSession_SetDeleteOnDestroy>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12ShaderCacheSession>()->SetDeleteOnDestroy();

        Encode_ID3D12ShaderCacheSession_SetDeleteOnDestroy(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12ShaderCacheSession_SetDeleteOnDestroy>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12ShaderCacheSession>()->SetDeleteOnDestroy();
    }

    manager->DecrementCallScope();
}

D3D12_SHADER_CACHE_SESSION_DESC STDMETHODCALLTYPE ID3D12ShaderCacheSession_Wrapper::GetDesc()
{
    D3D12_SHADER_CACHE_SESSION_DESC result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12ShaderCacheSession_GetDesc>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12ShaderCacheSession>()->GetDesc();

        Encode_ID3D12ShaderCacheSession_GetDesc(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12ShaderCacheSession_GetDesc>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12ShaderCacheSession>()->GetDesc();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Device9_Wrapper::ID3D12Device9_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Device8_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Device9_Wrapper::CreateShaderCacheSession(
    const D3D12_SHADER_CACHE_SESSION_DESC* pDesc,
    REFIID riid,
    void** ppvSession)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device9_CreateShaderCacheSession>::Dispatch(
            manager,
            this,
            pDesc,
            riid,
            ppvSession);

        result = GetWrappedObjectAs<ID3D12Device9>()->CreateShaderCacheSession(
            pDesc,
            riid,
            ppvSession);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvSession, nullptr);
        }

        Encode_ID3D12Device9_CreateShaderCacheSession(
            this,
            result,
            pDesc,
            riid,
            ppvSession);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device9_CreateShaderCacheSession>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            riid,
            ppvSession);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device9>()->CreateShaderCacheSession(
            pDesc,
            riid,
            ppvSession);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device9_Wrapper::ShaderCacheControl(
    D3D12_SHADER_CACHE_KIND_FLAGS Kinds,
    D3D12_SHADER_CACHE_CONTROL_FLAGS Control)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device9_ShaderCacheControl>::Dispatch(
            manager,
            this,
            Kinds,
            Control);

        result = GetWrappedObjectAs<ID3D12Device9>()->ShaderCacheControl(
            Kinds,
            Control);

        Encode_ID3D12Device9_ShaderCacheControl(
            this,
            result,
            Kinds,
            Control);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device9_ShaderCacheControl>::Dispatch(
            manager,
            this,
            result,
            Kinds,
            Control);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device9>()->ShaderCacheControl(
            Kinds,
            Control);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device9_Wrapper::CreateCommandQueue1(
    const D3D12_COMMAND_QUEUE_DESC* pDesc,
    REFIID CreatorID,
    REFIID riid,
    void** ppCommandQueue)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device9_CreateCommandQueue1>::Dispatch(
            manager,
            this,
            pDesc,
            CreatorID,
            riid,
            ppCommandQueue);

        result = GetWrappedObjectAs<ID3D12Device9>()->CreateCommandQueue1(
            pDesc,
            CreatorID,
            riid,
            ppCommandQueue);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppCommandQueue, nullptr);
        }

        Encode_ID3D12Device9_CreateCommandQueue1(
            this,
            result,
            pDesc,
            CreatorID,
            riid,
            ppCommandQueue);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device9_CreateCommandQueue1>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            CreatorID,
            riid,
            ppCommandQueue);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device9>()->CreateCommandQueue1(
            pDesc,
            CreatorID,
            riid,
            ppCommandQueue);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Device10_Wrapper::ID3D12Device10_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Device9_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Device10_Wrapper::CreateCommittedResource3(
    const D3D12_HEAP_PROPERTIES* pHeapProperties,
    D3D12_HEAP_FLAGS HeapFlags,
    const D3D12_RESOURCE_DESC1* pDesc,
    D3D12_BARRIER_LAYOUT InitialLayout,
    const D3D12_CLEAR_VALUE* pOptimizedClearValue,
    ID3D12ProtectedResourceSession* pProtectedSession,
    UINT32 NumCastableFormats,
    const DXGI_FORMAT* pCastableFormats,
    REFIID riidResource,
    void** ppvResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device10_CreateCommittedResource3>::Dispatch(
            manager,
            this,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            pProtectedSession,
            NumCastableFormats,
            pCastableFormats,
            riidResource,
            ppvResource);

        result = D3D12CaptureManager::Get()->OverrideID3D12Device10_CreateCommittedResource3(
            this,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            pProtectedSession,
            NumCastableFormats,
            pCastableFormats,
            riidResource,
            ppvResource);

        if (SUCCEEDED(result))
        {
            WrapObject(riidResource, ppvResource, nullptr);
        }

        Encode_ID3D12Device10_CreateCommittedResource3(
            this,
            result,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            pProtectedSession,
            NumCastableFormats,
            pCastableFormats,
            riidResource,
            ppvResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device10_CreateCommittedResource3>::Dispatch(
            manager,
            this,
            result,
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            pProtectedSession,
            NumCastableFormats,
            pCastableFormats,
            riidResource,
            ppvResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device10>()->CreateCommittedResource3(
            pHeapProperties,
            HeapFlags,
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            pProtectedSession,
            NumCastableFormats,
            pCastableFormats,
            riidResource,
            ppvResource);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device10_Wrapper::CreatePlacedResource2(
    ID3D12Heap* pHeap,
    UINT64 HeapOffset,
    const D3D12_RESOURCE_DESC1* pDesc,
    D3D12_BARRIER_LAYOUT InitialLayout,
    const D3D12_CLEAR_VALUE* pOptimizedClearValue,
    UINT32 NumCastableFormats,
    const DXGI_FORMAT* pCastableFormats,
    REFIID riid,
    void** ppvResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device10_CreatePlacedResource2>::Dispatch(
            manager,
            this,
            pHeap,
            HeapOffset,
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            NumCastableFormats,
            pCastableFormats,
            riid,
            ppvResource);

        result = GetWrappedObjectAs<ID3D12Device10>()->CreatePlacedResource2(
            encode::GetWrappedObject<ID3D12Heap>(pHeap),
            HeapOffset,
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            NumCastableFormats,
            pCastableFormats,
            riid,
            ppvResource);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvResource, nullptr);
        }

        Encode_ID3D12Device10_CreatePlacedResource2(
            this,
            result,
            pHeap,
            HeapOffset,
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            NumCastableFormats,
            pCastableFormats,
            riid,
            ppvResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device10_CreatePlacedResource2>::Dispatch(
            manager,
            this,
            result,
            pHeap,
            HeapOffset,
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            NumCastableFormats,
            pCastableFormats,
            riid,
            ppvResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device10>()->CreatePlacedResource2(
            pHeap,
            HeapOffset,
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            NumCastableFormats,
            pCastableFormats,
            riid,
            ppvResource);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12Device10_Wrapper::CreateReservedResource2(
    const D3D12_RESOURCE_DESC* pDesc,
    D3D12_BARRIER_LAYOUT InitialLayout,
    const D3D12_CLEAR_VALUE* pOptimizedClearValue,
    ID3D12ProtectedResourceSession* pProtectedSession,
    UINT32 NumCastableFormats,
    const DXGI_FORMAT* pCastableFormats,
    REFIID riid,
    void** ppvResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device10_CreateReservedResource2>::Dispatch(
            manager,
            this,
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            pProtectedSession,
            NumCastableFormats,
            pCastableFormats,
            riid,
            ppvResource);

        result = GetWrappedObjectAs<ID3D12Device10>()->CreateReservedResource2(
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            encode::GetWrappedObject<ID3D12ProtectedResourceSession>(pProtectedSession),
            NumCastableFormats,
            pCastableFormats,
            riid,
            ppvResource);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvResource, nullptr);
        }

        Encode_ID3D12Device10_CreateReservedResource2(
            this,
            result,
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            pProtectedSession,
            NumCastableFormats,
            pCastableFormats,
            riid,
            ppvResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device10_CreateReservedResource2>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            pProtectedSession,
            NumCastableFormats,
            pCastableFormats,
            riid,
            ppvResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device10>()->CreateReservedResource2(
            pDesc,
            InitialLayout,
            pOptimizedClearValue,
            pProtectedSession,
            NumCastableFormats,
            pCastableFormats,
            riid,
            ppvResource);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Device11_Wrapper::ID3D12Device11_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Device10_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12Device11_Wrapper::CreateSampler2(
    const D3D12_SAMPLER_DESC2* pDesc,
    D3D12_CPU_DESCRIPTOR_HANDLE DestDescriptor)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device11_CreateSampler2>::Dispatch(
            manager,
            this,
            pDesc,
            DestDescriptor);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12Device11>()->CreateSampler2(
            pDesc,
            *UnwrapStructPtrObjects(&DestDescriptor, unwrap_memory));

        Encode_ID3D12Device11_CreateSampler2(
            this,
            pDesc,
            DestDescriptor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device11_CreateSampler2>::Dispatch(
            manager,
            this,
            pDesc,
            DestDescriptor);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Device11>()->CreateSampler2(
            pDesc,
            DestDescriptor);
    }

    manager->DecrementCallScope();
}

ID3D12Device12_Wrapper::ID3D12Device12_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Device11_Wrapper(riid, object, resources, destructor)
{
}

D3D12_RESOURCE_ALLOCATION_INFO STDMETHODCALLTYPE ID3D12Device12_Wrapper::GetResourceAllocationInfo3(
    UINT visibleMask,
    UINT numResourceDescs,
    const D3D12_RESOURCE_DESC1* pResourceDescs,
    const UINT32* pNumCastableFormats,
    const DXGI_FORMAT* const* ppCastableFormats,
    D3D12_RESOURCE_ALLOCATION_INFO1* pResourceAllocationInfo1)
{
    D3D12_RESOURCE_ALLOCATION_INFO result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device12_GetResourceAllocationInfo3>::Dispatch(
            manager,
            this,
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pNumCastableFormats,
            ppCastableFormats,
            pResourceAllocationInfo1);

        result = GetWrappedObjectAs<ID3D12Device12>()->GetResourceAllocationInfo3(
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pNumCastableFormats,
            ppCastableFormats,
            pResourceAllocationInfo1);

        Encode_ID3D12Device12_GetResourceAllocationInfo3(
            this,
            result,
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pNumCastableFormats,
            ppCastableFormats,
            pResourceAllocationInfo1);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device12_GetResourceAllocationInfo3>::Dispatch(
            manager,
            this,
            result,
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pNumCastableFormats,
            ppCastableFormats,
            pResourceAllocationInfo1);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device12>()->GetResourceAllocationInfo3(
            visibleMask,
            numResourceDescs,
            pResourceDescs,
            pNumCastableFormats,
            ppCastableFormats,
            pResourceAllocationInfo1);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Device13_Wrapper::ID3D12Device13_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Device12_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Device13_Wrapper::OpenExistingHeapFromAddress1(
    const void* pAddress,
    SIZE_T size,
    REFIID riid,
    void** ppvHeap)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device13_OpenExistingHeapFromAddress1>::Dispatch(
            manager,
            this,
            pAddress,
            size,
            riid,
            ppvHeap);

        result = GetWrappedObjectAs<ID3D12Device13>()->OpenExistingHeapFromAddress1(
            pAddress,
            size,
            riid,
            ppvHeap);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvHeap, nullptr);
        }

        Encode_ID3D12Device13_OpenExistingHeapFromAddress1(
            this,
            result,
            pAddress,
            size,
            riid,
            ppvHeap);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device13_OpenExistingHeapFromAddress1>::Dispatch(
            manager,
            this,
            result,
            pAddress,
            size,
            riid,
            ppvHeap);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device13>()->OpenExistingHeapFromAddress1(
            pAddress,
            size,
            riid,
            ppvHeap);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Device14_Wrapper::ID3D12Device14_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Device13_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Device14_Wrapper::CreateRootSignatureFromSubobjectInLibrary(
    UINT nodeMask,
    const void* pLibraryBlob,
    SIZE_T blobLengthInBytes,
    LPCWSTR subobjectName,
    REFIID riid,
    void** ppvRootSignature)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Device14_CreateRootSignatureFromSubobjectInLibrary>::Dispatch(
            manager,
            this,
            nodeMask,
            pLibraryBlob,
            blobLengthInBytes,
            subobjectName,
            riid,
            ppvRootSignature);

        result = GetWrappedObjectAs<ID3D12Device14>()->CreateRootSignatureFromSubobjectInLibrary(
            nodeMask,
            pLibraryBlob,
            blobLengthInBytes,
            subobjectName,
            riid,
            ppvRootSignature);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvRootSignature, nullptr);
        }

        Encode_ID3D12Device14_CreateRootSignatureFromSubobjectInLibrary(
            this,
            result,
            nodeMask,
            pLibraryBlob,
            blobLengthInBytes,
            subobjectName,
            riid,
            ppvRootSignature);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Device14_CreateRootSignatureFromSubobjectInLibrary>::Dispatch(
            manager,
            this,
            result,
            nodeMask,
            pLibraryBlob,
            blobLengthInBytes,
            subobjectName,
            riid,
            ppvRootSignature);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Device14>()->CreateRootSignatureFromSubobjectInLibrary(
            nodeMask,
            pLibraryBlob,
            blobLengthInBytes,
            subobjectName,
            riid,
            ppvRootSignature);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12VirtualizationGuestDevice_Wrapper::ID3D12VirtualizationGuestDevice_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12VirtualizationGuestDeviceInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12VirtualizationGuestDevice_Wrapper::~ID3D12VirtualizationGuestDevice_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12VirtualizationGuestDevice>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12VirtualizationGuestDevice_Wrapper* ID3D12VirtualizationGuestDevice_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12VirtualizationGuestDevice_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12VirtualizationGuestDevice_Wrapper::ShareWithHost(
    ID3D12DeviceChild* pObject,
    HANDLE* pHandle)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12VirtualizationGuestDevice_ShareWithHost>::Dispatch(
            manager,
            this,
            pObject,
            pHandle);

        result = GetWrappedObjectAs<ID3D12VirtualizationGuestDevice>()->ShareWithHost(
            encode::GetWrappedObject<ID3D12DeviceChild>(pObject),
            pHandle);

        Encode_ID3D12VirtualizationGuestDevice_ShareWithHost(
            this,
            result,
            pObject,
            pHandle);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12VirtualizationGuestDevice_ShareWithHost>::Dispatch(
            manager,
            this,
            result,
            pObject,
            pHandle);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12VirtualizationGuestDevice>()->ShareWithHost(
            pObject,
            pHandle);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12VirtualizationGuestDevice_Wrapper::CreateFenceFd(
    ID3D12Fence* pFence,
    UINT64 FenceValue,
    int* pFenceFd)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12VirtualizationGuestDevice_CreateFenceFd>::Dispatch(
            manager,
            this,
            pFence,
            FenceValue,
            pFenceFd);

        result = GetWrappedObjectAs<ID3D12VirtualizationGuestDevice>()->CreateFenceFd(
            encode::GetWrappedObject<ID3D12Fence>(pFence),
            FenceValue,
            pFenceFd);

        Encode_ID3D12VirtualizationGuestDevice_CreateFenceFd(
            this,
            result,
            pFence,
            FenceValue,
            pFenceFd);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12VirtualizationGuestDevice_CreateFenceFd>::Dispatch(
            manager,
            this,
            result,
            pFence,
            FenceValue,
            pFenceFd);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12VirtualizationGuestDevice>()->CreateFenceFd(
            pFence,
            FenceValue,
            pFenceFd);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Tools_Wrapper::ID3D12Tools_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12ToolsInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12Tools_Wrapper::~ID3D12Tools_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12Tools>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12Tools_Wrapper* ID3D12Tools_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12Tools_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D12Tools_Wrapper::EnableShaderInstrumentation(
    BOOL bEnable)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Tools_EnableShaderInstrumentation>::Dispatch(
            manager,
            this,
            bEnable);

        GetWrappedObjectAs<ID3D12Tools>()->EnableShaderInstrumentation(
            bEnable);

        Encode_ID3D12Tools_EnableShaderInstrumentation(
            this,
            bEnable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Tools_EnableShaderInstrumentation>::Dispatch(
            manager,
            this,
            bEnable);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Tools>()->EnableShaderInstrumentation(
            bEnable);
    }

    manager->DecrementCallScope();
}

BOOL STDMETHODCALLTYPE ID3D12Tools_Wrapper::ShaderInstrumentationEnabled()
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Tools_ShaderInstrumentationEnabled>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12Tools>()->ShaderInstrumentationEnabled();

        Encode_ID3D12Tools_ShaderInstrumentationEnabled(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Tools_ShaderInstrumentationEnabled>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Tools>()->ShaderInstrumentationEnabled();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12Tools1_Wrapper::ID3D12Tools1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Tools_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12Tools1_Wrapper::ReserveGPUVARangesAtCreate(
    D3D12_GPU_VIRTUAL_ADDRESS_RANGE* pRanges,
    UINT uiNumRanges)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Tools1_ReserveGPUVARangesAtCreate>::Dispatch(
            manager,
            this,
            pRanges,
            uiNumRanges);

        result = GetWrappedObjectAs<ID3D12Tools1>()->ReserveGPUVARangesAtCreate(
            pRanges,
            uiNumRanges);

        Encode_ID3D12Tools1_ReserveGPUVARangesAtCreate(
            this,
            result,
            pRanges,
            uiNumRanges);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Tools1_ReserveGPUVARangesAtCreate>::Dispatch(
            manager,
            this,
            result,
            pRanges,
            uiNumRanges);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12Tools1>()->ReserveGPUVARangesAtCreate(
            pRanges,
            uiNumRanges);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12Tools1_Wrapper::ClearReservedGPUVARangesList()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Tools1_ClearReservedGPUVARangesList>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12Tools1>()->ClearReservedGPUVARangesList();

        Encode_ID3D12Tools1_ClearReservedGPUVARangesList(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Tools1_ClearReservedGPUVARangesList>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Tools1>()->ClearReservedGPUVARangesList();
    }

    manager->DecrementCallScope();
}

ID3D12PageableTools_Wrapper::ID3D12PageableTools_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12PageableToolsInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12PageableTools_Wrapper::~ID3D12PageableTools_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12PageableTools>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12PageableTools_Wrapper* ID3D12PageableTools_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12PageableTools_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12PageableTools_Wrapper::GetAllocation(
    D3D12_GPU_VIRTUAL_ADDRESS_RANGE* pAllocation)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12PageableTools_GetAllocation>::Dispatch(
            manager,
            this,
            pAllocation);

        result = GetWrappedObjectAs<ID3D12PageableTools>()->GetAllocation(
            pAllocation);

        Encode_ID3D12PageableTools_GetAllocation(
            this,
            result,
            pAllocation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12PageableTools_GetAllocation>::Dispatch(
            manager,
            this,
            result,
            pAllocation);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12PageableTools>()->GetAllocation(
            pAllocation);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DeviceTools_Wrapper::ID3D12DeviceTools_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12DeviceToolsInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12DeviceTools_Wrapper::~ID3D12DeviceTools_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12DeviceTools>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12DeviceTools_Wrapper* ID3D12DeviceTools_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12DeviceTools_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D12DeviceTools_Wrapper::SetNextAllocationAddress(
    D3D12_GPU_VIRTUAL_ADDRESS nextAllocationVirtualAddress)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        RvAnnotationUtil::RemoveRvAnnotation(nextAllocationVirtualAddress);

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceTools_SetNextAllocationAddress>::Dispatch(
            manager,
            this,
            nextAllocationVirtualAddress);

        GetWrappedObjectAs<ID3D12DeviceTools>()->SetNextAllocationAddress(
            nextAllocationVirtualAddress);

        Encode_ID3D12DeviceTools_SetNextAllocationAddress(
            this,
            nextAllocationVirtualAddress);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceTools_SetNextAllocationAddress>::Dispatch(
            manager,
            this,
            nextAllocationVirtualAddress);
    }
    else
    {
        GetWrappedObjectAs<ID3D12DeviceTools>()->SetNextAllocationAddress(
            nextAllocationVirtualAddress);
    }

    manager->DecrementCallScope();
}

ID3D12SDKConfiguration_Wrapper::ID3D12SDKConfiguration_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12SDKConfigurationInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12SDKConfiguration_Wrapper::~ID3D12SDKConfiguration_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12SDKConfiguration>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12SDKConfiguration_Wrapper* ID3D12SDKConfiguration_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12SDKConfiguration_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12SDKConfiguration_Wrapper::SetSDKVersion(
    UINT SDKVersion,
    LPCSTR SDKPath)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12SDKConfiguration_SetSDKVersion>::Dispatch(
            manager,
            this,
            SDKVersion,
            SDKPath);

        result = GetWrappedObjectAs<ID3D12SDKConfiguration>()->SetSDKVersion(
            SDKVersion,
            SDKPath);

        Encode_ID3D12SDKConfiguration_SetSDKVersion(
            this,
            result,
            SDKVersion,
            SDKPath);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12SDKConfiguration_SetSDKVersion>::Dispatch(
            manager,
            this,
            result,
            SDKVersion,
            SDKPath);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12SDKConfiguration>()->SetSDKVersion(
            SDKVersion,
            SDKPath);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12SDKConfiguration1_Wrapper::ID3D12SDKConfiguration1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12SDKConfiguration_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12SDKConfiguration1_Wrapper::CreateDeviceFactory(
    UINT SDKVersion,
    LPCSTR SDKPath,
    REFIID riid,
    void** ppvFactory)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12SDKConfiguration1_CreateDeviceFactory>::Dispatch(
            manager,
            this,
            SDKVersion,
            SDKPath,
            riid,
            ppvFactory);

        result = GetWrappedObjectAs<ID3D12SDKConfiguration1>()->CreateDeviceFactory(
            SDKVersion,
            SDKPath,
            riid,
            ppvFactory);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvFactory, nullptr);
        }

        Encode_ID3D12SDKConfiguration1_CreateDeviceFactory(
            this,
            result,
            SDKVersion,
            SDKPath,
            riid,
            ppvFactory);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12SDKConfiguration1_CreateDeviceFactory>::Dispatch(
            manager,
            this,
            result,
            SDKVersion,
            SDKPath,
            riid,
            ppvFactory);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12SDKConfiguration1>()->CreateDeviceFactory(
            SDKVersion,
            SDKPath,
            riid,
            ppvFactory);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12SDKConfiguration1_Wrapper::FreeUnusedSDKs()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12SDKConfiguration1_FreeUnusedSDKs>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12SDKConfiguration1>()->FreeUnusedSDKs();

        Encode_ID3D12SDKConfiguration1_FreeUnusedSDKs(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12SDKConfiguration1_FreeUnusedSDKs>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12SDKConfiguration1>()->FreeUnusedSDKs();
    }

    manager->DecrementCallScope();
}

ID3D12DeviceFactory_Wrapper::ID3D12DeviceFactory_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12DeviceFactoryInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12DeviceFactory_Wrapper::~ID3D12DeviceFactory_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12DeviceFactory>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12DeviceFactory_Wrapper* ID3D12DeviceFactory_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12DeviceFactory_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceFactory_Wrapper::InitializeFromGlobalState()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceFactory_InitializeFromGlobalState>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12DeviceFactory>()->InitializeFromGlobalState();

        Encode_ID3D12DeviceFactory_InitializeFromGlobalState(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceFactory_InitializeFromGlobalState>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceFactory>()->InitializeFromGlobalState();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceFactory_Wrapper::ApplyToGlobalState()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceFactory_ApplyToGlobalState>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12DeviceFactory>()->ApplyToGlobalState();

        Encode_ID3D12DeviceFactory_ApplyToGlobalState(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceFactory_ApplyToGlobalState>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceFactory>()->ApplyToGlobalState();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceFactory_Wrapper::SetFlags(
    D3D12_DEVICE_FACTORY_FLAGS flags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceFactory_SetFlags>::Dispatch(
            manager,
            this,
            flags);

        result = GetWrappedObjectAs<ID3D12DeviceFactory>()->SetFlags(
            flags);

        Encode_ID3D12DeviceFactory_SetFlags(
            this,
            result,
            flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceFactory_SetFlags>::Dispatch(
            manager,
            this,
            result,
            flags);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceFactory>()->SetFlags(
            flags);
    }

    manager->DecrementCallScope();

    return result;
}

D3D12_DEVICE_FACTORY_FLAGS STDMETHODCALLTYPE ID3D12DeviceFactory_Wrapper::GetFlags()
{
    D3D12_DEVICE_FACTORY_FLAGS result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceFactory_GetFlags>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12DeviceFactory>()->GetFlags();

        Encode_ID3D12DeviceFactory_GetFlags(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceFactory_GetFlags>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceFactory>()->GetFlags();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceFactory_Wrapper::GetConfigurationInterface(
    REFCLSID clsid,
    REFIID iid,
    void** ppv)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceFactory_GetConfigurationInterface>::Dispatch(
            manager,
            this,
            clsid,
            iid,
            ppv);

        result = GetWrappedObjectAs<ID3D12DeviceFactory>()->GetConfigurationInterface(
            clsid,
            iid,
            ppv);

        if (SUCCEEDED(result))
        {
            WrapObject(iid, ppv, nullptr);
        }

        Encode_ID3D12DeviceFactory_GetConfigurationInterface(
            this,
            result,
            clsid,
            iid,
            ppv);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceFactory_GetConfigurationInterface>::Dispatch(
            manager,
            this,
            result,
            clsid,
            iid,
            ppv);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceFactory>()->GetConfigurationInterface(
            clsid,
            iid,
            ppv);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceFactory_Wrapper::EnableExperimentalFeatures(
    UINT NumFeatures,
    const IID* pIIDs,
    void* pConfigurationStructs,
    UINT* pConfigurationStructSizes)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceFactory_EnableExperimentalFeatures>::Dispatch(
            manager,
            this,
            NumFeatures,
            pIIDs,
            pConfigurationStructs,
            pConfigurationStructSizes);

        result = GetWrappedObjectAs<ID3D12DeviceFactory>()->EnableExperimentalFeatures(
            NumFeatures,
            pIIDs,
            pConfigurationStructs,
            pConfigurationStructSizes);

        Encode_ID3D12DeviceFactory_EnableExperimentalFeatures(
            this,
            result,
            NumFeatures,
            pIIDs,
            pConfigurationStructs,
            pConfigurationStructSizes);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceFactory_EnableExperimentalFeatures>::Dispatch(
            manager,
            this,
            result,
            NumFeatures,
            pIIDs,
            pConfigurationStructs,
            pConfigurationStructSizes);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceFactory>()->EnableExperimentalFeatures(
            NumFeatures,
            pIIDs,
            pConfigurationStructs,
            pConfigurationStructSizes);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceFactory_Wrapper::CreateDevice(
    IUnknown* adapter,
    D3D_FEATURE_LEVEL FeatureLevel,
    REFIID riid,
    void** ppvDevice)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceFactory_CreateDevice>::Dispatch(
            manager,
            this,
            adapter,
            FeatureLevel,
            riid,
            ppvDevice);

        result = GetWrappedObjectAs<ID3D12DeviceFactory>()->CreateDevice(
            encode::GetWrappedObject<IUnknown>(adapter),
            FeatureLevel,
            riid,
            ppvDevice);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvDevice, nullptr);
        }

        Encode_ID3D12DeviceFactory_CreateDevice(
            this,
            result,
            adapter,
            FeatureLevel,
            riid,
            ppvDevice);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceFactory_CreateDevice>::Dispatch(
            manager,
            this,
            result,
            adapter,
            FeatureLevel,
            riid,
            ppvDevice);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceFactory>()->CreateDevice(
            adapter,
            FeatureLevel,
            riid,
            ppvDevice);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DeviceConfiguration_Wrapper::ID3D12DeviceConfiguration_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12DeviceConfigurationInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12DeviceConfiguration_Wrapper::~ID3D12DeviceConfiguration_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12DeviceConfiguration>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12DeviceConfiguration_Wrapper* ID3D12DeviceConfiguration_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12DeviceConfiguration_Wrapper>(object, object_map_, object_map_lock_);
}

D3D12_DEVICE_CONFIGURATION_DESC STDMETHODCALLTYPE ID3D12DeviceConfiguration_Wrapper::GetDesc()
{
    D3D12_DEVICE_CONFIGURATION_DESC result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceConfiguration_GetDesc>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12DeviceConfiguration>()->GetDesc();

        Encode_ID3D12DeviceConfiguration_GetDesc(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceConfiguration_GetDesc>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceConfiguration>()->GetDesc();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceConfiguration_Wrapper::GetEnabledExperimentalFeatures(
    GUID* pGuids,
    UINT NumGuids)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceConfiguration_GetEnabledExperimentalFeatures>::Dispatch(
            manager,
            this,
            pGuids,
            NumGuids);

        result = GetWrappedObjectAs<ID3D12DeviceConfiguration>()->GetEnabledExperimentalFeatures(
            pGuids,
            NumGuids);

        Encode_ID3D12DeviceConfiguration_GetEnabledExperimentalFeatures(
            this,
            result,
            pGuids,
            NumGuids);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceConfiguration_GetEnabledExperimentalFeatures>::Dispatch(
            manager,
            this,
            result,
            pGuids,
            NumGuids);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceConfiguration>()->GetEnabledExperimentalFeatures(
            pGuids,
            NumGuids);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceConfiguration_Wrapper::SerializeVersionedRootSignature(
    const D3D12_VERSIONED_ROOT_SIGNATURE_DESC* pDesc,
    ID3DBlob** ppResult,
    ID3DBlob** ppError)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceConfiguration_SerializeVersionedRootSignature>::Dispatch(
            manager,
            this,
            pDesc,
            ppResult,
            ppError);

        result = GetWrappedObjectAs<ID3D12DeviceConfiguration>()->SerializeVersionedRootSignature(
            pDesc,
            ppResult,
            ppError);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D10Blob, reinterpret_cast<void**>(ppResult), nullptr);
            WrapObject(IID_ID3D10Blob, reinterpret_cast<void**>(ppError), nullptr);
        }

        Encode_ID3D12DeviceConfiguration_SerializeVersionedRootSignature(
            this,
            result,
            pDesc,
            ppResult,
            ppError);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceConfiguration_SerializeVersionedRootSignature>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            ppResult,
            ppError);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceConfiguration>()->SerializeVersionedRootSignature(
            pDesc,
            ppResult,
            ppError);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceConfiguration_Wrapper::CreateVersionedRootSignatureDeserializer(
    const void* pBlob,
    SIZE_T Size,
    REFIID riid,
    void** ppvDeserializer)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceConfiguration_CreateVersionedRootSignatureDeserializer>::Dispatch(
            manager,
            this,
            pBlob,
            Size,
            riid,
            ppvDeserializer);

        result = GetWrappedObjectAs<ID3D12DeviceConfiguration>()->CreateVersionedRootSignatureDeserializer(
            pBlob,
            Size,
            riid,
            ppvDeserializer);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvDeserializer, nullptr);
        }

        Encode_ID3D12DeviceConfiguration_CreateVersionedRootSignatureDeserializer(
            this,
            result,
            pBlob,
            Size,
            riid,
            ppvDeserializer);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceConfiguration_CreateVersionedRootSignatureDeserializer>::Dispatch(
            manager,
            this,
            result,
            pBlob,
            Size,
            riid,
            ppvDeserializer);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceConfiguration>()->CreateVersionedRootSignatureDeserializer(
            pBlob,
            Size,
            riid,
            ppvDeserializer);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DeviceConfiguration1_Wrapper::ID3D12DeviceConfiguration1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DeviceConfiguration_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12DeviceConfiguration1_Wrapper::CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary(
    const void* pLibraryBlob,
    SIZE_T Size,
    LPCWSTR RootSignatureSubobjectName,
    REFIID riid,
    void** ppvDeserializer)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DeviceConfiguration1_CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary>::Dispatch(
            manager,
            this,
            pLibraryBlob,
            Size,
            RootSignatureSubobjectName,
            riid,
            ppvDeserializer);

        result = GetWrappedObjectAs<ID3D12DeviceConfiguration1>()->CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary(
            pLibraryBlob,
            Size,
            RootSignatureSubobjectName,
            riid,
            ppvDeserializer);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvDeserializer, nullptr);
        }

        Encode_ID3D12DeviceConfiguration1_CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary(
            this,
            result,
            pLibraryBlob,
            Size,
            RootSignatureSubobjectName,
            riid,
            ppvDeserializer);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DeviceConfiguration1_CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary>::Dispatch(
            manager,
            this,
            result,
            pLibraryBlob,
            Size,
            RootSignatureSubobjectName,
            riid,
            ppvDeserializer);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DeviceConfiguration1>()->CreateVersionedRootSignatureDeserializerFromSubobjectInLibrary(
            pLibraryBlob,
            Size,
            RootSignatureSubobjectName,
            riid,
            ppvDeserializer);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12GraphicsCommandList5_Wrapper::ID3D12GraphicsCommandList5_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12GraphicsCommandList4_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList5_Wrapper::RSSetShadingRate(
    D3D12_SHADING_RATE baseShadingRate,
    const D3D12_SHADING_RATE_COMBINER* combiners)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList5_RSSetShadingRate>::Dispatch(
            manager,
            this,
            baseShadingRate,
            combiners);

        GetWrappedObjectAs<ID3D12GraphicsCommandList5>()->RSSetShadingRate(
            baseShadingRate,
            combiners);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList5_RSSetShadingRate);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList5_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->RSSetShadingRate(
                    baseShadingRate,
                    combiners);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList5_RSSetShadingRate(
            this,
            baseShadingRate,
            combiners);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList5_RSSetShadingRate>::Dispatch(
            manager,
            this,
            baseShadingRate,
            combiners);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList5>()->RSSetShadingRate(
            baseShadingRate,
            combiners);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList5_Wrapper::RSSetShadingRateImage(
    ID3D12Resource* shadingRateImage)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList5_RSSetShadingRateImage>::Dispatch(
            manager,
            this,
            shadingRateImage);

        GetWrappedObjectAs<ID3D12GraphicsCommandList5>()->RSSetShadingRateImage(
            encode::GetWrappedObject<ID3D12Resource>(shadingRateImage));

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList5_RSSetShadingRateImage);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList5_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->RSSetShadingRateImage(
                    shadingRateImage);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList5_RSSetShadingRateImage(
            this,
            shadingRateImage);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList5_RSSetShadingRateImage>::Dispatch(
            manager,
            this,
            shadingRateImage);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList5>()->RSSetShadingRateImage(
            shadingRateImage);
    }

    manager->DecrementCallScope();
}

ID3D12GraphicsCommandList6_Wrapper::ID3D12GraphicsCommandList6_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12GraphicsCommandList5_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList6_Wrapper::DispatchMesh(
    UINT ThreadGroupCountX,
    UINT ThreadGroupCountY,
    UINT ThreadGroupCountZ)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList6_DispatchMesh>::Dispatch(
            manager,
            this,
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);

        GetWrappedObjectAs<ID3D12GraphicsCommandList6>()->DispatchMesh(
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList6_DispatchMesh);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList6_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->DispatchMesh(
                    ThreadGroupCountX,
                    ThreadGroupCountY,
                    ThreadGroupCountZ);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList6_DispatchMesh(
            this,
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList6_DispatchMesh>::Dispatch(
            manager,
            this,
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList6>()->DispatchMesh(
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);
    }

    manager->DecrementCallScope();
}

ID3D12GraphicsCommandList7_Wrapper::ID3D12GraphicsCommandList7_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12GraphicsCommandList6_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList7_Wrapper::Barrier(
    UINT32 NumBarrierGroups,
    const D3D12_BARRIER_GROUP* pBarrierGroups)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList7_Barrier>::Dispatch(
            manager,
            this,
            NumBarrierGroups,
            pBarrierGroups);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D12GraphicsCommandList7>()->Barrier(
            NumBarrierGroups,
            UnwrapStructArrayObjects(pBarrierGroups, NumBarrierGroups, unwrap_memory));

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList7_Barrier);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList7_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->Barrier(
                    NumBarrierGroups,
                    pBarrierGroups);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList7_Barrier(
            this,
            NumBarrierGroups,
            pBarrierGroups);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList7_Barrier>::Dispatch(
            manager,
            this,
            NumBarrierGroups,
            pBarrierGroups);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList7>()->Barrier(
            NumBarrierGroups,
            pBarrierGroups);
    }

    manager->DecrementCallScope();
}

ID3D12GraphicsCommandList8_Wrapper::ID3D12GraphicsCommandList8_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12GraphicsCommandList7_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList8_Wrapper::OMSetFrontAndBackStencilRef(
    UINT FrontStencilRef,
    UINT BackStencilRef)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList8_OMSetFrontAndBackStencilRef>::Dispatch(
            manager,
            this,
            FrontStencilRef,
            BackStencilRef);

        GetWrappedObjectAs<ID3D12GraphicsCommandList8>()->OMSetFrontAndBackStencilRef(
            FrontStencilRef,
            BackStencilRef);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList8_OMSetFrontAndBackStencilRef);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList8_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->OMSetFrontAndBackStencilRef(
                    FrontStencilRef,
                    BackStencilRef);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList8_OMSetFrontAndBackStencilRef(
            this,
            FrontStencilRef,
            BackStencilRef);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList8_OMSetFrontAndBackStencilRef>::Dispatch(
            manager,
            this,
            FrontStencilRef,
            BackStencilRef);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList8>()->OMSetFrontAndBackStencilRef(
            FrontStencilRef,
            BackStencilRef);
    }

    manager->DecrementCallScope();
}

ID3D12GraphicsCommandList9_Wrapper::ID3D12GraphicsCommandList9_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12GraphicsCommandList8_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList9_Wrapper::RSSetDepthBias(
    FLOAT DepthBias,
    FLOAT DepthBiasClamp,
    FLOAT SlopeScaledDepthBias)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList9_RSSetDepthBias>::Dispatch(
            manager,
            this,
            DepthBias,
            DepthBiasClamp,
            SlopeScaledDepthBias);

        GetWrappedObjectAs<ID3D12GraphicsCommandList9>()->RSSetDepthBias(
            DepthBias,
            DepthBiasClamp,
            SlopeScaledDepthBias);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList9_RSSetDepthBias);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList9_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->RSSetDepthBias(
                    DepthBias,
                    DepthBiasClamp,
                    SlopeScaledDepthBias);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList9_RSSetDepthBias(
            this,
            DepthBias,
            DepthBiasClamp,
            SlopeScaledDepthBias);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList9_RSSetDepthBias>::Dispatch(
            manager,
            this,
            DepthBias,
            DepthBiasClamp,
            SlopeScaledDepthBias);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList9>()->RSSetDepthBias(
            DepthBias,
            DepthBiasClamp,
            SlopeScaledDepthBias);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList9_Wrapper::IASetIndexBufferStripCutValue(
    D3D12_INDEX_BUFFER_STRIP_CUT_VALUE IBStripCutValue)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList9_IASetIndexBufferStripCutValue>::Dispatch(
            manager,
            this,
            IBStripCutValue);

        GetWrappedObjectAs<ID3D12GraphicsCommandList9>()->IASetIndexBufferStripCutValue(
            IBStripCutValue);

        if(manager->GetTrimBoundary() == CaptureSettings::TrimBoundary::kDrawCalls)
        {
            manager->DecrementCallScope();
            auto trim_draw_calls_command_sets = manager->GetCommandListsForTrimDrawCalls(this, format::ApiCall_ID3D12GraphicsCommandList9_IASetIndexBufferStripCutValue);
            for(auto& command_set : trim_draw_calls_command_sets)
            {
                auto* base_wrapper = reinterpret_cast<ID3D12GraphicsCommandList_Wrapper*>(command_set.list.GetInterfacePtr());
                auto* wrapper = static_cast<ID3D12GraphicsCommandList9_Wrapper*>(base_wrapper);
                GFXRECON_ASSERT(wrapper != nullptr);
                wrapper->IASetIndexBufferStripCutValue(
                    IBStripCutValue);
            }
            manager->IncrementCallScope();
        }

        Encode_ID3D12GraphicsCommandList9_IASetIndexBufferStripCutValue(
            this,
            IBStripCutValue);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList9_IASetIndexBufferStripCutValue>::Dispatch(
            manager,
            this,
            IBStripCutValue);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList9>()->IASetIndexBufferStripCutValue(
            IBStripCutValue);
    }

    manager->DecrementCallScope();
}

ID3D12GraphicsCommandList10_Wrapper::ID3D12GraphicsCommandList10_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12GraphicsCommandList9_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList10_Wrapper::SetProgram(
    const D3D12_SET_PROGRAM_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList10_SetProgram>::Dispatch(
            manager,
            this,
            pDesc);

        D3D12CaptureManager::Get()->OverrideID3D12GraphicsCommandList10_SetProgram(
            this,
            pDesc);

        Encode_ID3D12GraphicsCommandList10_SetProgram(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList10_SetProgram>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList10>()->SetProgram(
            pDesc);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GraphicsCommandList10_Wrapper::DispatchGraph(
    const D3D12_DISPATCH_GRAPH_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList10_DispatchGraph>::Dispatch(
            manager,
            this,
            pDesc);

        D3D12CaptureManager::Get()->OverrideID3D12GraphicsCommandList10_DispatchGraph(
            this,
            pDesc);

        Encode_ID3D12GraphicsCommandList10_DispatchGraph(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GraphicsCommandList10_DispatchGraph>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GraphicsCommandList10>()->DispatchGraph(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D12DSRDeviceFactory_Wrapper::ID3D12DSRDeviceFactory_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12DSRDeviceFactoryInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12DSRDeviceFactory_Wrapper::~ID3D12DSRDeviceFactory_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12DSRDeviceFactory>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12DSRDeviceFactory_Wrapper* ID3D12DSRDeviceFactory_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12DSRDeviceFactory_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12DSRDeviceFactory_Wrapper::CreateDSRDevice(
    ID3D12Device* pD3D12Device,
    UINT NodeMask,
    REFIID riid,
    void** ppvDSRDevice)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DSRDeviceFactory_CreateDSRDevice>::Dispatch(
            manager,
            this,
            pD3D12Device,
            NodeMask,
            riid,
            ppvDSRDevice);

        result = GetWrappedObjectAs<ID3D12DSRDeviceFactory>()->CreateDSRDevice(
            encode::GetWrappedObject<ID3D12Device>(pD3D12Device),
            NodeMask,
            riid,
            ppvDSRDevice);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvDSRDevice, nullptr);
        }

        Encode_ID3D12DSRDeviceFactory_CreateDSRDevice(
            this,
            result,
            pD3D12Device,
            NodeMask,
            riid,
            ppvDSRDevice);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DSRDeviceFactory_CreateDSRDevice>::Dispatch(
            manager,
            this,
            result,
            pD3D12Device,
            NodeMask,
            riid,
            ppvDSRDevice);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DSRDeviceFactory>()->CreateDSRDevice(
            pD3D12Device,
            NodeMask,
            riid,
            ppvDSRDevice);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12GBVDiagnostics_Wrapper::ID3D12GBVDiagnostics_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12GBVDiagnosticsInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12GBVDiagnostics_Wrapper::~ID3D12GBVDiagnostics_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12GBVDiagnostics>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12GBVDiagnostics_Wrapper* ID3D12GBVDiagnostics_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12GBVDiagnostics_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12GBVDiagnostics_Wrapper::GetGBVEntireSubresourceStatesData(
    ID3D12Resource* pResource,
    int* pData,
    UINT DataSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GBVDiagnostics_GetGBVEntireSubresourceStatesData>::Dispatch(
            manager,
            this,
            pResource,
            pData,
            DataSize);

        result = GetWrappedObjectAs<ID3D12GBVDiagnostics>()->GetGBVEntireSubresourceStatesData(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            pData,
            DataSize);

        Encode_ID3D12GBVDiagnostics_GetGBVEntireSubresourceStatesData(
            this,
            result,
            pResource,
            pData,
            DataSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GBVDiagnostics_GetGBVEntireSubresourceStatesData>::Dispatch(
            manager,
            this,
            result,
            pResource,
            pData,
            DataSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12GBVDiagnostics>()->GetGBVEntireSubresourceStatesData(
            pResource,
            pData,
            DataSize);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12GBVDiagnostics_Wrapper::GetGBVSubresourceState(
    ID3D12Resource* pResource,
    UINT Subresource,
    int* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GBVDiagnostics_GetGBVSubresourceState>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            pData);

        result = GetWrappedObjectAs<ID3D12GBVDiagnostics>()->GetGBVSubresourceState(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            Subresource,
            pData);

        Encode_ID3D12GBVDiagnostics_GetGBVSubresourceState(
            this,
            result,
            pResource,
            Subresource,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GBVDiagnostics_GetGBVSubresourceState>::Dispatch(
            manager,
            this,
            result,
            pResource,
            Subresource,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12GBVDiagnostics>()->GetGBVSubresourceState(
            pResource,
            Subresource,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12GBVDiagnostics_Wrapper::GetGBVResourceUniformState(
    ID3D12Resource* pResource,
    int* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GBVDiagnostics_GetGBVResourceUniformState>::Dispatch(
            manager,
            this,
            pResource,
            pData);

        result = GetWrappedObjectAs<ID3D12GBVDiagnostics>()->GetGBVResourceUniformState(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            pData);

        Encode_ID3D12GBVDiagnostics_GetGBVResourceUniformState(
            this,
            result,
            pResource,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GBVDiagnostics_GetGBVResourceUniformState>::Dispatch(
            manager,
            this,
            result,
            pResource,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12GBVDiagnostics>()->GetGBVResourceUniformState(
            pResource,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12GBVDiagnostics_Wrapper::GetGBVResourceInfo(
    ID3D12Resource* pResource,
    D3D12_RESOURCE_DESC* pResourceDesc,
    UINT32* pResourceHash,
    UINT32* pSubresourceStatesByteOffset)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GBVDiagnostics_GetGBVResourceInfo>::Dispatch(
            manager,
            this,
            pResource,
            pResourceDesc,
            pResourceHash,
            pSubresourceStatesByteOffset);

        result = GetWrappedObjectAs<ID3D12GBVDiagnostics>()->GetGBVResourceInfo(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            pResourceDesc,
            pResourceHash,
            pSubresourceStatesByteOffset);

        Encode_ID3D12GBVDiagnostics_GetGBVResourceInfo(
            this,
            result,
            pResource,
            pResourceDesc,
            pResourceHash,
            pSubresourceStatesByteOffset);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GBVDiagnostics_GetGBVResourceInfo>::Dispatch(
            manager,
            this,
            result,
            pResource,
            pResourceDesc,
            pResourceHash,
            pSubresourceStatesByteOffset);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12GBVDiagnostics>()->GetGBVResourceInfo(
            pResource,
            pResourceDesc,
            pResourceHash,
            pSubresourceStatesByteOffset);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12GBVDiagnostics_Wrapper::GBVReserved0()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GBVDiagnostics_GBVReserved0>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12GBVDiagnostics>()->GBVReserved0();

        Encode_ID3D12GBVDiagnostics_GBVReserved0(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GBVDiagnostics_GBVReserved0>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GBVDiagnostics>()->GBVReserved0();
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12GBVDiagnostics_Wrapper::GBVReserved1()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12GBVDiagnostics_GBVReserved1>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12GBVDiagnostics>()->GBVReserved1();

        Encode_ID3D12GBVDiagnostics_GBVReserved1(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12GBVDiagnostics_GBVReserved1>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12GBVDiagnostics>()->GBVReserved1();
    }

    manager->DecrementCallScope();
}


/*
** This part is generated from d3dcommon.h in Windows SDK: 10.0.20348.0
**
*/

ID3D10Blob_Wrapper::ID3D10Blob_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D10BlobInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D10Blob_Wrapper::~ID3D10Blob_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D10Blob>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D10Blob_Wrapper* ID3D10Blob_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D10Blob_Wrapper>(object, object_map_, object_map_lock_);
}

LPVOID STDMETHODCALLTYPE ID3D10Blob_Wrapper::GetBufferPointer()
{
    LPVOID result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D10Blob_GetBufferPointer>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D10Blob>()->GetBufferPointer();

        Encode_ID3D10Blob_GetBufferPointer(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D10Blob_GetBufferPointer>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D10Blob>()->GetBufferPointer();
    }

    manager->DecrementCallScope();

    return result;
}

SIZE_T STDMETHODCALLTYPE ID3D10Blob_Wrapper::GetBufferSize()
{
    SIZE_T result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D10Blob_GetBufferSize>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D10Blob>()->GetBufferSize();

        Encode_ID3D10Blob_GetBufferSize(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D10Blob_GetBufferSize>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D10Blob>()->GetBufferSize();
    }

    manager->DecrementCallScope();

    return result;
}

ID3DDestructionNotifier_Wrapper::ID3DDestructionNotifier_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3DDestructionNotifierInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3DDestructionNotifier_Wrapper::~ID3DDestructionNotifier_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3DDestructionNotifier>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3DDestructionNotifier_Wrapper* ID3DDestructionNotifier_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3DDestructionNotifier_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3DDestructionNotifier_Wrapper::RegisterDestructionCallback(
    PFN_DESTRUCTION_CALLBACK callbackFn,
    void* pData,
    UINT* pCallbackID)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3DDestructionNotifier_RegisterDestructionCallback>::Dispatch(
            manager,
            this,
            callbackFn,
            pData,
            pCallbackID);

        result = GetWrappedObjectAs<ID3DDestructionNotifier>()->RegisterDestructionCallback(
            callbackFn,
            pData,
            pCallbackID);

        Encode_ID3DDestructionNotifier_RegisterDestructionCallback(
            this,
            result,
            callbackFn,
            pData,
            pCallbackID);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3DDestructionNotifier_RegisterDestructionCallback>::Dispatch(
            manager,
            this,
            result,
            callbackFn,
            pData,
            pCallbackID);
    }
    else
    {
        result = GetWrappedObjectAs<ID3DDestructionNotifier>()->RegisterDestructionCallback(
            callbackFn,
            pData,
            pCallbackID);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3DDestructionNotifier_Wrapper::UnregisterDestructionCallback(
    UINT callbackID)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3DDestructionNotifier_UnregisterDestructionCallback>::Dispatch(
            manager,
            this,
            callbackID);

        result = GetWrappedObjectAs<ID3DDestructionNotifier>()->UnregisterDestructionCallback(
            callbackID);

        Encode_ID3DDestructionNotifier_UnregisterDestructionCallback(
            this,
            result,
            callbackID);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3DDestructionNotifier_UnregisterDestructionCallback>::Dispatch(
            manager,
            this,
            result,
            callbackID);
    }
    else
    {
        result = GetWrappedObjectAs<ID3DDestructionNotifier>()->UnregisterDestructionCallback(
            callbackID);
    }

    manager->DecrementCallScope();

    return result;
}


/*
** This part is generated from d3d12sdklayers.h in Windows SDK: 10.0.20348.0
**
*/

ID3D12Debug_Wrapper::ID3D12Debug_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12DebugInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12Debug_Wrapper::~ID3D12Debug_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12Debug>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12Debug_Wrapper* ID3D12Debug_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12Debug_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D12Debug_Wrapper::EnableDebugLayer()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Debug_EnableDebugLayer>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12Debug>()->EnableDebugLayer();

        Encode_ID3D12Debug_EnableDebugLayer(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Debug_EnableDebugLayer>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Debug>()->EnableDebugLayer();
    }

    manager->DecrementCallScope();
}

ID3D12Debug1_Wrapper::ID3D12Debug1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12Debug1Info>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12Debug1_Wrapper::~ID3D12Debug1_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12Debug1>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12Debug1_Wrapper* ID3D12Debug1_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12Debug1_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D12Debug1_Wrapper::EnableDebugLayer()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Debug1_EnableDebugLayer>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12Debug1>()->EnableDebugLayer();

        Encode_ID3D12Debug1_EnableDebugLayer(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Debug1_EnableDebugLayer>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Debug1>()->EnableDebugLayer();
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12Debug1_Wrapper::SetEnableGPUBasedValidation(
    BOOL Enable)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Debug1_SetEnableGPUBasedValidation>::Dispatch(
            manager,
            this,
            Enable);

        GetWrappedObjectAs<ID3D12Debug1>()->SetEnableGPUBasedValidation(
            Enable);

        Encode_ID3D12Debug1_SetEnableGPUBasedValidation(
            this,
            Enable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Debug1_SetEnableGPUBasedValidation>::Dispatch(
            manager,
            this,
            Enable);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Debug1>()->SetEnableGPUBasedValidation(
            Enable);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12Debug1_Wrapper::SetEnableSynchronizedCommandQueueValidation(
    BOOL Enable)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Debug1_SetEnableSynchronizedCommandQueueValidation>::Dispatch(
            manager,
            this,
            Enable);

        GetWrappedObjectAs<ID3D12Debug1>()->SetEnableSynchronizedCommandQueueValidation(
            Enable);

        Encode_ID3D12Debug1_SetEnableSynchronizedCommandQueueValidation(
            this,
            Enable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Debug1_SetEnableSynchronizedCommandQueueValidation>::Dispatch(
            manager,
            this,
            Enable);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Debug1>()->SetEnableSynchronizedCommandQueueValidation(
            Enable);
    }

    manager->DecrementCallScope();
}

ID3D12Debug2_Wrapper::ID3D12Debug2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12Debug2Info>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12Debug2_Wrapper::~ID3D12Debug2_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12Debug2>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12Debug2_Wrapper* ID3D12Debug2_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12Debug2_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D12Debug2_Wrapper::SetGPUBasedValidationFlags(
    D3D12_GPU_BASED_VALIDATION_FLAGS Flags)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Debug2_SetGPUBasedValidationFlags>::Dispatch(
            manager,
            this,
            Flags);

        GetWrappedObjectAs<ID3D12Debug2>()->SetGPUBasedValidationFlags(
            Flags);

        Encode_ID3D12Debug2_SetGPUBasedValidationFlags(
            this,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Debug2_SetGPUBasedValidationFlags>::Dispatch(
            manager,
            this,
            Flags);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Debug2>()->SetGPUBasedValidationFlags(
            Flags);
    }

    manager->DecrementCallScope();
}

ID3D12Debug3_Wrapper::ID3D12Debug3_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Debug_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12Debug3_Wrapper::SetEnableGPUBasedValidation(
    BOOL Enable)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Debug3_SetEnableGPUBasedValidation>::Dispatch(
            manager,
            this,
            Enable);

        GetWrappedObjectAs<ID3D12Debug3>()->SetEnableGPUBasedValidation(
            Enable);

        Encode_ID3D12Debug3_SetEnableGPUBasedValidation(
            this,
            Enable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Debug3_SetEnableGPUBasedValidation>::Dispatch(
            manager,
            this,
            Enable);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Debug3>()->SetEnableGPUBasedValidation(
            Enable);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12Debug3_Wrapper::SetEnableSynchronizedCommandQueueValidation(
    BOOL Enable)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Debug3_SetEnableSynchronizedCommandQueueValidation>::Dispatch(
            manager,
            this,
            Enable);

        GetWrappedObjectAs<ID3D12Debug3>()->SetEnableSynchronizedCommandQueueValidation(
            Enable);

        Encode_ID3D12Debug3_SetEnableSynchronizedCommandQueueValidation(
            this,
            Enable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Debug3_SetEnableSynchronizedCommandQueueValidation>::Dispatch(
            manager,
            this,
            Enable);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Debug3>()->SetEnableSynchronizedCommandQueueValidation(
            Enable);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12Debug3_Wrapper::SetGPUBasedValidationFlags(
    D3D12_GPU_BASED_VALIDATION_FLAGS Flags)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Debug3_SetGPUBasedValidationFlags>::Dispatch(
            manager,
            this,
            Flags);

        GetWrappedObjectAs<ID3D12Debug3>()->SetGPUBasedValidationFlags(
            Flags);

        Encode_ID3D12Debug3_SetGPUBasedValidationFlags(
            this,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Debug3_SetGPUBasedValidationFlags>::Dispatch(
            manager,
            this,
            Flags);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Debug3>()->SetGPUBasedValidationFlags(
            Flags);
    }

    manager->DecrementCallScope();
}

ID3D12Debug4_Wrapper::ID3D12Debug4_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Debug3_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12Debug4_Wrapper::DisableDebugLayer()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Debug4_DisableDebugLayer>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12Debug4>()->DisableDebugLayer();

        Encode_ID3D12Debug4_DisableDebugLayer(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Debug4_DisableDebugLayer>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Debug4>()->DisableDebugLayer();
    }

    manager->DecrementCallScope();
}

ID3D12Debug5_Wrapper::ID3D12Debug5_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Debug4_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12Debug5_Wrapper::SetEnableAutoName(
    BOOL Enable)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Debug5_SetEnableAutoName>::Dispatch(
            manager,
            this,
            Enable);

        GetWrappedObjectAs<ID3D12Debug5>()->SetEnableAutoName(
            Enable);

        Encode_ID3D12Debug5_SetEnableAutoName(
            this,
            Enable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Debug5_SetEnableAutoName>::Dispatch(
            manager,
            this,
            Enable);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Debug5>()->SetEnableAutoName(
            Enable);
    }

    manager->DecrementCallScope();
}

ID3D12Debug6_Wrapper::ID3D12Debug6_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12Debug5_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12Debug6_Wrapper::SetForceLegacyBarrierValidation(
    BOOL Enable)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12Debug6_SetForceLegacyBarrierValidation>::Dispatch(
            manager,
            this,
            Enable);

        GetWrappedObjectAs<ID3D12Debug6>()->SetForceLegacyBarrierValidation(
            Enable);

        Encode_ID3D12Debug6_SetForceLegacyBarrierValidation(
            this,
            Enable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12Debug6_SetForceLegacyBarrierValidation>::Dispatch(
            manager,
            this,
            Enable);
    }
    else
    {
        GetWrappedObjectAs<ID3D12Debug6>()->SetForceLegacyBarrierValidation(
            Enable);
    }

    manager->DecrementCallScope();
}

ID3D12DebugDevice1_Wrapper::ID3D12DebugDevice1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12DebugDevice1Info>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12DebugDevice1_Wrapper::~ID3D12DebugDevice1_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12DebugDevice1>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12DebugDevice1_Wrapper* ID3D12DebugDevice1_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12DebugDevice1_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12DebugDevice1_Wrapper::SetDebugParameter(
    D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,
    const void* pData,
    UINT DataSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugDevice1_SetDebugParameter>::Dispatch(
            manager,
            this,
            Type,
            pData,
            DataSize);

        result = GetWrappedObjectAs<ID3D12DebugDevice1>()->SetDebugParameter(
            Type,
            pData,
            DataSize);

        Encode_ID3D12DebugDevice1_SetDebugParameter(
            this,
            result,
            Type,
            pData,
            DataSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugDevice1_SetDebugParameter>::Dispatch(
            manager,
            this,
            result,
            Type,
            pData,
            DataSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugDevice1>()->SetDebugParameter(
            Type,
            pData,
            DataSize);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DebugDevice1_Wrapper::GetDebugParameter(
    D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,
    void* pData,
    UINT DataSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugDevice1_GetDebugParameter>::Dispatch(
            manager,
            this,
            Type,
            pData,
            DataSize);

        result = GetWrappedObjectAs<ID3D12DebugDevice1>()->GetDebugParameter(
            Type,
            pData,
            DataSize);

        Encode_ID3D12DebugDevice1_GetDebugParameter(
            this,
            result,
            Type,
            pData,
            DataSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugDevice1_GetDebugParameter>::Dispatch(
            manager,
            this,
            result,
            Type,
            pData,
            DataSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugDevice1>()->GetDebugParameter(
            Type,
            pData,
            DataSize);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DebugDevice1_Wrapper::ReportLiveDeviceObjects(
    D3D12_RLDO_FLAGS Flags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugDevice1_ReportLiveDeviceObjects>::Dispatch(
            manager,
            this,
            Flags);

        result = GetWrappedObjectAs<ID3D12DebugDevice1>()->ReportLiveDeviceObjects(
            Flags);

        Encode_ID3D12DebugDevice1_ReportLiveDeviceObjects(
            this,
            result,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugDevice1_ReportLiveDeviceObjects>::Dispatch(
            manager,
            this,
            result,
            Flags);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugDevice1>()->ReportLiveDeviceObjects(
            Flags);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DebugDevice_Wrapper::ID3D12DebugDevice_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12DebugDeviceInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12DebugDevice_Wrapper::~ID3D12DebugDevice_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12DebugDevice>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12DebugDevice_Wrapper* ID3D12DebugDevice_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12DebugDevice_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12DebugDevice_Wrapper::SetFeatureMask(
    D3D12_DEBUG_FEATURE Mask)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugDevice_SetFeatureMask>::Dispatch(
            manager,
            this,
            Mask);

        result = GetWrappedObjectAs<ID3D12DebugDevice>()->SetFeatureMask(
            Mask);

        Encode_ID3D12DebugDevice_SetFeatureMask(
            this,
            result,
            Mask);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugDevice_SetFeatureMask>::Dispatch(
            manager,
            this,
            result,
            Mask);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugDevice>()->SetFeatureMask(
            Mask);
    }

    manager->DecrementCallScope();

    return result;
}

D3D12_DEBUG_FEATURE STDMETHODCALLTYPE ID3D12DebugDevice_Wrapper::GetFeatureMask()
{
    D3D12_DEBUG_FEATURE result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugDevice_GetFeatureMask>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12DebugDevice>()->GetFeatureMask();

        Encode_ID3D12DebugDevice_GetFeatureMask(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugDevice_GetFeatureMask>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugDevice>()->GetFeatureMask();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DebugDevice_Wrapper::ReportLiveDeviceObjects(
    D3D12_RLDO_FLAGS Flags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugDevice_ReportLiveDeviceObjects>::Dispatch(
            manager,
            this,
            Flags);

        result = GetWrappedObjectAs<ID3D12DebugDevice>()->ReportLiveDeviceObjects(
            Flags);

        Encode_ID3D12DebugDevice_ReportLiveDeviceObjects(
            this,
            result,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugDevice_ReportLiveDeviceObjects>::Dispatch(
            manager,
            this,
            result,
            Flags);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugDevice>()->ReportLiveDeviceObjects(
            Flags);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DebugDevice2_Wrapper::ID3D12DebugDevice2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DebugDevice_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12DebugDevice2_Wrapper::SetDebugParameter(
    D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,
    const void* pData,
    UINT DataSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugDevice2_SetDebugParameter>::Dispatch(
            manager,
            this,
            Type,
            pData,
            DataSize);

        result = GetWrappedObjectAs<ID3D12DebugDevice2>()->SetDebugParameter(
            Type,
            pData,
            DataSize);

        Encode_ID3D12DebugDevice2_SetDebugParameter(
            this,
            result,
            Type,
            pData,
            DataSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugDevice2_SetDebugParameter>::Dispatch(
            manager,
            this,
            result,
            Type,
            pData,
            DataSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugDevice2>()->SetDebugParameter(
            Type,
            pData,
            DataSize);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DebugDevice2_Wrapper::GetDebugParameter(
    D3D12_DEBUG_DEVICE_PARAMETER_TYPE Type,
    void* pData,
    UINT DataSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugDevice2_GetDebugParameter>::Dispatch(
            manager,
            this,
            Type,
            pData,
            DataSize);

        result = GetWrappedObjectAs<ID3D12DebugDevice2>()->GetDebugParameter(
            Type,
            pData,
            DataSize);

        Encode_ID3D12DebugDevice2_GetDebugParameter(
            this,
            result,
            Type,
            pData,
            DataSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugDevice2_GetDebugParameter>::Dispatch(
            manager,
            this,
            result,
            Type,
            pData,
            DataSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugDevice2>()->GetDebugParameter(
            Type,
            pData,
            DataSize);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DebugCommandQueue_Wrapper::ID3D12DebugCommandQueue_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12DebugCommandQueueInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12DebugCommandQueue_Wrapper::~ID3D12DebugCommandQueue_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12DebugCommandQueue>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12DebugCommandQueue_Wrapper* ID3D12DebugCommandQueue_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12DebugCommandQueue_Wrapper>(object, object_map_, object_map_lock_);
}

BOOL STDMETHODCALLTYPE ID3D12DebugCommandQueue_Wrapper::AssertResourceState(
    ID3D12Resource* pResource,
    UINT Subresource,
    UINT State)
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugCommandQueue_AssertResourceState>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            State);

        result = GetWrappedObjectAs<ID3D12DebugCommandQueue>()->AssertResourceState(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            Subresource,
            State);

        Encode_ID3D12DebugCommandQueue_AssertResourceState(
            this,
            result,
            pResource,
            Subresource,
            State);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugCommandQueue_AssertResourceState>::Dispatch(
            manager,
            this,
            result,
            pResource,
            Subresource,
            State);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugCommandQueue>()->AssertResourceState(
            pResource,
            Subresource,
            State);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DebugCommandQueue1_Wrapper::ID3D12DebugCommandQueue1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DebugCommandQueue_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12DebugCommandQueue1_Wrapper::AssertResourceAccess(
    ID3D12Resource* pResource,
    UINT Subresource,
    D3D12_BARRIER_ACCESS Access)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugCommandQueue1_AssertResourceAccess>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            Access);

        GetWrappedObjectAs<ID3D12DebugCommandQueue1>()->AssertResourceAccess(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            Subresource,
            Access);

        Encode_ID3D12DebugCommandQueue1_AssertResourceAccess(
            this,
            pResource,
            Subresource,
            Access);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugCommandQueue1_AssertResourceAccess>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            Access);
    }
    else
    {
        GetWrappedObjectAs<ID3D12DebugCommandQueue1>()->AssertResourceAccess(
            pResource,
            Subresource,
            Access);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12DebugCommandQueue1_Wrapper::AssertTextureLayout(
    ID3D12Resource* pResource,
    UINT Subresource,
    D3D12_BARRIER_LAYOUT Layout)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugCommandQueue1_AssertTextureLayout>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            Layout);

        GetWrappedObjectAs<ID3D12DebugCommandQueue1>()->AssertTextureLayout(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            Subresource,
            Layout);

        Encode_ID3D12DebugCommandQueue1_AssertTextureLayout(
            this,
            pResource,
            Subresource,
            Layout);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugCommandQueue1_AssertTextureLayout>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            Layout);
    }
    else
    {
        GetWrappedObjectAs<ID3D12DebugCommandQueue1>()->AssertTextureLayout(
            pResource,
            Subresource,
            Layout);
    }

    manager->DecrementCallScope();
}

ID3D12DebugCommandList1_Wrapper::ID3D12DebugCommandList1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12DebugCommandList1Info>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12DebugCommandList1_Wrapper::~ID3D12DebugCommandList1_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12DebugCommandList1>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12DebugCommandList1_Wrapper* ID3D12DebugCommandList1_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12DebugCommandList1_Wrapper>(object, object_map_, object_map_lock_);
}

BOOL STDMETHODCALLTYPE ID3D12DebugCommandList1_Wrapper::AssertResourceState(
    ID3D12Resource* pResource,
    UINT Subresource,
    UINT State)
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList1_AssertResourceState>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            State);

        result = GetWrappedObjectAs<ID3D12DebugCommandList1>()->AssertResourceState(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            Subresource,
            State);

        Encode_ID3D12DebugCommandList1_AssertResourceState(
            this,
            result,
            pResource,
            Subresource,
            State);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList1_AssertResourceState>::Dispatch(
            manager,
            this,
            result,
            pResource,
            Subresource,
            State);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugCommandList1>()->AssertResourceState(
            pResource,
            Subresource,
            State);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DebugCommandList1_Wrapper::SetDebugParameter(
    D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,
    const void* pData,
    UINT DataSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList1_SetDebugParameter>::Dispatch(
            manager,
            this,
            Type,
            pData,
            DataSize);

        result = GetWrappedObjectAs<ID3D12DebugCommandList1>()->SetDebugParameter(
            Type,
            pData,
            DataSize);

        Encode_ID3D12DebugCommandList1_SetDebugParameter(
            this,
            result,
            Type,
            pData,
            DataSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList1_SetDebugParameter>::Dispatch(
            manager,
            this,
            result,
            Type,
            pData,
            DataSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugCommandList1>()->SetDebugParameter(
            Type,
            pData,
            DataSize);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DebugCommandList1_Wrapper::GetDebugParameter(
    D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,
    void* pData,
    UINT DataSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList1_GetDebugParameter>::Dispatch(
            manager,
            this,
            Type,
            pData,
            DataSize);

        result = GetWrappedObjectAs<ID3D12DebugCommandList1>()->GetDebugParameter(
            Type,
            pData,
            DataSize);

        Encode_ID3D12DebugCommandList1_GetDebugParameter(
            this,
            result,
            Type,
            pData,
            DataSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList1_GetDebugParameter>::Dispatch(
            manager,
            this,
            result,
            Type,
            pData,
            DataSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugCommandList1>()->GetDebugParameter(
            Type,
            pData,
            DataSize);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DebugCommandList_Wrapper::ID3D12DebugCommandList_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12DebugCommandListInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12DebugCommandList_Wrapper::~ID3D12DebugCommandList_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12DebugCommandList>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12DebugCommandList_Wrapper* ID3D12DebugCommandList_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12DebugCommandList_Wrapper>(object, object_map_, object_map_lock_);
}

BOOL STDMETHODCALLTYPE ID3D12DebugCommandList_Wrapper::AssertResourceState(
    ID3D12Resource* pResource,
    UINT Subresource,
    UINT State)
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList_AssertResourceState>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            State);

        result = GetWrappedObjectAs<ID3D12DebugCommandList>()->AssertResourceState(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            Subresource,
            State);

        Encode_ID3D12DebugCommandList_AssertResourceState(
            this,
            result,
            pResource,
            Subresource,
            State);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList_AssertResourceState>::Dispatch(
            manager,
            this,
            result,
            pResource,
            Subresource,
            State);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugCommandList>()->AssertResourceState(
            pResource,
            Subresource,
            State);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DebugCommandList_Wrapper::SetFeatureMask(
    D3D12_DEBUG_FEATURE Mask)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList_SetFeatureMask>::Dispatch(
            manager,
            this,
            Mask);

        result = GetWrappedObjectAs<ID3D12DebugCommandList>()->SetFeatureMask(
            Mask);

        Encode_ID3D12DebugCommandList_SetFeatureMask(
            this,
            result,
            Mask);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList_SetFeatureMask>::Dispatch(
            manager,
            this,
            result,
            Mask);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugCommandList>()->SetFeatureMask(
            Mask);
    }

    manager->DecrementCallScope();

    return result;
}

D3D12_DEBUG_FEATURE STDMETHODCALLTYPE ID3D12DebugCommandList_Wrapper::GetFeatureMask()
{
    D3D12_DEBUG_FEATURE result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList_GetFeatureMask>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12DebugCommandList>()->GetFeatureMask();

        Encode_ID3D12DebugCommandList_GetFeatureMask(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList_GetFeatureMask>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugCommandList>()->GetFeatureMask();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DebugCommandList2_Wrapper::ID3D12DebugCommandList2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DebugCommandList_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12DebugCommandList2_Wrapper::SetDebugParameter(
    D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,
    const void* pData,
    UINT DataSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList2_SetDebugParameter>::Dispatch(
            manager,
            this,
            Type,
            pData,
            DataSize);

        result = GetWrappedObjectAs<ID3D12DebugCommandList2>()->SetDebugParameter(
            Type,
            pData,
            DataSize);

        Encode_ID3D12DebugCommandList2_SetDebugParameter(
            this,
            result,
            Type,
            pData,
            DataSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList2_SetDebugParameter>::Dispatch(
            manager,
            this,
            result,
            Type,
            pData,
            DataSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugCommandList2>()->SetDebugParameter(
            Type,
            pData,
            DataSize);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12DebugCommandList2_Wrapper::GetDebugParameter(
    D3D12_DEBUG_COMMAND_LIST_PARAMETER_TYPE Type,
    void* pData,
    UINT DataSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList2_GetDebugParameter>::Dispatch(
            manager,
            this,
            Type,
            pData,
            DataSize);

        result = GetWrappedObjectAs<ID3D12DebugCommandList2>()->GetDebugParameter(
            Type,
            pData,
            DataSize);

        Encode_ID3D12DebugCommandList2_GetDebugParameter(
            this,
            result,
            Type,
            pData,
            DataSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList2_GetDebugParameter>::Dispatch(
            manager,
            this,
            result,
            Type,
            pData,
            DataSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12DebugCommandList2>()->GetDebugParameter(
            Type,
            pData,
            DataSize);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12DebugCommandList3_Wrapper::ID3D12DebugCommandList3_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12DebugCommandList2_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D12DebugCommandList3_Wrapper::AssertResourceAccess(
    ID3D12Resource* pResource,
    UINT Subresource,
    D3D12_BARRIER_ACCESS Access)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList3_AssertResourceAccess>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            Access);

        GetWrappedObjectAs<ID3D12DebugCommandList3>()->AssertResourceAccess(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            Subresource,
            Access);

        Encode_ID3D12DebugCommandList3_AssertResourceAccess(
            this,
            pResource,
            Subresource,
            Access);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList3_AssertResourceAccess>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            Access);
    }
    else
    {
        GetWrappedObjectAs<ID3D12DebugCommandList3>()->AssertResourceAccess(
            pResource,
            Subresource,
            Access);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12DebugCommandList3_Wrapper::AssertTextureLayout(
    ID3D12Resource* pResource,
    UINT Subresource,
    D3D12_BARRIER_LAYOUT Layout)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList3_AssertTextureLayout>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            Layout);

        GetWrappedObjectAs<ID3D12DebugCommandList3>()->AssertTextureLayout(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            Subresource,
            Layout);

        Encode_ID3D12DebugCommandList3_AssertTextureLayout(
            this,
            pResource,
            Subresource,
            Layout);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12DebugCommandList3_AssertTextureLayout>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            Layout);
    }
    else
    {
        GetWrappedObjectAs<ID3D12DebugCommandList3>()->AssertTextureLayout(
            pResource,
            Subresource,
            Layout);
    }

    manager->DecrementCallScope();
}

ID3D12SharingContract_Wrapper::ID3D12SharingContract_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12SharingContractInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12SharingContract_Wrapper::~ID3D12SharingContract_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12SharingContract>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12SharingContract_Wrapper* ID3D12SharingContract_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12SharingContract_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D12SharingContract_Wrapper::Present(
    ID3D12Resource* pResource,
    UINT Subresource,
    HWND window)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12SharingContract_Present>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            window);

        GetWrappedObjectAs<ID3D12SharingContract>()->Present(
            encode::GetWrappedObject<ID3D12Resource>(pResource),
            Subresource,
            window);

        Encode_ID3D12SharingContract_Present(
            this,
            pResource,
            Subresource,
            window);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12SharingContract_Present>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            window);
    }
    else
    {
        GetWrappedObjectAs<ID3D12SharingContract>()->Present(
            pResource,
            Subresource,
            window);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12SharingContract_Wrapper::SharedFenceSignal(
    ID3D12Fence* pFence,
    UINT64 FenceValue)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12SharingContract_SharedFenceSignal>::Dispatch(
            manager,
            this,
            pFence,
            FenceValue);

        GetWrappedObjectAs<ID3D12SharingContract>()->SharedFenceSignal(
            encode::GetWrappedObject<ID3D12Fence>(pFence),
            FenceValue);

        Encode_ID3D12SharingContract_SharedFenceSignal(
            this,
            pFence,
            FenceValue);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12SharingContract_SharedFenceSignal>::Dispatch(
            manager,
            this,
            pFence,
            FenceValue);
    }
    else
    {
        GetWrappedObjectAs<ID3D12SharingContract>()->SharedFenceSignal(
            pFence,
            FenceValue);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12SharingContract_Wrapper::BeginCapturableWork(
    REFGUID guid)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12SharingContract_BeginCapturableWork>::Dispatch(
            manager,
            this,
            guid);

        GetWrappedObjectAs<ID3D12SharingContract>()->BeginCapturableWork(
            guid);

        Encode_ID3D12SharingContract_BeginCapturableWork(
            this,
            guid);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12SharingContract_BeginCapturableWork>::Dispatch(
            manager,
            this,
            guid);
    }
    else
    {
        GetWrappedObjectAs<ID3D12SharingContract>()->BeginCapturableWork(
            guid);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D12SharingContract_Wrapper::EndCapturableWork(
    REFGUID guid)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12SharingContract_EndCapturableWork>::Dispatch(
            manager,
            this,
            guid);

        GetWrappedObjectAs<ID3D12SharingContract>()->EndCapturableWork(
            guid);

        Encode_ID3D12SharingContract_EndCapturableWork(
            this,
            guid);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12SharingContract_EndCapturableWork>::Dispatch(
            manager,
            this,
            guid);
    }
    else
    {
        GetWrappedObjectAs<ID3D12SharingContract>()->EndCapturableWork(
            guid);
    }

    manager->DecrementCallScope();
}

ID3D12ManualWriteTrackingResource_Wrapper::ID3D12ManualWriteTrackingResource_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12ManualWriteTrackingResourceInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12ManualWriteTrackingResource_Wrapper::~ID3D12ManualWriteTrackingResource_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12ManualWriteTrackingResource>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12ManualWriteTrackingResource_Wrapper* ID3D12ManualWriteTrackingResource_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12ManualWriteTrackingResource_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D12ManualWriteTrackingResource_Wrapper::TrackWrite(
    UINT Subresource,
    const D3D12_RANGE* pWrittenRange)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12ManualWriteTrackingResource_TrackWrite>::Dispatch(
            manager,
            this,
            Subresource,
            pWrittenRange);

        GetWrappedObjectAs<ID3D12ManualWriteTrackingResource>()->TrackWrite(
            Subresource,
            pWrittenRange);

        Encode_ID3D12ManualWriteTrackingResource_TrackWrite(
            this,
            Subresource,
            pWrittenRange);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12ManualWriteTrackingResource_TrackWrite>::Dispatch(
            manager,
            this,
            Subresource,
            pWrittenRange);
    }
    else
    {
        GetWrappedObjectAs<ID3D12ManualWriteTrackingResource>()->TrackWrite(
            Subresource,
            pWrittenRange);
    }

    manager->DecrementCallScope();
}

ID3D12InfoQueue_Wrapper::ID3D12InfoQueue_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D12InfoQueueInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D12InfoQueue_Wrapper::~ID3D12InfoQueue_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D12InfoQueue>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D12InfoQueue_Wrapper* ID3D12InfoQueue_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D12InfoQueue_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::SetMessageCountLimit(
    UINT64 MessageCountLimit)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_SetMessageCountLimit>::Dispatch(
            manager,
            this,
            MessageCountLimit);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->SetMessageCountLimit(
            MessageCountLimit);

        Encode_ID3D12InfoQueue_SetMessageCountLimit(
            this,
            result,
            MessageCountLimit);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_SetMessageCountLimit>::Dispatch(
            manager,
            this,
            result,
            MessageCountLimit);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->SetMessageCountLimit(
            MessageCountLimit);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::ClearStoredMessages()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_ClearStoredMessages>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12InfoQueue>()->ClearStoredMessages();

        Encode_ID3D12InfoQueue_ClearStoredMessages(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_ClearStoredMessages>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12InfoQueue>()->ClearStoredMessages();
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetMessage(
    UINT64 MessageIndex,
    D3D12_MESSAGE* pMessage,
    SIZE_T* pMessageByteLength)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetMessage>::Dispatch(
            manager,
            this,
            MessageIndex,
            pMessage,
            pMessageByteLength);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetMessage(
            MessageIndex,
            pMessage,
            pMessageByteLength);

        Encode_ID3D12InfoQueue_GetMessage(
            this,
            result,
            MessageIndex,
            pMessage,
            pMessageByteLength);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetMessage>::Dispatch(
            manager,
            this,
            result,
            MessageIndex,
            pMessage,
            pMessageByteLength);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetMessage(
            MessageIndex,
            pMessage,
            pMessageByteLength);
    }

    manager->DecrementCallScope();

    return result;
}

UINT64 STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetNumMessagesAllowedByStorageFilter()
{
    UINT64 result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetNumMessagesAllowedByStorageFilter>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetNumMessagesAllowedByStorageFilter();

        Encode_ID3D12InfoQueue_GetNumMessagesAllowedByStorageFilter(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetNumMessagesAllowedByStorageFilter>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetNumMessagesAllowedByStorageFilter();
    }

    manager->DecrementCallScope();

    return result;
}

UINT64 STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetNumMessagesDeniedByStorageFilter()
{
    UINT64 result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetNumMessagesDeniedByStorageFilter>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetNumMessagesDeniedByStorageFilter();

        Encode_ID3D12InfoQueue_GetNumMessagesDeniedByStorageFilter(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetNumMessagesDeniedByStorageFilter>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetNumMessagesDeniedByStorageFilter();
    }

    manager->DecrementCallScope();

    return result;
}

UINT64 STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetNumStoredMessages()
{
    UINT64 result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetNumStoredMessages>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetNumStoredMessages();

        Encode_ID3D12InfoQueue_GetNumStoredMessages(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetNumStoredMessages>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetNumStoredMessages();
    }

    manager->DecrementCallScope();

    return result;
}

UINT64 STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetNumStoredMessagesAllowedByRetrievalFilter()
{
    UINT64 result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetNumStoredMessagesAllowedByRetrievalFilter>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetNumStoredMessagesAllowedByRetrievalFilter();

        Encode_ID3D12InfoQueue_GetNumStoredMessagesAllowedByRetrievalFilter(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetNumStoredMessagesAllowedByRetrievalFilter>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetNumStoredMessagesAllowedByRetrievalFilter();
    }

    manager->DecrementCallScope();

    return result;
}

UINT64 STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetNumMessagesDiscardedByMessageCountLimit()
{
    UINT64 result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetNumMessagesDiscardedByMessageCountLimit>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetNumMessagesDiscardedByMessageCountLimit();

        Encode_ID3D12InfoQueue_GetNumMessagesDiscardedByMessageCountLimit(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetNumMessagesDiscardedByMessageCountLimit>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetNumMessagesDiscardedByMessageCountLimit();
    }

    manager->DecrementCallScope();

    return result;
}

UINT64 STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetMessageCountLimit()
{
    UINT64 result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetMessageCountLimit>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetMessageCountLimit();

        Encode_ID3D12InfoQueue_GetMessageCountLimit(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetMessageCountLimit>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetMessageCountLimit();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::AddStorageFilterEntries(
    D3D12_INFO_QUEUE_FILTER* pFilter)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_AddStorageFilterEntries>::Dispatch(
            manager,
            this,
            pFilter);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->AddStorageFilterEntries(
            pFilter);

        Encode_ID3D12InfoQueue_AddStorageFilterEntries(
            this,
            result,
            pFilter);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_AddStorageFilterEntries>::Dispatch(
            manager,
            this,
            result,
            pFilter);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->AddStorageFilterEntries(
            pFilter);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetStorageFilter(
    D3D12_INFO_QUEUE_FILTER* pFilter,
    SIZE_T* pFilterByteLength)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetStorageFilter>::Dispatch(
            manager,
            this,
            pFilter,
            pFilterByteLength);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetStorageFilter(
            pFilter,
            pFilterByteLength);

        Encode_ID3D12InfoQueue_GetStorageFilter(
            this,
            result,
            pFilter,
            pFilterByteLength);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetStorageFilter>::Dispatch(
            manager,
            this,
            result,
            pFilter,
            pFilterByteLength);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetStorageFilter(
            pFilter,
            pFilterByteLength);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::ClearStorageFilter()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_ClearStorageFilter>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12InfoQueue>()->ClearStorageFilter();

        Encode_ID3D12InfoQueue_ClearStorageFilter(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_ClearStorageFilter>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12InfoQueue>()->ClearStorageFilter();
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::PushEmptyStorageFilter()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PushEmptyStorageFilter>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->PushEmptyStorageFilter();

        Encode_ID3D12InfoQueue_PushEmptyStorageFilter(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PushEmptyStorageFilter>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->PushEmptyStorageFilter();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::PushCopyOfStorageFilter()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PushCopyOfStorageFilter>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->PushCopyOfStorageFilter();

        Encode_ID3D12InfoQueue_PushCopyOfStorageFilter(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PushCopyOfStorageFilter>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->PushCopyOfStorageFilter();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::PushStorageFilter(
    D3D12_INFO_QUEUE_FILTER* pFilter)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PushStorageFilter>::Dispatch(
            manager,
            this,
            pFilter);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->PushStorageFilter(
            pFilter);

        Encode_ID3D12InfoQueue_PushStorageFilter(
            this,
            result,
            pFilter);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PushStorageFilter>::Dispatch(
            manager,
            this,
            result,
            pFilter);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->PushStorageFilter(
            pFilter);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::PopStorageFilter()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PopStorageFilter>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12InfoQueue>()->PopStorageFilter();

        Encode_ID3D12InfoQueue_PopStorageFilter(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PopStorageFilter>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12InfoQueue>()->PopStorageFilter();
    }

    manager->DecrementCallScope();
}

UINT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetStorageFilterStackSize()
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetStorageFilterStackSize>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetStorageFilterStackSize();

        Encode_ID3D12InfoQueue_GetStorageFilterStackSize(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetStorageFilterStackSize>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetStorageFilterStackSize();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::AddRetrievalFilterEntries(
    D3D12_INFO_QUEUE_FILTER* pFilter)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_AddRetrievalFilterEntries>::Dispatch(
            manager,
            this,
            pFilter);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->AddRetrievalFilterEntries(
            pFilter);

        Encode_ID3D12InfoQueue_AddRetrievalFilterEntries(
            this,
            result,
            pFilter);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_AddRetrievalFilterEntries>::Dispatch(
            manager,
            this,
            result,
            pFilter);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->AddRetrievalFilterEntries(
            pFilter);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetRetrievalFilter(
    D3D12_INFO_QUEUE_FILTER* pFilter,
    SIZE_T* pFilterByteLength)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetRetrievalFilter>::Dispatch(
            manager,
            this,
            pFilter,
            pFilterByteLength);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetRetrievalFilter(
            pFilter,
            pFilterByteLength);

        Encode_ID3D12InfoQueue_GetRetrievalFilter(
            this,
            result,
            pFilter,
            pFilterByteLength);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetRetrievalFilter>::Dispatch(
            manager,
            this,
            result,
            pFilter,
            pFilterByteLength);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetRetrievalFilter(
            pFilter,
            pFilterByteLength);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::ClearRetrievalFilter()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_ClearRetrievalFilter>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12InfoQueue>()->ClearRetrievalFilter();

        Encode_ID3D12InfoQueue_ClearRetrievalFilter(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_ClearRetrievalFilter>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12InfoQueue>()->ClearRetrievalFilter();
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::PushEmptyRetrievalFilter()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PushEmptyRetrievalFilter>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->PushEmptyRetrievalFilter();

        Encode_ID3D12InfoQueue_PushEmptyRetrievalFilter(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PushEmptyRetrievalFilter>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->PushEmptyRetrievalFilter();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::PushCopyOfRetrievalFilter()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PushCopyOfRetrievalFilter>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->PushCopyOfRetrievalFilter();

        Encode_ID3D12InfoQueue_PushCopyOfRetrievalFilter(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PushCopyOfRetrievalFilter>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->PushCopyOfRetrievalFilter();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::PushRetrievalFilter(
    D3D12_INFO_QUEUE_FILTER* pFilter)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PushRetrievalFilter>::Dispatch(
            manager,
            this,
            pFilter);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->PushRetrievalFilter(
            pFilter);

        Encode_ID3D12InfoQueue_PushRetrievalFilter(
            this,
            result,
            pFilter);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PushRetrievalFilter>::Dispatch(
            manager,
            this,
            result,
            pFilter);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->PushRetrievalFilter(
            pFilter);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::PopRetrievalFilter()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PopRetrievalFilter>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D12InfoQueue>()->PopRetrievalFilter();

        Encode_ID3D12InfoQueue_PopRetrievalFilter(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_PopRetrievalFilter>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D12InfoQueue>()->PopRetrievalFilter();
    }

    manager->DecrementCallScope();
}

UINT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetRetrievalFilterStackSize()
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetRetrievalFilterStackSize>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetRetrievalFilterStackSize();

        Encode_ID3D12InfoQueue_GetRetrievalFilterStackSize(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetRetrievalFilterStackSize>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetRetrievalFilterStackSize();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::AddMessage(
    D3D12_MESSAGE_CATEGORY Category,
    D3D12_MESSAGE_SEVERITY Severity,
    D3D12_MESSAGE_ID ID,
    LPCSTR pDescription)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_AddMessage>::Dispatch(
            manager,
            this,
            Category,
            Severity,
            ID,
            pDescription);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->AddMessage(
            Category,
            Severity,
            ID,
            pDescription);

        Encode_ID3D12InfoQueue_AddMessage(
            this,
            result,
            Category,
            Severity,
            ID,
            pDescription);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_AddMessage>::Dispatch(
            manager,
            this,
            result,
            Category,
            Severity,
            ID,
            pDescription);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->AddMessage(
            Category,
            Severity,
            ID,
            pDescription);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::AddApplicationMessage(
    D3D12_MESSAGE_SEVERITY Severity,
    LPCSTR pDescription)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_AddApplicationMessage>::Dispatch(
            manager,
            this,
            Severity,
            pDescription);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->AddApplicationMessage(
            Severity,
            pDescription);

        Encode_ID3D12InfoQueue_AddApplicationMessage(
            this,
            result,
            Severity,
            pDescription);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_AddApplicationMessage>::Dispatch(
            manager,
            this,
            result,
            Severity,
            pDescription);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->AddApplicationMessage(
            Severity,
            pDescription);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::SetBreakOnCategory(
    D3D12_MESSAGE_CATEGORY Category,
    BOOL bEnable)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_SetBreakOnCategory>::Dispatch(
            manager,
            this,
            Category,
            bEnable);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->SetBreakOnCategory(
            Category,
            bEnable);

        Encode_ID3D12InfoQueue_SetBreakOnCategory(
            this,
            result,
            Category,
            bEnable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_SetBreakOnCategory>::Dispatch(
            manager,
            this,
            result,
            Category,
            bEnable);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->SetBreakOnCategory(
            Category,
            bEnable);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::SetBreakOnSeverity(
    D3D12_MESSAGE_SEVERITY Severity,
    BOOL bEnable)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_SetBreakOnSeverity>::Dispatch(
            manager,
            this,
            Severity,
            bEnable);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->SetBreakOnSeverity(
            Severity,
            bEnable);

        Encode_ID3D12InfoQueue_SetBreakOnSeverity(
            this,
            result,
            Severity,
            bEnable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_SetBreakOnSeverity>::Dispatch(
            manager,
            this,
            result,
            Severity,
            bEnable);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->SetBreakOnSeverity(
            Severity,
            bEnable);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::SetBreakOnID(
    D3D12_MESSAGE_ID ID,
    BOOL bEnable)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_SetBreakOnID>::Dispatch(
            manager,
            this,
            ID,
            bEnable);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->SetBreakOnID(
            ID,
            bEnable);

        Encode_ID3D12InfoQueue_SetBreakOnID(
            this,
            result,
            ID,
            bEnable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_SetBreakOnID>::Dispatch(
            manager,
            this,
            result,
            ID,
            bEnable);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->SetBreakOnID(
            ID,
            bEnable);
    }

    manager->DecrementCallScope();

    return result;
}

BOOL STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetBreakOnCategory(
    D3D12_MESSAGE_CATEGORY Category)
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetBreakOnCategory>::Dispatch(
            manager,
            this,
            Category);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetBreakOnCategory(
            Category);

        Encode_ID3D12InfoQueue_GetBreakOnCategory(
            this,
            result,
            Category);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetBreakOnCategory>::Dispatch(
            manager,
            this,
            result,
            Category);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetBreakOnCategory(
            Category);
    }

    manager->DecrementCallScope();

    return result;
}

BOOL STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetBreakOnSeverity(
    D3D12_MESSAGE_SEVERITY Severity)
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetBreakOnSeverity>::Dispatch(
            manager,
            this,
            Severity);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetBreakOnSeverity(
            Severity);

        Encode_ID3D12InfoQueue_GetBreakOnSeverity(
            this,
            result,
            Severity);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetBreakOnSeverity>::Dispatch(
            manager,
            this,
            result,
            Severity);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetBreakOnSeverity(
            Severity);
    }

    manager->DecrementCallScope();

    return result;
}

BOOL STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetBreakOnID(
    D3D12_MESSAGE_ID ID)
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetBreakOnID>::Dispatch(
            manager,
            this,
            ID);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetBreakOnID(
            ID);

        Encode_ID3D12InfoQueue_GetBreakOnID(
            this,
            result,
            ID);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetBreakOnID>::Dispatch(
            manager,
            this,
            result,
            ID);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetBreakOnID(
            ID);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::SetMuteDebugOutput(
    BOOL bMute)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_SetMuteDebugOutput>::Dispatch(
            manager,
            this,
            bMute);

        GetWrappedObjectAs<ID3D12InfoQueue>()->SetMuteDebugOutput(
            bMute);

        Encode_ID3D12InfoQueue_SetMuteDebugOutput(
            this,
            bMute);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_SetMuteDebugOutput>::Dispatch(
            manager,
            this,
            bMute);
    }
    else
    {
        GetWrappedObjectAs<ID3D12InfoQueue>()->SetMuteDebugOutput(
            bMute);
    }

    manager->DecrementCallScope();
}

BOOL STDMETHODCALLTYPE ID3D12InfoQueue_Wrapper::GetMuteDebugOutput()
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetMuteDebugOutput>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetMuteDebugOutput();

        Encode_ID3D12InfoQueue_GetMuteDebugOutput(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue_GetMuteDebugOutput>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue>()->GetMuteDebugOutput();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D12InfoQueue1_Wrapper::ID3D12InfoQueue1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D12InfoQueue_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue1_Wrapper::RegisterMessageCallback(
    D3D12MessageFunc CallbackFunc,
    D3D12_MESSAGE_CALLBACK_FLAGS CallbackFilterFlags,
    void* pContext,
    DWORD* pCallbackCookie)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue1_RegisterMessageCallback>::Dispatch(
            manager,
            this,
            CallbackFunc,
            CallbackFilterFlags,
            pContext,
            pCallbackCookie);

        result = GetWrappedObjectAs<ID3D12InfoQueue1>()->RegisterMessageCallback(
            CallbackFunc,
            CallbackFilterFlags,
            pContext,
            pCallbackCookie);

        Encode_ID3D12InfoQueue1_RegisterMessageCallback(
            this,
            result,
            CallbackFunc,
            CallbackFilterFlags,
            pContext,
            pCallbackCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue1_RegisterMessageCallback>::Dispatch(
            manager,
            this,
            result,
            CallbackFunc,
            CallbackFilterFlags,
            pContext,
            pCallbackCookie);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue1>()->RegisterMessageCallback(
            CallbackFunc,
            CallbackFilterFlags,
            pContext,
            pCallbackCookie);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D12InfoQueue1_Wrapper::UnregisterMessageCallback(
    DWORD CallbackCookie)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D12InfoQueue1_UnregisterMessageCallback>::Dispatch(
            manager,
            this,
            CallbackCookie);

        result = GetWrappedObjectAs<ID3D12InfoQueue1>()->UnregisterMessageCallback(
            CallbackCookie);

        Encode_ID3D12InfoQueue1_UnregisterMessageCallback(
            this,
            result,
            CallbackCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D12InfoQueue1_UnregisterMessageCallback>::Dispatch(
            manager,
            this,
            result,
            CallbackCookie);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D12InfoQueue1>()->UnregisterMessageCallback(
            CallbackCookie);
    }

    manager->DecrementCallScope();

    return result;
}


/*
** This part is generated from d3d11.h in Windows SDK: 10.0.20348.0
**
*/

HRESULT WINAPI D3D11CreateDevice(
    IDXGIAdapter* pAdapter,
    D3D_DRIVER_TYPE DriverType,
    HMODULE Software,
    UINT Flags,
    const D3D_FEATURE_LEVEL* pFeatureLevels,
    UINT FeatureLevels,
    UINT SDKVersion,
    ID3D11Device** ppDevice,
    D3D_FEATURE_LEVEL* pFeatureLevel,
    ID3D11DeviceContext** ppImmediateContext)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_D3D11CreateDevice>::Dispatch(
            manager,
            pAdapter,
            DriverType,
            Software,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            ppDevice,
            pFeatureLevel,
            ppImmediateContext);

        result = D3D12CaptureManager::Get()->OverrideD3D11CreateDevice(
            encode::GetWrappedObject<IDXGIAdapter>(pAdapter),
            DriverType,
            Software,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            ppDevice,
            pFeatureLevel,
            ppImmediateContext);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11Device, reinterpret_cast<void**>(ppDevice), nullptr);
            WrapObject(IID_ID3D11DeviceContext, reinterpret_cast<void**>(ppImmediateContext), nullptr);
        }

        Encode_D3D11CreateDevice(
            result,
            pAdapter,
            DriverType,
            Software,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            ppDevice,
            pFeatureLevel,
            ppImmediateContext);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_D3D11CreateDevice>::Dispatch(
            manager,
            result,
            pAdapter,
            DriverType,
            Software,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            ppDevice,
            pFeatureLevel,
            ppImmediateContext);
    }
    else
    {
        result = manager->GetD3D11DispatchTable().D3D11CreateDevice(
            pAdapter,
            DriverType,
            Software,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            ppDevice,
            pFeatureLevel,
            ppImmediateContext);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT WINAPI D3D11CreateDeviceAndSwapChain(
    IDXGIAdapter* pAdapter,
    D3D_DRIVER_TYPE DriverType,
    HMODULE Software,
    UINT Flags,
    const D3D_FEATURE_LEVEL* pFeatureLevels,
    UINT FeatureLevels,
    UINT SDKVersion,
    const DXGI_SWAP_CHAIN_DESC* pSwapChainDesc,
    IDXGISwapChain** ppSwapChain,
    ID3D11Device** ppDevice,
    D3D_FEATURE_LEVEL* pFeatureLevel,
    ID3D11DeviceContext** ppImmediateContext)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_D3D11CreateDeviceAndSwapChain>::Dispatch(
            manager,
            pAdapter,
            DriverType,
            Software,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            pSwapChainDesc,
            ppSwapChain,
            ppDevice,
            pFeatureLevel,
            ppImmediateContext);

        result = D3D12CaptureManager::Get()->OverrideD3D11CreateDeviceAndSwapChain(
            encode::GetWrappedObject<IDXGIAdapter>(pAdapter),
            DriverType,
            Software,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            pSwapChainDesc,
            ppSwapChain,
            ppDevice,
            pFeatureLevel,
            ppImmediateContext);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGISwapChain, reinterpret_cast<void**>(ppSwapChain), nullptr);
            WrapObject(IID_ID3D11Device, reinterpret_cast<void**>(ppDevice), nullptr);
            WrapObject(IID_ID3D11DeviceContext, reinterpret_cast<void**>(ppImmediateContext), nullptr);
        }

        Encode_D3D11CreateDeviceAndSwapChain(
            result,
            pAdapter,
            DriverType,
            Software,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            pSwapChainDesc,
            ppSwapChain,
            ppDevice,
            pFeatureLevel,
            ppImmediateContext);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_D3D11CreateDeviceAndSwapChain>::Dispatch(
            manager,
            result,
            pAdapter,
            DriverType,
            Software,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            pSwapChainDesc,
            ppSwapChain,
            ppDevice,
            pFeatureLevel,
            ppImmediateContext);
    }
    else
    {
        result = manager->GetD3D11DispatchTable().D3D11CreateDeviceAndSwapChain(
            pAdapter,
            DriverType,
            Software,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            pSwapChainDesc,
            ppSwapChain,
            ppDevice,
            pFeatureLevel,
            ppImmediateContext);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11DeviceChild_Wrapper::ID3D11DeviceChild_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11DeviceChild_Wrapper::GetDevice(
    ID3D11Device** ppDevice)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceChild_GetDevice>::Dispatch(
            manager,
            this,
            ppDevice);

        GetWrappedObjectAs<ID3D11DeviceChild>()->GetDevice(
            ppDevice);

        WrapObject(IID_ID3D11Device, reinterpret_cast<void**>(ppDevice), nullptr);

        Encode_ID3D11DeviceChild_GetDevice(
            this,
            ppDevice);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceChild_GetDevice>::Dispatch(
            manager,
            this,
            ppDevice);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceChild>()->GetDevice(
            ppDevice);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D11DeviceChild_Wrapper::GetPrivateData(
    REFGUID guid,
    UINT* pDataSize,
    void* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceChild_GetPrivateData>::Dispatch(
            manager,
            this,
            guid,
            pDataSize,
            pData);

        result = GetWrappedObjectAs<ID3D11DeviceChild>()->GetPrivateData(
            guid,
            pDataSize,
            pData);

        Encode_ID3D11DeviceChild_GetPrivateData(
            this,
            result,
            guid,
            pDataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceChild_GetPrivateData>::Dispatch(
            manager,
            this,
            result,
            guid,
            pDataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceChild>()->GetPrivateData(
            guid,
            pDataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11DeviceChild_Wrapper::SetPrivateData(
    REFGUID guid,
    UINT DataSize,
    const void* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceChild_SetPrivateData>::Dispatch(
            manager,
            this,
            guid,
            DataSize,
            pData);

        result = GetWrappedObjectAs<ID3D11DeviceChild>()->SetPrivateData(
            guid,
            DataSize,
            pData);

        Encode_ID3D11DeviceChild_SetPrivateData(
            this,
            result,
            guid,
            DataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceChild_SetPrivateData>::Dispatch(
            manager,
            this,
            result,
            guid,
            DataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceChild>()->SetPrivateData(
            guid,
            DataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11DeviceChild_Wrapper::SetPrivateDataInterface(
    REFGUID guid,
    const IUnknown* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceChild_SetPrivateDataInterface>::Dispatch(
            manager,
            this,
            guid,
            pData);

        result = GetWrappedObjectAs<ID3D11DeviceChild>()->SetPrivateDataInterface(
            guid,
            encode::GetWrappedObject<IUnknown>(pData));

        Encode_ID3D11DeviceChild_SetPrivateDataInterface(
            this,
            result,
            guid,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceChild_SetPrivateDataInterface>::Dispatch(
            manager,
            this,
            result,
            guid,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceChild>()->SetPrivateDataInterface(
            guid,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11DepthStencilState_Wrapper::ID3D11DepthStencilState_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11DepthStencilStateInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11DepthStencilState_Wrapper::~ID3D11DepthStencilState_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11DepthStencilState>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11DepthStencilState_Wrapper* ID3D11DepthStencilState_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11DepthStencilState_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11DepthStencilState_Wrapper::GetDesc(
    D3D11_DEPTH_STENCIL_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DepthStencilState_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11DepthStencilState>()->GetDesc(
            pDesc);

        Encode_ID3D11DepthStencilState_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DepthStencilState_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DepthStencilState>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11BlendState_Wrapper::ID3D11BlendState_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11BlendStateInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11BlendState_Wrapper::~ID3D11BlendState_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11BlendState>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11BlendState_Wrapper* ID3D11BlendState_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11BlendState_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11BlendState_Wrapper::GetDesc(
    D3D11_BLEND_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11BlendState_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11BlendState>()->GetDesc(
            pDesc);

        Encode_ID3D11BlendState_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11BlendState_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11BlendState>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11RasterizerState_Wrapper::ID3D11RasterizerState_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11RasterizerStateInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11RasterizerState_Wrapper::~ID3D11RasterizerState_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11RasterizerState>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11RasterizerState_Wrapper* ID3D11RasterizerState_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11RasterizerState_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11RasterizerState_Wrapper::GetDesc(
    D3D11_RASTERIZER_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11RasterizerState_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11RasterizerState>()->GetDesc(
            pDesc);

        Encode_ID3D11RasterizerState_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11RasterizerState_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11RasterizerState>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11Resource_Wrapper::ID3D11Resource_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11Resource_Wrapper::GetType(
    D3D11_RESOURCE_DIMENSION* pResourceDimension)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Resource_GetType>::Dispatch(
            manager,
            this,
            pResourceDimension);

        GetWrappedObjectAs<ID3D11Resource>()->GetType(
            pResourceDimension);

        Encode_ID3D11Resource_GetType(
            this,
            pResourceDimension);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Resource_GetType>::Dispatch(
            manager,
            this,
            pResourceDimension);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Resource>()->GetType(
            pResourceDimension);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11Resource_Wrapper::SetEvictionPriority(
    UINT EvictionPriority)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Resource_SetEvictionPriority>::Dispatch(
            manager,
            this,
            EvictionPriority);

        GetWrappedObjectAs<ID3D11Resource>()->SetEvictionPriority(
            EvictionPriority);

        Encode_ID3D11Resource_SetEvictionPriority(
            this,
            EvictionPriority);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Resource_SetEvictionPriority>::Dispatch(
            manager,
            this,
            EvictionPriority);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Resource>()->SetEvictionPriority(
            EvictionPriority);
    }

    manager->DecrementCallScope();
}

UINT STDMETHODCALLTYPE ID3D11Resource_Wrapper::GetEvictionPriority()
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Resource_GetEvictionPriority>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D11Resource>()->GetEvictionPriority();

        Encode_ID3D11Resource_GetEvictionPriority(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Resource_GetEvictionPriority>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Resource>()->GetEvictionPriority();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11Buffer_Wrapper::ID3D11Buffer_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Resource_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11BufferInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11Buffer_Wrapper::~ID3D11Buffer_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11Buffer>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11Buffer_Wrapper* ID3D11Buffer_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11Buffer_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11Buffer_Wrapper::GetDesc(
    D3D11_BUFFER_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Buffer_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11Buffer>()->GetDesc(
            pDesc);

        Encode_ID3D11Buffer_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Buffer_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Buffer>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11Texture1D_Wrapper::ID3D11Texture1D_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Resource_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11Texture1DInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11Texture1D_Wrapper::~ID3D11Texture1D_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11Texture1D>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11Texture1D_Wrapper* ID3D11Texture1D_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11Texture1D_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11Texture1D_Wrapper::GetDesc(
    D3D11_TEXTURE1D_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Texture1D_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11Texture1D>()->GetDesc(
            pDesc);

        Encode_ID3D11Texture1D_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Texture1D_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Texture1D>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11Texture2D_Wrapper::ID3D11Texture2D_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Resource_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11Texture2DInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11Texture2D_Wrapper::~ID3D11Texture2D_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11Texture2D>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11Texture2D_Wrapper* ID3D11Texture2D_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11Texture2D_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11Texture2D_Wrapper::GetDesc(
    D3D11_TEXTURE2D_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Texture2D_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11Texture2D>()->GetDesc(
            pDesc);

        Encode_ID3D11Texture2D_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Texture2D_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Texture2D>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11Texture3D_Wrapper::ID3D11Texture3D_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Resource_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11Texture3DInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11Texture3D_Wrapper::~ID3D11Texture3D_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11Texture3D>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11Texture3D_Wrapper* ID3D11Texture3D_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11Texture3D_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11Texture3D_Wrapper::GetDesc(
    D3D11_TEXTURE3D_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Texture3D_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11Texture3D>()->GetDesc(
            pDesc);

        Encode_ID3D11Texture3D_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Texture3D_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Texture3D>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11View_Wrapper::ID3D11View_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11View_Wrapper::GetResource(
    ID3D11Resource** ppResource)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11View_GetResource>::Dispatch(
            manager,
            this,
            ppResource);

        GetWrappedObjectAs<ID3D11View>()->GetResource(
            ppResource);

        WrapObject(IID_ID3D11Resource, reinterpret_cast<void**>(ppResource), nullptr);

        Encode_ID3D11View_GetResource(
            this,
            ppResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11View_GetResource>::Dispatch(
            manager,
            this,
            ppResource);
    }
    else
    {
        GetWrappedObjectAs<ID3D11View>()->GetResource(
            ppResource);
    }

    manager->DecrementCallScope();
}

ID3D11ShaderResourceView_Wrapper::ID3D11ShaderResourceView_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11View_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11ShaderResourceViewInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11ShaderResourceView_Wrapper::~ID3D11ShaderResourceView_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11ShaderResourceView>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11ShaderResourceView_Wrapper* ID3D11ShaderResourceView_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11ShaderResourceView_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11ShaderResourceView_Wrapper::GetDesc(
    D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11ShaderResourceView_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11ShaderResourceView>()->GetDesc(
            pDesc);

        Encode_ID3D11ShaderResourceView_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11ShaderResourceView_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11ShaderResourceView>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11RenderTargetView_Wrapper::ID3D11RenderTargetView_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11View_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11RenderTargetViewInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11RenderTargetView_Wrapper::~ID3D11RenderTargetView_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11RenderTargetView>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11RenderTargetView_Wrapper* ID3D11RenderTargetView_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11RenderTargetView_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11RenderTargetView_Wrapper::GetDesc(
    D3D11_RENDER_TARGET_VIEW_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11RenderTargetView_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11RenderTargetView>()->GetDesc(
            pDesc);

        Encode_ID3D11RenderTargetView_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11RenderTargetView_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11RenderTargetView>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11DepthStencilView_Wrapper::ID3D11DepthStencilView_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11View_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11DepthStencilViewInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11DepthStencilView_Wrapper::~ID3D11DepthStencilView_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11DepthStencilView>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11DepthStencilView_Wrapper* ID3D11DepthStencilView_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11DepthStencilView_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11DepthStencilView_Wrapper::GetDesc(
    D3D11_DEPTH_STENCIL_VIEW_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DepthStencilView_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11DepthStencilView>()->GetDesc(
            pDesc);

        Encode_ID3D11DepthStencilView_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DepthStencilView_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DepthStencilView>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11UnorderedAccessView_Wrapper::ID3D11UnorderedAccessView_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11View_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11UnorderedAccessViewInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11UnorderedAccessView_Wrapper::~ID3D11UnorderedAccessView_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11UnorderedAccessView>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11UnorderedAccessView_Wrapper* ID3D11UnorderedAccessView_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11UnorderedAccessView_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11UnorderedAccessView_Wrapper::GetDesc(
    D3D11_UNORDERED_ACCESS_VIEW_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11UnorderedAccessView_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11UnorderedAccessView>()->GetDesc(
            pDesc);

        Encode_ID3D11UnorderedAccessView_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11UnorderedAccessView_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11UnorderedAccessView>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11VertexShader_Wrapper::ID3D11VertexShader_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11VertexShaderInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11VertexShader_Wrapper::~ID3D11VertexShader_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11VertexShader>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11VertexShader_Wrapper* ID3D11VertexShader_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11VertexShader_Wrapper>(object, object_map_, object_map_lock_);
}

ID3D11HullShader_Wrapper::ID3D11HullShader_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11HullShaderInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11HullShader_Wrapper::~ID3D11HullShader_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11HullShader>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11HullShader_Wrapper* ID3D11HullShader_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11HullShader_Wrapper>(object, object_map_, object_map_lock_);
}

ID3D11DomainShader_Wrapper::ID3D11DomainShader_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11DomainShaderInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11DomainShader_Wrapper::~ID3D11DomainShader_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11DomainShader>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11DomainShader_Wrapper* ID3D11DomainShader_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11DomainShader_Wrapper>(object, object_map_, object_map_lock_);
}

ID3D11GeometryShader_Wrapper::ID3D11GeometryShader_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11GeometryShaderInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11GeometryShader_Wrapper::~ID3D11GeometryShader_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11GeometryShader>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11GeometryShader_Wrapper* ID3D11GeometryShader_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11GeometryShader_Wrapper>(object, object_map_, object_map_lock_);
}

ID3D11PixelShader_Wrapper::ID3D11PixelShader_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11PixelShaderInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11PixelShader_Wrapper::~ID3D11PixelShader_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11PixelShader>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11PixelShader_Wrapper* ID3D11PixelShader_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11PixelShader_Wrapper>(object, object_map_, object_map_lock_);
}

ID3D11ComputeShader_Wrapper::ID3D11ComputeShader_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11ComputeShaderInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11ComputeShader_Wrapper::~ID3D11ComputeShader_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11ComputeShader>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11ComputeShader_Wrapper* ID3D11ComputeShader_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11ComputeShader_Wrapper>(object, object_map_, object_map_lock_);
}

ID3D11InputLayout_Wrapper::ID3D11InputLayout_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11InputLayoutInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11InputLayout_Wrapper::~ID3D11InputLayout_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11InputLayout>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11InputLayout_Wrapper* ID3D11InputLayout_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11InputLayout_Wrapper>(object, object_map_, object_map_lock_);
}

ID3D11SamplerState_Wrapper::ID3D11SamplerState_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11SamplerStateInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11SamplerState_Wrapper::~ID3D11SamplerState_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11SamplerState>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11SamplerState_Wrapper* ID3D11SamplerState_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11SamplerState_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11SamplerState_Wrapper::GetDesc(
    D3D11_SAMPLER_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11SamplerState_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11SamplerState>()->GetDesc(
            pDesc);

        Encode_ID3D11SamplerState_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11SamplerState_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11SamplerState>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11Asynchronous_Wrapper::ID3D11Asynchronous_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
}

UINT STDMETHODCALLTYPE ID3D11Asynchronous_Wrapper::GetDataSize()
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Asynchronous_GetDataSize>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D11Asynchronous>()->GetDataSize();

        Encode_ID3D11Asynchronous_GetDataSize(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Asynchronous_GetDataSize>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Asynchronous>()->GetDataSize();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11Query_Wrapper::ID3D11Query_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Asynchronous_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11QueryInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11Query_Wrapper::~ID3D11Query_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11Query>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11Query_Wrapper* ID3D11Query_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11Query_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11Query_Wrapper::GetDesc(
    D3D11_QUERY_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Query_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11Query>()->GetDesc(
            pDesc);

        Encode_ID3D11Query_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Query_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Query>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11Predicate_Wrapper::ID3D11Predicate_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Query_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11PredicateInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11Predicate_Wrapper::~ID3D11Predicate_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11Predicate>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11Predicate_Wrapper* ID3D11Predicate_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11Predicate_Wrapper>(object, object_map_, object_map_lock_);
}

ID3D11Counter_Wrapper::ID3D11Counter_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Asynchronous_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11CounterInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11Counter_Wrapper::~ID3D11Counter_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11Counter>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11Counter_Wrapper* ID3D11Counter_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11Counter_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11Counter_Wrapper::GetDesc(
    D3D11_COUNTER_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Counter_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11Counter>()->GetDesc(
            pDesc);

        Encode_ID3D11Counter_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Counter_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Counter>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11ClassInstance_Wrapper::ID3D11ClassInstance_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11ClassInstanceInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11ClassInstance_Wrapper::~ID3D11ClassInstance_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11ClassInstance>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11ClassInstance_Wrapper* ID3D11ClassInstance_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11ClassInstance_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11ClassInstance_Wrapper::GetClassLinkage(
    ID3D11ClassLinkage** ppLinkage)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11ClassInstance_GetClassLinkage>::Dispatch(
            manager,
            this,
            ppLinkage);

        GetWrappedObjectAs<ID3D11ClassInstance>()->GetClassLinkage(
            ppLinkage);

        WrapObject(IID_ID3D11ClassLinkage, reinterpret_cast<void**>(ppLinkage), nullptr);

        Encode_ID3D11ClassInstance_GetClassLinkage(
            this,
            ppLinkage);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11ClassInstance_GetClassLinkage>::Dispatch(
            manager,
            this,
            ppLinkage);
    }
    else
    {
        GetWrappedObjectAs<ID3D11ClassInstance>()->GetClassLinkage(
            ppLinkage);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11ClassInstance_Wrapper::GetDesc(
    D3D11_CLASS_INSTANCE_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11ClassInstance_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11ClassInstance>()->GetDesc(
            pDesc);

        Encode_ID3D11ClassInstance_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11ClassInstance_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11ClassInstance>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11ClassInstance_Wrapper::GetInstanceName(
    LPSTR pInstanceName,
    SIZE_T* pBufferLength)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11ClassInstance_GetInstanceName>::Dispatch(
            manager,
            this,
            pInstanceName,
            pBufferLength);

        GetWrappedObjectAs<ID3D11ClassInstance>()->GetInstanceName(
            pInstanceName,
            pBufferLength);

        Encode_ID3D11ClassInstance_GetInstanceName(
            this,
            pInstanceName,
            pBufferLength);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11ClassInstance_GetInstanceName>::Dispatch(
            manager,
            this,
            pInstanceName,
            pBufferLength);
    }
    else
    {
        GetWrappedObjectAs<ID3D11ClassInstance>()->GetInstanceName(
            pInstanceName,
            pBufferLength);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11ClassInstance_Wrapper::GetTypeName(
    LPSTR pTypeName,
    SIZE_T* pBufferLength)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11ClassInstance_GetTypeName>::Dispatch(
            manager,
            this,
            pTypeName,
            pBufferLength);

        GetWrappedObjectAs<ID3D11ClassInstance>()->GetTypeName(
            pTypeName,
            pBufferLength);

        Encode_ID3D11ClassInstance_GetTypeName(
            this,
            pTypeName,
            pBufferLength);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11ClassInstance_GetTypeName>::Dispatch(
            manager,
            this,
            pTypeName,
            pBufferLength);
    }
    else
    {
        GetWrappedObjectAs<ID3D11ClassInstance>()->GetTypeName(
            pTypeName,
            pBufferLength);
    }

    manager->DecrementCallScope();
}

ID3D11ClassLinkage_Wrapper::ID3D11ClassLinkage_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11ClassLinkageInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11ClassLinkage_Wrapper::~ID3D11ClassLinkage_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11ClassLinkage>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11ClassLinkage_Wrapper* ID3D11ClassLinkage_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11ClassLinkage_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D11ClassLinkage_Wrapper::GetClassInstance(
    LPCSTR pClassInstanceName,
    UINT InstanceIndex,
    ID3D11ClassInstance** ppInstance)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11ClassLinkage_GetClassInstance>::Dispatch(
            manager,
            this,
            pClassInstanceName,
            InstanceIndex,
            ppInstance);

        result = GetWrappedObjectAs<ID3D11ClassLinkage>()->GetClassInstance(
            pClassInstanceName,
            InstanceIndex,
            ppInstance);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11ClassInstance, reinterpret_cast<void**>(ppInstance), nullptr);
        }

        Encode_ID3D11ClassLinkage_GetClassInstance(
            this,
            result,
            pClassInstanceName,
            InstanceIndex,
            ppInstance);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11ClassLinkage_GetClassInstance>::Dispatch(
            manager,
            this,
            result,
            pClassInstanceName,
            InstanceIndex,
            ppInstance);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11ClassLinkage>()->GetClassInstance(
            pClassInstanceName,
            InstanceIndex,
            ppInstance);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11ClassLinkage_Wrapper::CreateClassInstance(
    LPCSTR pClassTypeName,
    UINT ConstantBufferOffset,
    UINT ConstantVectorOffset,
    UINT TextureOffset,
    UINT SamplerOffset,
    ID3D11ClassInstance** ppInstance)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11ClassLinkage_CreateClassInstance>::Dispatch(
            manager,
            this,
            pClassTypeName,
            ConstantBufferOffset,
            ConstantVectorOffset,
            TextureOffset,
            SamplerOffset,
            ppInstance);

        result = GetWrappedObjectAs<ID3D11ClassLinkage>()->CreateClassInstance(
            pClassTypeName,
            ConstantBufferOffset,
            ConstantVectorOffset,
            TextureOffset,
            SamplerOffset,
            ppInstance);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11ClassInstance, reinterpret_cast<void**>(ppInstance), nullptr);
        }

        Encode_ID3D11ClassLinkage_CreateClassInstance(
            this,
            result,
            pClassTypeName,
            ConstantBufferOffset,
            ConstantVectorOffset,
            TextureOffset,
            SamplerOffset,
            ppInstance);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11ClassLinkage_CreateClassInstance>::Dispatch(
            manager,
            this,
            result,
            pClassTypeName,
            ConstantBufferOffset,
            ConstantVectorOffset,
            TextureOffset,
            SamplerOffset,
            ppInstance);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11ClassLinkage>()->CreateClassInstance(
            pClassTypeName,
            ConstantBufferOffset,
            ConstantVectorOffset,
            TextureOffset,
            SamplerOffset,
            ppInstance);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11CommandList_Wrapper::ID3D11CommandList_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11CommandListInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11CommandList_Wrapper::~ID3D11CommandList_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11CommandList>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11CommandList_Wrapper* ID3D11CommandList_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11CommandList_Wrapper>(object, object_map_, object_map_lock_);
}

UINT STDMETHODCALLTYPE ID3D11CommandList_Wrapper::GetContextFlags()
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11CommandList_GetContextFlags>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D11CommandList>()->GetContextFlags();

        Encode_ID3D11CommandList_GetContextFlags(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11CommandList_GetContextFlags>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11CommandList>()->GetContextFlags();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11DeviceContext_Wrapper::ID3D11DeviceContext_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11DeviceContextInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11DeviceContext_Wrapper::~ID3D11DeviceContext_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11DeviceContext>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11DeviceContext_Wrapper* ID3D11DeviceContext_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11DeviceContext_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::VSSetConstantBuffers(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer* const* ppConstantBuffers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSSetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->VSSetConstantBuffers(
            StartSlot,
            NumBuffers,
            UnwrapObjects<ID3D11Buffer>(ppConstantBuffers, NumBuffers, unwrap_memory));

        Encode_ID3D11DeviceContext_VSSetConstantBuffers(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSSetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->VSSetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::PSSetShaderResources(
    UINT StartSlot,
    UINT NumViews,
    ID3D11ShaderResourceView* const* ppShaderResourceViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSSetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->PSSetShaderResources(
            StartSlot,
            NumViews,
            UnwrapObjects<ID3D11ShaderResourceView>(ppShaderResourceViews, NumViews, unwrap_memory));

        Encode_ID3D11DeviceContext_PSSetShaderResources(
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSSetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->PSSetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::PSSetShader(
    ID3D11PixelShader* pPixelShader,
    ID3D11ClassInstance* const* ppClassInstances,
    UINT NumClassInstances)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSSetShader>::Dispatch(
            manager,
            this,
            pPixelShader,
            ppClassInstances,
            NumClassInstances);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->PSSetShader(
            encode::GetWrappedObject<ID3D11PixelShader>(pPixelShader),
            UnwrapObjects<ID3D11ClassInstance>(ppClassInstances, NumClassInstances, unwrap_memory),
            NumClassInstances);

        Encode_ID3D11DeviceContext_PSSetShader(
            this,
            pPixelShader,
            ppClassInstances,
            NumClassInstances);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSSetShader>::Dispatch(
            manager,
            this,
            pPixelShader,
            ppClassInstances,
            NumClassInstances);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->PSSetShader(
            pPixelShader,
            ppClassInstances,
            NumClassInstances);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::PSSetSamplers(
    UINT StartSlot,
    UINT NumSamplers,
    ID3D11SamplerState* const* ppSamplers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSSetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->PSSetSamplers(
            StartSlot,
            NumSamplers,
            UnwrapObjects<ID3D11SamplerState>(ppSamplers, NumSamplers, unwrap_memory));

        Encode_ID3D11DeviceContext_PSSetSamplers(
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSSetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->PSSetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::VSSetShader(
    ID3D11VertexShader* pVertexShader,
    ID3D11ClassInstance* const* ppClassInstances,
    UINT NumClassInstances)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSSetShader>::Dispatch(
            manager,
            this,
            pVertexShader,
            ppClassInstances,
            NumClassInstances);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->VSSetShader(
            encode::GetWrappedObject<ID3D11VertexShader>(pVertexShader),
            UnwrapObjects<ID3D11ClassInstance>(ppClassInstances, NumClassInstances, unwrap_memory),
            NumClassInstances);

        Encode_ID3D11DeviceContext_VSSetShader(
            this,
            pVertexShader,
            ppClassInstances,
            NumClassInstances);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSSetShader>::Dispatch(
            manager,
            this,
            pVertexShader,
            ppClassInstances,
            NumClassInstances);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->VSSetShader(
            pVertexShader,
            ppClassInstances,
            NumClassInstances);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DrawIndexed(
    UINT IndexCount,
    UINT StartIndexLocation,
    INT BaseVertexLocation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DrawIndexed>::Dispatch(
            manager,
            this,
            IndexCount,
            StartIndexLocation,
            BaseVertexLocation);

        GetWrappedObjectAs<ID3D11DeviceContext>()->DrawIndexed(
            IndexCount,
            StartIndexLocation,
            BaseVertexLocation);

        Encode_ID3D11DeviceContext_DrawIndexed(
            this,
            IndexCount,
            StartIndexLocation,
            BaseVertexLocation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DrawIndexed>::Dispatch(
            manager,
            this,
            IndexCount,
            StartIndexLocation,
            BaseVertexLocation);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DrawIndexed(
            IndexCount,
            StartIndexLocation,
            BaseVertexLocation);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::Draw(
    UINT VertexCount,
    UINT StartVertexLocation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_Draw>::Dispatch(
            manager,
            this,
            VertexCount,
            StartVertexLocation);

        GetWrappedObjectAs<ID3D11DeviceContext>()->Draw(
            VertexCount,
            StartVertexLocation);

        Encode_ID3D11DeviceContext_Draw(
            this,
            VertexCount,
            StartVertexLocation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_Draw>::Dispatch(
            manager,
            this,
            VertexCount,
            StartVertexLocation);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->Draw(
            VertexCount,
            StartVertexLocation);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::Map(
    ID3D11Resource* pResource,
    UINT Subresource,
    D3D11_MAP MapType,
    UINT MapFlags,
    D3D11_MAPPED_SUBRESOURCE* pMappedResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_Map>::Dispatch(
            manager,
            this,
            pResource,
            Subresource,
            MapType,
            MapFlags,
            pMappedResource);

        result = GetWrappedObjectAs<ID3D11DeviceContext>()->Map(
            encode::GetWrappedObject<ID3D11Resource>(pResource),
            Subresource,
            MapType,
            MapFlags,
            pMappedResource);

        Encode_ID3D11DeviceContext_Map(
            this,
            result,
            pResource,
            Subresource,
            MapType,
            MapFlags,
            pMappedResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_Map>::Dispatch(
            manager,
            this,
            result,
            pResource,
            Subresource,
            MapType,
            MapFlags,
            pMappedResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceContext>()->Map(
            pResource,
            Subresource,
            MapType,
            MapFlags,
            pMappedResource);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::Unmap(
    ID3D11Resource* pResource,
    UINT Subresource)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_Unmap>::Dispatch(
            manager,
            this,
            pResource,
            Subresource);

        GetWrappedObjectAs<ID3D11DeviceContext>()->Unmap(
            encode::GetWrappedObject<ID3D11Resource>(pResource),
            Subresource);

        Encode_ID3D11DeviceContext_Unmap(
            this,
            pResource,
            Subresource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_Unmap>::Dispatch(
            manager,
            this,
            pResource,
            Subresource);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->Unmap(
            pResource,
            Subresource);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::PSSetConstantBuffers(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer* const* ppConstantBuffers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSSetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->PSSetConstantBuffers(
            StartSlot,
            NumBuffers,
            UnwrapObjects<ID3D11Buffer>(ppConstantBuffers, NumBuffers, unwrap_memory));

        Encode_ID3D11DeviceContext_PSSetConstantBuffers(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSSetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->PSSetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::IASetInputLayout(
    ID3D11InputLayout* pInputLayout)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IASetInputLayout>::Dispatch(
            manager,
            this,
            pInputLayout);

        GetWrappedObjectAs<ID3D11DeviceContext>()->IASetInputLayout(
            encode::GetWrappedObject<ID3D11InputLayout>(pInputLayout));

        Encode_ID3D11DeviceContext_IASetInputLayout(
            this,
            pInputLayout);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IASetInputLayout>::Dispatch(
            manager,
            this,
            pInputLayout);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->IASetInputLayout(
            pInputLayout);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::IASetVertexBuffers(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer* const* ppVertexBuffers,
    const UINT* pStrides,
    const UINT* pOffsets)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IASetVertexBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppVertexBuffers,
            pStrides,
            pOffsets);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->IASetVertexBuffers(
            StartSlot,
            NumBuffers,
            UnwrapObjects<ID3D11Buffer>(ppVertexBuffers, NumBuffers, unwrap_memory),
            pStrides,
            pOffsets);

        Encode_ID3D11DeviceContext_IASetVertexBuffers(
            this,
            StartSlot,
            NumBuffers,
            ppVertexBuffers,
            pStrides,
            pOffsets);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IASetVertexBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppVertexBuffers,
            pStrides,
            pOffsets);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->IASetVertexBuffers(
            StartSlot,
            NumBuffers,
            ppVertexBuffers,
            pStrides,
            pOffsets);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::IASetIndexBuffer(
    ID3D11Buffer* pIndexBuffer,
    DXGI_FORMAT Format,
    UINT Offset)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IASetIndexBuffer>::Dispatch(
            manager,
            this,
            pIndexBuffer,
            Format,
            Offset);

        GetWrappedObjectAs<ID3D11DeviceContext>()->IASetIndexBuffer(
            encode::GetWrappedObject<ID3D11Buffer>(pIndexBuffer),
            Format,
            Offset);

        Encode_ID3D11DeviceContext_IASetIndexBuffer(
            this,
            pIndexBuffer,
            Format,
            Offset);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IASetIndexBuffer>::Dispatch(
            manager,
            this,
            pIndexBuffer,
            Format,
            Offset);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->IASetIndexBuffer(
            pIndexBuffer,
            Format,
            Offset);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DrawIndexedInstanced(
    UINT IndexCountPerInstance,
    UINT InstanceCount,
    UINT StartIndexLocation,
    INT BaseVertexLocation,
    UINT StartInstanceLocation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DrawIndexedInstanced>::Dispatch(
            manager,
            this,
            IndexCountPerInstance,
            InstanceCount,
            StartIndexLocation,
            BaseVertexLocation,
            StartInstanceLocation);

        GetWrappedObjectAs<ID3D11DeviceContext>()->DrawIndexedInstanced(
            IndexCountPerInstance,
            InstanceCount,
            StartIndexLocation,
            BaseVertexLocation,
            StartInstanceLocation);

        Encode_ID3D11DeviceContext_DrawIndexedInstanced(
            this,
            IndexCountPerInstance,
            InstanceCount,
            StartIndexLocation,
            BaseVertexLocation,
            StartInstanceLocation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DrawIndexedInstanced>::Dispatch(
            manager,
            this,
            IndexCountPerInstance,
            InstanceCount,
            StartIndexLocation,
            BaseVertexLocation,
            StartInstanceLocation);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DrawIndexedInstanced(
            IndexCountPerInstance,
            InstanceCount,
            StartIndexLocation,
            BaseVertexLocation,
            StartInstanceLocation);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DrawInstanced(
    UINT VertexCountPerInstance,
    UINT InstanceCount,
    UINT StartVertexLocation,
    UINT StartInstanceLocation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DrawInstanced>::Dispatch(
            manager,
            this,
            VertexCountPerInstance,
            InstanceCount,
            StartVertexLocation,
            StartInstanceLocation);

        GetWrappedObjectAs<ID3D11DeviceContext>()->DrawInstanced(
            VertexCountPerInstance,
            InstanceCount,
            StartVertexLocation,
            StartInstanceLocation);

        Encode_ID3D11DeviceContext_DrawInstanced(
            this,
            VertexCountPerInstance,
            InstanceCount,
            StartVertexLocation,
            StartInstanceLocation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DrawInstanced>::Dispatch(
            manager,
            this,
            VertexCountPerInstance,
            InstanceCount,
            StartVertexLocation,
            StartInstanceLocation);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DrawInstanced(
            VertexCountPerInstance,
            InstanceCount,
            StartVertexLocation,
            StartInstanceLocation);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::GSSetConstantBuffers(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer* const* ppConstantBuffers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSSetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->GSSetConstantBuffers(
            StartSlot,
            NumBuffers,
            UnwrapObjects<ID3D11Buffer>(ppConstantBuffers, NumBuffers, unwrap_memory));

        Encode_ID3D11DeviceContext_GSSetConstantBuffers(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSSetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->GSSetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::GSSetShader(
    ID3D11GeometryShader* pShader,
    ID3D11ClassInstance* const* ppClassInstances,
    UINT NumClassInstances)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSSetShader>::Dispatch(
            manager,
            this,
            pShader,
            ppClassInstances,
            NumClassInstances);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->GSSetShader(
            encode::GetWrappedObject<ID3D11GeometryShader>(pShader),
            UnwrapObjects<ID3D11ClassInstance>(ppClassInstances, NumClassInstances, unwrap_memory),
            NumClassInstances);

        Encode_ID3D11DeviceContext_GSSetShader(
            this,
            pShader,
            ppClassInstances,
            NumClassInstances);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSSetShader>::Dispatch(
            manager,
            this,
            pShader,
            ppClassInstances,
            NumClassInstances);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->GSSetShader(
            pShader,
            ppClassInstances,
            NumClassInstances);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::IASetPrimitiveTopology(
    D3D11_PRIMITIVE_TOPOLOGY Topology)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IASetPrimitiveTopology>::Dispatch(
            manager,
            this,
            Topology);

        GetWrappedObjectAs<ID3D11DeviceContext>()->IASetPrimitiveTopology(
            Topology);

        Encode_ID3D11DeviceContext_IASetPrimitiveTopology(
            this,
            Topology);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IASetPrimitiveTopology>::Dispatch(
            manager,
            this,
            Topology);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->IASetPrimitiveTopology(
            Topology);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::VSSetShaderResources(
    UINT StartSlot,
    UINT NumViews,
    ID3D11ShaderResourceView* const* ppShaderResourceViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSSetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->VSSetShaderResources(
            StartSlot,
            NumViews,
            UnwrapObjects<ID3D11ShaderResourceView>(ppShaderResourceViews, NumViews, unwrap_memory));

        Encode_ID3D11DeviceContext_VSSetShaderResources(
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSSetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->VSSetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::VSSetSamplers(
    UINT StartSlot,
    UINT NumSamplers,
    ID3D11SamplerState* const* ppSamplers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSSetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->VSSetSamplers(
            StartSlot,
            NumSamplers,
            UnwrapObjects<ID3D11SamplerState>(ppSamplers, NumSamplers, unwrap_memory));

        Encode_ID3D11DeviceContext_VSSetSamplers(
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSSetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->VSSetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::Begin(
    ID3D11Asynchronous* pAsync)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_Begin>::Dispatch(
            manager,
            this,
            pAsync);

        GetWrappedObjectAs<ID3D11DeviceContext>()->Begin(
            encode::GetWrappedObject<ID3D11Asynchronous>(pAsync));

        Encode_ID3D11DeviceContext_Begin(
            this,
            pAsync);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_Begin>::Dispatch(
            manager,
            this,
            pAsync);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->Begin(
            pAsync);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::End(
    ID3D11Asynchronous* pAsync)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_End>::Dispatch(
            manager,
            this,
            pAsync);

        GetWrappedObjectAs<ID3D11DeviceContext>()->End(
            encode::GetWrappedObject<ID3D11Asynchronous>(pAsync));

        Encode_ID3D11DeviceContext_End(
            this,
            pAsync);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_End>::Dispatch(
            manager,
            this,
            pAsync);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->End(
            pAsync);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::GetData(
    ID3D11Asynchronous* pAsync,
    void* pData,
    UINT DataSize,
    UINT GetDataFlags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GetData>::Dispatch(
            manager,
            this,
            pAsync,
            pData,
            DataSize,
            GetDataFlags);

        result = GetWrappedObjectAs<ID3D11DeviceContext>()->GetData(
            encode::GetWrappedObject<ID3D11Asynchronous>(pAsync),
            pData,
            DataSize,
            GetDataFlags);

        Encode_ID3D11DeviceContext_GetData(
            this,
            result,
            pAsync,
            pData,
            DataSize,
            GetDataFlags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GetData>::Dispatch(
            manager,
            this,
            result,
            pAsync,
            pData,
            DataSize,
            GetDataFlags);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceContext>()->GetData(
            pAsync,
            pData,
            DataSize,
            GetDataFlags);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::SetPredication(
    ID3D11Predicate* pPredicate,
    BOOL PredicateValue)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_SetPredication>::Dispatch(
            manager,
            this,
            pPredicate,
            PredicateValue);

        GetWrappedObjectAs<ID3D11DeviceContext>()->SetPredication(
            encode::GetWrappedObject<ID3D11Predicate>(pPredicate),
            PredicateValue);

        Encode_ID3D11DeviceContext_SetPredication(
            this,
            pPredicate,
            PredicateValue);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_SetPredication>::Dispatch(
            manager,
            this,
            pPredicate,
            PredicateValue);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->SetPredication(
            pPredicate,
            PredicateValue);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::GSSetShaderResources(
    UINT StartSlot,
    UINT NumViews,
    ID3D11ShaderResourceView* const* ppShaderResourceViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSSetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->GSSetShaderResources(
            StartSlot,
            NumViews,
            UnwrapObjects<ID3D11ShaderResourceView>(ppShaderResourceViews, NumViews, unwrap_memory));

        Encode_ID3D11DeviceContext_GSSetShaderResources(
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSSetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->GSSetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::GSSetSamplers(
    UINT StartSlot,
    UINT NumSamplers,
    ID3D11SamplerState* const* ppSamplers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSSetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->GSSetSamplers(
            StartSlot,
            NumSamplers,
            UnwrapObjects<ID3D11SamplerState>(ppSamplers, NumSamplers, unwrap_memory));

        Encode_ID3D11DeviceContext_GSSetSamplers(
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSSetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->GSSetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::OMSetRenderTargets(
    UINT NumViews,
    ID3D11RenderTargetView* const* ppRenderTargetViews,
    ID3D11DepthStencilView* pDepthStencilView)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMSetRenderTargets>::Dispatch(
            manager,
            this,
            NumViews,
            ppRenderTargetViews,
            pDepthStencilView);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->OMSetRenderTargets(
            NumViews,
            UnwrapObjects<ID3D11RenderTargetView>(ppRenderTargetViews, NumViews, unwrap_memory),
            encode::GetWrappedObject<ID3D11DepthStencilView>(pDepthStencilView));

        Encode_ID3D11DeviceContext_OMSetRenderTargets(
            this,
            NumViews,
            ppRenderTargetViews,
            pDepthStencilView);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMSetRenderTargets>::Dispatch(
            manager,
            this,
            NumViews,
            ppRenderTargetViews,
            pDepthStencilView);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->OMSetRenderTargets(
            NumViews,
            ppRenderTargetViews,
            pDepthStencilView);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::OMSetRenderTargetsAndUnorderedAccessViews(
    UINT NumRTVs,
    ID3D11RenderTargetView* const* ppRenderTargetViews,
    ID3D11DepthStencilView* pDepthStencilView,
    UINT UAVStartSlot,
    UINT NumUAVs,
    ID3D11UnorderedAccessView* const* ppUnorderedAccessViews,
    const UINT* pUAVInitialCounts)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMSetRenderTargetsAndUnorderedAccessViews>::Dispatch(
            manager,
            this,
            NumRTVs,
            ppRenderTargetViews,
            pDepthStencilView,
            UAVStartSlot,
            NumUAVs,
            ppUnorderedAccessViews,
            pUAVInitialCounts);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->OMSetRenderTargetsAndUnorderedAccessViews(
            NumRTVs,
            UnwrapObjects<ID3D11RenderTargetView>(ppRenderTargetViews, NumRTVs, unwrap_memory),
            encode::GetWrappedObject<ID3D11DepthStencilView>(pDepthStencilView),
            UAVStartSlot,
            NumUAVs,
            UnwrapObjects<ID3D11UnorderedAccessView>(ppUnorderedAccessViews, NumUAVs, unwrap_memory),
            pUAVInitialCounts);

        Encode_ID3D11DeviceContext_OMSetRenderTargetsAndUnorderedAccessViews(
            this,
            NumRTVs,
            ppRenderTargetViews,
            pDepthStencilView,
            UAVStartSlot,
            NumUAVs,
            ppUnorderedAccessViews,
            pUAVInitialCounts);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMSetRenderTargetsAndUnorderedAccessViews>::Dispatch(
            manager,
            this,
            NumRTVs,
            ppRenderTargetViews,
            pDepthStencilView,
            UAVStartSlot,
            NumUAVs,
            ppUnorderedAccessViews,
            pUAVInitialCounts);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->OMSetRenderTargetsAndUnorderedAccessViews(
            NumRTVs,
            ppRenderTargetViews,
            pDepthStencilView,
            UAVStartSlot,
            NumUAVs,
            ppUnorderedAccessViews,
            pUAVInitialCounts);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::OMSetBlendState(
    ID3D11BlendState* pBlendState,
    const FLOAT BlendFactor [4],
    UINT SampleMask)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMSetBlendState>::Dispatch(
            manager,
            this,
            pBlendState,
            BlendFactor,
            SampleMask);

        GetWrappedObjectAs<ID3D11DeviceContext>()->OMSetBlendState(
            encode::GetWrappedObject<ID3D11BlendState>(pBlendState),
            BlendFactor,
            SampleMask);

        Encode_ID3D11DeviceContext_OMSetBlendState(
            this,
            pBlendState,
            BlendFactor,
            SampleMask);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMSetBlendState>::Dispatch(
            manager,
            this,
            pBlendState,
            BlendFactor,
            SampleMask);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->OMSetBlendState(
            pBlendState,
            BlendFactor,
            SampleMask);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::OMSetDepthStencilState(
    ID3D11DepthStencilState* pDepthStencilState,
    UINT StencilRef)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMSetDepthStencilState>::Dispatch(
            manager,
            this,
            pDepthStencilState,
            StencilRef);

        GetWrappedObjectAs<ID3D11DeviceContext>()->OMSetDepthStencilState(
            encode::GetWrappedObject<ID3D11DepthStencilState>(pDepthStencilState),
            StencilRef);

        Encode_ID3D11DeviceContext_OMSetDepthStencilState(
            this,
            pDepthStencilState,
            StencilRef);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMSetDepthStencilState>::Dispatch(
            manager,
            this,
            pDepthStencilState,
            StencilRef);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->OMSetDepthStencilState(
            pDepthStencilState,
            StencilRef);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::SOSetTargets(
    UINT NumBuffers,
    ID3D11Buffer* const* ppSOTargets,
    const UINT* pOffsets)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_SOSetTargets>::Dispatch(
            manager,
            this,
            NumBuffers,
            ppSOTargets,
            pOffsets);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->SOSetTargets(
            NumBuffers,
            UnwrapObjects<ID3D11Buffer>(ppSOTargets, NumBuffers, unwrap_memory),
            pOffsets);

        Encode_ID3D11DeviceContext_SOSetTargets(
            this,
            NumBuffers,
            ppSOTargets,
            pOffsets);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_SOSetTargets>::Dispatch(
            manager,
            this,
            NumBuffers,
            ppSOTargets,
            pOffsets);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->SOSetTargets(
            NumBuffers,
            ppSOTargets,
            pOffsets);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DrawAuto()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DrawAuto>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D11DeviceContext>()->DrawAuto();

        Encode_ID3D11DeviceContext_DrawAuto(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DrawAuto>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DrawAuto();
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DrawIndexedInstancedIndirect(
    ID3D11Buffer* pBufferForArgs,
    UINT AlignedByteOffsetForArgs)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DrawIndexedInstancedIndirect>::Dispatch(
            manager,
            this,
            pBufferForArgs,
            AlignedByteOffsetForArgs);

        GetWrappedObjectAs<ID3D11DeviceContext>()->DrawIndexedInstancedIndirect(
            encode::GetWrappedObject<ID3D11Buffer>(pBufferForArgs),
            AlignedByteOffsetForArgs);

        Encode_ID3D11DeviceContext_DrawIndexedInstancedIndirect(
            this,
            pBufferForArgs,
            AlignedByteOffsetForArgs);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DrawIndexedInstancedIndirect>::Dispatch(
            manager,
            this,
            pBufferForArgs,
            AlignedByteOffsetForArgs);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DrawIndexedInstancedIndirect(
            pBufferForArgs,
            AlignedByteOffsetForArgs);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DrawInstancedIndirect(
    ID3D11Buffer* pBufferForArgs,
    UINT AlignedByteOffsetForArgs)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DrawInstancedIndirect>::Dispatch(
            manager,
            this,
            pBufferForArgs,
            AlignedByteOffsetForArgs);

        GetWrappedObjectAs<ID3D11DeviceContext>()->DrawInstancedIndirect(
            encode::GetWrappedObject<ID3D11Buffer>(pBufferForArgs),
            AlignedByteOffsetForArgs);

        Encode_ID3D11DeviceContext_DrawInstancedIndirect(
            this,
            pBufferForArgs,
            AlignedByteOffsetForArgs);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DrawInstancedIndirect>::Dispatch(
            manager,
            this,
            pBufferForArgs,
            AlignedByteOffsetForArgs);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DrawInstancedIndirect(
            pBufferForArgs,
            AlignedByteOffsetForArgs);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::Dispatch(
    UINT ThreadGroupCountX,
    UINT ThreadGroupCountY,
    UINT ThreadGroupCountZ)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_Dispatch>::Dispatch(
            manager,
            this,
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);

        GetWrappedObjectAs<ID3D11DeviceContext>()->Dispatch(
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);

        Encode_ID3D11DeviceContext_Dispatch(
            this,
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_Dispatch>::Dispatch(
            manager,
            this,
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->Dispatch(
            ThreadGroupCountX,
            ThreadGroupCountY,
            ThreadGroupCountZ);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DispatchIndirect(
    ID3D11Buffer* pBufferForArgs,
    UINT AlignedByteOffsetForArgs)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DispatchIndirect>::Dispatch(
            manager,
            this,
            pBufferForArgs,
            AlignedByteOffsetForArgs);

        GetWrappedObjectAs<ID3D11DeviceContext>()->DispatchIndirect(
            encode::GetWrappedObject<ID3D11Buffer>(pBufferForArgs),
            AlignedByteOffsetForArgs);

        Encode_ID3D11DeviceContext_DispatchIndirect(
            this,
            pBufferForArgs,
            AlignedByteOffsetForArgs);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DispatchIndirect>::Dispatch(
            manager,
            this,
            pBufferForArgs,
            AlignedByteOffsetForArgs);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DispatchIndirect(
            pBufferForArgs,
            AlignedByteOffsetForArgs);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::RSSetState(
    ID3D11RasterizerState* pRasterizerState)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_RSSetState>::Dispatch(
            manager,
            this,
            pRasterizerState);

        GetWrappedObjectAs<ID3D11DeviceContext>()->RSSetState(
            encode::GetWrappedObject<ID3D11RasterizerState>(pRasterizerState));

        Encode_ID3D11DeviceContext_RSSetState(
            this,
            pRasterizerState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_RSSetState>::Dispatch(
            manager,
            this,
            pRasterizerState);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->RSSetState(
            pRasterizerState);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::RSSetViewports(
    UINT NumViewports,
    const D3D11_VIEWPORT* pViewports)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_RSSetViewports>::Dispatch(
            manager,
            this,
            NumViewports,
            pViewports);

        GetWrappedObjectAs<ID3D11DeviceContext>()->RSSetViewports(
            NumViewports,
            pViewports);

        Encode_ID3D11DeviceContext_RSSetViewports(
            this,
            NumViewports,
            pViewports);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_RSSetViewports>::Dispatch(
            manager,
            this,
            NumViewports,
            pViewports);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->RSSetViewports(
            NumViewports,
            pViewports);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::RSSetScissorRects(
    UINT NumRects,
    const D3D11_RECT* pRects)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_RSSetScissorRects>::Dispatch(
            manager,
            this,
            NumRects,
            pRects);

        GetWrappedObjectAs<ID3D11DeviceContext>()->RSSetScissorRects(
            NumRects,
            pRects);

        Encode_ID3D11DeviceContext_RSSetScissorRects(
            this,
            NumRects,
            pRects);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_RSSetScissorRects>::Dispatch(
            manager,
            this,
            NumRects,
            pRects);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->RSSetScissorRects(
            NumRects,
            pRects);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::CopySubresourceRegion(
    ID3D11Resource* pDstResource,
    UINT DstSubresource,
    UINT DstX,
    UINT DstY,
    UINT DstZ,
    ID3D11Resource* pSrcResource,
    UINT SrcSubresource,
    const D3D11_BOX* pSrcBox)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CopySubresourceRegion>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            DstX,
            DstY,
            DstZ,
            pSrcResource,
            SrcSubresource,
            pSrcBox);

        GetWrappedObjectAs<ID3D11DeviceContext>()->CopySubresourceRegion(
            encode::GetWrappedObject<ID3D11Resource>(pDstResource),
            DstSubresource,
            DstX,
            DstY,
            DstZ,
            encode::GetWrappedObject<ID3D11Resource>(pSrcResource),
            SrcSubresource,
            pSrcBox);

        Encode_ID3D11DeviceContext_CopySubresourceRegion(
            this,
            pDstResource,
            DstSubresource,
            DstX,
            DstY,
            DstZ,
            pSrcResource,
            SrcSubresource,
            pSrcBox);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CopySubresourceRegion>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            DstX,
            DstY,
            DstZ,
            pSrcResource,
            SrcSubresource,
            pSrcBox);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->CopySubresourceRegion(
            pDstResource,
            DstSubresource,
            DstX,
            DstY,
            DstZ,
            pSrcResource,
            SrcSubresource,
            pSrcBox);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::CopyResource(
    ID3D11Resource* pDstResource,
    ID3D11Resource* pSrcResource)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CopyResource>::Dispatch(
            manager,
            this,
            pDstResource,
            pSrcResource);

        GetWrappedObjectAs<ID3D11DeviceContext>()->CopyResource(
            encode::GetWrappedObject<ID3D11Resource>(pDstResource),
            encode::GetWrappedObject<ID3D11Resource>(pSrcResource));

        Encode_ID3D11DeviceContext_CopyResource(
            this,
            pDstResource,
            pSrcResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CopyResource>::Dispatch(
            manager,
            this,
            pDstResource,
            pSrcResource);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->CopyResource(
            pDstResource,
            pSrcResource);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::UpdateSubresource(
    ID3D11Resource* pDstResource,
    UINT DstSubresource,
    const D3D11_BOX* pDstBox,
    const void* pSrcData,
    UINT SrcRowPitch,
    UINT SrcDepthPitch)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_UpdateSubresource>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);

        GetWrappedObjectAs<ID3D11DeviceContext>()->UpdateSubresource(
            encode::GetWrappedObject<ID3D11Resource>(pDstResource),
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);

        Encode_ID3D11DeviceContext_UpdateSubresource(
            this,
            pDstResource,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_UpdateSubresource>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->UpdateSubresource(
            pDstResource,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::CopyStructureCount(
    ID3D11Buffer* pDstBuffer,
    UINT DstAlignedByteOffset,
    ID3D11UnorderedAccessView* pSrcView)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CopyStructureCount>::Dispatch(
            manager,
            this,
            pDstBuffer,
            DstAlignedByteOffset,
            pSrcView);

        GetWrappedObjectAs<ID3D11DeviceContext>()->CopyStructureCount(
            encode::GetWrappedObject<ID3D11Buffer>(pDstBuffer),
            DstAlignedByteOffset,
            encode::GetWrappedObject<ID3D11UnorderedAccessView>(pSrcView));

        Encode_ID3D11DeviceContext_CopyStructureCount(
            this,
            pDstBuffer,
            DstAlignedByteOffset,
            pSrcView);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CopyStructureCount>::Dispatch(
            manager,
            this,
            pDstBuffer,
            DstAlignedByteOffset,
            pSrcView);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->CopyStructureCount(
            pDstBuffer,
            DstAlignedByteOffset,
            pSrcView);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::ClearRenderTargetView(
    ID3D11RenderTargetView* pRenderTargetView,
    const FLOAT ColorRGBA [4])
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_ClearRenderTargetView>::Dispatch(
            manager,
            this,
            pRenderTargetView,
            ColorRGBA);

        GetWrappedObjectAs<ID3D11DeviceContext>()->ClearRenderTargetView(
            encode::GetWrappedObject<ID3D11RenderTargetView>(pRenderTargetView),
            ColorRGBA);

        Encode_ID3D11DeviceContext_ClearRenderTargetView(
            this,
            pRenderTargetView,
            ColorRGBA);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_ClearRenderTargetView>::Dispatch(
            manager,
            this,
            pRenderTargetView,
            ColorRGBA);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->ClearRenderTargetView(
            pRenderTargetView,
            ColorRGBA);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::ClearUnorderedAccessViewUint(
    ID3D11UnorderedAccessView* pUnorderedAccessView,
    const UINT Values [4])
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_ClearUnorderedAccessViewUint>::Dispatch(
            manager,
            this,
            pUnorderedAccessView,
            Values);

        GetWrappedObjectAs<ID3D11DeviceContext>()->ClearUnorderedAccessViewUint(
            encode::GetWrappedObject<ID3D11UnorderedAccessView>(pUnorderedAccessView),
            Values);

        Encode_ID3D11DeviceContext_ClearUnorderedAccessViewUint(
            this,
            pUnorderedAccessView,
            Values);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_ClearUnorderedAccessViewUint>::Dispatch(
            manager,
            this,
            pUnorderedAccessView,
            Values);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->ClearUnorderedAccessViewUint(
            pUnorderedAccessView,
            Values);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::ClearUnorderedAccessViewFloat(
    ID3D11UnorderedAccessView* pUnorderedAccessView,
    const FLOAT Values [4])
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_ClearUnorderedAccessViewFloat>::Dispatch(
            manager,
            this,
            pUnorderedAccessView,
            Values);

        GetWrappedObjectAs<ID3D11DeviceContext>()->ClearUnorderedAccessViewFloat(
            encode::GetWrappedObject<ID3D11UnorderedAccessView>(pUnorderedAccessView),
            Values);

        Encode_ID3D11DeviceContext_ClearUnorderedAccessViewFloat(
            this,
            pUnorderedAccessView,
            Values);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_ClearUnorderedAccessViewFloat>::Dispatch(
            manager,
            this,
            pUnorderedAccessView,
            Values);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->ClearUnorderedAccessViewFloat(
            pUnorderedAccessView,
            Values);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::ClearDepthStencilView(
    ID3D11DepthStencilView* pDepthStencilView,
    UINT ClearFlags,
    FLOAT Depth,
    UINT8 Stencil)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_ClearDepthStencilView>::Dispatch(
            manager,
            this,
            pDepthStencilView,
            ClearFlags,
            Depth,
            Stencil);

        GetWrappedObjectAs<ID3D11DeviceContext>()->ClearDepthStencilView(
            encode::GetWrappedObject<ID3D11DepthStencilView>(pDepthStencilView),
            ClearFlags,
            Depth,
            Stencil);

        Encode_ID3D11DeviceContext_ClearDepthStencilView(
            this,
            pDepthStencilView,
            ClearFlags,
            Depth,
            Stencil);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_ClearDepthStencilView>::Dispatch(
            manager,
            this,
            pDepthStencilView,
            ClearFlags,
            Depth,
            Stencil);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->ClearDepthStencilView(
            pDepthStencilView,
            ClearFlags,
            Depth,
            Stencil);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::GenerateMips(
    ID3D11ShaderResourceView* pShaderResourceView)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GenerateMips>::Dispatch(
            manager,
            this,
            pShaderResourceView);

        GetWrappedObjectAs<ID3D11DeviceContext>()->GenerateMips(
            encode::GetWrappedObject<ID3D11ShaderResourceView>(pShaderResourceView));

        Encode_ID3D11DeviceContext_GenerateMips(
            this,
            pShaderResourceView);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GenerateMips>::Dispatch(
            manager,
            this,
            pShaderResourceView);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->GenerateMips(
            pShaderResourceView);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::SetResourceMinLOD(
    ID3D11Resource* pResource,
    FLOAT MinLOD)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_SetResourceMinLOD>::Dispatch(
            manager,
            this,
            pResource,
            MinLOD);

        GetWrappedObjectAs<ID3D11DeviceContext>()->SetResourceMinLOD(
            encode::GetWrappedObject<ID3D11Resource>(pResource),
            MinLOD);

        Encode_ID3D11DeviceContext_SetResourceMinLOD(
            this,
            pResource,
            MinLOD);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_SetResourceMinLOD>::Dispatch(
            manager,
            this,
            pResource,
            MinLOD);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->SetResourceMinLOD(
            pResource,
            MinLOD);
    }

    manager->DecrementCallScope();
}

FLOAT STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::GetResourceMinLOD(
    ID3D11Resource* pResource)
{
    FLOAT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GetResourceMinLOD>::Dispatch(
            manager,
            this,
            pResource);

        result = GetWrappedObjectAs<ID3D11DeviceContext>()->GetResourceMinLOD(
            encode::GetWrappedObject<ID3D11Resource>(pResource));

        Encode_ID3D11DeviceContext_GetResourceMinLOD(
            this,
            result,
            pResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GetResourceMinLOD>::Dispatch(
            manager,
            this,
            result,
            pResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceContext>()->GetResourceMinLOD(
            pResource);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::ResolveSubresource(
    ID3D11Resource* pDstResource,
    UINT DstSubresource,
    ID3D11Resource* pSrcResource,
    UINT SrcSubresource,
    DXGI_FORMAT Format)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_ResolveSubresource>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            pSrcResource,
            SrcSubresource,
            Format);

        GetWrappedObjectAs<ID3D11DeviceContext>()->ResolveSubresource(
            encode::GetWrappedObject<ID3D11Resource>(pDstResource),
            DstSubresource,
            encode::GetWrappedObject<ID3D11Resource>(pSrcResource),
            SrcSubresource,
            Format);

        Encode_ID3D11DeviceContext_ResolveSubresource(
            this,
            pDstResource,
            DstSubresource,
            pSrcResource,
            SrcSubresource,
            Format);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_ResolveSubresource>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            pSrcResource,
            SrcSubresource,
            Format);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->ResolveSubresource(
            pDstResource,
            DstSubresource,
            pSrcResource,
            SrcSubresource,
            Format);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::ExecuteCommandList(
    ID3D11CommandList* pCommandList,
    BOOL RestoreContextState)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_ExecuteCommandList>::Dispatch(
            manager,
            this,
            pCommandList,
            RestoreContextState);

        GetWrappedObjectAs<ID3D11DeviceContext>()->ExecuteCommandList(
            encode::GetWrappedObject<ID3D11CommandList>(pCommandList),
            RestoreContextState);

        Encode_ID3D11DeviceContext_ExecuteCommandList(
            this,
            pCommandList,
            RestoreContextState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_ExecuteCommandList>::Dispatch(
            manager,
            this,
            pCommandList,
            RestoreContextState);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->ExecuteCommandList(
            pCommandList,
            RestoreContextState);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::HSSetShaderResources(
    UINT StartSlot,
    UINT NumViews,
    ID3D11ShaderResourceView* const* ppShaderResourceViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSSetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->HSSetShaderResources(
            StartSlot,
            NumViews,
            UnwrapObjects<ID3D11ShaderResourceView>(ppShaderResourceViews, NumViews, unwrap_memory));

        Encode_ID3D11DeviceContext_HSSetShaderResources(
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSSetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->HSSetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::HSSetShader(
    ID3D11HullShader* pHullShader,
    ID3D11ClassInstance* const* ppClassInstances,
    UINT NumClassInstances)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSSetShader>::Dispatch(
            manager,
            this,
            pHullShader,
            ppClassInstances,
            NumClassInstances);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->HSSetShader(
            encode::GetWrappedObject<ID3D11HullShader>(pHullShader),
            UnwrapObjects<ID3D11ClassInstance>(ppClassInstances, NumClassInstances, unwrap_memory),
            NumClassInstances);

        Encode_ID3D11DeviceContext_HSSetShader(
            this,
            pHullShader,
            ppClassInstances,
            NumClassInstances);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSSetShader>::Dispatch(
            manager,
            this,
            pHullShader,
            ppClassInstances,
            NumClassInstances);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->HSSetShader(
            pHullShader,
            ppClassInstances,
            NumClassInstances);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::HSSetSamplers(
    UINT StartSlot,
    UINT NumSamplers,
    ID3D11SamplerState* const* ppSamplers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSSetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->HSSetSamplers(
            StartSlot,
            NumSamplers,
            UnwrapObjects<ID3D11SamplerState>(ppSamplers, NumSamplers, unwrap_memory));

        Encode_ID3D11DeviceContext_HSSetSamplers(
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSSetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->HSSetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::HSSetConstantBuffers(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer* const* ppConstantBuffers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSSetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->HSSetConstantBuffers(
            StartSlot,
            NumBuffers,
            UnwrapObjects<ID3D11Buffer>(ppConstantBuffers, NumBuffers, unwrap_memory));

        Encode_ID3D11DeviceContext_HSSetConstantBuffers(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSSetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->HSSetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DSSetShaderResources(
    UINT StartSlot,
    UINT NumViews,
    ID3D11ShaderResourceView* const* ppShaderResourceViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSSetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->DSSetShaderResources(
            StartSlot,
            NumViews,
            UnwrapObjects<ID3D11ShaderResourceView>(ppShaderResourceViews, NumViews, unwrap_memory));

        Encode_ID3D11DeviceContext_DSSetShaderResources(
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSSetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DSSetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DSSetShader(
    ID3D11DomainShader* pDomainShader,
    ID3D11ClassInstance* const* ppClassInstances,
    UINT NumClassInstances)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSSetShader>::Dispatch(
            manager,
            this,
            pDomainShader,
            ppClassInstances,
            NumClassInstances);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->DSSetShader(
            encode::GetWrappedObject<ID3D11DomainShader>(pDomainShader),
            UnwrapObjects<ID3D11ClassInstance>(ppClassInstances, NumClassInstances, unwrap_memory),
            NumClassInstances);

        Encode_ID3D11DeviceContext_DSSetShader(
            this,
            pDomainShader,
            ppClassInstances,
            NumClassInstances);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSSetShader>::Dispatch(
            manager,
            this,
            pDomainShader,
            ppClassInstances,
            NumClassInstances);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DSSetShader(
            pDomainShader,
            ppClassInstances,
            NumClassInstances);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DSSetSamplers(
    UINT StartSlot,
    UINT NumSamplers,
    ID3D11SamplerState* const* ppSamplers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSSetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->DSSetSamplers(
            StartSlot,
            NumSamplers,
            UnwrapObjects<ID3D11SamplerState>(ppSamplers, NumSamplers, unwrap_memory));

        Encode_ID3D11DeviceContext_DSSetSamplers(
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSSetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DSSetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DSSetConstantBuffers(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer* const* ppConstantBuffers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSSetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->DSSetConstantBuffers(
            StartSlot,
            NumBuffers,
            UnwrapObjects<ID3D11Buffer>(ppConstantBuffers, NumBuffers, unwrap_memory));

        Encode_ID3D11DeviceContext_DSSetConstantBuffers(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSSetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DSSetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::CSSetShaderResources(
    UINT StartSlot,
    UINT NumViews,
    ID3D11ShaderResourceView* const* ppShaderResourceViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSSetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->CSSetShaderResources(
            StartSlot,
            NumViews,
            UnwrapObjects<ID3D11ShaderResourceView>(ppShaderResourceViews, NumViews, unwrap_memory));

        Encode_ID3D11DeviceContext_CSSetShaderResources(
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSSetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->CSSetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::CSSetUnorderedAccessViews(
    UINT StartSlot,
    UINT NumUAVs,
    ID3D11UnorderedAccessView* const* ppUnorderedAccessViews,
    const UINT* pUAVInitialCounts)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSSetUnorderedAccessViews>::Dispatch(
            manager,
            this,
            StartSlot,
            NumUAVs,
            ppUnorderedAccessViews,
            pUAVInitialCounts);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->CSSetUnorderedAccessViews(
            StartSlot,
            NumUAVs,
            UnwrapObjects<ID3D11UnorderedAccessView>(ppUnorderedAccessViews, NumUAVs, unwrap_memory),
            pUAVInitialCounts);

        Encode_ID3D11DeviceContext_CSSetUnorderedAccessViews(
            this,
            StartSlot,
            NumUAVs,
            ppUnorderedAccessViews,
            pUAVInitialCounts);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSSetUnorderedAccessViews>::Dispatch(
            manager,
            this,
            StartSlot,
            NumUAVs,
            ppUnorderedAccessViews,
            pUAVInitialCounts);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->CSSetUnorderedAccessViews(
            StartSlot,
            NumUAVs,
            ppUnorderedAccessViews,
            pUAVInitialCounts);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::CSSetShader(
    ID3D11ComputeShader* pComputeShader,
    ID3D11ClassInstance* const* ppClassInstances,
    UINT NumClassInstances)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSSetShader>::Dispatch(
            manager,
            this,
            pComputeShader,
            ppClassInstances,
            NumClassInstances);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->CSSetShader(
            encode::GetWrappedObject<ID3D11ComputeShader>(pComputeShader),
            UnwrapObjects<ID3D11ClassInstance>(ppClassInstances, NumClassInstances, unwrap_memory),
            NumClassInstances);

        Encode_ID3D11DeviceContext_CSSetShader(
            this,
            pComputeShader,
            ppClassInstances,
            NumClassInstances);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSSetShader>::Dispatch(
            manager,
            this,
            pComputeShader,
            ppClassInstances,
            NumClassInstances);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->CSSetShader(
            pComputeShader,
            ppClassInstances,
            NumClassInstances);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::CSSetSamplers(
    UINT StartSlot,
    UINT NumSamplers,
    ID3D11SamplerState* const* ppSamplers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSSetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->CSSetSamplers(
            StartSlot,
            NumSamplers,
            UnwrapObjects<ID3D11SamplerState>(ppSamplers, NumSamplers, unwrap_memory));

        Encode_ID3D11DeviceContext_CSSetSamplers(
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSSetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->CSSetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::CSSetConstantBuffers(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer* const* ppConstantBuffers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSSetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext>()->CSSetConstantBuffers(
            StartSlot,
            NumBuffers,
            UnwrapObjects<ID3D11Buffer>(ppConstantBuffers, NumBuffers, unwrap_memory));

        Encode_ID3D11DeviceContext_CSSetConstantBuffers(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSSetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->CSSetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::VSGetConstantBuffers(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer** ppConstantBuffers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSGetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        GetWrappedObjectAs<ID3D11DeviceContext>()->VSGetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        WrapObjectArray(IID_ID3D11Buffer, reinterpret_cast<void**>(ppConstantBuffers), NumBuffers, nullptr);

        Encode_ID3D11DeviceContext_VSGetConstantBuffers(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSGetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->VSGetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::PSGetShaderResources(
    UINT StartSlot,
    UINT NumViews,
    ID3D11ShaderResourceView** ppShaderResourceViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSGetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        GetWrappedObjectAs<ID3D11DeviceContext>()->PSGetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        WrapObjectArray(IID_ID3D11ShaderResourceView, reinterpret_cast<void**>(ppShaderResourceViews), NumViews, nullptr);

        Encode_ID3D11DeviceContext_PSGetShaderResources(
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSGetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->PSGetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::PSGetShader(
    ID3D11PixelShader** ppPixelShader,
    ID3D11ClassInstance** ppClassInstances,
    UINT* pNumClassInstances)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSGetShader>::Dispatch(
            manager,
            this,
            ppPixelShader,
            ppClassInstances,
            pNumClassInstances);

        GetWrappedObjectAs<ID3D11DeviceContext>()->PSGetShader(
            ppPixelShader,
            ppClassInstances,
            pNumClassInstances);

        WrapObject(IID_ID3D11PixelShader, reinterpret_cast<void**>(ppPixelShader), nullptr);
        WrapObjectArray(IID_ID3D11ClassInstance, reinterpret_cast<void**>(ppClassInstances), (pNumClassInstances != nullptr) ? *pNumClassInstances : 0, nullptr);

        Encode_ID3D11DeviceContext_PSGetShader(
            this,
            ppPixelShader,
            ppClassInstances,
            pNumClassInstances);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSGetShader>::Dispatch(
            manager,
            this,
            ppPixelShader,
            ppClassInstances,
            pNumClassInstances);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->PSGetShader(
            ppPixelShader,
            ppClassInstances,
            pNumClassInstances);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::PSGetSamplers(
    UINT StartSlot,
    UINT NumSamplers,
    ID3D11SamplerState** ppSamplers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSGetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        GetWrappedObjectAs<ID3D11DeviceContext>()->PSGetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);

        WrapObjectArray(IID_ID3D11SamplerState, reinterpret_cast<void**>(ppSamplers), NumSamplers, nullptr);

        Encode_ID3D11DeviceContext_PSGetSamplers(
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSGetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->PSGetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::VSGetShader(
    ID3D11VertexShader** ppVertexShader,
    ID3D11ClassInstance** ppClassInstances,
    UINT* pNumClassInstances)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSGetShader>::Dispatch(
            manager,
            this,
            ppVertexShader,
            ppClassInstances,
            pNumClassInstances);

        GetWrappedObjectAs<ID3D11DeviceContext>()->VSGetShader(
            ppVertexShader,
            ppClassInstances,
            pNumClassInstances);

        WrapObject(IID_ID3D11VertexShader, reinterpret_cast<void**>(ppVertexShader), nullptr);
        WrapObjectArray(IID_ID3D11ClassInstance, reinterpret_cast<void**>(ppClassInstances), (pNumClassInstances != nullptr) ? *pNumClassInstances : 0, nullptr);

        Encode_ID3D11DeviceContext_VSGetShader(
            this,
            ppVertexShader,
            ppClassInstances,
            pNumClassInstances);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSGetShader>::Dispatch(
            manager,
            this,
            ppVertexShader,
            ppClassInstances,
            pNumClassInstances);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->VSGetShader(
            ppVertexShader,
            ppClassInstances,
            pNumClassInstances);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::PSGetConstantBuffers(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer** ppConstantBuffers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSGetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        GetWrappedObjectAs<ID3D11DeviceContext>()->PSGetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        WrapObjectArray(IID_ID3D11Buffer, reinterpret_cast<void**>(ppConstantBuffers), NumBuffers, nullptr);

        Encode_ID3D11DeviceContext_PSGetConstantBuffers(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_PSGetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->PSGetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::IAGetInputLayout(
    ID3D11InputLayout** ppInputLayout)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IAGetInputLayout>::Dispatch(
            manager,
            this,
            ppInputLayout);

        GetWrappedObjectAs<ID3D11DeviceContext>()->IAGetInputLayout(
            ppInputLayout);

        WrapObject(IID_ID3D11InputLayout, reinterpret_cast<void**>(ppInputLayout), nullptr);

        Encode_ID3D11DeviceContext_IAGetInputLayout(
            this,
            ppInputLayout);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IAGetInputLayout>::Dispatch(
            manager,
            this,
            ppInputLayout);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->IAGetInputLayout(
            ppInputLayout);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::IAGetVertexBuffers(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer** ppVertexBuffers,
    UINT* pStrides,
    UINT* pOffsets)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IAGetVertexBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppVertexBuffers,
            pStrides,
            pOffsets);

        GetWrappedObjectAs<ID3D11DeviceContext>()->IAGetVertexBuffers(
            StartSlot,
            NumBuffers,
            ppVertexBuffers,
            pStrides,
            pOffsets);

        WrapObjectArray(IID_ID3D11Buffer, reinterpret_cast<void**>(ppVertexBuffers), NumBuffers, nullptr);

        Encode_ID3D11DeviceContext_IAGetVertexBuffers(
            this,
            StartSlot,
            NumBuffers,
            ppVertexBuffers,
            pStrides,
            pOffsets);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IAGetVertexBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppVertexBuffers,
            pStrides,
            pOffsets);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->IAGetVertexBuffers(
            StartSlot,
            NumBuffers,
            ppVertexBuffers,
            pStrides,
            pOffsets);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::IAGetIndexBuffer(
    ID3D11Buffer** pIndexBuffer,
    DXGI_FORMAT* Format,
    UINT* Offset)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IAGetIndexBuffer>::Dispatch(
            manager,
            this,
            pIndexBuffer,
            Format,
            Offset);

        GetWrappedObjectAs<ID3D11DeviceContext>()->IAGetIndexBuffer(
            pIndexBuffer,
            Format,
            Offset);

        WrapObject(IID_ID3D11Buffer, reinterpret_cast<void**>(pIndexBuffer), nullptr);

        Encode_ID3D11DeviceContext_IAGetIndexBuffer(
            this,
            pIndexBuffer,
            Format,
            Offset);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IAGetIndexBuffer>::Dispatch(
            manager,
            this,
            pIndexBuffer,
            Format,
            Offset);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->IAGetIndexBuffer(
            pIndexBuffer,
            Format,
            Offset);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::GSGetConstantBuffers(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer** ppConstantBuffers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSGetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        GetWrappedObjectAs<ID3D11DeviceContext>()->GSGetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        WrapObjectArray(IID_ID3D11Buffer, reinterpret_cast<void**>(ppConstantBuffers), NumBuffers, nullptr);

        Encode_ID3D11DeviceContext_GSGetConstantBuffers(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSGetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->GSGetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::GSGetShader(
    ID3D11GeometryShader** ppGeometryShader,
    ID3D11ClassInstance** ppClassInstances,
    UINT* pNumClassInstances)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSGetShader>::Dispatch(
            manager,
            this,
            ppGeometryShader,
            ppClassInstances,
            pNumClassInstances);

        GetWrappedObjectAs<ID3D11DeviceContext>()->GSGetShader(
            ppGeometryShader,
            ppClassInstances,
            pNumClassInstances);

        WrapObject(IID_ID3D11GeometryShader, reinterpret_cast<void**>(ppGeometryShader), nullptr);
        WrapObjectArray(IID_ID3D11ClassInstance, reinterpret_cast<void**>(ppClassInstances), (pNumClassInstances != nullptr) ? *pNumClassInstances : 0, nullptr);

        Encode_ID3D11DeviceContext_GSGetShader(
            this,
            ppGeometryShader,
            ppClassInstances,
            pNumClassInstances);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSGetShader>::Dispatch(
            manager,
            this,
            ppGeometryShader,
            ppClassInstances,
            pNumClassInstances);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->GSGetShader(
            ppGeometryShader,
            ppClassInstances,
            pNumClassInstances);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::IAGetPrimitiveTopology(
    D3D11_PRIMITIVE_TOPOLOGY* pTopology)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IAGetPrimitiveTopology>::Dispatch(
            manager,
            this,
            pTopology);

        GetWrappedObjectAs<ID3D11DeviceContext>()->IAGetPrimitiveTopology(
            pTopology);

        Encode_ID3D11DeviceContext_IAGetPrimitiveTopology(
            this,
            pTopology);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_IAGetPrimitiveTopology>::Dispatch(
            manager,
            this,
            pTopology);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->IAGetPrimitiveTopology(
            pTopology);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::VSGetShaderResources(
    UINT StartSlot,
    UINT NumViews,
    ID3D11ShaderResourceView** ppShaderResourceViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSGetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        GetWrappedObjectAs<ID3D11DeviceContext>()->VSGetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        WrapObjectArray(IID_ID3D11ShaderResourceView, reinterpret_cast<void**>(ppShaderResourceViews), NumViews, nullptr);

        Encode_ID3D11DeviceContext_VSGetShaderResources(
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSGetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->VSGetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::VSGetSamplers(
    UINT StartSlot,
    UINT NumSamplers,
    ID3D11SamplerState** ppSamplers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSGetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        GetWrappedObjectAs<ID3D11DeviceContext>()->VSGetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);

        WrapObjectArray(IID_ID3D11SamplerState, reinterpret_cast<void**>(ppSamplers), NumSamplers, nullptr);

        Encode_ID3D11DeviceContext_VSGetSamplers(
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_VSGetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->VSGetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::GetPredication(
    ID3D11Predicate** ppPredicate,
    BOOL* pPredicateValue)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GetPredication>::Dispatch(
            manager,
            this,
            ppPredicate,
            pPredicateValue);

        GetWrappedObjectAs<ID3D11DeviceContext>()->GetPredication(
            ppPredicate,
            pPredicateValue);

        WrapObject(IID_ID3D11Predicate, reinterpret_cast<void**>(ppPredicate), nullptr);

        Encode_ID3D11DeviceContext_GetPredication(
            this,
            ppPredicate,
            pPredicateValue);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GetPredication>::Dispatch(
            manager,
            this,
            ppPredicate,
            pPredicateValue);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->GetPredication(
            ppPredicate,
            pPredicateValue);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::GSGetShaderResources(
    UINT StartSlot,
    UINT NumViews,
    ID3D11ShaderResourceView** ppShaderResourceViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSGetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        GetWrappedObjectAs<ID3D11DeviceContext>()->GSGetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        WrapObjectArray(IID_ID3D11ShaderResourceView, reinterpret_cast<void**>(ppShaderResourceViews), NumViews, nullptr);

        Encode_ID3D11DeviceContext_GSGetShaderResources(
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSGetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->GSGetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::GSGetSamplers(
    UINT StartSlot,
    UINT NumSamplers,
    ID3D11SamplerState** ppSamplers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSGetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        GetWrappedObjectAs<ID3D11DeviceContext>()->GSGetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);

        WrapObjectArray(IID_ID3D11SamplerState, reinterpret_cast<void**>(ppSamplers), NumSamplers, nullptr);

        Encode_ID3D11DeviceContext_GSGetSamplers(
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GSGetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->GSGetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::OMGetRenderTargets(
    UINT NumViews,
    ID3D11RenderTargetView** ppRenderTargetViews,
    ID3D11DepthStencilView** ppDepthStencilView)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMGetRenderTargets>::Dispatch(
            manager,
            this,
            NumViews,
            ppRenderTargetViews,
            ppDepthStencilView);

        GetWrappedObjectAs<ID3D11DeviceContext>()->OMGetRenderTargets(
            NumViews,
            ppRenderTargetViews,
            ppDepthStencilView);

        WrapObjectArray(IID_ID3D11RenderTargetView, reinterpret_cast<void**>(ppRenderTargetViews), NumViews, nullptr);
        WrapObject(IID_ID3D11DepthStencilView, reinterpret_cast<void**>(ppDepthStencilView), nullptr);

        Encode_ID3D11DeviceContext_OMGetRenderTargets(
            this,
            NumViews,
            ppRenderTargetViews,
            ppDepthStencilView);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMGetRenderTargets>::Dispatch(
            manager,
            this,
            NumViews,
            ppRenderTargetViews,
            ppDepthStencilView);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->OMGetRenderTargets(
            NumViews,
            ppRenderTargetViews,
            ppDepthStencilView);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::OMGetRenderTargetsAndUnorderedAccessViews(
    UINT NumRTVs,
    ID3D11RenderTargetView** ppRenderTargetViews,
    ID3D11DepthStencilView** ppDepthStencilView,
    UINT UAVStartSlot,
    UINT NumUAVs,
    ID3D11UnorderedAccessView** ppUnorderedAccessViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMGetRenderTargetsAndUnorderedAccessViews>::Dispatch(
            manager,
            this,
            NumRTVs,
            ppRenderTargetViews,
            ppDepthStencilView,
            UAVStartSlot,
            NumUAVs,
            ppUnorderedAccessViews);

        GetWrappedObjectAs<ID3D11DeviceContext>()->OMGetRenderTargetsAndUnorderedAccessViews(
            NumRTVs,
            ppRenderTargetViews,
            ppDepthStencilView,
            UAVStartSlot,
            NumUAVs,
            ppUnorderedAccessViews);

        WrapObjectArray(IID_ID3D11RenderTargetView, reinterpret_cast<void**>(ppRenderTargetViews), NumRTVs, nullptr);
        WrapObject(IID_ID3D11DepthStencilView, reinterpret_cast<void**>(ppDepthStencilView), nullptr);
        WrapObjectArray(IID_ID3D11UnorderedAccessView, reinterpret_cast<void**>(ppUnorderedAccessViews), NumUAVs, nullptr);

        Encode_ID3D11DeviceContext_OMGetRenderTargetsAndUnorderedAccessViews(
            this,
            NumRTVs,
            ppRenderTargetViews,
            ppDepthStencilView,
            UAVStartSlot,
            NumUAVs,
            ppUnorderedAccessViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMGetRenderTargetsAndUnorderedAccessViews>::Dispatch(
            manager,
            this,
            NumRTVs,
            ppRenderTargetViews,
            ppDepthStencilView,
            UAVStartSlot,
            NumUAVs,
            ppUnorderedAccessViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->OMGetRenderTargetsAndUnorderedAccessViews(
            NumRTVs,
            ppRenderTargetViews,
            ppDepthStencilView,
            UAVStartSlot,
            NumUAVs,
            ppUnorderedAccessViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::OMGetBlendState(
    ID3D11BlendState** ppBlendState,
    FLOAT BlendFactor [4],
    UINT* pSampleMask)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMGetBlendState>::Dispatch(
            manager,
            this,
            ppBlendState,
            BlendFactor,
            pSampleMask);

        GetWrappedObjectAs<ID3D11DeviceContext>()->OMGetBlendState(
            ppBlendState,
            BlendFactor,
            pSampleMask);

        WrapObject(IID_ID3D11BlendState, reinterpret_cast<void**>(ppBlendState), nullptr);

        Encode_ID3D11DeviceContext_OMGetBlendState(
            this,
            ppBlendState,
            BlendFactor,
            pSampleMask);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMGetBlendState>::Dispatch(
            manager,
            this,
            ppBlendState,
            BlendFactor,
            pSampleMask);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->OMGetBlendState(
            ppBlendState,
            BlendFactor,
            pSampleMask);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::OMGetDepthStencilState(
    ID3D11DepthStencilState** ppDepthStencilState,
    UINT* pStencilRef)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMGetDepthStencilState>::Dispatch(
            manager,
            this,
            ppDepthStencilState,
            pStencilRef);

        GetWrappedObjectAs<ID3D11DeviceContext>()->OMGetDepthStencilState(
            ppDepthStencilState,
            pStencilRef);

        WrapObject(IID_ID3D11DepthStencilState, reinterpret_cast<void**>(ppDepthStencilState), nullptr);

        Encode_ID3D11DeviceContext_OMGetDepthStencilState(
            this,
            ppDepthStencilState,
            pStencilRef);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_OMGetDepthStencilState>::Dispatch(
            manager,
            this,
            ppDepthStencilState,
            pStencilRef);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->OMGetDepthStencilState(
            ppDepthStencilState,
            pStencilRef);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::SOGetTargets(
    UINT NumBuffers,
    ID3D11Buffer** ppSOTargets)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_SOGetTargets>::Dispatch(
            manager,
            this,
            NumBuffers,
            ppSOTargets);

        GetWrappedObjectAs<ID3D11DeviceContext>()->SOGetTargets(
            NumBuffers,
            ppSOTargets);

        WrapObjectArray(IID_ID3D11Buffer, reinterpret_cast<void**>(ppSOTargets), NumBuffers, nullptr);

        Encode_ID3D11DeviceContext_SOGetTargets(
            this,
            NumBuffers,
            ppSOTargets);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_SOGetTargets>::Dispatch(
            manager,
            this,
            NumBuffers,
            ppSOTargets);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->SOGetTargets(
            NumBuffers,
            ppSOTargets);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::RSGetState(
    ID3D11RasterizerState** ppRasterizerState)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_RSGetState>::Dispatch(
            manager,
            this,
            ppRasterizerState);

        GetWrappedObjectAs<ID3D11DeviceContext>()->RSGetState(
            ppRasterizerState);

        WrapObject(IID_ID3D11RasterizerState, reinterpret_cast<void**>(ppRasterizerState), nullptr);

        Encode_ID3D11DeviceContext_RSGetState(
            this,
            ppRasterizerState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_RSGetState>::Dispatch(
            manager,
            this,
            ppRasterizerState);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->RSGetState(
            ppRasterizerState);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::RSGetViewports(
    UINT* pNumViewports,
    D3D11_VIEWPORT* pViewports)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_RSGetViewports>::Dispatch(
            manager,
            this,
            pNumViewports,
            pViewports);

        GetWrappedObjectAs<ID3D11DeviceContext>()->RSGetViewports(
            pNumViewports,
            pViewports);

        Encode_ID3D11DeviceContext_RSGetViewports(
            this,
            pNumViewports,
            pViewports);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_RSGetViewports>::Dispatch(
            manager,
            this,
            pNumViewports,
            pViewports);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->RSGetViewports(
            pNumViewports,
            pViewports);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::RSGetScissorRects(
    UINT* pNumRects,
    D3D11_RECT* pRects)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_RSGetScissorRects>::Dispatch(
            manager,
            this,
            pNumRects,
            pRects);

        GetWrappedObjectAs<ID3D11DeviceContext>()->RSGetScissorRects(
            pNumRects,
            pRects);

        Encode_ID3D11DeviceContext_RSGetScissorRects(
            this,
            pNumRects,
            pRects);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_RSGetScissorRects>::Dispatch(
            manager,
            this,
            pNumRects,
            pRects);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->RSGetScissorRects(
            pNumRects,
            pRects);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::HSGetShaderResources(
    UINT StartSlot,
    UINT NumViews,
    ID3D11ShaderResourceView** ppShaderResourceViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSGetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        GetWrappedObjectAs<ID3D11DeviceContext>()->HSGetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        WrapObjectArray(IID_ID3D11ShaderResourceView, reinterpret_cast<void**>(ppShaderResourceViews), NumViews, nullptr);

        Encode_ID3D11DeviceContext_HSGetShaderResources(
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSGetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->HSGetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::HSGetShader(
    ID3D11HullShader** ppHullShader,
    ID3D11ClassInstance** ppClassInstances,
    UINT* pNumClassInstances)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSGetShader>::Dispatch(
            manager,
            this,
            ppHullShader,
            ppClassInstances,
            pNumClassInstances);

        GetWrappedObjectAs<ID3D11DeviceContext>()->HSGetShader(
            ppHullShader,
            ppClassInstances,
            pNumClassInstances);

        WrapObject(IID_ID3D11HullShader, reinterpret_cast<void**>(ppHullShader), nullptr);
        WrapObjectArray(IID_ID3D11ClassInstance, reinterpret_cast<void**>(ppClassInstances), (pNumClassInstances != nullptr) ? *pNumClassInstances : 0, nullptr);

        Encode_ID3D11DeviceContext_HSGetShader(
            this,
            ppHullShader,
            ppClassInstances,
            pNumClassInstances);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSGetShader>::Dispatch(
            manager,
            this,
            ppHullShader,
            ppClassInstances,
            pNumClassInstances);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->HSGetShader(
            ppHullShader,
            ppClassInstances,
            pNumClassInstances);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::HSGetSamplers(
    UINT StartSlot,
    UINT NumSamplers,
    ID3D11SamplerState** ppSamplers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSGetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        GetWrappedObjectAs<ID3D11DeviceContext>()->HSGetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);

        WrapObjectArray(IID_ID3D11SamplerState, reinterpret_cast<void**>(ppSamplers), NumSamplers, nullptr);

        Encode_ID3D11DeviceContext_HSGetSamplers(
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSGetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->HSGetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::HSGetConstantBuffers(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer** ppConstantBuffers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSGetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        GetWrappedObjectAs<ID3D11DeviceContext>()->HSGetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        WrapObjectArray(IID_ID3D11Buffer, reinterpret_cast<void**>(ppConstantBuffers), NumBuffers, nullptr);

        Encode_ID3D11DeviceContext_HSGetConstantBuffers(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_HSGetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->HSGetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DSGetShaderResources(
    UINT StartSlot,
    UINT NumViews,
    ID3D11ShaderResourceView** ppShaderResourceViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSGetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        GetWrappedObjectAs<ID3D11DeviceContext>()->DSGetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        WrapObjectArray(IID_ID3D11ShaderResourceView, reinterpret_cast<void**>(ppShaderResourceViews), NumViews, nullptr);

        Encode_ID3D11DeviceContext_DSGetShaderResources(
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSGetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DSGetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DSGetShader(
    ID3D11DomainShader** ppDomainShader,
    ID3D11ClassInstance** ppClassInstances,
    UINT* pNumClassInstances)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSGetShader>::Dispatch(
            manager,
            this,
            ppDomainShader,
            ppClassInstances,
            pNumClassInstances);

        GetWrappedObjectAs<ID3D11DeviceContext>()->DSGetShader(
            ppDomainShader,
            ppClassInstances,
            pNumClassInstances);

        WrapObject(IID_ID3D11DomainShader, reinterpret_cast<void**>(ppDomainShader), nullptr);
        WrapObjectArray(IID_ID3D11ClassInstance, reinterpret_cast<void**>(ppClassInstances), (pNumClassInstances != nullptr) ? *pNumClassInstances : 0, nullptr);

        Encode_ID3D11DeviceContext_DSGetShader(
            this,
            ppDomainShader,
            ppClassInstances,
            pNumClassInstances);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSGetShader>::Dispatch(
            manager,
            this,
            ppDomainShader,
            ppClassInstances,
            pNumClassInstances);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DSGetShader(
            ppDomainShader,
            ppClassInstances,
            pNumClassInstances);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DSGetSamplers(
    UINT StartSlot,
    UINT NumSamplers,
    ID3D11SamplerState** ppSamplers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSGetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        GetWrappedObjectAs<ID3D11DeviceContext>()->DSGetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);

        WrapObjectArray(IID_ID3D11SamplerState, reinterpret_cast<void**>(ppSamplers), NumSamplers, nullptr);

        Encode_ID3D11DeviceContext_DSGetSamplers(
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSGetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DSGetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::DSGetConstantBuffers(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer** ppConstantBuffers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSGetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        GetWrappedObjectAs<ID3D11DeviceContext>()->DSGetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        WrapObjectArray(IID_ID3D11Buffer, reinterpret_cast<void**>(ppConstantBuffers), NumBuffers, nullptr);

        Encode_ID3D11DeviceContext_DSGetConstantBuffers(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_DSGetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->DSGetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::CSGetShaderResources(
    UINT StartSlot,
    UINT NumViews,
    ID3D11ShaderResourceView** ppShaderResourceViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSGetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        GetWrappedObjectAs<ID3D11DeviceContext>()->CSGetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        WrapObjectArray(IID_ID3D11ShaderResourceView, reinterpret_cast<void**>(ppShaderResourceViews), NumViews, nullptr);

        Encode_ID3D11DeviceContext_CSGetShaderResources(
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSGetShaderResources>::Dispatch(
            manager,
            this,
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->CSGetShaderResources(
            StartSlot,
            NumViews,
            ppShaderResourceViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::CSGetUnorderedAccessViews(
    UINT StartSlot,
    UINT NumUAVs,
    ID3D11UnorderedAccessView** ppUnorderedAccessViews)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSGetUnorderedAccessViews>::Dispatch(
            manager,
            this,
            StartSlot,
            NumUAVs,
            ppUnorderedAccessViews);

        GetWrappedObjectAs<ID3D11DeviceContext>()->CSGetUnorderedAccessViews(
            StartSlot,
            NumUAVs,
            ppUnorderedAccessViews);

        WrapObjectArray(IID_ID3D11UnorderedAccessView, reinterpret_cast<void**>(ppUnorderedAccessViews), NumUAVs, nullptr);

        Encode_ID3D11DeviceContext_CSGetUnorderedAccessViews(
            this,
            StartSlot,
            NumUAVs,
            ppUnorderedAccessViews);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSGetUnorderedAccessViews>::Dispatch(
            manager,
            this,
            StartSlot,
            NumUAVs,
            ppUnorderedAccessViews);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->CSGetUnorderedAccessViews(
            StartSlot,
            NumUAVs,
            ppUnorderedAccessViews);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::CSGetShader(
    ID3D11ComputeShader** ppComputeShader,
    ID3D11ClassInstance** ppClassInstances,
    UINT* pNumClassInstances)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSGetShader>::Dispatch(
            manager,
            this,
            ppComputeShader,
            ppClassInstances,
            pNumClassInstances);

        GetWrappedObjectAs<ID3D11DeviceContext>()->CSGetShader(
            ppComputeShader,
            ppClassInstances,
            pNumClassInstances);

        WrapObject(IID_ID3D11ComputeShader, reinterpret_cast<void**>(ppComputeShader), nullptr);
        WrapObjectArray(IID_ID3D11ClassInstance, reinterpret_cast<void**>(ppClassInstances), (pNumClassInstances != nullptr) ? *pNumClassInstances : 0, nullptr);

        Encode_ID3D11DeviceContext_CSGetShader(
            this,
            ppComputeShader,
            ppClassInstances,
            pNumClassInstances);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSGetShader>::Dispatch(
            manager,
            this,
            ppComputeShader,
            ppClassInstances,
            pNumClassInstances);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->CSGetShader(
            ppComputeShader,
            ppClassInstances,
            pNumClassInstances);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::CSGetSamplers(
    UINT StartSlot,
    UINT NumSamplers,
    ID3D11SamplerState** ppSamplers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSGetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        GetWrappedObjectAs<ID3D11DeviceContext>()->CSGetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);

        WrapObjectArray(IID_ID3D11SamplerState, reinterpret_cast<void**>(ppSamplers), NumSamplers, nullptr);

        Encode_ID3D11DeviceContext_CSGetSamplers(
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSGetSamplers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumSamplers,
            ppSamplers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->CSGetSamplers(
            StartSlot,
            NumSamplers,
            ppSamplers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::CSGetConstantBuffers(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer** ppConstantBuffers)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSGetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        GetWrappedObjectAs<ID3D11DeviceContext>()->CSGetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        WrapObjectArray(IID_ID3D11Buffer, reinterpret_cast<void**>(ppConstantBuffers), NumBuffers, nullptr);

        Encode_ID3D11DeviceContext_CSGetConstantBuffers(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_CSGetConstantBuffers>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->CSGetConstantBuffers(
            StartSlot,
            NumBuffers,
            ppConstantBuffers);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::ClearState()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_ClearState>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D11DeviceContext>()->ClearState();

        Encode_ID3D11DeviceContext_ClearState(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_ClearState>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->ClearState();
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::Flush()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_Flush>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D11DeviceContext>()->Flush();

        Encode_ID3D11DeviceContext_Flush(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_Flush>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext>()->Flush();
    }

    manager->DecrementCallScope();
}

D3D11_DEVICE_CONTEXT_TYPE STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::GetType()
{
    D3D11_DEVICE_CONTEXT_TYPE result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GetType>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D11DeviceContext>()->GetType();

        Encode_ID3D11DeviceContext_GetType(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GetType>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceContext>()->GetType();
    }

    manager->DecrementCallScope();

    return result;
}

UINT STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::GetContextFlags()
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GetContextFlags>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D11DeviceContext>()->GetContextFlags();

        Encode_ID3D11DeviceContext_GetContextFlags(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_GetContextFlags>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceContext>()->GetContextFlags();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11DeviceContext_Wrapper::FinishCommandList(
    BOOL RestoreDeferredContextState,
    ID3D11CommandList** ppCommandList)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_FinishCommandList>::Dispatch(
            manager,
            this,
            RestoreDeferredContextState,
            ppCommandList);

        result = GetWrappedObjectAs<ID3D11DeviceContext>()->FinishCommandList(
            RestoreDeferredContextState,
            ppCommandList);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11CommandList, reinterpret_cast<void**>(ppCommandList), nullptr);
        }

        Encode_ID3D11DeviceContext_FinishCommandList(
            this,
            result,
            RestoreDeferredContextState,
            ppCommandList);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext_FinishCommandList>::Dispatch(
            manager,
            this,
            result,
            RestoreDeferredContextState,
            ppCommandList);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceContext>()->FinishCommandList(
            RestoreDeferredContextState,
            ppCommandList);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11VideoDecoder_Wrapper::ID3D11VideoDecoder_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11VideoDecoderInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11VideoDecoder_Wrapper::~ID3D11VideoDecoder_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11VideoDecoder>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11VideoDecoder_Wrapper* ID3D11VideoDecoder_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11VideoDecoder_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDecoder_Wrapper::GetCreationParameters(
    D3D11_VIDEO_DECODER_DESC* pVideoDesc,
    D3D11_VIDEO_DECODER_CONFIG* pConfig)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDecoder_GetCreationParameters>::Dispatch(
            manager,
            this,
            pVideoDesc,
            pConfig);

        result = GetWrappedObjectAs<ID3D11VideoDecoder>()->GetCreationParameters(
            pVideoDesc,
            pConfig);

        Encode_ID3D11VideoDecoder_GetCreationParameters(
            this,
            result,
            pVideoDesc,
            pConfig);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDecoder_GetCreationParameters>::Dispatch(
            manager,
            this,
            result,
            pVideoDesc,
            pConfig);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDecoder>()->GetCreationParameters(
            pVideoDesc,
            pConfig);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDecoder_Wrapper::GetDriverHandle(
    HANDLE* pDriverHandle)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDecoder_GetDriverHandle>::Dispatch(
            manager,
            this,
            pDriverHandle);

        result = GetWrappedObjectAs<ID3D11VideoDecoder>()->GetDriverHandle(
            pDriverHandle);

        Encode_ID3D11VideoDecoder_GetDriverHandle(
            this,
            result,
            pDriverHandle);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDecoder_GetDriverHandle>::Dispatch(
            manager,
            this,
            result,
            pDriverHandle);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDecoder>()->GetDriverHandle(
            pDriverHandle);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11VideoProcessorEnumerator_Wrapper::ID3D11VideoProcessorEnumerator_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11VideoProcessorEnumeratorInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11VideoProcessorEnumerator_Wrapper::~ID3D11VideoProcessorEnumerator_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11VideoProcessorEnumerator>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11VideoProcessorEnumerator_Wrapper* ID3D11VideoProcessorEnumerator_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11VideoProcessorEnumerator_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D11VideoProcessorEnumerator_Wrapper::GetVideoProcessorContentDesc(
    D3D11_VIDEO_PROCESSOR_CONTENT_DESC* pContentDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorEnumerator_GetVideoProcessorContentDesc>::Dispatch(
            manager,
            this,
            pContentDesc);

        result = GetWrappedObjectAs<ID3D11VideoProcessorEnumerator>()->GetVideoProcessorContentDesc(
            pContentDesc);

        Encode_ID3D11VideoProcessorEnumerator_GetVideoProcessorContentDesc(
            this,
            result,
            pContentDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorEnumerator_GetVideoProcessorContentDesc>::Dispatch(
            manager,
            this,
            result,
            pContentDesc);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoProcessorEnumerator>()->GetVideoProcessorContentDesc(
            pContentDesc);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoProcessorEnumerator_Wrapper::CheckVideoProcessorFormat(
    DXGI_FORMAT Format,
    UINT* pFlags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorEnumerator_CheckVideoProcessorFormat>::Dispatch(
            manager,
            this,
            Format,
            pFlags);

        result = GetWrappedObjectAs<ID3D11VideoProcessorEnumerator>()->CheckVideoProcessorFormat(
            Format,
            pFlags);

        Encode_ID3D11VideoProcessorEnumerator_CheckVideoProcessorFormat(
            this,
            result,
            Format,
            pFlags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorEnumerator_CheckVideoProcessorFormat>::Dispatch(
            manager,
            this,
            result,
            Format,
            pFlags);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoProcessorEnumerator>()->CheckVideoProcessorFormat(
            Format,
            pFlags);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoProcessorEnumerator_Wrapper::GetVideoProcessorCaps(
    D3D11_VIDEO_PROCESSOR_CAPS* pCaps)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorEnumerator_GetVideoProcessorCaps>::Dispatch(
            manager,
            this,
            pCaps);

        result = GetWrappedObjectAs<ID3D11VideoProcessorEnumerator>()->GetVideoProcessorCaps(
            pCaps);

        Encode_ID3D11VideoProcessorEnumerator_GetVideoProcessorCaps(
            this,
            result,
            pCaps);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorEnumerator_GetVideoProcessorCaps>::Dispatch(
            manager,
            this,
            result,
            pCaps);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoProcessorEnumerator>()->GetVideoProcessorCaps(
            pCaps);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoProcessorEnumerator_Wrapper::GetVideoProcessorRateConversionCaps(
    UINT TypeIndex,
    D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS* pCaps)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorEnumerator_GetVideoProcessorRateConversionCaps>::Dispatch(
            manager,
            this,
            TypeIndex,
            pCaps);

        result = GetWrappedObjectAs<ID3D11VideoProcessorEnumerator>()->GetVideoProcessorRateConversionCaps(
            TypeIndex,
            pCaps);

        Encode_ID3D11VideoProcessorEnumerator_GetVideoProcessorRateConversionCaps(
            this,
            result,
            TypeIndex,
            pCaps);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorEnumerator_GetVideoProcessorRateConversionCaps>::Dispatch(
            manager,
            this,
            result,
            TypeIndex,
            pCaps);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoProcessorEnumerator>()->GetVideoProcessorRateConversionCaps(
            TypeIndex,
            pCaps);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoProcessorEnumerator_Wrapper::GetVideoProcessorCustomRate(
    UINT TypeIndex,
    UINT CustomRateIndex,
    D3D11_VIDEO_PROCESSOR_CUSTOM_RATE* pRate)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorEnumerator_GetVideoProcessorCustomRate>::Dispatch(
            manager,
            this,
            TypeIndex,
            CustomRateIndex,
            pRate);

        result = GetWrappedObjectAs<ID3D11VideoProcessorEnumerator>()->GetVideoProcessorCustomRate(
            TypeIndex,
            CustomRateIndex,
            pRate);

        Encode_ID3D11VideoProcessorEnumerator_GetVideoProcessorCustomRate(
            this,
            result,
            TypeIndex,
            CustomRateIndex,
            pRate);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorEnumerator_GetVideoProcessorCustomRate>::Dispatch(
            manager,
            this,
            result,
            TypeIndex,
            CustomRateIndex,
            pRate);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoProcessorEnumerator>()->GetVideoProcessorCustomRate(
            TypeIndex,
            CustomRateIndex,
            pRate);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoProcessorEnumerator_Wrapper::GetVideoProcessorFilterRange(
    D3D11_VIDEO_PROCESSOR_FILTER Filter,
    D3D11_VIDEO_PROCESSOR_FILTER_RANGE* pRange)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorEnumerator_GetVideoProcessorFilterRange>::Dispatch(
            manager,
            this,
            Filter,
            pRange);

        result = GetWrappedObjectAs<ID3D11VideoProcessorEnumerator>()->GetVideoProcessorFilterRange(
            Filter,
            pRange);

        Encode_ID3D11VideoProcessorEnumerator_GetVideoProcessorFilterRange(
            this,
            result,
            Filter,
            pRange);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorEnumerator_GetVideoProcessorFilterRange>::Dispatch(
            manager,
            this,
            result,
            Filter,
            pRange);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoProcessorEnumerator>()->GetVideoProcessorFilterRange(
            Filter,
            pRange);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11VideoProcessor_Wrapper::ID3D11VideoProcessor_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11VideoProcessorInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11VideoProcessor_Wrapper::~ID3D11VideoProcessor_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11VideoProcessor>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11VideoProcessor_Wrapper* ID3D11VideoProcessor_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11VideoProcessor_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11VideoProcessor_Wrapper::GetContentDesc(
    D3D11_VIDEO_PROCESSOR_CONTENT_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoProcessor_GetContentDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11VideoProcessor>()->GetContentDesc(
            pDesc);

        Encode_ID3D11VideoProcessor_GetContentDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoProcessor_GetContentDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoProcessor>()->GetContentDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoProcessor_Wrapper::GetRateConversionCaps(
    D3D11_VIDEO_PROCESSOR_RATE_CONVERSION_CAPS* pCaps)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoProcessor_GetRateConversionCaps>::Dispatch(
            manager,
            this,
            pCaps);

        GetWrappedObjectAs<ID3D11VideoProcessor>()->GetRateConversionCaps(
            pCaps);

        Encode_ID3D11VideoProcessor_GetRateConversionCaps(
            this,
            pCaps);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoProcessor_GetRateConversionCaps>::Dispatch(
            manager,
            this,
            pCaps);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoProcessor>()->GetRateConversionCaps(
            pCaps);
    }

    manager->DecrementCallScope();
}

ID3D11AuthenticatedChannel_Wrapper::ID3D11AuthenticatedChannel_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11AuthenticatedChannelInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11AuthenticatedChannel_Wrapper::~ID3D11AuthenticatedChannel_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11AuthenticatedChannel>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11AuthenticatedChannel_Wrapper* ID3D11AuthenticatedChannel_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11AuthenticatedChannel_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D11AuthenticatedChannel_Wrapper::GetCertificateSize(
    UINT* pCertificateSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11AuthenticatedChannel_GetCertificateSize>::Dispatch(
            manager,
            this,
            pCertificateSize);

        result = GetWrappedObjectAs<ID3D11AuthenticatedChannel>()->GetCertificateSize(
            pCertificateSize);

        Encode_ID3D11AuthenticatedChannel_GetCertificateSize(
            this,
            result,
            pCertificateSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11AuthenticatedChannel_GetCertificateSize>::Dispatch(
            manager,
            this,
            result,
            pCertificateSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11AuthenticatedChannel>()->GetCertificateSize(
            pCertificateSize);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11AuthenticatedChannel_Wrapper::GetCertificate(
    UINT CertificateSize,
    BYTE* pCertificate)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11AuthenticatedChannel_GetCertificate>::Dispatch(
            manager,
            this,
            CertificateSize,
            pCertificate);

        result = GetWrappedObjectAs<ID3D11AuthenticatedChannel>()->GetCertificate(
            CertificateSize,
            pCertificate);

        Encode_ID3D11AuthenticatedChannel_GetCertificate(
            this,
            result,
            CertificateSize,
            pCertificate);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11AuthenticatedChannel_GetCertificate>::Dispatch(
            manager,
            this,
            result,
            CertificateSize,
            pCertificate);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11AuthenticatedChannel>()->GetCertificate(
            CertificateSize,
            pCertificate);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11AuthenticatedChannel_Wrapper::GetChannelHandle(
    HANDLE* pChannelHandle)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11AuthenticatedChannel_GetChannelHandle>::Dispatch(
            manager,
            this,
            pChannelHandle);

        GetWrappedObjectAs<ID3D11AuthenticatedChannel>()->GetChannelHandle(
            pChannelHandle);

        Encode_ID3D11AuthenticatedChannel_GetChannelHandle(
            this,
            pChannelHandle);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11AuthenticatedChannel_GetChannelHandle>::Dispatch(
            manager,
            this,
            pChannelHandle);
    }
    else
    {
        GetWrappedObjectAs<ID3D11AuthenticatedChannel>()->GetChannelHandle(
            pChannelHandle);
    }

    manager->DecrementCallScope();
}

ID3D11CryptoSession_Wrapper::ID3D11CryptoSession_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11CryptoSessionInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11CryptoSession_Wrapper::~ID3D11CryptoSession_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11CryptoSession>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11CryptoSession_Wrapper* ID3D11CryptoSession_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11CryptoSession_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11CryptoSession_Wrapper::GetCryptoType(
    GUID* pCryptoType)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11CryptoSession_GetCryptoType>::Dispatch(
            manager,
            this,
            pCryptoType);

        GetWrappedObjectAs<ID3D11CryptoSession>()->GetCryptoType(
            pCryptoType);

        Encode_ID3D11CryptoSession_GetCryptoType(
            this,
            pCryptoType);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11CryptoSession_GetCryptoType>::Dispatch(
            manager,
            this,
            pCryptoType);
    }
    else
    {
        GetWrappedObjectAs<ID3D11CryptoSession>()->GetCryptoType(
            pCryptoType);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11CryptoSession_Wrapper::GetDecoderProfile(
    GUID* pDecoderProfile)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11CryptoSession_GetDecoderProfile>::Dispatch(
            manager,
            this,
            pDecoderProfile);

        GetWrappedObjectAs<ID3D11CryptoSession>()->GetDecoderProfile(
            pDecoderProfile);

        Encode_ID3D11CryptoSession_GetDecoderProfile(
            this,
            pDecoderProfile);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11CryptoSession_GetDecoderProfile>::Dispatch(
            manager,
            this,
            pDecoderProfile);
    }
    else
    {
        GetWrappedObjectAs<ID3D11CryptoSession>()->GetDecoderProfile(
            pDecoderProfile);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D11CryptoSession_Wrapper::GetCertificateSize(
    UINT* pCertificateSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11CryptoSession_GetCertificateSize>::Dispatch(
            manager,
            this,
            pCertificateSize);

        result = GetWrappedObjectAs<ID3D11CryptoSession>()->GetCertificateSize(
            pCertificateSize);

        Encode_ID3D11CryptoSession_GetCertificateSize(
            this,
            result,
            pCertificateSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11CryptoSession_GetCertificateSize>::Dispatch(
            manager,
            this,
            result,
            pCertificateSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11CryptoSession>()->GetCertificateSize(
            pCertificateSize);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11CryptoSession_Wrapper::GetCertificate(
    UINT CertificateSize,
    BYTE* pCertificate)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11CryptoSession_GetCertificate>::Dispatch(
            manager,
            this,
            CertificateSize,
            pCertificate);

        result = GetWrappedObjectAs<ID3D11CryptoSession>()->GetCertificate(
            CertificateSize,
            pCertificate);

        Encode_ID3D11CryptoSession_GetCertificate(
            this,
            result,
            CertificateSize,
            pCertificate);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11CryptoSession_GetCertificate>::Dispatch(
            manager,
            this,
            result,
            CertificateSize,
            pCertificate);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11CryptoSession>()->GetCertificate(
            CertificateSize,
            pCertificate);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11CryptoSession_Wrapper::GetCryptoSessionHandle(
    HANDLE* pCryptoSessionHandle)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11CryptoSession_GetCryptoSessionHandle>::Dispatch(
            manager,
            this,
            pCryptoSessionHandle);

        GetWrappedObjectAs<ID3D11CryptoSession>()->GetCryptoSessionHandle(
            pCryptoSessionHandle);

        Encode_ID3D11CryptoSession_GetCryptoSessionHandle(
            this,
            pCryptoSessionHandle);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11CryptoSession_GetCryptoSessionHandle>::Dispatch(
            manager,
            this,
            pCryptoSessionHandle);
    }
    else
    {
        GetWrappedObjectAs<ID3D11CryptoSession>()->GetCryptoSessionHandle(
            pCryptoSessionHandle);
    }

    manager->DecrementCallScope();
}

ID3D11VideoDecoderOutputView_Wrapper::ID3D11VideoDecoderOutputView_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11View_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11VideoDecoderOutputViewInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11VideoDecoderOutputView_Wrapper::~ID3D11VideoDecoderOutputView_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11VideoDecoderOutputView>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11VideoDecoderOutputView_Wrapper* ID3D11VideoDecoderOutputView_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11VideoDecoderOutputView_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11VideoDecoderOutputView_Wrapper::GetDesc(
    D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDecoderOutputView_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11VideoDecoderOutputView>()->GetDesc(
            pDesc);

        Encode_ID3D11VideoDecoderOutputView_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDecoderOutputView_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoDecoderOutputView>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11VideoProcessorInputView_Wrapper::ID3D11VideoProcessorInputView_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11View_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11VideoProcessorInputViewInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11VideoProcessorInputView_Wrapper::~ID3D11VideoProcessorInputView_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11VideoProcessorInputView>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11VideoProcessorInputView_Wrapper* ID3D11VideoProcessorInputView_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11VideoProcessorInputView_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11VideoProcessorInputView_Wrapper::GetDesc(
    D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorInputView_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11VideoProcessorInputView>()->GetDesc(
            pDesc);

        Encode_ID3D11VideoProcessorInputView_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorInputView_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoProcessorInputView>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11VideoProcessorOutputView_Wrapper::ID3D11VideoProcessorOutputView_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11View_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11VideoProcessorOutputViewInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11VideoProcessorOutputView_Wrapper::~ID3D11VideoProcessorOutputView_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11VideoProcessorOutputView>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11VideoProcessorOutputView_Wrapper* ID3D11VideoProcessorOutputView_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11VideoProcessorOutputView_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11VideoProcessorOutputView_Wrapper::GetDesc(
    D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorOutputView_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11VideoProcessorOutputView>()->GetDesc(
            pDesc);

        Encode_ID3D11VideoProcessorOutputView_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorOutputView_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoProcessorOutputView>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11VideoContext_Wrapper::ID3D11VideoContext_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11VideoContextInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11VideoContext_Wrapper::~ID3D11VideoContext_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11VideoContext>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11VideoContext_Wrapper* ID3D11VideoContext_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11VideoContext_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::GetDecoderBuffer(
    ID3D11VideoDecoder* pDecoder,
    D3D11_VIDEO_DECODER_BUFFER_TYPE Type,
    UINT* pBufferSize,
    void** ppBuffer)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_GetDecoderBuffer>::Dispatch(
            manager,
            this,
            pDecoder,
            Type,
            pBufferSize,
            ppBuffer);

        result = GetWrappedObjectAs<ID3D11VideoContext>()->GetDecoderBuffer(
            encode::GetWrappedObject<ID3D11VideoDecoder>(pDecoder),
            Type,
            pBufferSize,
            ppBuffer);

        Encode_ID3D11VideoContext_GetDecoderBuffer(
            this,
            result,
            pDecoder,
            Type,
            pBufferSize,
            ppBuffer);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_GetDecoderBuffer>::Dispatch(
            manager,
            this,
            result,
            pDecoder,
            Type,
            pBufferSize,
            ppBuffer);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->GetDecoderBuffer(
            pDecoder,
            Type,
            pBufferSize,
            ppBuffer);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::ReleaseDecoderBuffer(
    ID3D11VideoDecoder* pDecoder,
    D3D11_VIDEO_DECODER_BUFFER_TYPE Type)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_ReleaseDecoderBuffer>::Dispatch(
            manager,
            this,
            pDecoder,
            Type);

        result = GetWrappedObjectAs<ID3D11VideoContext>()->ReleaseDecoderBuffer(
            encode::GetWrappedObject<ID3D11VideoDecoder>(pDecoder),
            Type);

        Encode_ID3D11VideoContext_ReleaseDecoderBuffer(
            this,
            result,
            pDecoder,
            Type);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_ReleaseDecoderBuffer>::Dispatch(
            manager,
            this,
            result,
            pDecoder,
            Type);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->ReleaseDecoderBuffer(
            pDecoder,
            Type);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::DecoderBeginFrame(
    ID3D11VideoDecoder* pDecoder,
    ID3D11VideoDecoderOutputView* pView,
    UINT ContentKeySize,
    const void* pContentKey)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_DecoderBeginFrame>::Dispatch(
            manager,
            this,
            pDecoder,
            pView,
            ContentKeySize,
            pContentKey);

        result = GetWrappedObjectAs<ID3D11VideoContext>()->DecoderBeginFrame(
            encode::GetWrappedObject<ID3D11VideoDecoder>(pDecoder),
            encode::GetWrappedObject<ID3D11VideoDecoderOutputView>(pView),
            ContentKeySize,
            pContentKey);

        Encode_ID3D11VideoContext_DecoderBeginFrame(
            this,
            result,
            pDecoder,
            pView,
            ContentKeySize,
            pContentKey);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_DecoderBeginFrame>::Dispatch(
            manager,
            this,
            result,
            pDecoder,
            pView,
            ContentKeySize,
            pContentKey);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->DecoderBeginFrame(
            pDecoder,
            pView,
            ContentKeySize,
            pContentKey);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::DecoderEndFrame(
    ID3D11VideoDecoder* pDecoder)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_DecoderEndFrame>::Dispatch(
            manager,
            this,
            pDecoder);

        result = GetWrappedObjectAs<ID3D11VideoContext>()->DecoderEndFrame(
            encode::GetWrappedObject<ID3D11VideoDecoder>(pDecoder));

        Encode_ID3D11VideoContext_DecoderEndFrame(
            this,
            result,
            pDecoder);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_DecoderEndFrame>::Dispatch(
            manager,
            this,
            result,
            pDecoder);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->DecoderEndFrame(
            pDecoder);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::SubmitDecoderBuffers(
    ID3D11VideoDecoder* pDecoder,
    UINT NumBuffers,
    const D3D11_VIDEO_DECODER_BUFFER_DESC* pBufferDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_SubmitDecoderBuffers>::Dispatch(
            manager,
            this,
            pDecoder,
            NumBuffers,
            pBufferDesc);

        result = GetWrappedObjectAs<ID3D11VideoContext>()->SubmitDecoderBuffers(
            encode::GetWrappedObject<ID3D11VideoDecoder>(pDecoder),
            NumBuffers,
            pBufferDesc);

        Encode_ID3D11VideoContext_SubmitDecoderBuffers(
            this,
            result,
            pDecoder,
            NumBuffers,
            pBufferDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_SubmitDecoderBuffers>::Dispatch(
            manager,
            this,
            result,
            pDecoder,
            NumBuffers,
            pBufferDesc);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->SubmitDecoderBuffers(
            pDecoder,
            NumBuffers,
            pBufferDesc);
    }

    manager->DecrementCallScope();

    return result;
}

APP_DEPRECATED_HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::DecoderExtension(
    ID3D11VideoDecoder* pDecoder,
    const D3D11_VIDEO_DECODER_EXTENSION* pExtensionData)
{
    APP_DEPRECATED_HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_DecoderExtension>::Dispatch(
            manager,
            this,
            pDecoder,
            pExtensionData);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<ID3D11VideoContext>()->DecoderExtension(
            encode::GetWrappedObject<ID3D11VideoDecoder>(pDecoder),
            UnwrapStructPtrObjects(pExtensionData, unwrap_memory));

        Encode_ID3D11VideoContext_DecoderExtension(
            this,
            result,
            pDecoder,
            pExtensionData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_DecoderExtension>::Dispatch(
            manager,
            this,
            result,
            pDecoder,
            pExtensionData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->DecoderExtension(
            pDecoder,
            pExtensionData);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetOutputTargetRect(
    ID3D11VideoProcessor* pVideoProcessor,
    BOOL Enable,
    const RECT* pRect)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetOutputTargetRect>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            Enable,
            pRect);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetOutputTargetRect(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            Enable,
            pRect);

        Encode_ID3D11VideoContext_VideoProcessorSetOutputTargetRect(
            this,
            pVideoProcessor,
            Enable,
            pRect);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetOutputTargetRect>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            Enable,
            pRect);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetOutputTargetRect(
            pVideoProcessor,
            Enable,
            pRect);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetOutputBackgroundColor(
    ID3D11VideoProcessor* pVideoProcessor,
    BOOL YCbCr,
    const D3D11_VIDEO_COLOR* pColor)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetOutputBackgroundColor>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            YCbCr,
            pColor);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetOutputBackgroundColor(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            YCbCr,
            pColor);

        Encode_ID3D11VideoContext_VideoProcessorSetOutputBackgroundColor(
            this,
            pVideoProcessor,
            YCbCr,
            pColor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetOutputBackgroundColor>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            YCbCr,
            pColor);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetOutputBackgroundColor(
            pVideoProcessor,
            YCbCr,
            pColor);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetOutputColorSpace(
    ID3D11VideoProcessor* pVideoProcessor,
    const D3D11_VIDEO_PROCESSOR_COLOR_SPACE* pColorSpace)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetOutputColorSpace>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pColorSpace);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetOutputColorSpace(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            pColorSpace);

        Encode_ID3D11VideoContext_VideoProcessorSetOutputColorSpace(
            this,
            pVideoProcessor,
            pColorSpace);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetOutputColorSpace>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pColorSpace);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetOutputColorSpace(
            pVideoProcessor,
            pColorSpace);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetOutputAlphaFillMode(
    ID3D11VideoProcessor* pVideoProcessor,
    D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE AlphaFillMode,
    UINT StreamIndex)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetOutputAlphaFillMode>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            AlphaFillMode,
            StreamIndex);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetOutputAlphaFillMode(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            AlphaFillMode,
            StreamIndex);

        Encode_ID3D11VideoContext_VideoProcessorSetOutputAlphaFillMode(
            this,
            pVideoProcessor,
            AlphaFillMode,
            StreamIndex);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetOutputAlphaFillMode>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            AlphaFillMode,
            StreamIndex);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetOutputAlphaFillMode(
            pVideoProcessor,
            AlphaFillMode,
            StreamIndex);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetOutputConstriction(
    ID3D11VideoProcessor* pVideoProcessor,
    BOOL Enable,
    SIZE Size)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetOutputConstriction>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            Enable,
            Size);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetOutputConstriction(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            Enable,
            Size);

        Encode_ID3D11VideoContext_VideoProcessorSetOutputConstriction(
            this,
            pVideoProcessor,
            Enable,
            Size);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetOutputConstriction>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            Enable,
            Size);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetOutputConstriction(
            pVideoProcessor,
            Enable,
            Size);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetOutputStereoMode(
    ID3D11VideoProcessor* pVideoProcessor,
    BOOL Enable)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetOutputStereoMode>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            Enable);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetOutputStereoMode(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            Enable);

        Encode_ID3D11VideoContext_VideoProcessorSetOutputStereoMode(
            this,
            pVideoProcessor,
            Enable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetOutputStereoMode>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            Enable);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetOutputStereoMode(
            pVideoProcessor,
            Enable);
    }

    manager->DecrementCallScope();
}

APP_DEPRECATED_HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetOutputExtension(
    ID3D11VideoProcessor* pVideoProcessor,
    const GUID* pExtensionGuid,
    UINT DataSize,
    void* pData)
{
    APP_DEPRECATED_HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetOutputExtension>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pExtensionGuid,
            DataSize,
            pData);

        result = GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetOutputExtension(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            pExtensionGuid,
            DataSize,
            pData);

        Encode_ID3D11VideoContext_VideoProcessorSetOutputExtension(
            this,
            result,
            pVideoProcessor,
            pExtensionGuid,
            DataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetOutputExtension>::Dispatch(
            manager,
            this,
            result,
            pVideoProcessor,
            pExtensionGuid,
            DataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetOutputExtension(
            pVideoProcessor,
            pExtensionGuid,
            DataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetOutputTargetRect(
    ID3D11VideoProcessor* pVideoProcessor,
    BOOL* Enabled,
    RECT* pRect)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetOutputTargetRect>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            Enabled,
            pRect);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetOutputTargetRect(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            Enabled,
            pRect);

        Encode_ID3D11VideoContext_VideoProcessorGetOutputTargetRect(
            this,
            pVideoProcessor,
            Enabled,
            pRect);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetOutputTargetRect>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            Enabled,
            pRect);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetOutputTargetRect(
            pVideoProcessor,
            Enabled,
            pRect);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetOutputBackgroundColor(
    ID3D11VideoProcessor* pVideoProcessor,
    BOOL* pYCbCr,
    D3D11_VIDEO_COLOR* pColor)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetOutputBackgroundColor>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pYCbCr,
            pColor);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetOutputBackgroundColor(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            pYCbCr,
            pColor);

        Encode_ID3D11VideoContext_VideoProcessorGetOutputBackgroundColor(
            this,
            pVideoProcessor,
            pYCbCr,
            pColor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetOutputBackgroundColor>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pYCbCr,
            pColor);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetOutputBackgroundColor(
            pVideoProcessor,
            pYCbCr,
            pColor);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetOutputColorSpace(
    ID3D11VideoProcessor* pVideoProcessor,
    D3D11_VIDEO_PROCESSOR_COLOR_SPACE* pColorSpace)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetOutputColorSpace>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pColorSpace);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetOutputColorSpace(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            pColorSpace);

        Encode_ID3D11VideoContext_VideoProcessorGetOutputColorSpace(
            this,
            pVideoProcessor,
            pColorSpace);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetOutputColorSpace>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pColorSpace);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetOutputColorSpace(
            pVideoProcessor,
            pColorSpace);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetOutputAlphaFillMode(
    ID3D11VideoProcessor* pVideoProcessor,
    D3D11_VIDEO_PROCESSOR_ALPHA_FILL_MODE* pAlphaFillMode,
    UINT* pStreamIndex)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetOutputAlphaFillMode>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pAlphaFillMode,
            pStreamIndex);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetOutputAlphaFillMode(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            pAlphaFillMode,
            pStreamIndex);

        Encode_ID3D11VideoContext_VideoProcessorGetOutputAlphaFillMode(
            this,
            pVideoProcessor,
            pAlphaFillMode,
            pStreamIndex);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetOutputAlphaFillMode>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pAlphaFillMode,
            pStreamIndex);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetOutputAlphaFillMode(
            pVideoProcessor,
            pAlphaFillMode,
            pStreamIndex);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetOutputConstriction(
    ID3D11VideoProcessor* pVideoProcessor,
    BOOL* pEnabled,
    SIZE* pSize)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetOutputConstriction>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pEnabled,
            pSize);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetOutputConstriction(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            pEnabled,
            pSize);

        Encode_ID3D11VideoContext_VideoProcessorGetOutputConstriction(
            this,
            pVideoProcessor,
            pEnabled,
            pSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetOutputConstriction>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pEnabled,
            pSize);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetOutputConstriction(
            pVideoProcessor,
            pEnabled,
            pSize);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetOutputStereoMode(
    ID3D11VideoProcessor* pVideoProcessor,
    BOOL* pEnabled)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetOutputStereoMode>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pEnabled);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetOutputStereoMode(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            pEnabled);

        Encode_ID3D11VideoContext_VideoProcessorGetOutputStereoMode(
            this,
            pVideoProcessor,
            pEnabled);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetOutputStereoMode>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pEnabled);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetOutputStereoMode(
            pVideoProcessor,
            pEnabled);
    }

    manager->DecrementCallScope();
}

APP_DEPRECATED_HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetOutputExtension(
    ID3D11VideoProcessor* pVideoProcessor,
    const GUID* pExtensionGuid,
    UINT DataSize,
    void* pData)
{
    APP_DEPRECATED_HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetOutputExtension>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pExtensionGuid,
            DataSize,
            pData);

        result = GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetOutputExtension(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            pExtensionGuid,
            DataSize,
            pData);

        Encode_ID3D11VideoContext_VideoProcessorGetOutputExtension(
            this,
            result,
            pVideoProcessor,
            pExtensionGuid,
            DataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetOutputExtension>::Dispatch(
            manager,
            this,
            result,
            pVideoProcessor,
            pExtensionGuid,
            DataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetOutputExtension(
            pVideoProcessor,
            pExtensionGuid,
            DataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetStreamFrameFormat(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    D3D11_VIDEO_FRAME_FORMAT FrameFormat)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamFrameFormat>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            FrameFormat);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamFrameFormat(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            FrameFormat);

        Encode_ID3D11VideoContext_VideoProcessorSetStreamFrameFormat(
            this,
            pVideoProcessor,
            StreamIndex,
            FrameFormat);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamFrameFormat>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            FrameFormat);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamFrameFormat(
            pVideoProcessor,
            StreamIndex,
            FrameFormat);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetStreamColorSpace(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    const D3D11_VIDEO_PROCESSOR_COLOR_SPACE* pColorSpace)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamColorSpace>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pColorSpace);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamColorSpace(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pColorSpace);

        Encode_ID3D11VideoContext_VideoProcessorSetStreamColorSpace(
            this,
            pVideoProcessor,
            StreamIndex,
            pColorSpace);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamColorSpace>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pColorSpace);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamColorSpace(
            pVideoProcessor,
            StreamIndex,
            pColorSpace);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetStreamOutputRate(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    D3D11_VIDEO_PROCESSOR_OUTPUT_RATE OutputRate,
    BOOL RepeatFrame,
    const DXGI_RATIONAL* pCustomRate)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamOutputRate>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            OutputRate,
            RepeatFrame,
            pCustomRate);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamOutputRate(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            OutputRate,
            RepeatFrame,
            pCustomRate);

        Encode_ID3D11VideoContext_VideoProcessorSetStreamOutputRate(
            this,
            pVideoProcessor,
            StreamIndex,
            OutputRate,
            RepeatFrame,
            pCustomRate);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamOutputRate>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            OutputRate,
            RepeatFrame,
            pCustomRate);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamOutputRate(
            pVideoProcessor,
            StreamIndex,
            OutputRate,
            RepeatFrame,
            pCustomRate);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetStreamSourceRect(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL Enable,
    const RECT* pRect)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamSourceRect>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            pRect);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamSourceRect(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            Enable,
            pRect);

        Encode_ID3D11VideoContext_VideoProcessorSetStreamSourceRect(
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            pRect);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamSourceRect>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            pRect);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamSourceRect(
            pVideoProcessor,
            StreamIndex,
            Enable,
            pRect);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetStreamDestRect(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL Enable,
    const RECT* pRect)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamDestRect>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            pRect);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamDestRect(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            Enable,
            pRect);

        Encode_ID3D11VideoContext_VideoProcessorSetStreamDestRect(
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            pRect);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamDestRect>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            pRect);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamDestRect(
            pVideoProcessor,
            StreamIndex,
            Enable,
            pRect);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetStreamAlpha(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL Enable,
    FLOAT Alpha)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamAlpha>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            Alpha);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamAlpha(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            Enable,
            Alpha);

        Encode_ID3D11VideoContext_VideoProcessorSetStreamAlpha(
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            Alpha);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamAlpha>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            Alpha);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamAlpha(
            pVideoProcessor,
            StreamIndex,
            Enable,
            Alpha);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetStreamPalette(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    UINT Count,
    const UINT* pEntries)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamPalette>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Count,
            pEntries);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamPalette(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            Count,
            pEntries);

        Encode_ID3D11VideoContext_VideoProcessorSetStreamPalette(
            this,
            pVideoProcessor,
            StreamIndex,
            Count,
            pEntries);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamPalette>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Count,
            pEntries);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamPalette(
            pVideoProcessor,
            StreamIndex,
            Count,
            pEntries);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetStreamPixelAspectRatio(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL Enable,
    const DXGI_RATIONAL* pSourceAspectRatio,
    const DXGI_RATIONAL* pDestinationAspectRatio)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamPixelAspectRatio>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            pSourceAspectRatio,
            pDestinationAspectRatio);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamPixelAspectRatio(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            Enable,
            pSourceAspectRatio,
            pDestinationAspectRatio);

        Encode_ID3D11VideoContext_VideoProcessorSetStreamPixelAspectRatio(
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            pSourceAspectRatio,
            pDestinationAspectRatio);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamPixelAspectRatio>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            pSourceAspectRatio,
            pDestinationAspectRatio);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamPixelAspectRatio(
            pVideoProcessor,
            StreamIndex,
            Enable,
            pSourceAspectRatio,
            pDestinationAspectRatio);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetStreamLumaKey(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL Enable,
    FLOAT Lower,
    FLOAT Upper)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamLumaKey>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            Lower,
            Upper);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamLumaKey(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            Enable,
            Lower,
            Upper);

        Encode_ID3D11VideoContext_VideoProcessorSetStreamLumaKey(
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            Lower,
            Upper);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamLumaKey>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            Lower,
            Upper);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamLumaKey(
            pVideoProcessor,
            StreamIndex,
            Enable,
            Lower,
            Upper);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetStreamStereoFormat(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL Enable,
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT Format,
    BOOL LeftViewFrame0,
    BOOL BaseViewFrame0,
    D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE FlipMode,
    int MonoOffset)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamStereoFormat>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            Format,
            LeftViewFrame0,
            BaseViewFrame0,
            FlipMode,
            MonoOffset);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamStereoFormat(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            Enable,
            Format,
            LeftViewFrame0,
            BaseViewFrame0,
            FlipMode,
            MonoOffset);

        Encode_ID3D11VideoContext_VideoProcessorSetStreamStereoFormat(
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            Format,
            LeftViewFrame0,
            BaseViewFrame0,
            FlipMode,
            MonoOffset);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamStereoFormat>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            Format,
            LeftViewFrame0,
            BaseViewFrame0,
            FlipMode,
            MonoOffset);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamStereoFormat(
            pVideoProcessor,
            StreamIndex,
            Enable,
            Format,
            LeftViewFrame0,
            BaseViewFrame0,
            FlipMode,
            MonoOffset);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetStreamAutoProcessingMode(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL Enable)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamAutoProcessingMode>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamAutoProcessingMode(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            Enable);

        Encode_ID3D11VideoContext_VideoProcessorSetStreamAutoProcessingMode(
            this,
            pVideoProcessor,
            StreamIndex,
            Enable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamAutoProcessingMode>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamAutoProcessingMode(
            pVideoProcessor,
            StreamIndex,
            Enable);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetStreamFilter(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    D3D11_VIDEO_PROCESSOR_FILTER Filter,
    BOOL Enable,
    int Level)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamFilter>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Filter,
            Enable,
            Level);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamFilter(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            Filter,
            Enable,
            Level);

        Encode_ID3D11VideoContext_VideoProcessorSetStreamFilter(
            this,
            pVideoProcessor,
            StreamIndex,
            Filter,
            Enable,
            Level);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamFilter>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Filter,
            Enable,
            Level);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamFilter(
            pVideoProcessor,
            StreamIndex,
            Filter,
            Enable,
            Level);
    }

    manager->DecrementCallScope();
}

APP_DEPRECATED_HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetStreamExtension(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    const GUID* pExtensionGuid,
    UINT DataSize,
    void* pData)
{
    APP_DEPRECATED_HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamExtension>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pExtensionGuid,
            DataSize,
            pData);

        result = GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamExtension(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pExtensionGuid,
            DataSize,
            pData);

        Encode_ID3D11VideoContext_VideoProcessorSetStreamExtension(
            this,
            result,
            pVideoProcessor,
            StreamIndex,
            pExtensionGuid,
            DataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamExtension>::Dispatch(
            manager,
            this,
            result,
            pVideoProcessor,
            StreamIndex,
            pExtensionGuid,
            DataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamExtension(
            pVideoProcessor,
            StreamIndex,
            pExtensionGuid,
            DataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetStreamFrameFormat(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    D3D11_VIDEO_FRAME_FORMAT* pFrameFormat)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamFrameFormat>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pFrameFormat);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamFrameFormat(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pFrameFormat);

        Encode_ID3D11VideoContext_VideoProcessorGetStreamFrameFormat(
            this,
            pVideoProcessor,
            StreamIndex,
            pFrameFormat);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamFrameFormat>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pFrameFormat);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamFrameFormat(
            pVideoProcessor,
            StreamIndex,
            pFrameFormat);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetStreamColorSpace(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    D3D11_VIDEO_PROCESSOR_COLOR_SPACE* pColorSpace)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamColorSpace>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pColorSpace);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamColorSpace(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pColorSpace);

        Encode_ID3D11VideoContext_VideoProcessorGetStreamColorSpace(
            this,
            pVideoProcessor,
            StreamIndex,
            pColorSpace);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamColorSpace>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pColorSpace);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamColorSpace(
            pVideoProcessor,
            StreamIndex,
            pColorSpace);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetStreamOutputRate(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    D3D11_VIDEO_PROCESSOR_OUTPUT_RATE* pOutputRate,
    BOOL* pRepeatFrame,
    DXGI_RATIONAL* pCustomRate)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamOutputRate>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pOutputRate,
            pRepeatFrame,
            pCustomRate);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamOutputRate(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pOutputRate,
            pRepeatFrame,
            pCustomRate);

        Encode_ID3D11VideoContext_VideoProcessorGetStreamOutputRate(
            this,
            pVideoProcessor,
            StreamIndex,
            pOutputRate,
            pRepeatFrame,
            pCustomRate);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamOutputRate>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pOutputRate,
            pRepeatFrame,
            pCustomRate);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamOutputRate(
            pVideoProcessor,
            StreamIndex,
            pOutputRate,
            pRepeatFrame,
            pCustomRate);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetStreamSourceRect(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL* pEnabled,
    RECT* pRect)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamSourceRect>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pRect);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamSourceRect(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pEnabled,
            pRect);

        Encode_ID3D11VideoContext_VideoProcessorGetStreamSourceRect(
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pRect);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamSourceRect>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pRect);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamSourceRect(
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pRect);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetStreamDestRect(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL* pEnabled,
    RECT* pRect)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamDestRect>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pRect);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamDestRect(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pEnabled,
            pRect);

        Encode_ID3D11VideoContext_VideoProcessorGetStreamDestRect(
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pRect);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamDestRect>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pRect);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamDestRect(
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pRect);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetStreamAlpha(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL* pEnabled,
    FLOAT* pAlpha)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamAlpha>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pAlpha);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamAlpha(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pEnabled,
            pAlpha);

        Encode_ID3D11VideoContext_VideoProcessorGetStreamAlpha(
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pAlpha);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamAlpha>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pAlpha);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamAlpha(
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pAlpha);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetStreamPalette(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    UINT Count,
    UINT* pEntries)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamPalette>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Count,
            pEntries);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamPalette(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            Count,
            pEntries);

        Encode_ID3D11VideoContext_VideoProcessorGetStreamPalette(
            this,
            pVideoProcessor,
            StreamIndex,
            Count,
            pEntries);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamPalette>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Count,
            pEntries);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamPalette(
            pVideoProcessor,
            StreamIndex,
            Count,
            pEntries);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetStreamPixelAspectRatio(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL* pEnabled,
    DXGI_RATIONAL* pSourceAspectRatio,
    DXGI_RATIONAL* pDestinationAspectRatio)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamPixelAspectRatio>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pSourceAspectRatio,
            pDestinationAspectRatio);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamPixelAspectRatio(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pEnabled,
            pSourceAspectRatio,
            pDestinationAspectRatio);

        Encode_ID3D11VideoContext_VideoProcessorGetStreamPixelAspectRatio(
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pSourceAspectRatio,
            pDestinationAspectRatio);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamPixelAspectRatio>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pSourceAspectRatio,
            pDestinationAspectRatio);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamPixelAspectRatio(
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pSourceAspectRatio,
            pDestinationAspectRatio);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetStreamLumaKey(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL* pEnabled,
    FLOAT* pLower,
    FLOAT* pUpper)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamLumaKey>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pLower,
            pUpper);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamLumaKey(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pEnabled,
            pLower,
            pUpper);

        Encode_ID3D11VideoContext_VideoProcessorGetStreamLumaKey(
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pLower,
            pUpper);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamLumaKey>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pLower,
            pUpper);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamLumaKey(
            pVideoProcessor,
            StreamIndex,
            pEnabled,
            pLower,
            pUpper);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetStreamStereoFormat(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL* pEnable,
    D3D11_VIDEO_PROCESSOR_STEREO_FORMAT* pFormat,
    BOOL* pLeftViewFrame0,
    BOOL* pBaseViewFrame0,
    D3D11_VIDEO_PROCESSOR_STEREO_FLIP_MODE* pFlipMode,
    int* MonoOffset)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamStereoFormat>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnable,
            pFormat,
            pLeftViewFrame0,
            pBaseViewFrame0,
            pFlipMode,
            MonoOffset);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamStereoFormat(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pEnable,
            pFormat,
            pLeftViewFrame0,
            pBaseViewFrame0,
            pFlipMode,
            MonoOffset);

        Encode_ID3D11VideoContext_VideoProcessorGetStreamStereoFormat(
            this,
            pVideoProcessor,
            StreamIndex,
            pEnable,
            pFormat,
            pLeftViewFrame0,
            pBaseViewFrame0,
            pFlipMode,
            MonoOffset);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamStereoFormat>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnable,
            pFormat,
            pLeftViewFrame0,
            pBaseViewFrame0,
            pFlipMode,
            MonoOffset);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamStereoFormat(
            pVideoProcessor,
            StreamIndex,
            pEnable,
            pFormat,
            pLeftViewFrame0,
            pBaseViewFrame0,
            pFlipMode,
            MonoOffset);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetStreamAutoProcessingMode(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL* pEnabled)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamAutoProcessingMode>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamAutoProcessingMode(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pEnabled);

        Encode_ID3D11VideoContext_VideoProcessorGetStreamAutoProcessingMode(
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamAutoProcessingMode>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnabled);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamAutoProcessingMode(
            pVideoProcessor,
            StreamIndex,
            pEnabled);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetStreamFilter(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    D3D11_VIDEO_PROCESSOR_FILTER Filter,
    BOOL* pEnabled,
    int* pLevel)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamFilter>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Filter,
            pEnabled,
            pLevel);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamFilter(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            Filter,
            pEnabled,
            pLevel);

        Encode_ID3D11VideoContext_VideoProcessorGetStreamFilter(
            this,
            pVideoProcessor,
            StreamIndex,
            Filter,
            pEnabled,
            pLevel);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamFilter>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Filter,
            pEnabled,
            pLevel);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamFilter(
            pVideoProcessor,
            StreamIndex,
            Filter,
            pEnabled,
            pLevel);
    }

    manager->DecrementCallScope();
}

APP_DEPRECATED_HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetStreamExtension(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    const GUID* pExtensionGuid,
    UINT DataSize,
    void* pData)
{
    APP_DEPRECATED_HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamExtension>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pExtensionGuid,
            DataSize,
            pData);

        result = GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamExtension(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pExtensionGuid,
            DataSize,
            pData);

        Encode_ID3D11VideoContext_VideoProcessorGetStreamExtension(
            this,
            result,
            pVideoProcessor,
            StreamIndex,
            pExtensionGuid,
            DataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamExtension>::Dispatch(
            manager,
            this,
            result,
            pVideoProcessor,
            StreamIndex,
            pExtensionGuid,
            DataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamExtension(
            pVideoProcessor,
            StreamIndex,
            pExtensionGuid,
            DataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorBlt(
    ID3D11VideoProcessor* pVideoProcessor,
    ID3D11VideoProcessorOutputView* pView,
    UINT OutputFrame,
    UINT StreamCount,
    const D3D11_VIDEO_PROCESSOR_STREAM* pStreams)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorBlt>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pView,
            OutputFrame,
            StreamCount,
            pStreams);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorBlt(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            encode::GetWrappedObject<ID3D11VideoProcessorOutputView>(pView),
            OutputFrame,
            StreamCount,
            UnwrapStructArrayObjects(pStreams, StreamCount, unwrap_memory));

        Encode_ID3D11VideoContext_VideoProcessorBlt(
            this,
            result,
            pVideoProcessor,
            pView,
            OutputFrame,
            StreamCount,
            pStreams);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorBlt>::Dispatch(
            manager,
            this,
            result,
            pVideoProcessor,
            pView,
            OutputFrame,
            StreamCount,
            pStreams);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorBlt(
            pVideoProcessor,
            pView,
            OutputFrame,
            StreamCount,
            pStreams);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::NegotiateCryptoSessionKeyExchange(
    ID3D11CryptoSession* pCryptoSession,
    UINT DataSize,
    void* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_NegotiateCryptoSessionKeyExchange>::Dispatch(
            manager,
            this,
            pCryptoSession,
            DataSize,
            pData);

        result = GetWrappedObjectAs<ID3D11VideoContext>()->NegotiateCryptoSessionKeyExchange(
            encode::GetWrappedObject<ID3D11CryptoSession>(pCryptoSession),
            DataSize,
            pData);

        Encode_ID3D11VideoContext_NegotiateCryptoSessionKeyExchange(
            this,
            result,
            pCryptoSession,
            DataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_NegotiateCryptoSessionKeyExchange>::Dispatch(
            manager,
            this,
            result,
            pCryptoSession,
            DataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->NegotiateCryptoSessionKeyExchange(
            pCryptoSession,
            DataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::EncryptionBlt(
    ID3D11CryptoSession* pCryptoSession,
    ID3D11Texture2D* pSrcSurface,
    ID3D11Texture2D* pDstSurface,
    UINT IVSize,
    void* pIV)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_EncryptionBlt>::Dispatch(
            manager,
            this,
            pCryptoSession,
            pSrcSurface,
            pDstSurface,
            IVSize,
            pIV);

        GetWrappedObjectAs<ID3D11VideoContext>()->EncryptionBlt(
            encode::GetWrappedObject<ID3D11CryptoSession>(pCryptoSession),
            encode::GetWrappedObject<ID3D11Texture2D>(pSrcSurface),
            encode::GetWrappedObject<ID3D11Texture2D>(pDstSurface),
            IVSize,
            pIV);

        Encode_ID3D11VideoContext_EncryptionBlt(
            this,
            pCryptoSession,
            pSrcSurface,
            pDstSurface,
            IVSize,
            pIV);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_EncryptionBlt>::Dispatch(
            manager,
            this,
            pCryptoSession,
            pSrcSurface,
            pDstSurface,
            IVSize,
            pIV);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->EncryptionBlt(
            pCryptoSession,
            pSrcSurface,
            pDstSurface,
            IVSize,
            pIV);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::DecryptionBlt(
    ID3D11CryptoSession* pCryptoSession,
    ID3D11Texture2D* pSrcSurface,
    ID3D11Texture2D* pDstSurface,
    D3D11_ENCRYPTED_BLOCK_INFO* pEncryptedBlockInfo,
    UINT ContentKeySize,
    const void* pContentKey,
    UINT IVSize,
    void* pIV)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_DecryptionBlt>::Dispatch(
            manager,
            this,
            pCryptoSession,
            pSrcSurface,
            pDstSurface,
            pEncryptedBlockInfo,
            ContentKeySize,
            pContentKey,
            IVSize,
            pIV);

        GetWrappedObjectAs<ID3D11VideoContext>()->DecryptionBlt(
            encode::GetWrappedObject<ID3D11CryptoSession>(pCryptoSession),
            encode::GetWrappedObject<ID3D11Texture2D>(pSrcSurface),
            encode::GetWrappedObject<ID3D11Texture2D>(pDstSurface),
            pEncryptedBlockInfo,
            ContentKeySize,
            pContentKey,
            IVSize,
            pIV);

        Encode_ID3D11VideoContext_DecryptionBlt(
            this,
            pCryptoSession,
            pSrcSurface,
            pDstSurface,
            pEncryptedBlockInfo,
            ContentKeySize,
            pContentKey,
            IVSize,
            pIV);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_DecryptionBlt>::Dispatch(
            manager,
            this,
            pCryptoSession,
            pSrcSurface,
            pDstSurface,
            pEncryptedBlockInfo,
            ContentKeySize,
            pContentKey,
            IVSize,
            pIV);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->DecryptionBlt(
            pCryptoSession,
            pSrcSurface,
            pDstSurface,
            pEncryptedBlockInfo,
            ContentKeySize,
            pContentKey,
            IVSize,
            pIV);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::StartSessionKeyRefresh(
    ID3D11CryptoSession* pCryptoSession,
    UINT RandomNumberSize,
    void* pRandomNumber)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_StartSessionKeyRefresh>::Dispatch(
            manager,
            this,
            pCryptoSession,
            RandomNumberSize,
            pRandomNumber);

        GetWrappedObjectAs<ID3D11VideoContext>()->StartSessionKeyRefresh(
            encode::GetWrappedObject<ID3D11CryptoSession>(pCryptoSession),
            RandomNumberSize,
            pRandomNumber);

        Encode_ID3D11VideoContext_StartSessionKeyRefresh(
            this,
            pCryptoSession,
            RandomNumberSize,
            pRandomNumber);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_StartSessionKeyRefresh>::Dispatch(
            manager,
            this,
            pCryptoSession,
            RandomNumberSize,
            pRandomNumber);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->StartSessionKeyRefresh(
            pCryptoSession,
            RandomNumberSize,
            pRandomNumber);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::FinishSessionKeyRefresh(
    ID3D11CryptoSession* pCryptoSession)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_FinishSessionKeyRefresh>::Dispatch(
            manager,
            this,
            pCryptoSession);

        GetWrappedObjectAs<ID3D11VideoContext>()->FinishSessionKeyRefresh(
            encode::GetWrappedObject<ID3D11CryptoSession>(pCryptoSession));

        Encode_ID3D11VideoContext_FinishSessionKeyRefresh(
            this,
            pCryptoSession);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_FinishSessionKeyRefresh>::Dispatch(
            manager,
            this,
            pCryptoSession);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->FinishSessionKeyRefresh(
            pCryptoSession);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::GetEncryptionBltKey(
    ID3D11CryptoSession* pCryptoSession,
    UINT KeySize,
    void* pReadbackKey)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_GetEncryptionBltKey>::Dispatch(
            manager,
            this,
            pCryptoSession,
            KeySize,
            pReadbackKey);

        result = GetWrappedObjectAs<ID3D11VideoContext>()->GetEncryptionBltKey(
            encode::GetWrappedObject<ID3D11CryptoSession>(pCryptoSession),
            KeySize,
            pReadbackKey);

        Encode_ID3D11VideoContext_GetEncryptionBltKey(
            this,
            result,
            pCryptoSession,
            KeySize,
            pReadbackKey);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_GetEncryptionBltKey>::Dispatch(
            manager,
            this,
            result,
            pCryptoSession,
            KeySize,
            pReadbackKey);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->GetEncryptionBltKey(
            pCryptoSession,
            KeySize,
            pReadbackKey);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::NegotiateAuthenticatedChannelKeyExchange(
    ID3D11AuthenticatedChannel* pChannel,
    UINT DataSize,
    void* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_NegotiateAuthenticatedChannelKeyExchange>::Dispatch(
            manager,
            this,
            pChannel,
            DataSize,
            pData);

        result = GetWrappedObjectAs<ID3D11VideoContext>()->NegotiateAuthenticatedChannelKeyExchange(
            encode::GetWrappedObject<ID3D11AuthenticatedChannel>(pChannel),
            DataSize,
            pData);

        Encode_ID3D11VideoContext_NegotiateAuthenticatedChannelKeyExchange(
            this,
            result,
            pChannel,
            DataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_NegotiateAuthenticatedChannelKeyExchange>::Dispatch(
            manager,
            this,
            result,
            pChannel,
            DataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->NegotiateAuthenticatedChannelKeyExchange(
            pChannel,
            DataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::QueryAuthenticatedChannel(
    ID3D11AuthenticatedChannel* pChannel,
    UINT InputSize,
    const void* pInput,
    UINT OutputSize,
    void* pOutput)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_QueryAuthenticatedChannel>::Dispatch(
            manager,
            this,
            pChannel,
            InputSize,
            pInput,
            OutputSize,
            pOutput);

        result = GetWrappedObjectAs<ID3D11VideoContext>()->QueryAuthenticatedChannel(
            encode::GetWrappedObject<ID3D11AuthenticatedChannel>(pChannel),
            InputSize,
            pInput,
            OutputSize,
            pOutput);

        Encode_ID3D11VideoContext_QueryAuthenticatedChannel(
            this,
            result,
            pChannel,
            InputSize,
            pInput,
            OutputSize,
            pOutput);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_QueryAuthenticatedChannel>::Dispatch(
            manager,
            this,
            result,
            pChannel,
            InputSize,
            pInput,
            OutputSize,
            pOutput);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->QueryAuthenticatedChannel(
            pChannel,
            InputSize,
            pInput,
            OutputSize,
            pOutput);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::ConfigureAuthenticatedChannel(
    ID3D11AuthenticatedChannel* pChannel,
    UINT InputSize,
    const void* pInput,
    D3D11_AUTHENTICATED_CONFIGURE_OUTPUT* pOutput)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_ConfigureAuthenticatedChannel>::Dispatch(
            manager,
            this,
            pChannel,
            InputSize,
            pInput,
            pOutput);

        result = GetWrappedObjectAs<ID3D11VideoContext>()->ConfigureAuthenticatedChannel(
            encode::GetWrappedObject<ID3D11AuthenticatedChannel>(pChannel),
            InputSize,
            pInput,
            pOutput);

        Encode_ID3D11VideoContext_ConfigureAuthenticatedChannel(
            this,
            result,
            pChannel,
            InputSize,
            pInput,
            pOutput);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_ConfigureAuthenticatedChannel>::Dispatch(
            manager,
            this,
            result,
            pChannel,
            InputSize,
            pInput,
            pOutput);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext>()->ConfigureAuthenticatedChannel(
            pChannel,
            InputSize,
            pInput,
            pOutput);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorSetStreamRotation(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL Enable,
    D3D11_VIDEO_PROCESSOR_ROTATION Rotation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamRotation>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            Rotation);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamRotation(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            Enable,
            Rotation);

        Encode_ID3D11VideoContext_VideoProcessorSetStreamRotation(
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            Rotation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorSetStreamRotation>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            Rotation);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorSetStreamRotation(
            pVideoProcessor,
            StreamIndex,
            Enable,
            Rotation);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext_Wrapper::VideoProcessorGetStreamRotation(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL* pEnable,
    D3D11_VIDEO_PROCESSOR_ROTATION* pRotation)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamRotation>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnable,
            pRotation);

        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamRotation(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pEnable,
            pRotation);

        Encode_ID3D11VideoContext_VideoProcessorGetStreamRotation(
            this,
            pVideoProcessor,
            StreamIndex,
            pEnable,
            pRotation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext_VideoProcessorGetStreamRotation>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnable,
            pRotation);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext>()->VideoProcessorGetStreamRotation(
            pVideoProcessor,
            StreamIndex,
            pEnable,
            pRotation);
    }

    manager->DecrementCallScope();
}

ID3D11VideoDevice_Wrapper::ID3D11VideoDevice_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11VideoDeviceInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11VideoDevice_Wrapper::~ID3D11VideoDevice_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11VideoDevice>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11VideoDevice_Wrapper* ID3D11VideoDevice_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11VideoDevice_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::CreateVideoDecoder(
    const D3D11_VIDEO_DECODER_DESC* pVideoDesc,
    const D3D11_VIDEO_DECODER_CONFIG* pConfig,
    ID3D11VideoDecoder** ppDecoder)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateVideoDecoder>::Dispatch(
            manager,
            this,
            pVideoDesc,
            pConfig,
            ppDecoder);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateVideoDecoder(
            pVideoDesc,
            pConfig,
            ppDecoder);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11VideoDecoder, reinterpret_cast<void**>(ppDecoder), nullptr);
        }

        Encode_ID3D11VideoDevice_CreateVideoDecoder(
            this,
            result,
            pVideoDesc,
            pConfig,
            ppDecoder);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateVideoDecoder>::Dispatch(
            manager,
            this,
            result,
            pVideoDesc,
            pConfig,
            ppDecoder);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateVideoDecoder(
            pVideoDesc,
            pConfig,
            ppDecoder);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::CreateVideoProcessor(
    ID3D11VideoProcessorEnumerator* pEnum,
    UINT RateConversionIndex,
    ID3D11VideoProcessor** ppVideoProcessor)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateVideoProcessor>::Dispatch(
            manager,
            this,
            pEnum,
            RateConversionIndex,
            ppVideoProcessor);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateVideoProcessor(
            encode::GetWrappedObject<ID3D11VideoProcessorEnumerator>(pEnum),
            RateConversionIndex,
            ppVideoProcessor);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11VideoProcessor, reinterpret_cast<void**>(ppVideoProcessor), nullptr);
        }

        Encode_ID3D11VideoDevice_CreateVideoProcessor(
            this,
            result,
            pEnum,
            RateConversionIndex,
            ppVideoProcessor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateVideoProcessor>::Dispatch(
            manager,
            this,
            result,
            pEnum,
            RateConversionIndex,
            ppVideoProcessor);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateVideoProcessor(
            pEnum,
            RateConversionIndex,
            ppVideoProcessor);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::CreateAuthenticatedChannel(
    D3D11_AUTHENTICATED_CHANNEL_TYPE ChannelType,
    ID3D11AuthenticatedChannel** ppAuthenticatedChannel)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateAuthenticatedChannel>::Dispatch(
            manager,
            this,
            ChannelType,
            ppAuthenticatedChannel);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateAuthenticatedChannel(
            ChannelType,
            ppAuthenticatedChannel);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11AuthenticatedChannel, reinterpret_cast<void**>(ppAuthenticatedChannel), nullptr);
        }

        Encode_ID3D11VideoDevice_CreateAuthenticatedChannel(
            this,
            result,
            ChannelType,
            ppAuthenticatedChannel);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateAuthenticatedChannel>::Dispatch(
            manager,
            this,
            result,
            ChannelType,
            ppAuthenticatedChannel);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateAuthenticatedChannel(
            ChannelType,
            ppAuthenticatedChannel);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::CreateCryptoSession(
    const GUID* pCryptoType,
    const GUID* pDecoderProfile,
    const GUID* pKeyExchangeType,
    ID3D11CryptoSession** ppCryptoSession)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateCryptoSession>::Dispatch(
            manager,
            this,
            pCryptoType,
            pDecoderProfile,
            pKeyExchangeType,
            ppCryptoSession);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateCryptoSession(
            pCryptoType,
            pDecoderProfile,
            pKeyExchangeType,
            ppCryptoSession);

        Encode_ID3D11VideoDevice_CreateCryptoSession(
            this,
            result,
            pCryptoType,
            pDecoderProfile,
            pKeyExchangeType,
            ppCryptoSession);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateCryptoSession>::Dispatch(
            manager,
            this,
            result,
            pCryptoType,
            pDecoderProfile,
            pKeyExchangeType,
            ppCryptoSession);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateCryptoSession(
            pCryptoType,
            pDecoderProfile,
            pKeyExchangeType,
            ppCryptoSession);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::CreateVideoDecoderOutputView(
    ID3D11Resource* pResource,
    const D3D11_VIDEO_DECODER_OUTPUT_VIEW_DESC* pDesc,
    ID3D11VideoDecoderOutputView** ppVDOVView)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateVideoDecoderOutputView>::Dispatch(
            manager,
            this,
            pResource,
            pDesc,
            ppVDOVView);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateVideoDecoderOutputView(
            encode::GetWrappedObject<ID3D11Resource>(pResource),
            pDesc,
            ppVDOVView);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11VideoDecoderOutputView, reinterpret_cast<void**>(ppVDOVView), nullptr);
        }

        Encode_ID3D11VideoDevice_CreateVideoDecoderOutputView(
            this,
            result,
            pResource,
            pDesc,
            ppVDOVView);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateVideoDecoderOutputView>::Dispatch(
            manager,
            this,
            result,
            pResource,
            pDesc,
            ppVDOVView);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateVideoDecoderOutputView(
            pResource,
            pDesc,
            ppVDOVView);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::CreateVideoProcessorInputView(
    ID3D11Resource* pResource,
    ID3D11VideoProcessorEnumerator* pEnum,
    const D3D11_VIDEO_PROCESSOR_INPUT_VIEW_DESC* pDesc,
    ID3D11VideoProcessorInputView** ppVPIView)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateVideoProcessorInputView>::Dispatch(
            manager,
            this,
            pResource,
            pEnum,
            pDesc,
            ppVPIView);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateVideoProcessorInputView(
            encode::GetWrappedObject<ID3D11Resource>(pResource),
            encode::GetWrappedObject<ID3D11VideoProcessorEnumerator>(pEnum),
            pDesc,
            ppVPIView);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11VideoProcessorInputView, reinterpret_cast<void**>(ppVPIView), nullptr);
        }

        Encode_ID3D11VideoDevice_CreateVideoProcessorInputView(
            this,
            result,
            pResource,
            pEnum,
            pDesc,
            ppVPIView);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateVideoProcessorInputView>::Dispatch(
            manager,
            this,
            result,
            pResource,
            pEnum,
            pDesc,
            ppVPIView);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateVideoProcessorInputView(
            pResource,
            pEnum,
            pDesc,
            ppVPIView);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::CreateVideoProcessorOutputView(
    ID3D11Resource* pResource,
    ID3D11VideoProcessorEnumerator* pEnum,
    const D3D11_VIDEO_PROCESSOR_OUTPUT_VIEW_DESC* pDesc,
    ID3D11VideoProcessorOutputView** ppVPOView)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateVideoProcessorOutputView>::Dispatch(
            manager,
            this,
            pResource,
            pEnum,
            pDesc,
            ppVPOView);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateVideoProcessorOutputView(
            encode::GetWrappedObject<ID3D11Resource>(pResource),
            encode::GetWrappedObject<ID3D11VideoProcessorEnumerator>(pEnum),
            pDesc,
            ppVPOView);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11VideoProcessorOutputView, reinterpret_cast<void**>(ppVPOView), nullptr);
        }

        Encode_ID3D11VideoDevice_CreateVideoProcessorOutputView(
            this,
            result,
            pResource,
            pEnum,
            pDesc,
            ppVPOView);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateVideoProcessorOutputView>::Dispatch(
            manager,
            this,
            result,
            pResource,
            pEnum,
            pDesc,
            ppVPOView);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateVideoProcessorOutputView(
            pResource,
            pEnum,
            pDesc,
            ppVPOView);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::CreateVideoProcessorEnumerator(
    const D3D11_VIDEO_PROCESSOR_CONTENT_DESC* pDesc,
    ID3D11VideoProcessorEnumerator** ppEnum)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateVideoProcessorEnumerator>::Dispatch(
            manager,
            this,
            pDesc,
            ppEnum);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateVideoProcessorEnumerator(
            pDesc,
            ppEnum);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11VideoProcessorEnumerator, reinterpret_cast<void**>(ppEnum), nullptr);
        }

        Encode_ID3D11VideoDevice_CreateVideoProcessorEnumerator(
            this,
            result,
            pDesc,
            ppEnum);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CreateVideoProcessorEnumerator>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            ppEnum);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CreateVideoProcessorEnumerator(
            pDesc,
            ppEnum);
    }

    manager->DecrementCallScope();

    return result;
}

UINT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::GetVideoDecoderProfileCount()
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_GetVideoDecoderProfileCount>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->GetVideoDecoderProfileCount();

        Encode_ID3D11VideoDevice_GetVideoDecoderProfileCount(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_GetVideoDecoderProfileCount>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->GetVideoDecoderProfileCount();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::GetVideoDecoderProfile(
    UINT Index,
    GUID* pDecoderProfile)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_GetVideoDecoderProfile>::Dispatch(
            manager,
            this,
            Index,
            pDecoderProfile);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->GetVideoDecoderProfile(
            Index,
            pDecoderProfile);

        Encode_ID3D11VideoDevice_GetVideoDecoderProfile(
            this,
            result,
            Index,
            pDecoderProfile);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_GetVideoDecoderProfile>::Dispatch(
            manager,
            this,
            result,
            Index,
            pDecoderProfile);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->GetVideoDecoderProfile(
            Index,
            pDecoderProfile);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::CheckVideoDecoderFormat(
    const GUID* pDecoderProfile,
    DXGI_FORMAT Format,
    BOOL* pSupported)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CheckVideoDecoderFormat>::Dispatch(
            manager,
            this,
            pDecoderProfile,
            Format,
            pSupported);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CheckVideoDecoderFormat(
            pDecoderProfile,
            Format,
            pSupported);

        Encode_ID3D11VideoDevice_CheckVideoDecoderFormat(
            this,
            result,
            pDecoderProfile,
            Format,
            pSupported);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CheckVideoDecoderFormat>::Dispatch(
            manager,
            this,
            result,
            pDecoderProfile,
            Format,
            pSupported);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CheckVideoDecoderFormat(
            pDecoderProfile,
            Format,
            pSupported);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::GetVideoDecoderConfigCount(
    const D3D11_VIDEO_DECODER_DESC* pDesc,
    UINT* pCount)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_GetVideoDecoderConfigCount>::Dispatch(
            manager,
            this,
            pDesc,
            pCount);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->GetVideoDecoderConfigCount(
            pDesc,
            pCount);

        Encode_ID3D11VideoDevice_GetVideoDecoderConfigCount(
            this,
            result,
            pDesc,
            pCount);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_GetVideoDecoderConfigCount>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            pCount);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->GetVideoDecoderConfigCount(
            pDesc,
            pCount);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::GetVideoDecoderConfig(
    const D3D11_VIDEO_DECODER_DESC* pDesc,
    UINT Index,
    D3D11_VIDEO_DECODER_CONFIG* pConfig)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_GetVideoDecoderConfig>::Dispatch(
            manager,
            this,
            pDesc,
            Index,
            pConfig);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->GetVideoDecoderConfig(
            pDesc,
            Index,
            pConfig);

        Encode_ID3D11VideoDevice_GetVideoDecoderConfig(
            this,
            result,
            pDesc,
            Index,
            pConfig);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_GetVideoDecoderConfig>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            Index,
            pConfig);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->GetVideoDecoderConfig(
            pDesc,
            Index,
            pConfig);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::GetContentProtectionCaps(
    const GUID* pCryptoType,
    const GUID* pDecoderProfile,
    D3D11_VIDEO_CONTENT_PROTECTION_CAPS* pCaps)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_GetContentProtectionCaps>::Dispatch(
            manager,
            this,
            pCryptoType,
            pDecoderProfile,
            pCaps);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->GetContentProtectionCaps(
            pCryptoType,
            pDecoderProfile,
            pCaps);

        Encode_ID3D11VideoDevice_GetContentProtectionCaps(
            this,
            result,
            pCryptoType,
            pDecoderProfile,
            pCaps);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_GetContentProtectionCaps>::Dispatch(
            manager,
            this,
            result,
            pCryptoType,
            pDecoderProfile,
            pCaps);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->GetContentProtectionCaps(
            pCryptoType,
            pDecoderProfile,
            pCaps);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::CheckCryptoKeyExchange(
    const GUID* pCryptoType,
    const GUID* pDecoderProfile,
    UINT Index,
    GUID* pKeyExchangeType)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CheckCryptoKeyExchange>::Dispatch(
            manager,
            this,
            pCryptoType,
            pDecoderProfile,
            Index,
            pKeyExchangeType);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CheckCryptoKeyExchange(
            pCryptoType,
            pDecoderProfile,
            Index,
            pKeyExchangeType);

        Encode_ID3D11VideoDevice_CheckCryptoKeyExchange(
            this,
            result,
            pCryptoType,
            pDecoderProfile,
            Index,
            pKeyExchangeType);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_CheckCryptoKeyExchange>::Dispatch(
            manager,
            this,
            result,
            pCryptoType,
            pDecoderProfile,
            Index,
            pKeyExchangeType);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->CheckCryptoKeyExchange(
            pCryptoType,
            pDecoderProfile,
            Index,
            pKeyExchangeType);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::SetPrivateData(
    REFGUID guid,
    UINT DataSize,
    const void* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_SetPrivateData>::Dispatch(
            manager,
            this,
            guid,
            DataSize,
            pData);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->SetPrivateData(
            guid,
            DataSize,
            pData);

        Encode_ID3D11VideoDevice_SetPrivateData(
            this,
            result,
            guid,
            DataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_SetPrivateData>::Dispatch(
            manager,
            this,
            result,
            guid,
            DataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->SetPrivateData(
            guid,
            DataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice_Wrapper::SetPrivateDataInterface(
    REFGUID guid,
    const IUnknown* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_SetPrivateDataInterface>::Dispatch(
            manager,
            this,
            guid,
            pData);

        result = GetWrappedObjectAs<ID3D11VideoDevice>()->SetPrivateDataInterface(
            guid,
            encode::GetWrappedObject<IUnknown>(pData));

        Encode_ID3D11VideoDevice_SetPrivateDataInterface(
            this,
            result,
            guid,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice_SetPrivateDataInterface>::Dispatch(
            manager,
            this,
            result,
            guid,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice>()->SetPrivateDataInterface(
            guid,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11Device_Wrapper::ID3D11Device_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11DeviceInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11Device_Wrapper::~ID3D11Device_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11Device>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11Device_Wrapper* ID3D11Device_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11Device_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateBuffer(
    const D3D11_BUFFER_DESC* pDesc,
    const D3D11_SUBRESOURCE_DATA* pInitialData,
    ID3D11Buffer** ppBuffer)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateBuffer>::Dispatch(
            manager,
            this,
            pDesc,
            pInitialData,
            ppBuffer);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateBuffer(
            pDesc,
            pInitialData,
            ppBuffer);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11Buffer, reinterpret_cast<void**>(ppBuffer), nullptr);
        }

        Encode_ID3D11Device_CreateBuffer(
            this,
            result,
            pDesc,
            pInitialData,
            ppBuffer);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateBuffer>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            pInitialData,
            ppBuffer);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateBuffer(
            pDesc,
            pInitialData,
            ppBuffer);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateTexture1D(
    const D3D11_TEXTURE1D_DESC* pDesc,
    const D3D11_SUBRESOURCE_DATA* pInitialData,
    ID3D11Texture1D** ppTexture1D)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateTexture1D>::Dispatch(
            manager,
            this,
            pDesc,
            pInitialData,
            ppTexture1D);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateTexture1D(
            pDesc,
            pInitialData,
            ppTexture1D);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11Texture1D, reinterpret_cast<void**>(ppTexture1D), nullptr);
        }

        Encode_ID3D11Device_CreateTexture1D(
            this,
            result,
            pDesc,
            pInitialData,
            ppTexture1D);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateTexture1D>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            pInitialData,
            ppTexture1D);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateTexture1D(
            pDesc,
            pInitialData,
            ppTexture1D);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateTexture2D(
    const D3D11_TEXTURE2D_DESC* pDesc,
    const D3D11_SUBRESOURCE_DATA* pInitialData,
    ID3D11Texture2D** ppTexture2D)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateTexture2D>::Dispatch(
            manager,
            this,
            pDesc,
            pInitialData,
            ppTexture2D);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateTexture2D(
            pDesc,
            pInitialData,
            ppTexture2D);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11Texture2D, reinterpret_cast<void**>(ppTexture2D), nullptr);
        }

        Encode_ID3D11Device_CreateTexture2D(
            this,
            result,
            pDesc,
            pInitialData,
            ppTexture2D);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateTexture2D>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            pInitialData,
            ppTexture2D);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateTexture2D(
            pDesc,
            pInitialData,
            ppTexture2D);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateTexture3D(
    const D3D11_TEXTURE3D_DESC* pDesc,
    const D3D11_SUBRESOURCE_DATA* pInitialData,
    ID3D11Texture3D** ppTexture3D)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateTexture3D>::Dispatch(
            manager,
            this,
            pDesc,
            pInitialData,
            ppTexture3D);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateTexture3D(
            pDesc,
            pInitialData,
            ppTexture3D);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11Texture3D, reinterpret_cast<void**>(ppTexture3D), nullptr);
        }

        Encode_ID3D11Device_CreateTexture3D(
            this,
            result,
            pDesc,
            pInitialData,
            ppTexture3D);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateTexture3D>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            pInitialData,
            ppTexture3D);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateTexture3D(
            pDesc,
            pInitialData,
            ppTexture3D);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateShaderResourceView(
    ID3D11Resource* pResource,
    const D3D11_SHADER_RESOURCE_VIEW_DESC* pDesc,
    ID3D11ShaderResourceView** ppSRView)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateShaderResourceView>::Dispatch(
            manager,
            this,
            pResource,
            pDesc,
            ppSRView);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateShaderResourceView(
            encode::GetWrappedObject<ID3D11Resource>(pResource),
            pDesc,
            ppSRView);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11ShaderResourceView, reinterpret_cast<void**>(ppSRView), nullptr);
        }

        Encode_ID3D11Device_CreateShaderResourceView(
            this,
            result,
            pResource,
            pDesc,
            ppSRView);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateShaderResourceView>::Dispatch(
            manager,
            this,
            result,
            pResource,
            pDesc,
            ppSRView);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateShaderResourceView(
            pResource,
            pDesc,
            ppSRView);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateUnorderedAccessView(
    ID3D11Resource* pResource,
    const D3D11_UNORDERED_ACCESS_VIEW_DESC* pDesc,
    ID3D11UnorderedAccessView** ppUAView)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateUnorderedAccessView>::Dispatch(
            manager,
            this,
            pResource,
            pDesc,
            ppUAView);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateUnorderedAccessView(
            encode::GetWrappedObject<ID3D11Resource>(pResource),
            pDesc,
            ppUAView);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11UnorderedAccessView, reinterpret_cast<void**>(ppUAView), nullptr);
        }

        Encode_ID3D11Device_CreateUnorderedAccessView(
            this,
            result,
            pResource,
            pDesc,
            ppUAView);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateUnorderedAccessView>::Dispatch(
            manager,
            this,
            result,
            pResource,
            pDesc,
            ppUAView);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateUnorderedAccessView(
            pResource,
            pDesc,
            ppUAView);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateRenderTargetView(
    ID3D11Resource* pResource,
    const D3D11_RENDER_TARGET_VIEW_DESC* pDesc,
    ID3D11RenderTargetView** ppRTView)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateRenderTargetView>::Dispatch(
            manager,
            this,
            pResource,
            pDesc,
            ppRTView);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateRenderTargetView(
            encode::GetWrappedObject<ID3D11Resource>(pResource),
            pDesc,
            ppRTView);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11RenderTargetView, reinterpret_cast<void**>(ppRTView), nullptr);
        }

        Encode_ID3D11Device_CreateRenderTargetView(
            this,
            result,
            pResource,
            pDesc,
            ppRTView);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateRenderTargetView>::Dispatch(
            manager,
            this,
            result,
            pResource,
            pDesc,
            ppRTView);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateRenderTargetView(
            pResource,
            pDesc,
            ppRTView);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateDepthStencilView(
    ID3D11Resource* pResource,
    const D3D11_DEPTH_STENCIL_VIEW_DESC* pDesc,
    ID3D11DepthStencilView** ppDepthStencilView)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateDepthStencilView>::Dispatch(
            manager,
            this,
            pResource,
            pDesc,
            ppDepthStencilView);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateDepthStencilView(
            encode::GetWrappedObject<ID3D11Resource>(pResource),
            pDesc,
            ppDepthStencilView);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11DepthStencilView, reinterpret_cast<void**>(ppDepthStencilView), nullptr);
        }

        Encode_ID3D11Device_CreateDepthStencilView(
            this,
            result,
            pResource,
            pDesc,
            ppDepthStencilView);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateDepthStencilView>::Dispatch(
            manager,
            this,
            result,
            pResource,
            pDesc,
            ppDepthStencilView);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateDepthStencilView(
            pResource,
            pDesc,
            ppDepthStencilView);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateInputLayout(
    const D3D11_INPUT_ELEMENT_DESC* pInputElementDescs,
    UINT NumElements,
    const void* pShaderBytecodeWithInputSignature,
    SIZE_T BytecodeLength,
    ID3D11InputLayout** ppInputLayout)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateInputLayout>::Dispatch(
            manager,
            this,
            pInputElementDescs,
            NumElements,
            pShaderBytecodeWithInputSignature,
            BytecodeLength,
            ppInputLayout);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateInputLayout(
            pInputElementDescs,
            NumElements,
            pShaderBytecodeWithInputSignature,
            BytecodeLength,
            ppInputLayout);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11InputLayout, reinterpret_cast<void**>(ppInputLayout), nullptr);
        }

        Encode_ID3D11Device_CreateInputLayout(
            this,
            result,
            pInputElementDescs,
            NumElements,
            pShaderBytecodeWithInputSignature,
            BytecodeLength,
            ppInputLayout);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateInputLayout>::Dispatch(
            manager,
            this,
            result,
            pInputElementDescs,
            NumElements,
            pShaderBytecodeWithInputSignature,
            BytecodeLength,
            ppInputLayout);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateInputLayout(
            pInputElementDescs,
            NumElements,
            pShaderBytecodeWithInputSignature,
            BytecodeLength,
            ppInputLayout);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateVertexShader(
    const void* pShaderBytecode,
    SIZE_T BytecodeLength,
    ID3D11ClassLinkage* pClassLinkage,
    ID3D11VertexShader** ppVertexShader)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateVertexShader>::Dispatch(
            manager,
            this,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppVertexShader);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateVertexShader(
            pShaderBytecode,
            BytecodeLength,
            encode::GetWrappedObject<ID3D11ClassLinkage>(pClassLinkage),
            ppVertexShader);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11VertexShader, reinterpret_cast<void**>(ppVertexShader), nullptr);
        }

        Encode_ID3D11Device_CreateVertexShader(
            this,
            result,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppVertexShader);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateVertexShader>::Dispatch(
            manager,
            this,
            result,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppVertexShader);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateVertexShader(
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppVertexShader);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateGeometryShader(
    const void* pShaderBytecode,
    SIZE_T BytecodeLength,
    ID3D11ClassLinkage* pClassLinkage,
    ID3D11GeometryShader** ppGeometryShader)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateGeometryShader>::Dispatch(
            manager,
            this,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppGeometryShader);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateGeometryShader(
            pShaderBytecode,
            BytecodeLength,
            encode::GetWrappedObject<ID3D11ClassLinkage>(pClassLinkage),
            ppGeometryShader);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11GeometryShader, reinterpret_cast<void**>(ppGeometryShader), nullptr);
        }

        Encode_ID3D11Device_CreateGeometryShader(
            this,
            result,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppGeometryShader);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateGeometryShader>::Dispatch(
            manager,
            this,
            result,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppGeometryShader);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateGeometryShader(
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppGeometryShader);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateGeometryShaderWithStreamOutput(
    const void* pShaderBytecode,
    SIZE_T BytecodeLength,
    const D3D11_SO_DECLARATION_ENTRY* pSODeclaration,
    UINT NumEntries,
    const UINT* pBufferStrides,
    UINT NumStrides,
    UINT RasterizedStream,
    ID3D11ClassLinkage* pClassLinkage,
    ID3D11GeometryShader** ppGeometryShader)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateGeometryShaderWithStreamOutput>::Dispatch(
            manager,
            this,
            pShaderBytecode,
            BytecodeLength,
            pSODeclaration,
            NumEntries,
            pBufferStrides,
            NumStrides,
            RasterizedStream,
            pClassLinkage,
            ppGeometryShader);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateGeometryShaderWithStreamOutput(
            pShaderBytecode,
            BytecodeLength,
            pSODeclaration,
            NumEntries,
            pBufferStrides,
            NumStrides,
            RasterizedStream,
            encode::GetWrappedObject<ID3D11ClassLinkage>(pClassLinkage),
            ppGeometryShader);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11GeometryShader, reinterpret_cast<void**>(ppGeometryShader), nullptr);
        }

        Encode_ID3D11Device_CreateGeometryShaderWithStreamOutput(
            this,
            result,
            pShaderBytecode,
            BytecodeLength,
            pSODeclaration,
            NumEntries,
            pBufferStrides,
            NumStrides,
            RasterizedStream,
            pClassLinkage,
            ppGeometryShader);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateGeometryShaderWithStreamOutput>::Dispatch(
            manager,
            this,
            result,
            pShaderBytecode,
            BytecodeLength,
            pSODeclaration,
            NumEntries,
            pBufferStrides,
            NumStrides,
            RasterizedStream,
            pClassLinkage,
            ppGeometryShader);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateGeometryShaderWithStreamOutput(
            pShaderBytecode,
            BytecodeLength,
            pSODeclaration,
            NumEntries,
            pBufferStrides,
            NumStrides,
            RasterizedStream,
            pClassLinkage,
            ppGeometryShader);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreatePixelShader(
    const void* pShaderBytecode,
    SIZE_T BytecodeLength,
    ID3D11ClassLinkage* pClassLinkage,
    ID3D11PixelShader** ppPixelShader)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreatePixelShader>::Dispatch(
            manager,
            this,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppPixelShader);

        result = GetWrappedObjectAs<ID3D11Device>()->CreatePixelShader(
            pShaderBytecode,
            BytecodeLength,
            encode::GetWrappedObject<ID3D11ClassLinkage>(pClassLinkage),
            ppPixelShader);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11PixelShader, reinterpret_cast<void**>(ppPixelShader), nullptr);
        }

        Encode_ID3D11Device_CreatePixelShader(
            this,
            result,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppPixelShader);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreatePixelShader>::Dispatch(
            manager,
            this,
            result,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppPixelShader);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreatePixelShader(
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppPixelShader);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateHullShader(
    const void* pShaderBytecode,
    SIZE_T BytecodeLength,
    ID3D11ClassLinkage* pClassLinkage,
    ID3D11HullShader** ppHullShader)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateHullShader>::Dispatch(
            manager,
            this,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppHullShader);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateHullShader(
            pShaderBytecode,
            BytecodeLength,
            encode::GetWrappedObject<ID3D11ClassLinkage>(pClassLinkage),
            ppHullShader);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11HullShader, reinterpret_cast<void**>(ppHullShader), nullptr);
        }

        Encode_ID3D11Device_CreateHullShader(
            this,
            result,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppHullShader);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateHullShader>::Dispatch(
            manager,
            this,
            result,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppHullShader);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateHullShader(
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppHullShader);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateDomainShader(
    const void* pShaderBytecode,
    SIZE_T BytecodeLength,
    ID3D11ClassLinkage* pClassLinkage,
    ID3D11DomainShader** ppDomainShader)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateDomainShader>::Dispatch(
            manager,
            this,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppDomainShader);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateDomainShader(
            pShaderBytecode,
            BytecodeLength,
            encode::GetWrappedObject<ID3D11ClassLinkage>(pClassLinkage),
            ppDomainShader);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11DomainShader, reinterpret_cast<void**>(ppDomainShader), nullptr);
        }

        Encode_ID3D11Device_CreateDomainShader(
            this,
            result,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppDomainShader);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateDomainShader>::Dispatch(
            manager,
            this,
            result,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppDomainShader);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateDomainShader(
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppDomainShader);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateComputeShader(
    const void* pShaderBytecode,
    SIZE_T BytecodeLength,
    ID3D11ClassLinkage* pClassLinkage,
    ID3D11ComputeShader** ppComputeShader)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateComputeShader>::Dispatch(
            manager,
            this,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppComputeShader);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateComputeShader(
            pShaderBytecode,
            BytecodeLength,
            encode::GetWrappedObject<ID3D11ClassLinkage>(pClassLinkage),
            ppComputeShader);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11ComputeShader, reinterpret_cast<void**>(ppComputeShader), nullptr);
        }

        Encode_ID3D11Device_CreateComputeShader(
            this,
            result,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppComputeShader);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateComputeShader>::Dispatch(
            manager,
            this,
            result,
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppComputeShader);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateComputeShader(
            pShaderBytecode,
            BytecodeLength,
            pClassLinkage,
            ppComputeShader);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateClassLinkage(
    ID3D11ClassLinkage** ppLinkage)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateClassLinkage>::Dispatch(
            manager,
            this,
            ppLinkage);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateClassLinkage(
            ppLinkage);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11ClassLinkage, reinterpret_cast<void**>(ppLinkage), nullptr);
        }

        Encode_ID3D11Device_CreateClassLinkage(
            this,
            result,
            ppLinkage);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateClassLinkage>::Dispatch(
            manager,
            this,
            result,
            ppLinkage);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateClassLinkage(
            ppLinkage);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateBlendState(
    const D3D11_BLEND_DESC* pBlendStateDesc,
    ID3D11BlendState** ppBlendState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateBlendState>::Dispatch(
            manager,
            this,
            pBlendStateDesc,
            ppBlendState);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateBlendState(
            pBlendStateDesc,
            ppBlendState);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11BlendState, reinterpret_cast<void**>(ppBlendState), nullptr);
        }

        Encode_ID3D11Device_CreateBlendState(
            this,
            result,
            pBlendStateDesc,
            ppBlendState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateBlendState>::Dispatch(
            manager,
            this,
            result,
            pBlendStateDesc,
            ppBlendState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateBlendState(
            pBlendStateDesc,
            ppBlendState);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateDepthStencilState(
    const D3D11_DEPTH_STENCIL_DESC* pDepthStencilDesc,
    ID3D11DepthStencilState** ppDepthStencilState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateDepthStencilState>::Dispatch(
            manager,
            this,
            pDepthStencilDesc,
            ppDepthStencilState);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateDepthStencilState(
            pDepthStencilDesc,
            ppDepthStencilState);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11DepthStencilState, reinterpret_cast<void**>(ppDepthStencilState), nullptr);
        }

        Encode_ID3D11Device_CreateDepthStencilState(
            this,
            result,
            pDepthStencilDesc,
            ppDepthStencilState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateDepthStencilState>::Dispatch(
            manager,
            this,
            result,
            pDepthStencilDesc,
            ppDepthStencilState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateDepthStencilState(
            pDepthStencilDesc,
            ppDepthStencilState);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateRasterizerState(
    const D3D11_RASTERIZER_DESC* pRasterizerDesc,
    ID3D11RasterizerState** ppRasterizerState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateRasterizerState>::Dispatch(
            manager,
            this,
            pRasterizerDesc,
            ppRasterizerState);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateRasterizerState(
            pRasterizerDesc,
            ppRasterizerState);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11RasterizerState, reinterpret_cast<void**>(ppRasterizerState), nullptr);
        }

        Encode_ID3D11Device_CreateRasterizerState(
            this,
            result,
            pRasterizerDesc,
            ppRasterizerState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateRasterizerState>::Dispatch(
            manager,
            this,
            result,
            pRasterizerDesc,
            ppRasterizerState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateRasterizerState(
            pRasterizerDesc,
            ppRasterizerState);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateSamplerState(
    const D3D11_SAMPLER_DESC* pSamplerDesc,
    ID3D11SamplerState** ppSamplerState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateSamplerState>::Dispatch(
            manager,
            this,
            pSamplerDesc,
            ppSamplerState);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateSamplerState(
            pSamplerDesc,
            ppSamplerState);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11SamplerState, reinterpret_cast<void**>(ppSamplerState), nullptr);
        }

        Encode_ID3D11Device_CreateSamplerState(
            this,
            result,
            pSamplerDesc,
            ppSamplerState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateSamplerState>::Dispatch(
            manager,
            this,
            result,
            pSamplerDesc,
            ppSamplerState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateSamplerState(
            pSamplerDesc,
            ppSamplerState);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateQuery(
    const D3D11_QUERY_DESC* pQueryDesc,
    ID3D11Query** ppQuery)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateQuery>::Dispatch(
            manager,
            this,
            pQueryDesc,
            ppQuery);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateQuery(
            pQueryDesc,
            ppQuery);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11Query, reinterpret_cast<void**>(ppQuery), nullptr);
        }

        Encode_ID3D11Device_CreateQuery(
            this,
            result,
            pQueryDesc,
            ppQuery);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateQuery>::Dispatch(
            manager,
            this,
            result,
            pQueryDesc,
            ppQuery);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateQuery(
            pQueryDesc,
            ppQuery);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreatePredicate(
    const D3D11_QUERY_DESC* pPredicateDesc,
    ID3D11Predicate** ppPredicate)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreatePredicate>::Dispatch(
            manager,
            this,
            pPredicateDesc,
            ppPredicate);

        result = GetWrappedObjectAs<ID3D11Device>()->CreatePredicate(
            pPredicateDesc,
            ppPredicate);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11Predicate, reinterpret_cast<void**>(ppPredicate), nullptr);
        }

        Encode_ID3D11Device_CreatePredicate(
            this,
            result,
            pPredicateDesc,
            ppPredicate);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreatePredicate>::Dispatch(
            manager,
            this,
            result,
            pPredicateDesc,
            ppPredicate);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreatePredicate(
            pPredicateDesc,
            ppPredicate);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateCounter(
    const D3D11_COUNTER_DESC* pCounterDesc,
    ID3D11Counter** ppCounter)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateCounter>::Dispatch(
            manager,
            this,
            pCounterDesc,
            ppCounter);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateCounter(
            pCounterDesc,
            ppCounter);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11Counter, reinterpret_cast<void**>(ppCounter), nullptr);
        }

        Encode_ID3D11Device_CreateCounter(
            this,
            result,
            pCounterDesc,
            ppCounter);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateCounter>::Dispatch(
            manager,
            this,
            result,
            pCounterDesc,
            ppCounter);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateCounter(
            pCounterDesc,
            ppCounter);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CreateDeferredContext(
    UINT ContextFlags,
    ID3D11DeviceContext** ppDeferredContext)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CreateDeferredContext>::Dispatch(
            manager,
            this,
            ContextFlags,
            ppDeferredContext);

        result = GetWrappedObjectAs<ID3D11Device>()->CreateDeferredContext(
            ContextFlags,
            ppDeferredContext);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11DeviceContext, reinterpret_cast<void**>(ppDeferredContext), nullptr);
        }

        Encode_ID3D11Device_CreateDeferredContext(
            this,
            result,
            ContextFlags,
            ppDeferredContext);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CreateDeferredContext>::Dispatch(
            manager,
            this,
            result,
            ContextFlags,
            ppDeferredContext);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CreateDeferredContext(
            ContextFlags,
            ppDeferredContext);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::OpenSharedResource(
    HANDLE hResource,
    REFIID ReturnedInterface,
    void** ppResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_OpenSharedResource>::Dispatch(
            manager,
            this,
            hResource,
            ReturnedInterface,
            ppResource);

        result = GetWrappedObjectAs<ID3D11Device>()->OpenSharedResource(
            hResource,
            ReturnedInterface,
            ppResource);

        if (SUCCEEDED(result))
        {
            WrapObject(ReturnedInterface, ppResource, nullptr);
        }

        Encode_ID3D11Device_OpenSharedResource(
            this,
            result,
            hResource,
            ReturnedInterface,
            ppResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_OpenSharedResource>::Dispatch(
            manager,
            this,
            result,
            hResource,
            ReturnedInterface,
            ppResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->OpenSharedResource(
            hResource,
            ReturnedInterface,
            ppResource);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CheckFormatSupport(
    DXGI_FORMAT Format,
    UINT* pFormatSupport)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CheckFormatSupport>::Dispatch(
            manager,
            this,
            Format,
            pFormatSupport);

        result = GetWrappedObjectAs<ID3D11Device>()->CheckFormatSupport(
            Format,
            pFormatSupport);

        Encode_ID3D11Device_CheckFormatSupport(
            this,
            result,
            Format,
            pFormatSupport);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CheckFormatSupport>::Dispatch(
            manager,
            this,
            result,
            Format,
            pFormatSupport);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CheckFormatSupport(
            Format,
            pFormatSupport);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CheckMultisampleQualityLevels(
    DXGI_FORMAT Format,
    UINT SampleCount,
    UINT* pNumQualityLevels)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CheckMultisampleQualityLevels>::Dispatch(
            manager,
            this,
            Format,
            SampleCount,
            pNumQualityLevels);

        result = GetWrappedObjectAs<ID3D11Device>()->CheckMultisampleQualityLevels(
            Format,
            SampleCount,
            pNumQualityLevels);

        Encode_ID3D11Device_CheckMultisampleQualityLevels(
            this,
            result,
            Format,
            SampleCount,
            pNumQualityLevels);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CheckMultisampleQualityLevels>::Dispatch(
            manager,
            this,
            result,
            Format,
            SampleCount,
            pNumQualityLevels);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CheckMultisampleQualityLevels(
            Format,
            SampleCount,
            pNumQualityLevels);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11Device_Wrapper::CheckCounterInfo(
    D3D11_COUNTER_INFO* pCounterInfo)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CheckCounterInfo>::Dispatch(
            manager,
            this,
            pCounterInfo);

        GetWrappedObjectAs<ID3D11Device>()->CheckCounterInfo(
            pCounterInfo);

        Encode_ID3D11Device_CheckCounterInfo(
            this,
            pCounterInfo);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CheckCounterInfo>::Dispatch(
            manager,
            this,
            pCounterInfo);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Device>()->CheckCounterInfo(
            pCounterInfo);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CheckCounter(
    const D3D11_COUNTER_DESC* pDesc,
    D3D11_COUNTER_TYPE* pType,
    UINT* pActiveCounters,
    LPSTR szName,
    UINT* pNameLength,
    LPSTR szUnits,
    UINT* pUnitsLength,
    LPSTR szDescription,
    UINT* pDescriptionLength)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CheckCounter>::Dispatch(
            manager,
            this,
            pDesc,
            pType,
            pActiveCounters,
            szName,
            pNameLength,
            szUnits,
            pUnitsLength,
            szDescription,
            pDescriptionLength);

        result = GetWrappedObjectAs<ID3D11Device>()->CheckCounter(
            pDesc,
            pType,
            pActiveCounters,
            szName,
            pNameLength,
            szUnits,
            pUnitsLength,
            szDescription,
            pDescriptionLength);

        Encode_ID3D11Device_CheckCounter(
            this,
            result,
            pDesc,
            pType,
            pActiveCounters,
            szName,
            pNameLength,
            szUnits,
            pUnitsLength,
            szDescription,
            pDescriptionLength);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CheckCounter>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            pType,
            pActiveCounters,
            szName,
            pNameLength,
            szUnits,
            pUnitsLength,
            szDescription,
            pDescriptionLength);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CheckCounter(
            pDesc,
            pType,
            pActiveCounters,
            szName,
            pNameLength,
            szUnits,
            pUnitsLength,
            szDescription,
            pDescriptionLength);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::CheckFeatureSupport(
    D3D11_FEATURE Feature,
    void* pFeatureSupportData,
    UINT FeatureSupportDataSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_CheckFeatureSupport>::Dispatch(
            manager,
            this,
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);

        result = GetWrappedObjectAs<ID3D11Device>()->CheckFeatureSupport(
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);

        Encode_ID3D11Device_CheckFeatureSupport(
            this,
            result,
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_CheckFeatureSupport>::Dispatch(
            manager,
            this,
            result,
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->CheckFeatureSupport(
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::GetPrivateData(
    REFGUID guid,
    UINT* pDataSize,
    void* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_GetPrivateData>::Dispatch(
            manager,
            this,
            guid,
            pDataSize,
            pData);

        result = GetWrappedObjectAs<ID3D11Device>()->GetPrivateData(
            guid,
            pDataSize,
            pData);

        Encode_ID3D11Device_GetPrivateData(
            this,
            result,
            guid,
            pDataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_GetPrivateData>::Dispatch(
            manager,
            this,
            result,
            guid,
            pDataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->GetPrivateData(
            guid,
            pDataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::SetPrivateData(
    REFGUID guid,
    UINT DataSize,
    const void* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_SetPrivateData>::Dispatch(
            manager,
            this,
            guid,
            DataSize,
            pData);

        result = GetWrappedObjectAs<ID3D11Device>()->SetPrivateData(
            guid,
            DataSize,
            pData);

        Encode_ID3D11Device_SetPrivateData(
            this,
            result,
            guid,
            DataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_SetPrivateData>::Dispatch(
            manager,
            this,
            result,
            guid,
            DataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->SetPrivateData(
            guid,
            DataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::SetPrivateDataInterface(
    REFGUID guid,
    const IUnknown* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_SetPrivateDataInterface>::Dispatch(
            manager,
            this,
            guid,
            pData);

        result = GetWrappedObjectAs<ID3D11Device>()->SetPrivateDataInterface(
            guid,
            encode::GetWrappedObject<IUnknown>(pData));

        Encode_ID3D11Device_SetPrivateDataInterface(
            this,
            result,
            guid,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_SetPrivateDataInterface>::Dispatch(
            manager,
            this,
            result,
            guid,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->SetPrivateDataInterface(
            guid,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

D3D_FEATURE_LEVEL STDMETHODCALLTYPE ID3D11Device_Wrapper::GetFeatureLevel()
{
    D3D_FEATURE_LEVEL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_GetFeatureLevel>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D11Device>()->GetFeatureLevel();

        Encode_ID3D11Device_GetFeatureLevel(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_GetFeatureLevel>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->GetFeatureLevel();
    }

    manager->DecrementCallScope();

    return result;
}

UINT STDMETHODCALLTYPE ID3D11Device_Wrapper::GetCreationFlags()
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_GetCreationFlags>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D11Device>()->GetCreationFlags();

        Encode_ID3D11Device_GetCreationFlags(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_GetCreationFlags>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->GetCreationFlags();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::GetDeviceRemovedReason()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_GetDeviceRemovedReason>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D11Device>()->GetDeviceRemovedReason();

        Encode_ID3D11Device_GetDeviceRemovedReason(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_GetDeviceRemovedReason>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->GetDeviceRemovedReason();
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11Device_Wrapper::GetImmediateContext(
    ID3D11DeviceContext** ppImmediateContext)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_GetImmediateContext>::Dispatch(
            manager,
            this,
            ppImmediateContext);

        GetWrappedObjectAs<ID3D11Device>()->GetImmediateContext(
            ppImmediateContext);

        WrapObject(IID_ID3D11DeviceContext, reinterpret_cast<void**>(ppImmediateContext), nullptr);

        Encode_ID3D11Device_GetImmediateContext(
            this,
            ppImmediateContext);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_GetImmediateContext>::Dispatch(
            manager,
            this,
            ppImmediateContext);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Device>()->GetImmediateContext(
            ppImmediateContext);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D11Device_Wrapper::SetExceptionMode(
    UINT RaiseFlags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_SetExceptionMode>::Dispatch(
            manager,
            this,
            RaiseFlags);

        result = GetWrappedObjectAs<ID3D11Device>()->SetExceptionMode(
            RaiseFlags);

        Encode_ID3D11Device_SetExceptionMode(
            this,
            result,
            RaiseFlags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_SetExceptionMode>::Dispatch(
            manager,
            this,
            result,
            RaiseFlags);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->SetExceptionMode(
            RaiseFlags);
    }

    manager->DecrementCallScope();

    return result;
}

UINT STDMETHODCALLTYPE ID3D11Device_Wrapper::GetExceptionMode()
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device_GetExceptionMode>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D11Device>()->GetExceptionMode();

        Encode_ID3D11Device_GetExceptionMode(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device_GetExceptionMode>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device>()->GetExceptionMode();
    }

    manager->DecrementCallScope();

    return result;
}


/*
** This part is generated from d3d11_1.h in Windows SDK: 10.0.20348.0
**
*/

ID3D11BlendState1_Wrapper::ID3D11BlendState1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11BlendState_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11BlendState1_Wrapper::GetDesc1(
    D3D11_BLEND_DESC1* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11BlendState1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11BlendState1>()->GetDesc1(
            pDesc);

        Encode_ID3D11BlendState1_GetDesc1(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11BlendState1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11BlendState1>()->GetDesc1(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11RasterizerState1_Wrapper::ID3D11RasterizerState1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11RasterizerState_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11RasterizerState1_Wrapper::GetDesc1(
    D3D11_RASTERIZER_DESC1* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11RasterizerState1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11RasterizerState1>()->GetDesc1(
            pDesc);

        Encode_ID3D11RasterizerState1_GetDesc1(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11RasterizerState1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11RasterizerState1>()->GetDesc1(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3DDeviceContextState_Wrapper::ID3DDeviceContextState_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3DDeviceContextStateInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3DDeviceContextState_Wrapper::~ID3DDeviceContextState_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3DDeviceContextState>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3DDeviceContextState_Wrapper* ID3DDeviceContextState_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3DDeviceContextState_Wrapper>(object, object_map_, object_map_lock_);
}

ID3D11DeviceContext1_Wrapper::ID3D11DeviceContext1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceContext_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::CopySubresourceRegion1(
    ID3D11Resource* pDstResource,
    UINT DstSubresource,
    UINT DstX,
    UINT DstY,
    UINT DstZ,
    ID3D11Resource* pSrcResource,
    UINT SrcSubresource,
    const D3D11_BOX* pSrcBox,
    UINT CopyFlags)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_CopySubresourceRegion1>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            DstX,
            DstY,
            DstZ,
            pSrcResource,
            SrcSubresource,
            pSrcBox,
            CopyFlags);

        GetWrappedObjectAs<ID3D11DeviceContext1>()->CopySubresourceRegion1(
            encode::GetWrappedObject<ID3D11Resource>(pDstResource),
            DstSubresource,
            DstX,
            DstY,
            DstZ,
            encode::GetWrappedObject<ID3D11Resource>(pSrcResource),
            SrcSubresource,
            pSrcBox,
            CopyFlags);

        Encode_ID3D11DeviceContext1_CopySubresourceRegion1(
            this,
            pDstResource,
            DstSubresource,
            DstX,
            DstY,
            DstZ,
            pSrcResource,
            SrcSubresource,
            pSrcBox,
            CopyFlags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_CopySubresourceRegion1>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            DstX,
            DstY,
            DstZ,
            pSrcResource,
            SrcSubresource,
            pSrcBox,
            CopyFlags);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->CopySubresourceRegion1(
            pDstResource,
            DstSubresource,
            DstX,
            DstY,
            DstZ,
            pSrcResource,
            SrcSubresource,
            pSrcBox,
            CopyFlags);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::UpdateSubresource1(
    ID3D11Resource* pDstResource,
    UINT DstSubresource,
    const D3D11_BOX* pDstBox,
    const void* pSrcData,
    UINT SrcRowPitch,
    UINT SrcDepthPitch,
    UINT CopyFlags)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_UpdateSubresource1>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch,
            CopyFlags);

        GetWrappedObjectAs<ID3D11DeviceContext1>()->UpdateSubresource1(
            encode::GetWrappedObject<ID3D11Resource>(pDstResource),
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch,
            CopyFlags);

        Encode_ID3D11DeviceContext1_UpdateSubresource1(
            this,
            pDstResource,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch,
            CopyFlags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_UpdateSubresource1>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch,
            CopyFlags);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->UpdateSubresource1(
            pDstResource,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch,
            CopyFlags);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::DiscardResource(
    ID3D11Resource* pResource)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_DiscardResource>::Dispatch(
            manager,
            this,
            pResource);

        GetWrappedObjectAs<ID3D11DeviceContext1>()->DiscardResource(
            encode::GetWrappedObject<ID3D11Resource>(pResource));

        Encode_ID3D11DeviceContext1_DiscardResource(
            this,
            pResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_DiscardResource>::Dispatch(
            manager,
            this,
            pResource);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->DiscardResource(
            pResource);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::DiscardView(
    ID3D11View* pResourceView)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_DiscardView>::Dispatch(
            manager,
            this,
            pResourceView);

        GetWrappedObjectAs<ID3D11DeviceContext1>()->DiscardView(
            encode::GetWrappedObject<ID3D11View>(pResourceView));

        Encode_ID3D11DeviceContext1_DiscardView(
            this,
            pResourceView);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_DiscardView>::Dispatch(
            manager,
            this,
            pResourceView);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->DiscardView(
            pResourceView);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::VSSetConstantBuffers1(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer* const* ppConstantBuffers,
    const UINT* pFirstConstant,
    const UINT* pNumConstants)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_VSSetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext1>()->VSSetConstantBuffers1(
            StartSlot,
            NumBuffers,
            UnwrapObjects<ID3D11Buffer>(ppConstantBuffers, NumBuffers, unwrap_memory),
            pFirstConstant,
            pNumConstants);

        Encode_ID3D11DeviceContext1_VSSetConstantBuffers1(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_VSSetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->VSSetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::HSSetConstantBuffers1(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer* const* ppConstantBuffers,
    const UINT* pFirstConstant,
    const UINT* pNumConstants)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_HSSetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext1>()->HSSetConstantBuffers1(
            StartSlot,
            NumBuffers,
            UnwrapObjects<ID3D11Buffer>(ppConstantBuffers, NumBuffers, unwrap_memory),
            pFirstConstant,
            pNumConstants);

        Encode_ID3D11DeviceContext1_HSSetConstantBuffers1(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_HSSetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->HSSetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::DSSetConstantBuffers1(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer* const* ppConstantBuffers,
    const UINT* pFirstConstant,
    const UINT* pNumConstants)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_DSSetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext1>()->DSSetConstantBuffers1(
            StartSlot,
            NumBuffers,
            UnwrapObjects<ID3D11Buffer>(ppConstantBuffers, NumBuffers, unwrap_memory),
            pFirstConstant,
            pNumConstants);

        Encode_ID3D11DeviceContext1_DSSetConstantBuffers1(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_DSSetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->DSSetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::GSSetConstantBuffers1(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer* const* ppConstantBuffers,
    const UINT* pFirstConstant,
    const UINT* pNumConstants)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_GSSetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext1>()->GSSetConstantBuffers1(
            StartSlot,
            NumBuffers,
            UnwrapObjects<ID3D11Buffer>(ppConstantBuffers, NumBuffers, unwrap_memory),
            pFirstConstant,
            pNumConstants);

        Encode_ID3D11DeviceContext1_GSSetConstantBuffers1(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_GSSetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->GSSetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::PSSetConstantBuffers1(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer* const* ppConstantBuffers,
    const UINT* pFirstConstant,
    const UINT* pNumConstants)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_PSSetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext1>()->PSSetConstantBuffers1(
            StartSlot,
            NumBuffers,
            UnwrapObjects<ID3D11Buffer>(ppConstantBuffers, NumBuffers, unwrap_memory),
            pFirstConstant,
            pNumConstants);

        Encode_ID3D11DeviceContext1_PSSetConstantBuffers1(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_PSSetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->PSSetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::CSSetConstantBuffers1(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer* const* ppConstantBuffers,
    const UINT* pFirstConstant,
    const UINT* pNumConstants)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_CSSetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11DeviceContext1>()->CSSetConstantBuffers1(
            StartSlot,
            NumBuffers,
            UnwrapObjects<ID3D11Buffer>(ppConstantBuffers, NumBuffers, unwrap_memory),
            pFirstConstant,
            pNumConstants);

        Encode_ID3D11DeviceContext1_CSSetConstantBuffers1(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_CSSetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->CSSetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::VSGetConstantBuffers1(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer** ppConstantBuffers,
    UINT* pFirstConstant,
    UINT* pNumConstants)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_VSGetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        GetWrappedObjectAs<ID3D11DeviceContext1>()->VSGetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        WrapObjectArray(IID_ID3D11Buffer, reinterpret_cast<void**>(ppConstantBuffers), NumBuffers, nullptr);

        Encode_ID3D11DeviceContext1_VSGetConstantBuffers1(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_VSGetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->VSGetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::HSGetConstantBuffers1(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer** ppConstantBuffers,
    UINT* pFirstConstant,
    UINT* pNumConstants)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_HSGetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        GetWrappedObjectAs<ID3D11DeviceContext1>()->HSGetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        WrapObjectArray(IID_ID3D11Buffer, reinterpret_cast<void**>(ppConstantBuffers), NumBuffers, nullptr);

        Encode_ID3D11DeviceContext1_HSGetConstantBuffers1(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_HSGetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->HSGetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::DSGetConstantBuffers1(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer** ppConstantBuffers,
    UINT* pFirstConstant,
    UINT* pNumConstants)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_DSGetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        GetWrappedObjectAs<ID3D11DeviceContext1>()->DSGetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        WrapObjectArray(IID_ID3D11Buffer, reinterpret_cast<void**>(ppConstantBuffers), NumBuffers, nullptr);

        Encode_ID3D11DeviceContext1_DSGetConstantBuffers1(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_DSGetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->DSGetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::GSGetConstantBuffers1(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer** ppConstantBuffers,
    UINT* pFirstConstant,
    UINT* pNumConstants)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_GSGetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        GetWrappedObjectAs<ID3D11DeviceContext1>()->GSGetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        WrapObjectArray(IID_ID3D11Buffer, reinterpret_cast<void**>(ppConstantBuffers), NumBuffers, nullptr);

        Encode_ID3D11DeviceContext1_GSGetConstantBuffers1(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_GSGetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->GSGetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::PSGetConstantBuffers1(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer** ppConstantBuffers,
    UINT* pFirstConstant,
    UINT* pNumConstants)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_PSGetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        GetWrappedObjectAs<ID3D11DeviceContext1>()->PSGetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        WrapObjectArray(IID_ID3D11Buffer, reinterpret_cast<void**>(ppConstantBuffers), NumBuffers, nullptr);

        Encode_ID3D11DeviceContext1_PSGetConstantBuffers1(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_PSGetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->PSGetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::CSGetConstantBuffers1(
    UINT StartSlot,
    UINT NumBuffers,
    ID3D11Buffer** ppConstantBuffers,
    UINT* pFirstConstant,
    UINT* pNumConstants)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_CSGetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        GetWrappedObjectAs<ID3D11DeviceContext1>()->CSGetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        WrapObjectArray(IID_ID3D11Buffer, reinterpret_cast<void**>(ppConstantBuffers), NumBuffers, nullptr);

        Encode_ID3D11DeviceContext1_CSGetConstantBuffers1(
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_CSGetConstantBuffers1>::Dispatch(
            manager,
            this,
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->CSGetConstantBuffers1(
            StartSlot,
            NumBuffers,
            ppConstantBuffers,
            pFirstConstant,
            pNumConstants);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::SwapDeviceContextState(
    ID3DDeviceContextState* pState,
    ID3DDeviceContextState** ppPreviousState)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_SwapDeviceContextState>::Dispatch(
            manager,
            this,
            pState,
            ppPreviousState);

        GetWrappedObjectAs<ID3D11DeviceContext1>()->SwapDeviceContextState(
            encode::GetWrappedObject<ID3DDeviceContextState>(pState),
            ppPreviousState);

        WrapObject(IID_ID3DDeviceContextState, reinterpret_cast<void**>(ppPreviousState), nullptr);

        Encode_ID3D11DeviceContext1_SwapDeviceContextState(
            this,
            pState,
            ppPreviousState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_SwapDeviceContextState>::Dispatch(
            manager,
            this,
            pState,
            ppPreviousState);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->SwapDeviceContextState(
            pState,
            ppPreviousState);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::ClearView(
    ID3D11View* pView,
    const FLOAT Color [4],
    const D3D11_RECT* pRect,
    UINT NumRects)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_ClearView>::Dispatch(
            manager,
            this,
            pView,
            Color,
            pRect,
            NumRects);

        GetWrappedObjectAs<ID3D11DeviceContext1>()->ClearView(
            encode::GetWrappedObject<ID3D11View>(pView),
            Color,
            pRect,
            NumRects);

        Encode_ID3D11DeviceContext1_ClearView(
            this,
            pView,
            Color,
            pRect,
            NumRects);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_ClearView>::Dispatch(
            manager,
            this,
            pView,
            Color,
            pRect,
            NumRects);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->ClearView(
            pView,
            Color,
            pRect,
            NumRects);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext1_Wrapper::DiscardView1(
    ID3D11View* pResourceView,
    const D3D11_RECT* pRects,
    UINT NumRects)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_DiscardView1>::Dispatch(
            manager,
            this,
            pResourceView,
            pRects,
            NumRects);

        GetWrappedObjectAs<ID3D11DeviceContext1>()->DiscardView1(
            encode::GetWrappedObject<ID3D11View>(pResourceView),
            pRects,
            NumRects);

        Encode_ID3D11DeviceContext1_DiscardView1(
            this,
            pResourceView,
            pRects,
            NumRects);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext1_DiscardView1>::Dispatch(
            manager,
            this,
            pResourceView,
            pRects,
            NumRects);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext1>()->DiscardView1(
            pResourceView,
            pRects,
            NumRects);
    }

    manager->DecrementCallScope();
}

ID3D11VideoContext1_Wrapper::ID3D11VideoContext1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11VideoContext_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext1_Wrapper::SubmitDecoderBuffers1(
    ID3D11VideoDecoder* pDecoder,
    UINT NumBuffers,
    const D3D11_VIDEO_DECODER_BUFFER_DESC1* pBufferDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_SubmitDecoderBuffers1>::Dispatch(
            manager,
            this,
            pDecoder,
            NumBuffers,
            pBufferDesc);

        result = GetWrappedObjectAs<ID3D11VideoContext1>()->SubmitDecoderBuffers1(
            encode::GetWrappedObject<ID3D11VideoDecoder>(pDecoder),
            NumBuffers,
            pBufferDesc);

        Encode_ID3D11VideoContext1_SubmitDecoderBuffers1(
            this,
            result,
            pDecoder,
            NumBuffers,
            pBufferDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_SubmitDecoderBuffers1>::Dispatch(
            manager,
            this,
            result,
            pDecoder,
            NumBuffers,
            pBufferDesc);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext1>()->SubmitDecoderBuffers1(
            pDecoder,
            NumBuffers,
            pBufferDesc);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext1_Wrapper::GetDataForNewHardwareKey(
    ID3D11CryptoSession* pCryptoSession,
    UINT PrivateInputSize,
    const void* pPrivatInputData,
    UINT64* pPrivateOutputData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_GetDataForNewHardwareKey>::Dispatch(
            manager,
            this,
            pCryptoSession,
            PrivateInputSize,
            pPrivatInputData,
            pPrivateOutputData);

        result = GetWrappedObjectAs<ID3D11VideoContext1>()->GetDataForNewHardwareKey(
            encode::GetWrappedObject<ID3D11CryptoSession>(pCryptoSession),
            PrivateInputSize,
            pPrivatInputData,
            pPrivateOutputData);

        Encode_ID3D11VideoContext1_GetDataForNewHardwareKey(
            this,
            result,
            pCryptoSession,
            PrivateInputSize,
            pPrivatInputData,
            pPrivateOutputData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_GetDataForNewHardwareKey>::Dispatch(
            manager,
            this,
            result,
            pCryptoSession,
            PrivateInputSize,
            pPrivatInputData,
            pPrivateOutputData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext1>()->GetDataForNewHardwareKey(
            pCryptoSession,
            PrivateInputSize,
            pPrivatInputData,
            pPrivateOutputData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext1_Wrapper::CheckCryptoSessionStatus(
    ID3D11CryptoSession* pCryptoSession,
    D3D11_CRYPTO_SESSION_STATUS* pStatus)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_CheckCryptoSessionStatus>::Dispatch(
            manager,
            this,
            pCryptoSession,
            pStatus);

        result = GetWrappedObjectAs<ID3D11VideoContext1>()->CheckCryptoSessionStatus(
            encode::GetWrappedObject<ID3D11CryptoSession>(pCryptoSession),
            pStatus);

        Encode_ID3D11VideoContext1_CheckCryptoSessionStatus(
            this,
            result,
            pCryptoSession,
            pStatus);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_CheckCryptoSessionStatus>::Dispatch(
            manager,
            this,
            result,
            pCryptoSession,
            pStatus);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext1>()->CheckCryptoSessionStatus(
            pCryptoSession,
            pStatus);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext1_Wrapper::DecoderEnableDownsampling(
    ID3D11VideoDecoder* pDecoder,
    DXGI_COLOR_SPACE_TYPE InputColorSpace,
    const D3D11_VIDEO_SAMPLE_DESC* pOutputDesc,
    UINT ReferenceFrameCount)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_DecoderEnableDownsampling>::Dispatch(
            manager,
            this,
            pDecoder,
            InputColorSpace,
            pOutputDesc,
            ReferenceFrameCount);

        result = GetWrappedObjectAs<ID3D11VideoContext1>()->DecoderEnableDownsampling(
            encode::GetWrappedObject<ID3D11VideoDecoder>(pDecoder),
            InputColorSpace,
            pOutputDesc,
            ReferenceFrameCount);

        Encode_ID3D11VideoContext1_DecoderEnableDownsampling(
            this,
            result,
            pDecoder,
            InputColorSpace,
            pOutputDesc,
            ReferenceFrameCount);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_DecoderEnableDownsampling>::Dispatch(
            manager,
            this,
            result,
            pDecoder,
            InputColorSpace,
            pOutputDesc,
            ReferenceFrameCount);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext1>()->DecoderEnableDownsampling(
            pDecoder,
            InputColorSpace,
            pOutputDesc,
            ReferenceFrameCount);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext1_Wrapper::DecoderUpdateDownsampling(
    ID3D11VideoDecoder* pDecoder,
    const D3D11_VIDEO_SAMPLE_DESC* pOutputDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_DecoderUpdateDownsampling>::Dispatch(
            manager,
            this,
            pDecoder,
            pOutputDesc);

        result = GetWrappedObjectAs<ID3D11VideoContext1>()->DecoderUpdateDownsampling(
            encode::GetWrappedObject<ID3D11VideoDecoder>(pDecoder),
            pOutputDesc);

        Encode_ID3D11VideoContext1_DecoderUpdateDownsampling(
            this,
            result,
            pDecoder,
            pOutputDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_DecoderUpdateDownsampling>::Dispatch(
            manager,
            this,
            result,
            pDecoder,
            pOutputDesc);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext1>()->DecoderUpdateDownsampling(
            pDecoder,
            pOutputDesc);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11VideoContext1_Wrapper::VideoProcessorSetOutputColorSpace1(
    ID3D11VideoProcessor* pVideoProcessor,
    DXGI_COLOR_SPACE_TYPE ColorSpace)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorSetOutputColorSpace1>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            ColorSpace);

        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorSetOutputColorSpace1(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            ColorSpace);

        Encode_ID3D11VideoContext1_VideoProcessorSetOutputColorSpace1(
            this,
            pVideoProcessor,
            ColorSpace);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorSetOutputColorSpace1>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            ColorSpace);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorSetOutputColorSpace1(
            pVideoProcessor,
            ColorSpace);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext1_Wrapper::VideoProcessorSetOutputShaderUsage(
    ID3D11VideoProcessor* pVideoProcessor,
    BOOL ShaderUsage)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorSetOutputShaderUsage>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            ShaderUsage);

        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorSetOutputShaderUsage(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            ShaderUsage);

        Encode_ID3D11VideoContext1_VideoProcessorSetOutputShaderUsage(
            this,
            pVideoProcessor,
            ShaderUsage);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorSetOutputShaderUsage>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            ShaderUsage);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorSetOutputShaderUsage(
            pVideoProcessor,
            ShaderUsage);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext1_Wrapper::VideoProcessorGetOutputColorSpace1(
    ID3D11VideoProcessor* pVideoProcessor,
    DXGI_COLOR_SPACE_TYPE* pColorSpace)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorGetOutputColorSpace1>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pColorSpace);

        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorGetOutputColorSpace1(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            pColorSpace);

        Encode_ID3D11VideoContext1_VideoProcessorGetOutputColorSpace1(
            this,
            pVideoProcessor,
            pColorSpace);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorGetOutputColorSpace1>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pColorSpace);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorGetOutputColorSpace1(
            pVideoProcessor,
            pColorSpace);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext1_Wrapper::VideoProcessorGetOutputShaderUsage(
    ID3D11VideoProcessor* pVideoProcessor,
    BOOL* pShaderUsage)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorGetOutputShaderUsage>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pShaderUsage);

        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorGetOutputShaderUsage(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            pShaderUsage);

        Encode_ID3D11VideoContext1_VideoProcessorGetOutputShaderUsage(
            this,
            pVideoProcessor,
            pShaderUsage);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorGetOutputShaderUsage>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pShaderUsage);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorGetOutputShaderUsage(
            pVideoProcessor,
            pShaderUsage);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext1_Wrapper::VideoProcessorSetStreamColorSpace1(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    DXGI_COLOR_SPACE_TYPE ColorSpace)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorSetStreamColorSpace1>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            ColorSpace);

        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorSetStreamColorSpace1(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            ColorSpace);

        Encode_ID3D11VideoContext1_VideoProcessorSetStreamColorSpace1(
            this,
            pVideoProcessor,
            StreamIndex,
            ColorSpace);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorSetStreamColorSpace1>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            ColorSpace);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorSetStreamColorSpace1(
            pVideoProcessor,
            StreamIndex,
            ColorSpace);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext1_Wrapper::VideoProcessorSetStreamMirror(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL Enable,
    BOOL FlipHorizontal,
    BOOL FlipVertical)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorSetStreamMirror>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            FlipHorizontal,
            FlipVertical);

        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorSetStreamMirror(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            Enable,
            FlipHorizontal,
            FlipVertical);

        Encode_ID3D11VideoContext1_VideoProcessorSetStreamMirror(
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            FlipHorizontal,
            FlipVertical);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorSetStreamMirror>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Enable,
            FlipHorizontal,
            FlipVertical);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorSetStreamMirror(
            pVideoProcessor,
            StreamIndex,
            Enable,
            FlipHorizontal,
            FlipVertical);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext1_Wrapper::VideoProcessorGetStreamColorSpace1(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    DXGI_COLOR_SPACE_TYPE* pColorSpace)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorGetStreamColorSpace1>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pColorSpace);

        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorGetStreamColorSpace1(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pColorSpace);

        Encode_ID3D11VideoContext1_VideoProcessorGetStreamColorSpace1(
            this,
            pVideoProcessor,
            StreamIndex,
            pColorSpace);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorGetStreamColorSpace1>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pColorSpace);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorGetStreamColorSpace1(
            pVideoProcessor,
            StreamIndex,
            pColorSpace);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext1_Wrapper::VideoProcessorGetStreamMirror(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    BOOL* pEnable,
    BOOL* pFlipHorizontal,
    BOOL* pFlipVertical)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorGetStreamMirror>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnable,
            pFlipHorizontal,
            pFlipVertical);

        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorGetStreamMirror(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pEnable,
            pFlipHorizontal,
            pFlipVertical);

        Encode_ID3D11VideoContext1_VideoProcessorGetStreamMirror(
            this,
            pVideoProcessor,
            StreamIndex,
            pEnable,
            pFlipHorizontal,
            pFlipVertical);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorGetStreamMirror>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pEnable,
            pFlipHorizontal,
            pFlipVertical);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorGetStreamMirror(
            pVideoProcessor,
            StreamIndex,
            pEnable,
            pFlipHorizontal,
            pFlipVertical);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext1_Wrapper::VideoProcessorGetBehaviorHints(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT OutputWidth,
    UINT OutputHeight,
    DXGI_FORMAT OutputFormat,
    UINT StreamCount,
    const D3D11_VIDEO_PROCESSOR_STREAM_BEHAVIOR_HINT* pStreams,
    UINT* pBehaviorHints)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorGetBehaviorHints>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            OutputWidth,
            OutputHeight,
            OutputFormat,
            StreamCount,
            pStreams,
            pBehaviorHints);

        result = GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorGetBehaviorHints(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            OutputWidth,
            OutputHeight,
            OutputFormat,
            StreamCount,
            pStreams,
            pBehaviorHints);

        Encode_ID3D11VideoContext1_VideoProcessorGetBehaviorHints(
            this,
            result,
            pVideoProcessor,
            OutputWidth,
            OutputHeight,
            OutputFormat,
            StreamCount,
            pStreams,
            pBehaviorHints);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext1_VideoProcessorGetBehaviorHints>::Dispatch(
            manager,
            this,
            result,
            pVideoProcessor,
            OutputWidth,
            OutputHeight,
            OutputFormat,
            StreamCount,
            pStreams,
            pBehaviorHints);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext1>()->VideoProcessorGetBehaviorHints(
            pVideoProcessor,
            OutputWidth,
            OutputHeight,
            OutputFormat,
            StreamCount,
            pStreams,
            pBehaviorHints);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11VideoDevice1_Wrapper::ID3D11VideoDevice1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11VideoDevice_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice1_Wrapper::GetCryptoSessionPrivateDataSize(
    const GUID* pCryptoType,
    const GUID* pDecoderProfile,
    const GUID* pKeyExchangeType,
    UINT* pPrivateInputSize,
    UINT* pPrivateOutputSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice1_GetCryptoSessionPrivateDataSize>::Dispatch(
            manager,
            this,
            pCryptoType,
            pDecoderProfile,
            pKeyExchangeType,
            pPrivateInputSize,
            pPrivateOutputSize);

        result = GetWrappedObjectAs<ID3D11VideoDevice1>()->GetCryptoSessionPrivateDataSize(
            pCryptoType,
            pDecoderProfile,
            pKeyExchangeType,
            pPrivateInputSize,
            pPrivateOutputSize);

        Encode_ID3D11VideoDevice1_GetCryptoSessionPrivateDataSize(
            this,
            result,
            pCryptoType,
            pDecoderProfile,
            pKeyExchangeType,
            pPrivateInputSize,
            pPrivateOutputSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice1_GetCryptoSessionPrivateDataSize>::Dispatch(
            manager,
            this,
            result,
            pCryptoType,
            pDecoderProfile,
            pKeyExchangeType,
            pPrivateInputSize,
            pPrivateOutputSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice1>()->GetCryptoSessionPrivateDataSize(
            pCryptoType,
            pDecoderProfile,
            pKeyExchangeType,
            pPrivateInputSize,
            pPrivateOutputSize);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice1_Wrapper::GetVideoDecoderCaps(
    const GUID* pDecoderProfile,
    UINT SampleWidth,
    UINT SampleHeight,
    const DXGI_RATIONAL* pFrameRate,
    UINT BitRate,
    const GUID* pCryptoType,
    UINT* pDecoderCaps)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice1_GetVideoDecoderCaps>::Dispatch(
            manager,
            this,
            pDecoderProfile,
            SampleWidth,
            SampleHeight,
            pFrameRate,
            BitRate,
            pCryptoType,
            pDecoderCaps);

        result = GetWrappedObjectAs<ID3D11VideoDevice1>()->GetVideoDecoderCaps(
            pDecoderProfile,
            SampleWidth,
            SampleHeight,
            pFrameRate,
            BitRate,
            pCryptoType,
            pDecoderCaps);

        Encode_ID3D11VideoDevice1_GetVideoDecoderCaps(
            this,
            result,
            pDecoderProfile,
            SampleWidth,
            SampleHeight,
            pFrameRate,
            BitRate,
            pCryptoType,
            pDecoderCaps);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice1_GetVideoDecoderCaps>::Dispatch(
            manager,
            this,
            result,
            pDecoderProfile,
            SampleWidth,
            SampleHeight,
            pFrameRate,
            BitRate,
            pCryptoType,
            pDecoderCaps);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice1>()->GetVideoDecoderCaps(
            pDecoderProfile,
            SampleWidth,
            SampleHeight,
            pFrameRate,
            BitRate,
            pCryptoType,
            pDecoderCaps);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice1_Wrapper::CheckVideoDecoderDownsampling(
    const D3D11_VIDEO_DECODER_DESC* pInputDesc,
    DXGI_COLOR_SPACE_TYPE InputColorSpace,
    const D3D11_VIDEO_DECODER_CONFIG* pInputConfig,
    const DXGI_RATIONAL* pFrameRate,
    const D3D11_VIDEO_SAMPLE_DESC* pOutputDesc,
    BOOL* pSupported,
    BOOL* pRealTimeHint)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice1_CheckVideoDecoderDownsampling>::Dispatch(
            manager,
            this,
            pInputDesc,
            InputColorSpace,
            pInputConfig,
            pFrameRate,
            pOutputDesc,
            pSupported,
            pRealTimeHint);

        result = GetWrappedObjectAs<ID3D11VideoDevice1>()->CheckVideoDecoderDownsampling(
            pInputDesc,
            InputColorSpace,
            pInputConfig,
            pFrameRate,
            pOutputDesc,
            pSupported,
            pRealTimeHint);

        Encode_ID3D11VideoDevice1_CheckVideoDecoderDownsampling(
            this,
            result,
            pInputDesc,
            InputColorSpace,
            pInputConfig,
            pFrameRate,
            pOutputDesc,
            pSupported,
            pRealTimeHint);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice1_CheckVideoDecoderDownsampling>::Dispatch(
            manager,
            this,
            result,
            pInputDesc,
            InputColorSpace,
            pInputConfig,
            pFrameRate,
            pOutputDesc,
            pSupported,
            pRealTimeHint);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice1>()->CheckVideoDecoderDownsampling(
            pInputDesc,
            InputColorSpace,
            pInputConfig,
            pFrameRate,
            pOutputDesc,
            pSupported,
            pRealTimeHint);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice1_Wrapper::RecommendVideoDecoderDownsampleParameters(
    const D3D11_VIDEO_DECODER_DESC* pInputDesc,
    DXGI_COLOR_SPACE_TYPE InputColorSpace,
    const D3D11_VIDEO_DECODER_CONFIG* pInputConfig,
    const DXGI_RATIONAL* pFrameRate,
    D3D11_VIDEO_SAMPLE_DESC* pRecommendedOutputDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice1_RecommendVideoDecoderDownsampleParameters>::Dispatch(
            manager,
            this,
            pInputDesc,
            InputColorSpace,
            pInputConfig,
            pFrameRate,
            pRecommendedOutputDesc);

        result = GetWrappedObjectAs<ID3D11VideoDevice1>()->RecommendVideoDecoderDownsampleParameters(
            pInputDesc,
            InputColorSpace,
            pInputConfig,
            pFrameRate,
            pRecommendedOutputDesc);

        Encode_ID3D11VideoDevice1_RecommendVideoDecoderDownsampleParameters(
            this,
            result,
            pInputDesc,
            InputColorSpace,
            pInputConfig,
            pFrameRate,
            pRecommendedOutputDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice1_RecommendVideoDecoderDownsampleParameters>::Dispatch(
            manager,
            this,
            result,
            pInputDesc,
            InputColorSpace,
            pInputConfig,
            pFrameRate,
            pRecommendedOutputDesc);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice1>()->RecommendVideoDecoderDownsampleParameters(
            pInputDesc,
            InputColorSpace,
            pInputConfig,
            pFrameRate,
            pRecommendedOutputDesc);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11VideoProcessorEnumerator1_Wrapper::ID3D11VideoProcessorEnumerator1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11VideoProcessorEnumerator_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D11VideoProcessorEnumerator1_Wrapper::CheckVideoProcessorFormatConversion(
    DXGI_FORMAT InputFormat,
    DXGI_COLOR_SPACE_TYPE InputColorSpace,
    DXGI_FORMAT OutputFormat,
    DXGI_COLOR_SPACE_TYPE OutputColorSpace,
    BOOL* pSupported)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorEnumerator1_CheckVideoProcessorFormatConversion>::Dispatch(
            manager,
            this,
            InputFormat,
            InputColorSpace,
            OutputFormat,
            OutputColorSpace,
            pSupported);

        result = GetWrappedObjectAs<ID3D11VideoProcessorEnumerator1>()->CheckVideoProcessorFormatConversion(
            InputFormat,
            InputColorSpace,
            OutputFormat,
            OutputColorSpace,
            pSupported);

        Encode_ID3D11VideoProcessorEnumerator1_CheckVideoProcessorFormatConversion(
            this,
            result,
            InputFormat,
            InputColorSpace,
            OutputFormat,
            OutputColorSpace,
            pSupported);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoProcessorEnumerator1_CheckVideoProcessorFormatConversion>::Dispatch(
            manager,
            this,
            result,
            InputFormat,
            InputColorSpace,
            OutputFormat,
            OutputColorSpace,
            pSupported);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoProcessorEnumerator1>()->CheckVideoProcessorFormatConversion(
            InputFormat,
            InputColorSpace,
            OutputFormat,
            OutputColorSpace,
            pSupported);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11Device1_Wrapper::ID3D11Device1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Device_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11Device1_Wrapper::GetImmediateContext1(
    ID3D11DeviceContext1** ppImmediateContext)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device1_GetImmediateContext1>::Dispatch(
            manager,
            this,
            ppImmediateContext);

        GetWrappedObjectAs<ID3D11Device1>()->GetImmediateContext1(
            ppImmediateContext);

        WrapObject(IID_ID3D11DeviceContext1, reinterpret_cast<void**>(ppImmediateContext), nullptr);

        Encode_ID3D11Device1_GetImmediateContext1(
            this,
            ppImmediateContext);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device1_GetImmediateContext1>::Dispatch(
            manager,
            this,
            ppImmediateContext);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Device1>()->GetImmediateContext1(
            ppImmediateContext);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D11Device1_Wrapper::CreateDeferredContext1(
    UINT ContextFlags,
    ID3D11DeviceContext1** ppDeferredContext)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device1_CreateDeferredContext1>::Dispatch(
            manager,
            this,
            ContextFlags,
            ppDeferredContext);

        result = GetWrappedObjectAs<ID3D11Device1>()->CreateDeferredContext1(
            ContextFlags,
            ppDeferredContext);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11DeviceContext1, reinterpret_cast<void**>(ppDeferredContext), nullptr);
        }

        Encode_ID3D11Device1_CreateDeferredContext1(
            this,
            result,
            ContextFlags,
            ppDeferredContext);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device1_CreateDeferredContext1>::Dispatch(
            manager,
            this,
            result,
            ContextFlags,
            ppDeferredContext);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device1>()->CreateDeferredContext1(
            ContextFlags,
            ppDeferredContext);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device1_Wrapper::CreateBlendState1(
    const D3D11_BLEND_DESC1* pBlendStateDesc,
    ID3D11BlendState1** ppBlendState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device1_CreateBlendState1>::Dispatch(
            manager,
            this,
            pBlendStateDesc,
            ppBlendState);

        result = GetWrappedObjectAs<ID3D11Device1>()->CreateBlendState1(
            pBlendStateDesc,
            ppBlendState);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11BlendState1, reinterpret_cast<void**>(ppBlendState), nullptr);
        }

        Encode_ID3D11Device1_CreateBlendState1(
            this,
            result,
            pBlendStateDesc,
            ppBlendState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device1_CreateBlendState1>::Dispatch(
            manager,
            this,
            result,
            pBlendStateDesc,
            ppBlendState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device1>()->CreateBlendState1(
            pBlendStateDesc,
            ppBlendState);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device1_Wrapper::CreateRasterizerState1(
    const D3D11_RASTERIZER_DESC1* pRasterizerDesc,
    ID3D11RasterizerState1** ppRasterizerState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device1_CreateRasterizerState1>::Dispatch(
            manager,
            this,
            pRasterizerDesc,
            ppRasterizerState);

        result = GetWrappedObjectAs<ID3D11Device1>()->CreateRasterizerState1(
            pRasterizerDesc,
            ppRasterizerState);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11RasterizerState1, reinterpret_cast<void**>(ppRasterizerState), nullptr);
        }

        Encode_ID3D11Device1_CreateRasterizerState1(
            this,
            result,
            pRasterizerDesc,
            ppRasterizerState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device1_CreateRasterizerState1>::Dispatch(
            manager,
            this,
            result,
            pRasterizerDesc,
            ppRasterizerState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device1>()->CreateRasterizerState1(
            pRasterizerDesc,
            ppRasterizerState);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device1_Wrapper::CreateDeviceContextState(
    UINT Flags,
    const D3D_FEATURE_LEVEL* pFeatureLevels,
    UINT FeatureLevels,
    UINT SDKVersion,
    REFIID EmulatedInterface,
    D3D_FEATURE_LEVEL* pChosenFeatureLevel,
    ID3DDeviceContextState** ppContextState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device1_CreateDeviceContextState>::Dispatch(
            manager,
            this,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            EmulatedInterface,
            pChosenFeatureLevel,
            ppContextState);

        result = GetWrappedObjectAs<ID3D11Device1>()->CreateDeviceContextState(
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            EmulatedInterface,
            pChosenFeatureLevel,
            ppContextState);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3DDeviceContextState, reinterpret_cast<void**>(ppContextState), nullptr);
        }

        Encode_ID3D11Device1_CreateDeviceContextState(
            this,
            result,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            EmulatedInterface,
            pChosenFeatureLevel,
            ppContextState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device1_CreateDeviceContextState>::Dispatch(
            manager,
            this,
            result,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            EmulatedInterface,
            pChosenFeatureLevel,
            ppContextState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device1>()->CreateDeviceContextState(
            Flags,
            pFeatureLevels,
            FeatureLevels,
            SDKVersion,
            EmulatedInterface,
            pChosenFeatureLevel,
            ppContextState);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device1_Wrapper::OpenSharedResource1(
    HANDLE hResource,
    REFIID returnedInterface,
    void** ppResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device1_OpenSharedResource1>::Dispatch(
            manager,
            this,
            hResource,
            returnedInterface,
            ppResource);

        result = GetWrappedObjectAs<ID3D11Device1>()->OpenSharedResource1(
            hResource,
            returnedInterface,
            ppResource);

        if (SUCCEEDED(result))
        {
            WrapObject(returnedInterface, ppResource, nullptr);
        }

        Encode_ID3D11Device1_OpenSharedResource1(
            this,
            result,
            hResource,
            returnedInterface,
            ppResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device1_OpenSharedResource1>::Dispatch(
            manager,
            this,
            result,
            hResource,
            returnedInterface,
            ppResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device1>()->OpenSharedResource1(
            hResource,
            returnedInterface,
            ppResource);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device1_Wrapper::OpenSharedResourceByName(
    LPCWSTR lpName,
    DWORD dwDesiredAccess,
    REFIID returnedInterface,
    void** ppResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device1_OpenSharedResourceByName>::Dispatch(
            manager,
            this,
            lpName,
            dwDesiredAccess,
            returnedInterface,
            ppResource);

        result = GetWrappedObjectAs<ID3D11Device1>()->OpenSharedResourceByName(
            lpName,
            dwDesiredAccess,
            returnedInterface,
            ppResource);

        if (SUCCEEDED(result))
        {
            WrapObject(returnedInterface, ppResource, nullptr);
        }

        Encode_ID3D11Device1_OpenSharedResourceByName(
            this,
            result,
            lpName,
            dwDesiredAccess,
            returnedInterface,
            ppResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device1_OpenSharedResourceByName>::Dispatch(
            manager,
            this,
            result,
            lpName,
            dwDesiredAccess,
            returnedInterface,
            ppResource);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device1>()->OpenSharedResourceByName(
            lpName,
            dwDesiredAccess,
            returnedInterface,
            ppResource);
    }

    manager->DecrementCallScope();

    return result;
}

ID3DUserDefinedAnnotation_Wrapper::ID3DUserDefinedAnnotation_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3DUserDefinedAnnotationInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3DUserDefinedAnnotation_Wrapper::~ID3DUserDefinedAnnotation_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3DUserDefinedAnnotation>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3DUserDefinedAnnotation_Wrapper* ID3DUserDefinedAnnotation_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3DUserDefinedAnnotation_Wrapper>(object, object_map_, object_map_lock_);
}

INT STDMETHODCALLTYPE ID3DUserDefinedAnnotation_Wrapper::BeginEvent(
    LPCWSTR Name)
{
    INT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3DUserDefinedAnnotation_BeginEvent>::Dispatch(
            manager,
            this,
            Name);

        result = GetWrappedObjectAs<ID3DUserDefinedAnnotation>()->BeginEvent(
            Name);

        Encode_ID3DUserDefinedAnnotation_BeginEvent(
            this,
            result,
            Name);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3DUserDefinedAnnotation_BeginEvent>::Dispatch(
            manager,
            this,
            result,
            Name);
    }
    else
    {
        result = GetWrappedObjectAs<ID3DUserDefinedAnnotation>()->BeginEvent(
            Name);
    }

    manager->DecrementCallScope();

    return result;
}

INT STDMETHODCALLTYPE ID3DUserDefinedAnnotation_Wrapper::EndEvent()
{
    INT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3DUserDefinedAnnotation_EndEvent>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3DUserDefinedAnnotation>()->EndEvent();

        Encode_ID3DUserDefinedAnnotation_EndEvent(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3DUserDefinedAnnotation_EndEvent>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3DUserDefinedAnnotation>()->EndEvent();
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3DUserDefinedAnnotation_Wrapper::SetMarker(
    LPCWSTR Name)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3DUserDefinedAnnotation_SetMarker>::Dispatch(
            manager,
            this,
            Name);

        GetWrappedObjectAs<ID3DUserDefinedAnnotation>()->SetMarker(
            Name);

        Encode_ID3DUserDefinedAnnotation_SetMarker(
            this,
            Name);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3DUserDefinedAnnotation_SetMarker>::Dispatch(
            manager,
            this,
            Name);
    }
    else
    {
        GetWrappedObjectAs<ID3DUserDefinedAnnotation>()->SetMarker(
            Name);
    }

    manager->DecrementCallScope();
}

BOOL STDMETHODCALLTYPE ID3DUserDefinedAnnotation_Wrapper::GetStatus()
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3DUserDefinedAnnotation_GetStatus>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3DUserDefinedAnnotation>()->GetStatus();

        Encode_ID3DUserDefinedAnnotation_GetStatus(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3DUserDefinedAnnotation_GetStatus>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3DUserDefinedAnnotation>()->GetStatus();
    }

    manager->DecrementCallScope();

    return result;
}


/*
** This part is generated from d3d11_2.h in Windows SDK: 10.0.20348.0
**
*/

ID3D11DeviceContext2_Wrapper::ID3D11DeviceContext2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceContext1_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D11DeviceContext2_Wrapper::UpdateTileMappings(
    ID3D11Resource* pTiledResource,
    UINT NumTiledResourceRegions,
    const D3D11_TILED_RESOURCE_COORDINATE* pTiledResourceRegionStartCoordinates,
    const D3D11_TILE_REGION_SIZE* pTiledResourceRegionSizes,
    ID3D11Buffer* pTilePool,
    UINT NumRanges,
    const UINT* pRangeFlags,
    const UINT* pTilePoolStartOffsets,
    const UINT* pRangeTileCounts,
    UINT Flags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_UpdateTileMappings>::Dispatch(
            manager,
            this,
            pTiledResource,
            NumTiledResourceRegions,
            pTiledResourceRegionStartCoordinates,
            pTiledResourceRegionSizes,
            pTilePool,
            NumRanges,
            pRangeFlags,
            pTilePoolStartOffsets,
            pRangeTileCounts,
            Flags);

        result = GetWrappedObjectAs<ID3D11DeviceContext2>()->UpdateTileMappings(
            encode::GetWrappedObject<ID3D11Resource>(pTiledResource),
            NumTiledResourceRegions,
            pTiledResourceRegionStartCoordinates,
            pTiledResourceRegionSizes,
            encode::GetWrappedObject<ID3D11Buffer>(pTilePool),
            NumRanges,
            pRangeFlags,
            pTilePoolStartOffsets,
            pRangeTileCounts,
            Flags);

        Encode_ID3D11DeviceContext2_UpdateTileMappings(
            this,
            result,
            pTiledResource,
            NumTiledResourceRegions,
            pTiledResourceRegionStartCoordinates,
            pTiledResourceRegionSizes,
            pTilePool,
            NumRanges,
            pRangeFlags,
            pTilePoolStartOffsets,
            pRangeTileCounts,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_UpdateTileMappings>::Dispatch(
            manager,
            this,
            result,
            pTiledResource,
            NumTiledResourceRegions,
            pTiledResourceRegionStartCoordinates,
            pTiledResourceRegionSizes,
            pTilePool,
            NumRanges,
            pRangeFlags,
            pTilePoolStartOffsets,
            pRangeTileCounts,
            Flags);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceContext2>()->UpdateTileMappings(
            pTiledResource,
            NumTiledResourceRegions,
            pTiledResourceRegionStartCoordinates,
            pTiledResourceRegionSizes,
            pTilePool,
            NumRanges,
            pRangeFlags,
            pTilePoolStartOffsets,
            pRangeTileCounts,
            Flags);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11DeviceContext2_Wrapper::CopyTileMappings(
    ID3D11Resource* pDestTiledResource,
    const D3D11_TILED_RESOURCE_COORDINATE* pDestRegionStartCoordinate,
    ID3D11Resource* pSourceTiledResource,
    const D3D11_TILED_RESOURCE_COORDINATE* pSourceRegionStartCoordinate,
    const D3D11_TILE_REGION_SIZE* pTileRegionSize,
    UINT Flags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_CopyTileMappings>::Dispatch(
            manager,
            this,
            pDestTiledResource,
            pDestRegionStartCoordinate,
            pSourceTiledResource,
            pSourceRegionStartCoordinate,
            pTileRegionSize,
            Flags);

        result = GetWrappedObjectAs<ID3D11DeviceContext2>()->CopyTileMappings(
            encode::GetWrappedObject<ID3D11Resource>(pDestTiledResource),
            pDestRegionStartCoordinate,
            encode::GetWrappedObject<ID3D11Resource>(pSourceTiledResource),
            pSourceRegionStartCoordinate,
            pTileRegionSize,
            Flags);

        Encode_ID3D11DeviceContext2_CopyTileMappings(
            this,
            result,
            pDestTiledResource,
            pDestRegionStartCoordinate,
            pSourceTiledResource,
            pSourceRegionStartCoordinate,
            pTileRegionSize,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_CopyTileMappings>::Dispatch(
            manager,
            this,
            result,
            pDestTiledResource,
            pDestRegionStartCoordinate,
            pSourceTiledResource,
            pSourceRegionStartCoordinate,
            pTileRegionSize,
            Flags);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceContext2>()->CopyTileMappings(
            pDestTiledResource,
            pDestRegionStartCoordinate,
            pSourceTiledResource,
            pSourceRegionStartCoordinate,
            pTileRegionSize,
            Flags);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11DeviceContext2_Wrapper::CopyTiles(
    ID3D11Resource* pTiledResource,
    const D3D11_TILED_RESOURCE_COORDINATE* pTileRegionStartCoordinate,
    const D3D11_TILE_REGION_SIZE* pTileRegionSize,
    ID3D11Buffer* pBuffer,
    UINT64 BufferStartOffsetInBytes,
    UINT Flags)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_CopyTiles>::Dispatch(
            manager,
            this,
            pTiledResource,
            pTileRegionStartCoordinate,
            pTileRegionSize,
            pBuffer,
            BufferStartOffsetInBytes,
            Flags);

        GetWrappedObjectAs<ID3D11DeviceContext2>()->CopyTiles(
            encode::GetWrappedObject<ID3D11Resource>(pTiledResource),
            pTileRegionStartCoordinate,
            pTileRegionSize,
            encode::GetWrappedObject<ID3D11Buffer>(pBuffer),
            BufferStartOffsetInBytes,
            Flags);

        Encode_ID3D11DeviceContext2_CopyTiles(
            this,
            pTiledResource,
            pTileRegionStartCoordinate,
            pTileRegionSize,
            pBuffer,
            BufferStartOffsetInBytes,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_CopyTiles>::Dispatch(
            manager,
            this,
            pTiledResource,
            pTileRegionStartCoordinate,
            pTileRegionSize,
            pBuffer,
            BufferStartOffsetInBytes,
            Flags);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext2>()->CopyTiles(
            pTiledResource,
            pTileRegionStartCoordinate,
            pTileRegionSize,
            pBuffer,
            BufferStartOffsetInBytes,
            Flags);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext2_Wrapper::UpdateTiles(
    ID3D11Resource* pDestTiledResource,
    const D3D11_TILED_RESOURCE_COORDINATE* pDestTileRegionStartCoordinate,
    const D3D11_TILE_REGION_SIZE* pDestTileRegionSize,
    const void* pSourceTileData,
    UINT Flags)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_UpdateTiles>::Dispatch(
            manager,
            this,
            pDestTiledResource,
            pDestTileRegionStartCoordinate,
            pDestTileRegionSize,
            pSourceTileData,
            Flags);

        GetWrappedObjectAs<ID3D11DeviceContext2>()->UpdateTiles(
            encode::GetWrappedObject<ID3D11Resource>(pDestTiledResource),
            pDestTileRegionStartCoordinate,
            pDestTileRegionSize,
            pSourceTileData,
            Flags);

        Encode_ID3D11DeviceContext2_UpdateTiles(
            this,
            pDestTiledResource,
            pDestTileRegionStartCoordinate,
            pDestTileRegionSize,
            pSourceTileData,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_UpdateTiles>::Dispatch(
            manager,
            this,
            pDestTiledResource,
            pDestTileRegionStartCoordinate,
            pDestTileRegionSize,
            pSourceTileData,
            Flags);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext2>()->UpdateTiles(
            pDestTiledResource,
            pDestTileRegionStartCoordinate,
            pDestTileRegionSize,
            pSourceTileData,
            Flags);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D11DeviceContext2_Wrapper::ResizeTilePool(
    ID3D11Buffer* pTilePool,
    UINT64 NewSizeInBytes)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_ResizeTilePool>::Dispatch(
            manager,
            this,
            pTilePool,
            NewSizeInBytes);

        result = GetWrappedObjectAs<ID3D11DeviceContext2>()->ResizeTilePool(
            encode::GetWrappedObject<ID3D11Buffer>(pTilePool),
            NewSizeInBytes);

        Encode_ID3D11DeviceContext2_ResizeTilePool(
            this,
            result,
            pTilePool,
            NewSizeInBytes);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_ResizeTilePool>::Dispatch(
            manager,
            this,
            result,
            pTilePool,
            NewSizeInBytes);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceContext2>()->ResizeTilePool(
            pTilePool,
            NewSizeInBytes);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11DeviceContext2_Wrapper::TiledResourceBarrier(
    ID3D11DeviceChild* pTiledResourceOrViewAccessBeforeBarrier,
    ID3D11DeviceChild* pTiledResourceOrViewAccessAfterBarrier)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_TiledResourceBarrier>::Dispatch(
            manager,
            this,
            pTiledResourceOrViewAccessBeforeBarrier,
            pTiledResourceOrViewAccessAfterBarrier);

        GetWrappedObjectAs<ID3D11DeviceContext2>()->TiledResourceBarrier(
            encode::GetWrappedObject<ID3D11DeviceChild>(pTiledResourceOrViewAccessBeforeBarrier),
            encode::GetWrappedObject<ID3D11DeviceChild>(pTiledResourceOrViewAccessAfterBarrier));

        Encode_ID3D11DeviceContext2_TiledResourceBarrier(
            this,
            pTiledResourceOrViewAccessBeforeBarrier,
            pTiledResourceOrViewAccessAfterBarrier);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_TiledResourceBarrier>::Dispatch(
            manager,
            this,
            pTiledResourceOrViewAccessBeforeBarrier,
            pTiledResourceOrViewAccessAfterBarrier);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext2>()->TiledResourceBarrier(
            pTiledResourceOrViewAccessBeforeBarrier,
            pTiledResourceOrViewAccessAfterBarrier);
    }

    manager->DecrementCallScope();
}

BOOL STDMETHODCALLTYPE ID3D11DeviceContext2_Wrapper::IsAnnotationEnabled()
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_IsAnnotationEnabled>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D11DeviceContext2>()->IsAnnotationEnabled();

        Encode_ID3D11DeviceContext2_IsAnnotationEnabled(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_IsAnnotationEnabled>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceContext2>()->IsAnnotationEnabled();
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11DeviceContext2_Wrapper::SetMarkerInt(
    LPCWSTR pLabel,
    INT Data)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_SetMarkerInt>::Dispatch(
            manager,
            this,
            pLabel,
            Data);

        GetWrappedObjectAs<ID3D11DeviceContext2>()->SetMarkerInt(
            pLabel,
            Data);

        Encode_ID3D11DeviceContext2_SetMarkerInt(
            this,
            pLabel,
            Data);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_SetMarkerInt>::Dispatch(
            manager,
            this,
            pLabel,
            Data);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext2>()->SetMarkerInt(
            pLabel,
            Data);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext2_Wrapper::BeginEventInt(
    LPCWSTR pLabel,
    INT Data)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_BeginEventInt>::Dispatch(
            manager,
            this,
            pLabel,
            Data);

        GetWrappedObjectAs<ID3D11DeviceContext2>()->BeginEventInt(
            pLabel,
            Data);

        Encode_ID3D11DeviceContext2_BeginEventInt(
            this,
            pLabel,
            Data);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_BeginEventInt>::Dispatch(
            manager,
            this,
            pLabel,
            Data);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext2>()->BeginEventInt(
            pLabel,
            Data);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext2_Wrapper::EndEvent()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_EndEvent>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D11DeviceContext2>()->EndEvent();

        Encode_ID3D11DeviceContext2_EndEvent(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext2_EndEvent>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext2>()->EndEvent();
    }

    manager->DecrementCallScope();
}

ID3D11Device2_Wrapper::ID3D11Device2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Device1_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11Device2_Wrapper::GetImmediateContext2(
    ID3D11DeviceContext2** ppImmediateContext)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device2_GetImmediateContext2>::Dispatch(
            manager,
            this,
            ppImmediateContext);

        GetWrappedObjectAs<ID3D11Device2>()->GetImmediateContext2(
            ppImmediateContext);

        WrapObject(IID_ID3D11DeviceContext2, reinterpret_cast<void**>(ppImmediateContext), nullptr);

        Encode_ID3D11Device2_GetImmediateContext2(
            this,
            ppImmediateContext);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device2_GetImmediateContext2>::Dispatch(
            manager,
            this,
            ppImmediateContext);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Device2>()->GetImmediateContext2(
            ppImmediateContext);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D11Device2_Wrapper::CreateDeferredContext2(
    UINT ContextFlags,
    ID3D11DeviceContext2** ppDeferredContext)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device2_CreateDeferredContext2>::Dispatch(
            manager,
            this,
            ContextFlags,
            ppDeferredContext);

        result = GetWrappedObjectAs<ID3D11Device2>()->CreateDeferredContext2(
            ContextFlags,
            ppDeferredContext);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11DeviceContext2, reinterpret_cast<void**>(ppDeferredContext), nullptr);
        }

        Encode_ID3D11Device2_CreateDeferredContext2(
            this,
            result,
            ContextFlags,
            ppDeferredContext);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device2_CreateDeferredContext2>::Dispatch(
            manager,
            this,
            result,
            ContextFlags,
            ppDeferredContext);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device2>()->CreateDeferredContext2(
            ContextFlags,
            ppDeferredContext);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11Device2_Wrapper::GetResourceTiling(
    ID3D11Resource* pTiledResource,
    UINT* pNumTilesForEntireResource,
    D3D11_PACKED_MIP_DESC* pPackedMipDesc,
    D3D11_TILE_SHAPE* pStandardTileShapeForNonPackedMips,
    UINT* pNumSubresourceTilings,
    UINT FirstSubresourceTilingToGet,
    D3D11_SUBRESOURCE_TILING* pSubresourceTilingsForNonPackedMips)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device2_GetResourceTiling>::Dispatch(
            manager,
            this,
            pTiledResource,
            pNumTilesForEntireResource,
            pPackedMipDesc,
            pStandardTileShapeForNonPackedMips,
            pNumSubresourceTilings,
            FirstSubresourceTilingToGet,
            pSubresourceTilingsForNonPackedMips);

        GetWrappedObjectAs<ID3D11Device2>()->GetResourceTiling(
            encode::GetWrappedObject<ID3D11Resource>(pTiledResource),
            pNumTilesForEntireResource,
            pPackedMipDesc,
            pStandardTileShapeForNonPackedMips,
            pNumSubresourceTilings,
            FirstSubresourceTilingToGet,
            pSubresourceTilingsForNonPackedMips);

        Encode_ID3D11Device2_GetResourceTiling(
            this,
            pTiledResource,
            pNumTilesForEntireResource,
            pPackedMipDesc,
            pStandardTileShapeForNonPackedMips,
            pNumSubresourceTilings,
            FirstSubresourceTilingToGet,
            pSubresourceTilingsForNonPackedMips);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device2_GetResourceTiling>::Dispatch(
            manager,
            this,
            pTiledResource,
            pNumTilesForEntireResource,
            pPackedMipDesc,
            pStandardTileShapeForNonPackedMips,
            pNumSubresourceTilings,
            FirstSubresourceTilingToGet,
            pSubresourceTilingsForNonPackedMips);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Device2>()->GetResourceTiling(
            pTiledResource,
            pNumTilesForEntireResource,
            pPackedMipDesc,
            pStandardTileShapeForNonPackedMips,
            pNumSubresourceTilings,
            FirstSubresourceTilingToGet,
            pSubresourceTilingsForNonPackedMips);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D11Device2_Wrapper::CheckMultisampleQualityLevels1(
    DXGI_FORMAT Format,
    UINT SampleCount,
    UINT Flags,
    UINT* pNumQualityLevels)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device2_CheckMultisampleQualityLevels1>::Dispatch(
            manager,
            this,
            Format,
            SampleCount,
            Flags,
            pNumQualityLevels);

        result = GetWrappedObjectAs<ID3D11Device2>()->CheckMultisampleQualityLevels1(
            Format,
            SampleCount,
            Flags,
            pNumQualityLevels);

        Encode_ID3D11Device2_CheckMultisampleQualityLevels1(
            this,
            result,
            Format,
            SampleCount,
            Flags,
            pNumQualityLevels);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device2_CheckMultisampleQualityLevels1>::Dispatch(
            manager,
            this,
            result,
            Format,
            SampleCount,
            Flags,
            pNumQualityLevels);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device2>()->CheckMultisampleQualityLevels1(
            Format,
            SampleCount,
            Flags,
            pNumQualityLevels);
    }

    manager->DecrementCallScope();

    return result;
}


/*
** This part is generated from d3d11_3.h in Windows SDK: 10.0.20348.0
**
*/

ID3D11Texture2D1_Wrapper::ID3D11Texture2D1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Texture2D_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11Texture2D1_Wrapper::GetDesc1(
    D3D11_TEXTURE2D_DESC1* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Texture2D1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11Texture2D1>()->GetDesc1(
            pDesc);

        Encode_ID3D11Texture2D1_GetDesc1(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Texture2D1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Texture2D1>()->GetDesc1(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11Texture3D1_Wrapper::ID3D11Texture3D1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Texture3D_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11Texture3D1_Wrapper::GetDesc1(
    D3D11_TEXTURE3D_DESC1* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Texture3D1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11Texture3D1>()->GetDesc1(
            pDesc);

        Encode_ID3D11Texture3D1_GetDesc1(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Texture3D1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Texture3D1>()->GetDesc1(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11RasterizerState2_Wrapper::ID3D11RasterizerState2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11RasterizerState1_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11RasterizerState2_Wrapper::GetDesc2(
    D3D11_RASTERIZER_DESC2* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11RasterizerState2_GetDesc2>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<ID3D11RasterizerState2>()->GetDesc2(
            pDesc);

        Encode_ID3D11RasterizerState2_GetDesc2(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11RasterizerState2_GetDesc2>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<ID3D11RasterizerState2>()->GetDesc2(
            pDesc);
    }

    manager->DecrementCallScope();
}

ID3D11ShaderResourceView1_Wrapper::ID3D11ShaderResourceView1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11ShaderResourceView_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11ShaderResourceView1_Wrapper::GetDesc1(
    D3D11_SHADER_RESOURCE_VIEW_DESC1* pDesc1)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11ShaderResourceView1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc1);

        GetWrappedObjectAs<ID3D11ShaderResourceView1>()->GetDesc1(
            pDesc1);

        Encode_ID3D11ShaderResourceView1_GetDesc1(
            this,
            pDesc1);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11ShaderResourceView1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc1);
    }
    else
    {
        GetWrappedObjectAs<ID3D11ShaderResourceView1>()->GetDesc1(
            pDesc1);
    }

    manager->DecrementCallScope();
}

ID3D11RenderTargetView1_Wrapper::ID3D11RenderTargetView1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11RenderTargetView_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11RenderTargetView1_Wrapper::GetDesc1(
    D3D11_RENDER_TARGET_VIEW_DESC1* pDesc1)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11RenderTargetView1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc1);

        GetWrappedObjectAs<ID3D11RenderTargetView1>()->GetDesc1(
            pDesc1);

        Encode_ID3D11RenderTargetView1_GetDesc1(
            this,
            pDesc1);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11RenderTargetView1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc1);
    }
    else
    {
        GetWrappedObjectAs<ID3D11RenderTargetView1>()->GetDesc1(
            pDesc1);
    }

    manager->DecrementCallScope();
}

ID3D11UnorderedAccessView1_Wrapper::ID3D11UnorderedAccessView1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11UnorderedAccessView_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11UnorderedAccessView1_Wrapper::GetDesc1(
    D3D11_UNORDERED_ACCESS_VIEW_DESC1* pDesc1)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11UnorderedAccessView1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc1);

        GetWrappedObjectAs<ID3D11UnorderedAccessView1>()->GetDesc1(
            pDesc1);

        Encode_ID3D11UnorderedAccessView1_GetDesc1(
            this,
            pDesc1);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11UnorderedAccessView1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc1);
    }
    else
    {
        GetWrappedObjectAs<ID3D11UnorderedAccessView1>()->GetDesc1(
            pDesc1);
    }

    manager->DecrementCallScope();
}

ID3D11Query1_Wrapper::ID3D11Query1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Query_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11Query1_Wrapper::GetDesc1(
    D3D11_QUERY_DESC1* pDesc1)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Query1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc1);

        GetWrappedObjectAs<ID3D11Query1>()->GetDesc1(
            pDesc1);

        Encode_ID3D11Query1_GetDesc1(
            this,
            pDesc1);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Query1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc1);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Query1>()->GetDesc1(
            pDesc1);
    }

    manager->DecrementCallScope();
}

ID3D11DeviceContext3_Wrapper::ID3D11DeviceContext3_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceContext2_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11DeviceContext3_Wrapper::Flush1(
    D3D11_CONTEXT_TYPE ContextType,
    HANDLE hEvent)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext3_Flush1>::Dispatch(
            manager,
            this,
            ContextType,
            hEvent);

        GetWrappedObjectAs<ID3D11DeviceContext3>()->Flush1(
            ContextType,
            hEvent);

        Encode_ID3D11DeviceContext3_Flush1(
            this,
            ContextType,
            hEvent);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext3_Flush1>::Dispatch(
            manager,
            this,
            ContextType,
            hEvent);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext3>()->Flush1(
            ContextType,
            hEvent);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext3_Wrapper::SetHardwareProtectionState(
    BOOL HwProtectionEnable)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext3_SetHardwareProtectionState>::Dispatch(
            manager,
            this,
            HwProtectionEnable);

        GetWrappedObjectAs<ID3D11DeviceContext3>()->SetHardwareProtectionState(
            HwProtectionEnable);

        Encode_ID3D11DeviceContext3_SetHardwareProtectionState(
            this,
            HwProtectionEnable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext3_SetHardwareProtectionState>::Dispatch(
            manager,
            this,
            HwProtectionEnable);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext3>()->SetHardwareProtectionState(
            HwProtectionEnable);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11DeviceContext3_Wrapper::GetHardwareProtectionState(
    BOOL* pHwProtectionEnable)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext3_GetHardwareProtectionState>::Dispatch(
            manager,
            this,
            pHwProtectionEnable);

        GetWrappedObjectAs<ID3D11DeviceContext3>()->GetHardwareProtectionState(
            pHwProtectionEnable);

        Encode_ID3D11DeviceContext3_GetHardwareProtectionState(
            this,
            pHwProtectionEnable);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext3_GetHardwareProtectionState>::Dispatch(
            manager,
            this,
            pHwProtectionEnable);
    }
    else
    {
        GetWrappedObjectAs<ID3D11DeviceContext3>()->GetHardwareProtectionState(
            pHwProtectionEnable);
    }

    manager->DecrementCallScope();
}

ID3D11Fence_Wrapper::ID3D11Fence_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceChild_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11FenceInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11Fence_Wrapper::~ID3D11Fence_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11Fence>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11Fence_Wrapper* ID3D11Fence_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11Fence_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D11Fence_Wrapper::CreateSharedHandle(
    const SECURITY_ATTRIBUTES* pAttributes,
    DWORD dwAccess,
    LPCWSTR lpName,
    HANDLE* pHandle)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Fence_CreateSharedHandle>::Dispatch(
            manager,
            this,
            pAttributes,
            dwAccess,
            lpName,
            pHandle);

        result = GetWrappedObjectAs<ID3D11Fence>()->CreateSharedHandle(
            pAttributes,
            dwAccess,
            lpName,
            pHandle);

        Encode_ID3D11Fence_CreateSharedHandle(
            this,
            result,
            pAttributes,
            dwAccess,
            lpName,
            pHandle);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Fence_CreateSharedHandle>::Dispatch(
            manager,
            this,
            result,
            pAttributes,
            dwAccess,
            lpName,
            pHandle);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Fence>()->CreateSharedHandle(
            pAttributes,
            dwAccess,
            lpName,
            pHandle);
    }

    manager->DecrementCallScope();

    return result;
}

UINT64 STDMETHODCALLTYPE ID3D11Fence_Wrapper::GetCompletedValue()
{
    UINT64 result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Fence_GetCompletedValue>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D11Fence>()->GetCompletedValue();

        Encode_ID3D11Fence_GetCompletedValue(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Fence_GetCompletedValue>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Fence>()->GetCompletedValue();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Fence_Wrapper::SetEventOnCompletion(
    UINT64 Value,
    HANDLE hEvent)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Fence_SetEventOnCompletion>::Dispatch(
            manager,
            this,
            Value,
            hEvent);

        result = GetWrappedObjectAs<ID3D11Fence>()->SetEventOnCompletion(
            Value,
            hEvent);

        Encode_ID3D11Fence_SetEventOnCompletion(
            this,
            result,
            Value,
            hEvent);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Fence_SetEventOnCompletion>::Dispatch(
            manager,
            this,
            result,
            Value,
            hEvent);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Fence>()->SetEventOnCompletion(
            Value,
            hEvent);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11DeviceContext4_Wrapper::ID3D11DeviceContext4_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11DeviceContext3_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D11DeviceContext4_Wrapper::Signal(
    ID3D11Fence* pFence,
    UINT64 Value)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext4_Signal>::Dispatch(
            manager,
            this,
            pFence,
            Value);

        result = GetWrappedObjectAs<ID3D11DeviceContext4>()->Signal(
            encode::GetWrappedObject<ID3D11Fence>(pFence),
            Value);

        Encode_ID3D11DeviceContext4_Signal(
            this,
            result,
            pFence,
            Value);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext4_Signal>::Dispatch(
            manager,
            this,
            result,
            pFence,
            Value);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceContext4>()->Signal(
            pFence,
            Value);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11DeviceContext4_Wrapper::Wait(
    ID3D11Fence* pFence,
    UINT64 Value)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11DeviceContext4_Wait>::Dispatch(
            manager,
            this,
            pFence,
            Value);

        result = GetWrappedObjectAs<ID3D11DeviceContext4>()->Wait(
            encode::GetWrappedObject<ID3D11Fence>(pFence),
            Value);

        Encode_ID3D11DeviceContext4_Wait(
            this,
            result,
            pFence,
            Value);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11DeviceContext4_Wait>::Dispatch(
            manager,
            this,
            result,
            pFence,
            Value);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11DeviceContext4>()->Wait(
            pFence,
            Value);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11Device3_Wrapper::ID3D11Device3_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Device2_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D11Device3_Wrapper::CreateTexture2D1(
    const D3D11_TEXTURE2D_DESC1* pDesc1,
    const D3D11_SUBRESOURCE_DATA* pInitialData,
    ID3D11Texture2D1** ppTexture2D)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateTexture2D1>::Dispatch(
            manager,
            this,
            pDesc1,
            pInitialData,
            ppTexture2D);

        result = GetWrappedObjectAs<ID3D11Device3>()->CreateTexture2D1(
            pDesc1,
            pInitialData,
            ppTexture2D);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11Texture2D1, reinterpret_cast<void**>(ppTexture2D), nullptr);
        }

        Encode_ID3D11Device3_CreateTexture2D1(
            this,
            result,
            pDesc1,
            pInitialData,
            ppTexture2D);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateTexture2D1>::Dispatch(
            manager,
            this,
            result,
            pDesc1,
            pInitialData,
            ppTexture2D);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device3>()->CreateTexture2D1(
            pDesc1,
            pInitialData,
            ppTexture2D);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device3_Wrapper::CreateTexture3D1(
    const D3D11_TEXTURE3D_DESC1* pDesc1,
    const D3D11_SUBRESOURCE_DATA* pInitialData,
    ID3D11Texture3D1** ppTexture3D)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateTexture3D1>::Dispatch(
            manager,
            this,
            pDesc1,
            pInitialData,
            ppTexture3D);

        result = GetWrappedObjectAs<ID3D11Device3>()->CreateTexture3D1(
            pDesc1,
            pInitialData,
            ppTexture3D);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11Texture3D1, reinterpret_cast<void**>(ppTexture3D), nullptr);
        }

        Encode_ID3D11Device3_CreateTexture3D1(
            this,
            result,
            pDesc1,
            pInitialData,
            ppTexture3D);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateTexture3D1>::Dispatch(
            manager,
            this,
            result,
            pDesc1,
            pInitialData,
            ppTexture3D);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device3>()->CreateTexture3D1(
            pDesc1,
            pInitialData,
            ppTexture3D);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device3_Wrapper::CreateRasterizerState2(
    const D3D11_RASTERIZER_DESC2* pRasterizerDesc,
    ID3D11RasterizerState2** ppRasterizerState)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateRasterizerState2>::Dispatch(
            manager,
            this,
            pRasterizerDesc,
            ppRasterizerState);

        result = GetWrappedObjectAs<ID3D11Device3>()->CreateRasterizerState2(
            pRasterizerDesc,
            ppRasterizerState);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11RasterizerState2, reinterpret_cast<void**>(ppRasterizerState), nullptr);
        }

        Encode_ID3D11Device3_CreateRasterizerState2(
            this,
            result,
            pRasterizerDesc,
            ppRasterizerState);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateRasterizerState2>::Dispatch(
            manager,
            this,
            result,
            pRasterizerDesc,
            ppRasterizerState);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device3>()->CreateRasterizerState2(
            pRasterizerDesc,
            ppRasterizerState);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device3_Wrapper::CreateShaderResourceView1(
    ID3D11Resource* pResource,
    const D3D11_SHADER_RESOURCE_VIEW_DESC1* pDesc1,
    ID3D11ShaderResourceView1** ppSRView1)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateShaderResourceView1>::Dispatch(
            manager,
            this,
            pResource,
            pDesc1,
            ppSRView1);

        result = GetWrappedObjectAs<ID3D11Device3>()->CreateShaderResourceView1(
            encode::GetWrappedObject<ID3D11Resource>(pResource),
            pDesc1,
            ppSRView1);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11ShaderResourceView1, reinterpret_cast<void**>(ppSRView1), nullptr);
        }

        Encode_ID3D11Device3_CreateShaderResourceView1(
            this,
            result,
            pResource,
            pDesc1,
            ppSRView1);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateShaderResourceView1>::Dispatch(
            manager,
            this,
            result,
            pResource,
            pDesc1,
            ppSRView1);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device3>()->CreateShaderResourceView1(
            pResource,
            pDesc1,
            ppSRView1);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device3_Wrapper::CreateUnorderedAccessView1(
    ID3D11Resource* pResource,
    const D3D11_UNORDERED_ACCESS_VIEW_DESC1* pDesc1,
    ID3D11UnorderedAccessView1** ppUAView1)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateUnorderedAccessView1>::Dispatch(
            manager,
            this,
            pResource,
            pDesc1,
            ppUAView1);

        result = GetWrappedObjectAs<ID3D11Device3>()->CreateUnorderedAccessView1(
            encode::GetWrappedObject<ID3D11Resource>(pResource),
            pDesc1,
            ppUAView1);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11UnorderedAccessView1, reinterpret_cast<void**>(ppUAView1), nullptr);
        }

        Encode_ID3D11Device3_CreateUnorderedAccessView1(
            this,
            result,
            pResource,
            pDesc1,
            ppUAView1);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateUnorderedAccessView1>::Dispatch(
            manager,
            this,
            result,
            pResource,
            pDesc1,
            ppUAView1);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device3>()->CreateUnorderedAccessView1(
            pResource,
            pDesc1,
            ppUAView1);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device3_Wrapper::CreateRenderTargetView1(
    ID3D11Resource* pResource,
    const D3D11_RENDER_TARGET_VIEW_DESC1* pDesc1,
    ID3D11RenderTargetView1** ppRTView1)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateRenderTargetView1>::Dispatch(
            manager,
            this,
            pResource,
            pDesc1,
            ppRTView1);

        result = GetWrappedObjectAs<ID3D11Device3>()->CreateRenderTargetView1(
            encode::GetWrappedObject<ID3D11Resource>(pResource),
            pDesc1,
            ppRTView1);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11RenderTargetView1, reinterpret_cast<void**>(ppRTView1), nullptr);
        }

        Encode_ID3D11Device3_CreateRenderTargetView1(
            this,
            result,
            pResource,
            pDesc1,
            ppRTView1);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateRenderTargetView1>::Dispatch(
            manager,
            this,
            result,
            pResource,
            pDesc1,
            ppRTView1);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device3>()->CreateRenderTargetView1(
            pResource,
            pDesc1,
            ppRTView1);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device3_Wrapper::CreateQuery1(
    const D3D11_QUERY_DESC1* pQueryDesc1,
    ID3D11Query1** ppQuery1)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateQuery1>::Dispatch(
            manager,
            this,
            pQueryDesc1,
            ppQuery1);

        result = GetWrappedObjectAs<ID3D11Device3>()->CreateQuery1(
            pQueryDesc1,
            ppQuery1);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11Query1, reinterpret_cast<void**>(ppQuery1), nullptr);
        }

        Encode_ID3D11Device3_CreateQuery1(
            this,
            result,
            pQueryDesc1,
            ppQuery1);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateQuery1>::Dispatch(
            manager,
            this,
            result,
            pQueryDesc1,
            ppQuery1);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device3>()->CreateQuery1(
            pQueryDesc1,
            ppQuery1);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11Device3_Wrapper::GetImmediateContext3(
    ID3D11DeviceContext3** ppImmediateContext)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device3_GetImmediateContext3>::Dispatch(
            manager,
            this,
            ppImmediateContext);

        GetWrappedObjectAs<ID3D11Device3>()->GetImmediateContext3(
            ppImmediateContext);

        WrapObject(IID_ID3D11DeviceContext3, reinterpret_cast<void**>(ppImmediateContext), nullptr);

        Encode_ID3D11Device3_GetImmediateContext3(
            this,
            ppImmediateContext);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device3_GetImmediateContext3>::Dispatch(
            manager,
            this,
            ppImmediateContext);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Device3>()->GetImmediateContext3(
            ppImmediateContext);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE ID3D11Device3_Wrapper::CreateDeferredContext3(
    UINT ContextFlags,
    ID3D11DeviceContext3** ppDeferredContext)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateDeferredContext3>::Dispatch(
            manager,
            this,
            ContextFlags,
            ppDeferredContext);

        result = GetWrappedObjectAs<ID3D11Device3>()->CreateDeferredContext3(
            ContextFlags,
            ppDeferredContext);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11DeviceContext3, reinterpret_cast<void**>(ppDeferredContext), nullptr);
        }

        Encode_ID3D11Device3_CreateDeferredContext3(
            this,
            result,
            ContextFlags,
            ppDeferredContext);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device3_CreateDeferredContext3>::Dispatch(
            manager,
            this,
            result,
            ContextFlags,
            ppDeferredContext);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device3>()->CreateDeferredContext3(
            ContextFlags,
            ppDeferredContext);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11Device3_Wrapper::WriteToSubresource(
    ID3D11Resource* pDstResource,
    UINT DstSubresource,
    const D3D11_BOX* pDstBox,
    const void* pSrcData,
    UINT SrcRowPitch,
    UINT SrcDepthPitch)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device3_WriteToSubresource>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);

        GetWrappedObjectAs<ID3D11Device3>()->WriteToSubresource(
            encode::GetWrappedObject<ID3D11Resource>(pDstResource),
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);

        Encode_ID3D11Device3_WriteToSubresource(
            this,
            pDstResource,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device3_WriteToSubresource>::Dispatch(
            manager,
            this,
            pDstResource,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Device3>()->WriteToSubresource(
            pDstResource,
            DstSubresource,
            pDstBox,
            pSrcData,
            SrcRowPitch,
            SrcDepthPitch);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11Device3_Wrapper::ReadFromSubresource(
    void* pDstData,
    UINT DstRowPitch,
    UINT DstDepthPitch,
    ID3D11Resource* pSrcResource,
    UINT SrcSubresource,
    const D3D11_BOX* pSrcBox)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device3_ReadFromSubresource>::Dispatch(
            manager,
            this,
            pDstData,
            DstRowPitch,
            DstDepthPitch,
            pSrcResource,
            SrcSubresource,
            pSrcBox);

        GetWrappedObjectAs<ID3D11Device3>()->ReadFromSubresource(
            pDstData,
            DstRowPitch,
            DstDepthPitch,
            encode::GetWrappedObject<ID3D11Resource>(pSrcResource),
            SrcSubresource,
            pSrcBox);

        Encode_ID3D11Device3_ReadFromSubresource(
            this,
            pDstData,
            DstRowPitch,
            DstDepthPitch,
            pSrcResource,
            SrcSubresource,
            pSrcBox);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device3_ReadFromSubresource>::Dispatch(
            manager,
            this,
            pDstData,
            DstRowPitch,
            DstDepthPitch,
            pSrcResource,
            SrcSubresource,
            pSrcBox);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Device3>()->ReadFromSubresource(
            pDstData,
            DstRowPitch,
            DstDepthPitch,
            pSrcResource,
            SrcSubresource,
            pSrcBox);
    }

    manager->DecrementCallScope();
}


/*
** This part is generated from d3d11_4.h in Windows SDK: 10.0.20348.0
**
*/

ID3D11Device4_Wrapper::ID3D11Device4_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Device3_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D11Device4_Wrapper::RegisterDeviceRemovedEvent(
    HANDLE hEvent,
    DWORD* pdwCookie)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device4_RegisterDeviceRemovedEvent>::Dispatch(
            manager,
            this,
            hEvent,
            pdwCookie);

        result = GetWrappedObjectAs<ID3D11Device4>()->RegisterDeviceRemovedEvent(
            hEvent,
            pdwCookie);

        Encode_ID3D11Device4_RegisterDeviceRemovedEvent(
            this,
            result,
            hEvent,
            pdwCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device4_RegisterDeviceRemovedEvent>::Dispatch(
            manager,
            this,
            result,
            hEvent,
            pdwCookie);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device4>()->RegisterDeviceRemovedEvent(
            hEvent,
            pdwCookie);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11Device4_Wrapper::UnregisterDeviceRemoved(
    DWORD dwCookie)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device4_UnregisterDeviceRemoved>::Dispatch(
            manager,
            this,
            dwCookie);

        GetWrappedObjectAs<ID3D11Device4>()->UnregisterDeviceRemoved(
            dwCookie);

        Encode_ID3D11Device4_UnregisterDeviceRemoved(
            this,
            dwCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device4_UnregisterDeviceRemoved>::Dispatch(
            manager,
            this,
            dwCookie);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Device4>()->UnregisterDeviceRemoved(
            dwCookie);
    }

    manager->DecrementCallScope();
}

ID3D11Device5_Wrapper::ID3D11Device5_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11Device4_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D11Device5_Wrapper::OpenSharedFence(
    HANDLE hFence,
    REFIID ReturnedInterface,
    void** ppFence)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device5_OpenSharedFence>::Dispatch(
            manager,
            this,
            hFence,
            ReturnedInterface,
            ppFence);

        result = GetWrappedObjectAs<ID3D11Device5>()->OpenSharedFence(
            hFence,
            ReturnedInterface,
            ppFence);

        if (SUCCEEDED(result))
        {
            WrapObject(ReturnedInterface, ppFence, nullptr);
        }

        Encode_ID3D11Device5_OpenSharedFence(
            this,
            result,
            hFence,
            ReturnedInterface,
            ppFence);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device5_OpenSharedFence>::Dispatch(
            manager,
            this,
            result,
            hFence,
            ReturnedInterface,
            ppFence);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device5>()->OpenSharedFence(
            hFence,
            ReturnedInterface,
            ppFence);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11Device5_Wrapper::CreateFence(
    UINT64 InitialValue,
    D3D11_FENCE_FLAG Flags,
    REFIID ReturnedInterface,
    void** ppFence)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Device5_CreateFence>::Dispatch(
            manager,
            this,
            InitialValue,
            Flags,
            ReturnedInterface,
            ppFence);

        result = GetWrappedObjectAs<ID3D11Device5>()->CreateFence(
            InitialValue,
            Flags,
            ReturnedInterface,
            ppFence);

        if (SUCCEEDED(result))
        {
            WrapObject(ReturnedInterface, ppFence, nullptr);
        }

        Encode_ID3D11Device5_CreateFence(
            this,
            result,
            InitialValue,
            Flags,
            ReturnedInterface,
            ppFence);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Device5_CreateFence>::Dispatch(
            manager,
            this,
            result,
            InitialValue,
            Flags,
            ReturnedInterface,
            ppFence);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Device5>()->CreateFence(
            InitialValue,
            Flags,
            ReturnedInterface,
            ppFence);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11Multithread_Wrapper::ID3D11Multithread_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11MultithreadInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11Multithread_Wrapper::~ID3D11Multithread_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11Multithread>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11Multithread_Wrapper* ID3D11Multithread_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11Multithread_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE ID3D11Multithread_Wrapper::Enter()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Multithread_Enter>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D11Multithread>()->Enter();

        Encode_ID3D11Multithread_Enter(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Multithread_Enter>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Multithread>()->Enter();
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11Multithread_Wrapper::Leave()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Multithread_Leave>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<ID3D11Multithread>()->Leave();

        Encode_ID3D11Multithread_Leave(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Multithread_Leave>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<ID3D11Multithread>()->Leave();
    }

    manager->DecrementCallScope();
}

BOOL STDMETHODCALLTYPE ID3D11Multithread_Wrapper::SetMultithreadProtected(
    BOOL bMTProtect)
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Multithread_SetMultithreadProtected>::Dispatch(
            manager,
            this,
            bMTProtect);

        result = GetWrappedObjectAs<ID3D11Multithread>()->SetMultithreadProtected(
            bMTProtect);

        Encode_ID3D11Multithread_SetMultithreadProtected(
            this,
            result,
            bMTProtect);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Multithread_SetMultithreadProtected>::Dispatch(
            manager,
            this,
            result,
            bMTProtect);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Multithread>()->SetMultithreadProtected(
            bMTProtect);
    }

    manager->DecrementCallScope();

    return result;
}

BOOL STDMETHODCALLTYPE ID3D11Multithread_Wrapper::GetMultithreadProtected()
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11Multithread_GetMultithreadProtected>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<ID3D11Multithread>()->GetMultithreadProtected();

        Encode_ID3D11Multithread_GetMultithreadProtected(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11Multithread_GetMultithreadProtected>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11Multithread>()->GetMultithreadProtected();
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11VideoContext2_Wrapper::ID3D11VideoContext2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11VideoContext1_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE ID3D11VideoContext2_Wrapper::VideoProcessorSetOutputHDRMetaData(
    ID3D11VideoProcessor* pVideoProcessor,
    DXGI_HDR_METADATA_TYPE Type,
    UINT Size,
    const void* pHDRMetaData)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext2_VideoProcessorSetOutputHDRMetaData>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            Type,
            Size,
            pHDRMetaData);

        GetWrappedObjectAs<ID3D11VideoContext2>()->VideoProcessorSetOutputHDRMetaData(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            Type,
            Size,
            pHDRMetaData);

        Encode_ID3D11VideoContext2_VideoProcessorSetOutputHDRMetaData(
            this,
            pVideoProcessor,
            Type,
            Size,
            pHDRMetaData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext2_VideoProcessorSetOutputHDRMetaData>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            Type,
            Size,
            pHDRMetaData);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext2>()->VideoProcessorSetOutputHDRMetaData(
            pVideoProcessor,
            Type,
            Size,
            pHDRMetaData);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext2_Wrapper::VideoProcessorGetOutputHDRMetaData(
    ID3D11VideoProcessor* pVideoProcessor,
    DXGI_HDR_METADATA_TYPE* pType,
    UINT Size,
    void* pMetaData)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext2_VideoProcessorGetOutputHDRMetaData>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pType,
            Size,
            pMetaData);

        GetWrappedObjectAs<ID3D11VideoContext2>()->VideoProcessorGetOutputHDRMetaData(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            pType,
            Size,
            pMetaData);

        Encode_ID3D11VideoContext2_VideoProcessorGetOutputHDRMetaData(
            this,
            pVideoProcessor,
            pType,
            Size,
            pMetaData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext2_VideoProcessorGetOutputHDRMetaData>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            pType,
            Size,
            pMetaData);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext2>()->VideoProcessorGetOutputHDRMetaData(
            pVideoProcessor,
            pType,
            Size,
            pMetaData);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext2_Wrapper::VideoProcessorSetStreamHDRMetaData(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    DXGI_HDR_METADATA_TYPE Type,
    UINT Size,
    const void* pHDRMetaData)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext2_VideoProcessorSetStreamHDRMetaData>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Type,
            Size,
            pHDRMetaData);

        GetWrappedObjectAs<ID3D11VideoContext2>()->VideoProcessorSetStreamHDRMetaData(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            Type,
            Size,
            pHDRMetaData);

        Encode_ID3D11VideoContext2_VideoProcessorSetStreamHDRMetaData(
            this,
            pVideoProcessor,
            StreamIndex,
            Type,
            Size,
            pHDRMetaData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext2_VideoProcessorSetStreamHDRMetaData>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            Type,
            Size,
            pHDRMetaData);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext2>()->VideoProcessorSetStreamHDRMetaData(
            pVideoProcessor,
            StreamIndex,
            Type,
            Size,
            pHDRMetaData);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11VideoContext2_Wrapper::VideoProcessorGetStreamHDRMetaData(
    ID3D11VideoProcessor* pVideoProcessor,
    UINT StreamIndex,
    DXGI_HDR_METADATA_TYPE* pType,
    UINT Size,
    void* pMetaData)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext2_VideoProcessorGetStreamHDRMetaData>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pType,
            Size,
            pMetaData);

        GetWrappedObjectAs<ID3D11VideoContext2>()->VideoProcessorGetStreamHDRMetaData(
            encode::GetWrappedObject<ID3D11VideoProcessor>(pVideoProcessor),
            StreamIndex,
            pType,
            Size,
            pMetaData);

        Encode_ID3D11VideoContext2_VideoProcessorGetStreamHDRMetaData(
            this,
            pVideoProcessor,
            StreamIndex,
            pType,
            Size,
            pMetaData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext2_VideoProcessorGetStreamHDRMetaData>::Dispatch(
            manager,
            this,
            pVideoProcessor,
            StreamIndex,
            pType,
            Size,
            pMetaData);
    }
    else
    {
        GetWrappedObjectAs<ID3D11VideoContext2>()->VideoProcessorGetStreamHDRMetaData(
            pVideoProcessor,
            StreamIndex,
            pType,
            Size,
            pMetaData);
    }

    manager->DecrementCallScope();
}

ID3D11VideoDevice2_Wrapper::ID3D11VideoDevice2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11VideoDevice1_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice2_Wrapper::CheckFeatureSupport(
    D3D11_FEATURE_VIDEO Feature,
    void* pFeatureSupportData,
    UINT FeatureSupportDataSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice2_CheckFeatureSupport>::Dispatch(
            manager,
            this,
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);

        result = GetWrappedObjectAs<ID3D11VideoDevice2>()->CheckFeatureSupport(
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);

        Encode_ID3D11VideoDevice2_CheckFeatureSupport(
            this,
            result,
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice2_CheckFeatureSupport>::Dispatch(
            manager,
            this,
            result,
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice2>()->CheckFeatureSupport(
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoDevice2_Wrapper::NegotiateCryptoSessionKeyExchangeMT(
    ID3D11CryptoSession* pCryptoSession,
    D3D11_CRYPTO_SESSION_KEY_EXCHANGE_FLAGS flags,
    UINT DataSize,
    void* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoDevice2_NegotiateCryptoSessionKeyExchangeMT>::Dispatch(
            manager,
            this,
            pCryptoSession,
            flags,
            DataSize,
            pData);

        result = GetWrappedObjectAs<ID3D11VideoDevice2>()->NegotiateCryptoSessionKeyExchangeMT(
            encode::GetWrappedObject<ID3D11CryptoSession>(pCryptoSession),
            flags,
            DataSize,
            pData);

        Encode_ID3D11VideoDevice2_NegotiateCryptoSessionKeyExchangeMT(
            this,
            result,
            pCryptoSession,
            flags,
            DataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoDevice2_NegotiateCryptoSessionKeyExchangeMT>::Dispatch(
            manager,
            this,
            result,
            pCryptoSession,
            flags,
            DataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoDevice2>()->NegotiateCryptoSessionKeyExchangeMT(
            pCryptoSession,
            flags,
            DataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11VideoContext3_Wrapper::ID3D11VideoContext3_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11VideoContext2_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext3_Wrapper::DecoderBeginFrame1(
    ID3D11VideoDecoder* pDecoder,
    ID3D11VideoDecoderOutputView* pView,
    UINT ContentKeySize,
    const void* pContentKey,
    UINT NumComponentHistograms,
    const UINT* pHistogramOffsets,
    ID3D11Buffer* const* ppHistogramBuffers)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext3_DecoderBeginFrame1>::Dispatch(
            manager,
            this,
            pDecoder,
            pView,
            ContentKeySize,
            pContentKey,
            NumComponentHistograms,
            pHistogramOffsets,
            ppHistogramBuffers);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<ID3D11VideoContext3>()->DecoderBeginFrame1(
            encode::GetWrappedObject<ID3D11VideoDecoder>(pDecoder),
            encode::GetWrappedObject<ID3D11VideoDecoderOutputView>(pView),
            ContentKeySize,
            pContentKey,
            NumComponentHistograms,
            pHistogramOffsets,
            UnwrapObjects<ID3D11Buffer>(ppHistogramBuffers, NumComponentHistograms, unwrap_memory));

        Encode_ID3D11VideoContext3_DecoderBeginFrame1(
            this,
            result,
            pDecoder,
            pView,
            ContentKeySize,
            pContentKey,
            NumComponentHistograms,
            pHistogramOffsets,
            ppHistogramBuffers);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext3_DecoderBeginFrame1>::Dispatch(
            manager,
            this,
            result,
            pDecoder,
            pView,
            ContentKeySize,
            pContentKey,
            NumComponentHistograms,
            pHistogramOffsets,
            ppHistogramBuffers);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext3>()->DecoderBeginFrame1(
            pDecoder,
            pView,
            ContentKeySize,
            pContentKey,
            NumComponentHistograms,
            pHistogramOffsets,
            ppHistogramBuffers);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11VideoContext3_Wrapper::SubmitDecoderBuffers2(
    ID3D11VideoDecoder* pDecoder,
    UINT NumBuffers,
    const D3D11_VIDEO_DECODER_BUFFER_DESC2* pBufferDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11VideoContext3_SubmitDecoderBuffers2>::Dispatch(
            manager,
            this,
            pDecoder,
            NumBuffers,
            pBufferDesc);

        result = GetWrappedObjectAs<ID3D11VideoContext3>()->SubmitDecoderBuffers2(
            encode::GetWrappedObject<ID3D11VideoDecoder>(pDecoder),
            NumBuffers,
            pBufferDesc);

        Encode_ID3D11VideoContext3_SubmitDecoderBuffers2(
            this,
            result,
            pDecoder,
            NumBuffers,
            pBufferDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11VideoContext3_SubmitDecoderBuffers2>::Dispatch(
            manager,
            this,
            result,
            pDecoder,
            NumBuffers,
            pBufferDesc);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11VideoContext3>()->SubmitDecoderBuffers2(
            pDecoder,
            NumBuffers,
            pBufferDesc);
    }

    manager->DecrementCallScope();

    return result;
}


/*
** This part is generated from d3d11on12.h in Windows SDK: 10.0.20348.0
**
*/

HRESULT WINAPI D3D11On12CreateDevice(
    IUnknown* pDevice,
    UINT Flags,
    const D3D_FEATURE_LEVEL* pFeatureLevels,
    UINT FeatureLevels,
    IUnknown* const* ppCommandQueues,
    UINT NumQueues,
    UINT NodeMask,
    ID3D11Device** ppDevice,
    ID3D11DeviceContext** ppImmediateContext,
    D3D_FEATURE_LEVEL* pChosenFeatureLevel)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_D3D11On12CreateDevice>::Dispatch(
            manager,
            pDevice,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            ppCommandQueues,
            NumQueues,
            NodeMask,
            ppDevice,
            ppImmediateContext,
            pChosenFeatureLevel);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = manager->GetD3D11DispatchTable().D3D11On12CreateDevice(
            encode::GetWrappedObject<IUnknown>(pDevice),
            Flags,
            pFeatureLevels,
            FeatureLevels,
            UnwrapObjects<IUnknown>(ppCommandQueues, NumQueues, unwrap_memory),
            NumQueues,
            NodeMask,
            ppDevice,
            ppImmediateContext,
            pChosenFeatureLevel);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_ID3D11Device, reinterpret_cast<void**>(ppDevice), nullptr);
            WrapObject(IID_ID3D11DeviceContext, reinterpret_cast<void**>(ppImmediateContext), nullptr);
        }

        Encode_D3D11On12CreateDevice(
            result,
            pDevice,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            ppCommandQueues,
            NumQueues,
            NodeMask,
            ppDevice,
            ppImmediateContext,
            pChosenFeatureLevel);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_D3D11On12CreateDevice>::Dispatch(
            manager,
            result,
            pDevice,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            ppCommandQueues,
            NumQueues,
            NodeMask,
            ppDevice,
            ppImmediateContext,
            pChosenFeatureLevel);
    }
    else
    {
        result = manager->GetD3D11DispatchTable().D3D11On12CreateDevice(
            pDevice,
            Flags,
            pFeatureLevels,
            FeatureLevels,
            ppCommandQueues,
            NumQueues,
            NodeMask,
            ppDevice,
            ppImmediateContext,
            pChosenFeatureLevel);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11On12Device_Wrapper::ID3D11On12Device_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<ID3D11On12DeviceInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

ID3D11On12Device_Wrapper::~ID3D11On12Device_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<ID3D11On12Device>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

ID3D11On12Device_Wrapper* ID3D11On12Device_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<ID3D11On12Device_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE ID3D11On12Device_Wrapper::CreateWrappedResource(
    IUnknown* pResource12,
    const D3D11_RESOURCE_FLAGS* pFlags11,
    D3D12_RESOURCE_STATES InState,
    D3D12_RESOURCE_STATES OutState,
    REFIID riid,
    void** ppResource11)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11On12Device_CreateWrappedResource>::Dispatch(
            manager,
            this,
            pResource12,
            pFlags11,
            InState,
            OutState,
            riid,
            ppResource11);

        result = GetWrappedObjectAs<ID3D11On12Device>()->CreateWrappedResource(
            encode::GetWrappedObject<IUnknown>(pResource12),
            pFlags11,
            InState,
            OutState,
            riid,
            ppResource11);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppResource11, nullptr);
        }

        Encode_ID3D11On12Device_CreateWrappedResource(
            this,
            result,
            pResource12,
            pFlags11,
            InState,
            OutState,
            riid,
            ppResource11);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11On12Device_CreateWrappedResource>::Dispatch(
            manager,
            this,
            result,
            pResource12,
            pFlags11,
            InState,
            OutState,
            riid,
            ppResource11);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11On12Device>()->CreateWrappedResource(
            pResource12,
            pFlags11,
            InState,
            OutState,
            riid,
            ppResource11);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE ID3D11On12Device_Wrapper::ReleaseWrappedResources(
    ID3D11Resource* const* ppResources,
    UINT NumResources)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11On12Device_ReleaseWrappedResources>::Dispatch(
            manager,
            this,
            ppResources,
            NumResources);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11On12Device>()->ReleaseWrappedResources(
            UnwrapObjects<ID3D11Resource>(ppResources, NumResources, unwrap_memory),
            NumResources);

        Encode_ID3D11On12Device_ReleaseWrappedResources(
            this,
            ppResources,
            NumResources);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11On12Device_ReleaseWrappedResources>::Dispatch(
            manager,
            this,
            ppResources,
            NumResources);
    }
    else
    {
        GetWrappedObjectAs<ID3D11On12Device>()->ReleaseWrappedResources(
            ppResources,
            NumResources);
    }

    manager->DecrementCallScope();
}

void STDMETHODCALLTYPE ID3D11On12Device_Wrapper::AcquireWrappedResources(
    ID3D11Resource* const* ppResources,
    UINT NumResources)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11On12Device_AcquireWrappedResources>::Dispatch(
            manager,
            this,
            ppResources,
            NumResources);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        GetWrappedObjectAs<ID3D11On12Device>()->AcquireWrappedResources(
            UnwrapObjects<ID3D11Resource>(ppResources, NumResources, unwrap_memory),
            NumResources);

        Encode_ID3D11On12Device_AcquireWrappedResources(
            this,
            ppResources,
            NumResources);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11On12Device_AcquireWrappedResources>::Dispatch(
            manager,
            this,
            ppResources,
            NumResources);
    }
    else
    {
        GetWrappedObjectAs<ID3D11On12Device>()->AcquireWrappedResources(
            ppResources,
            NumResources);
    }

    manager->DecrementCallScope();
}

ID3D11On12Device1_Wrapper::ID3D11On12Device1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11On12Device_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D11On12Device1_Wrapper::GetD3D12Device(
    REFIID riid,
    void** ppvDevice)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11On12Device1_GetD3D12Device>::Dispatch(
            manager,
            this,
            riid,
            ppvDevice);

        result = GetWrappedObjectAs<ID3D11On12Device1>()->GetD3D12Device(
            riid,
            ppvDevice);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvDevice, nullptr);
        }

        Encode_ID3D11On12Device1_GetD3D12Device(
            this,
            result,
            riid,
            ppvDevice);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11On12Device1_GetD3D12Device>::Dispatch(
            manager,
            this,
            result,
            riid,
            ppvDevice);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11On12Device1>()->GetD3D12Device(
            riid,
            ppvDevice);
    }

    manager->DecrementCallScope();

    return result;
}

ID3D11On12Device2_Wrapper::ID3D11On12Device2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : ID3D11On12Device1_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE ID3D11On12Device2_Wrapper::UnwrapUnderlyingResource(
    ID3D11Resource* pResource11,
    ID3D12CommandQueue* pCommandQueue,
    REFIID riid,
    void** ppvResource12)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11On12Device2_UnwrapUnderlyingResource>::Dispatch(
            manager,
            this,
            pResource11,
            pCommandQueue,
            riid,
            ppvResource12);

        result = GetWrappedObjectAs<ID3D11On12Device2>()->UnwrapUnderlyingResource(
            encode::GetWrappedObject<ID3D11Resource>(pResource11),
            encode::GetWrappedObject<ID3D12CommandQueue>(pCommandQueue),
            riid,
            ppvResource12);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvResource12, nullptr);
        }

        Encode_ID3D11On12Device2_UnwrapUnderlyingResource(
            this,
            result,
            pResource11,
            pCommandQueue,
            riid,
            ppvResource12);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11On12Device2_UnwrapUnderlyingResource>::Dispatch(
            manager,
            this,
            result,
            pResource11,
            pCommandQueue,
            riid,
            ppvResource12);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11On12Device2>()->UnwrapUnderlyingResource(
            pResource11,
            pCommandQueue,
            riid,
            ppvResource12);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE ID3D11On12Device2_Wrapper::ReturnUnderlyingResource(
    ID3D11Resource* pResource11,
    UINT NumSync,
    UINT64* pSignalValues,
    ID3D12Fence** ppFences)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_ID3D11On12Device2_ReturnUnderlyingResource>::Dispatch(
            manager,
            this,
            pResource11,
            NumSync,
            pSignalValues,
            ppFences);

        result = GetWrappedObjectAs<ID3D11On12Device2>()->ReturnUnderlyingResource(
            encode::GetWrappedObject<ID3D11Resource>(pResource11),
            NumSync,
            pSignalValues,
            ppFences);

        if (SUCCEEDED(result))
        {
            WrapObjectArray(IID_ID3D12Fence, reinterpret_cast<void**>(ppFences), NumSync, nullptr);
        }

        Encode_ID3D11On12Device2_ReturnUnderlyingResource(
            this,
            result,
            pResource11,
            NumSync,
            pSignalValues,
            ppFences);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_ID3D11On12Device2_ReturnUnderlyingResource>::Dispatch(
            manager,
            this,
            result,
            pResource11,
            NumSync,
            pSignalValues,
            ppFences);
    }
    else
    {
        result = GetWrappedObjectAs<ID3D11On12Device2>()->ReturnUnderlyingResource(
            pResource11,
            NumSync,
            pSignalValues,
            ppFences);
    }

    manager->DecrementCallScope();

    return result;
}


/*
** This part is generated from dxgi.h in Windows SDK: 10.0.20348.0
**
*/

HRESULT WINAPI CreateDXGIFactory(
    REFIID riid,
    void** ppFactory)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_CreateDXGIFactory>::Dispatch(
            manager,
            riid,
            ppFactory);

        result = manager->GetDxgiDispatchTable().CreateDXGIFactory(
            riid,
            ppFactory);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppFactory, nullptr);
        }

        Encode_CreateDXGIFactory(
            result,
            riid,
            ppFactory);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_CreateDXGIFactory>::Dispatch(
            manager,
            result,
            riid,
            ppFactory);
    }
    else
    {
        result = manager->GetDxgiDispatchTable().CreateDXGIFactory(
            riid,
            ppFactory);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT WINAPI CreateDXGIFactory1(
    REFIID riid,
    void** ppFactory)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_CreateDXGIFactory1>::Dispatch(
            manager,
            riid,
            ppFactory);

        result = manager->GetDxgiDispatchTable().CreateDXGIFactory1(
            riid,
            ppFactory);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppFactory, nullptr);
        }

        Encode_CreateDXGIFactory1(
            result,
            riid,
            ppFactory);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_CreateDXGIFactory1>::Dispatch(
            manager,
            result,
            riid,
            ppFactory);
    }
    else
    {
        result = manager->GetDxgiDispatchTable().CreateDXGIFactory1(
            riid,
            ppFactory);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIObject_Wrapper::IDXGIObject_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIObject_Wrapper::SetPrivateData(
    REFGUID Name,
    UINT DataSize,
    const void* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIObject_SetPrivateData>::Dispatch(
            manager,
            this,
            Name,
            DataSize,
            pData);

        result = GetWrappedObjectAs<IDXGIObject>()->SetPrivateData(
            Name,
            DataSize,
            pData);

        Encode_IDXGIObject_SetPrivateData(
            this,
            result,
            Name,
            DataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIObject_SetPrivateData>::Dispatch(
            manager,
            this,
            result,
            Name,
            DataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIObject>()->SetPrivateData(
            Name,
            DataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIObject_Wrapper::SetPrivateDataInterface(
    REFGUID Name,
    const IUnknown* pUnknown)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIObject_SetPrivateDataInterface>::Dispatch(
            manager,
            this,
            Name,
            pUnknown);

        result = GetWrappedObjectAs<IDXGIObject>()->SetPrivateDataInterface(
            Name,
            encode::GetWrappedObject<IUnknown>(pUnknown));

        Encode_IDXGIObject_SetPrivateDataInterface(
            this,
            result,
            Name,
            pUnknown);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIObject_SetPrivateDataInterface>::Dispatch(
            manager,
            this,
            result,
            Name,
            pUnknown);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIObject>()->SetPrivateDataInterface(
            Name,
            pUnknown);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIObject_Wrapper::GetPrivateData(
    REFGUID Name,
    UINT* pDataSize,
    void* pData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIObject_GetPrivateData>::Dispatch(
            manager,
            this,
            Name,
            pDataSize,
            pData);

        result = GetWrappedObjectAs<IDXGIObject>()->GetPrivateData(
            Name,
            pDataSize,
            pData);

        Encode_IDXGIObject_GetPrivateData(
            this,
            result,
            Name,
            pDataSize,
            pData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIObject_GetPrivateData>::Dispatch(
            manager,
            this,
            result,
            Name,
            pDataSize,
            pData);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIObject>()->GetPrivateData(
            Name,
            pDataSize,
            pData);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIObject_Wrapper::GetParent(
    REFIID riid,
    void** ppParent)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIObject_GetParent>::Dispatch(
            manager,
            this,
            riid,
            ppParent);

        result = GetWrappedObjectAs<IDXGIObject>()->GetParent(
            riid,
            ppParent);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppParent, nullptr);
        }

        Encode_IDXGIObject_GetParent(
            this,
            result,
            riid,
            ppParent);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIObject_GetParent>::Dispatch(
            manager,
            this,
            result,
            riid,
            ppParent);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIObject>()->GetParent(
            riid,
            ppParent);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIDeviceSubObject_Wrapper::IDXGIDeviceSubObject_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIObject_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIDeviceSubObject_Wrapper::GetDevice(
    REFIID riid,
    void** ppDevice)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDeviceSubObject_GetDevice>::Dispatch(
            manager,
            this,
            riid,
            ppDevice);

        result = GetWrappedObjectAs<IDXGIDeviceSubObject>()->GetDevice(
            riid,
            ppDevice);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppDevice, nullptr);
        }

        Encode_IDXGIDeviceSubObject_GetDevice(
            this,
            result,
            riid,
            ppDevice);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDeviceSubObject_GetDevice>::Dispatch(
            manager,
            this,
            result,
            riid,
            ppDevice);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDeviceSubObject>()->GetDevice(
            riid,
            ppDevice);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIResource_Wrapper::IDXGIResource_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIDeviceSubObject_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<IDXGIResourceInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

IDXGIResource_Wrapper::~IDXGIResource_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<IDXGIResource>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

IDXGIResource_Wrapper* IDXGIResource_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<IDXGIResource_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE IDXGIResource_Wrapper::GetSharedHandle(
    HANDLE* pSharedHandle)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIResource_GetSharedHandle>::Dispatch(
            manager,
            this,
            pSharedHandle);

        result = GetWrappedObjectAs<IDXGIResource>()->GetSharedHandle(
            pSharedHandle);

        Encode_IDXGIResource_GetSharedHandle(
            this,
            result,
            pSharedHandle);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIResource_GetSharedHandle>::Dispatch(
            manager,
            this,
            result,
            pSharedHandle);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIResource>()->GetSharedHandle(
            pSharedHandle);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIResource_Wrapper::GetUsage(
    DXGI_USAGE* pUsage)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIResource_GetUsage>::Dispatch(
            manager,
            this,
            pUsage);

        result = GetWrappedObjectAs<IDXGIResource>()->GetUsage(
            pUsage);

        Encode_IDXGIResource_GetUsage(
            this,
            result,
            pUsage);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIResource_GetUsage>::Dispatch(
            manager,
            this,
            result,
            pUsage);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIResource>()->GetUsage(
            pUsage);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIResource_Wrapper::SetEvictionPriority(
    UINT EvictionPriority)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIResource_SetEvictionPriority>::Dispatch(
            manager,
            this,
            EvictionPriority);

        result = GetWrappedObjectAs<IDXGIResource>()->SetEvictionPriority(
            EvictionPriority);

        Encode_IDXGIResource_SetEvictionPriority(
            this,
            result,
            EvictionPriority);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIResource_SetEvictionPriority>::Dispatch(
            manager,
            this,
            result,
            EvictionPriority);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIResource>()->SetEvictionPriority(
            EvictionPriority);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIResource_Wrapper::GetEvictionPriority(
    UINT* pEvictionPriority)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIResource_GetEvictionPriority>::Dispatch(
            manager,
            this,
            pEvictionPriority);

        result = GetWrappedObjectAs<IDXGIResource>()->GetEvictionPriority(
            pEvictionPriority);

        Encode_IDXGIResource_GetEvictionPriority(
            this,
            result,
            pEvictionPriority);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIResource_GetEvictionPriority>::Dispatch(
            manager,
            this,
            result,
            pEvictionPriority);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIResource>()->GetEvictionPriority(
            pEvictionPriority);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIKeyedMutex_Wrapper::IDXGIKeyedMutex_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIDeviceSubObject_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<IDXGIKeyedMutexInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

IDXGIKeyedMutex_Wrapper::~IDXGIKeyedMutex_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<IDXGIKeyedMutex>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

IDXGIKeyedMutex_Wrapper* IDXGIKeyedMutex_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<IDXGIKeyedMutex_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE IDXGIKeyedMutex_Wrapper::AcquireSync(
    UINT64 Key,
    DWORD dwMilliseconds)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIKeyedMutex_AcquireSync>::Dispatch(
            manager,
            this,
            Key,
            dwMilliseconds);

        result = GetWrappedObjectAs<IDXGIKeyedMutex>()->AcquireSync(
            Key,
            dwMilliseconds);

        Encode_IDXGIKeyedMutex_AcquireSync(
            this,
            result,
            Key,
            dwMilliseconds);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIKeyedMutex_AcquireSync>::Dispatch(
            manager,
            this,
            result,
            Key,
            dwMilliseconds);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIKeyedMutex>()->AcquireSync(
            Key,
            dwMilliseconds);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIKeyedMutex_Wrapper::ReleaseSync(
    UINT64 Key)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIKeyedMutex_ReleaseSync>::Dispatch(
            manager,
            this,
            Key);

        result = GetWrappedObjectAs<IDXGIKeyedMutex>()->ReleaseSync(
            Key);

        Encode_IDXGIKeyedMutex_ReleaseSync(
            this,
            result,
            Key);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIKeyedMutex_ReleaseSync>::Dispatch(
            manager,
            this,
            result,
            Key);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIKeyedMutex>()->ReleaseSync(
            Key);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGISurface_Wrapper::IDXGISurface_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIDeviceSubObject_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<IDXGISurfaceInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

IDXGISurface_Wrapper::~IDXGISurface_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<IDXGISurface>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

IDXGISurface_Wrapper* IDXGISurface_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<IDXGISurface_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE IDXGISurface_Wrapper::GetDesc(
    DXGI_SURFACE_DESC* pDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISurface_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        result = GetWrappedObjectAs<IDXGISurface>()->GetDesc(
            pDesc);

        Encode_IDXGISurface_GetDesc(
            this,
            result,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISurface_GetDesc>::Dispatch(
            manager,
            this,
            result,
            pDesc);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISurface>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISurface_Wrapper::Map(
    DXGI_MAPPED_RECT* pLockedRect,
    UINT MapFlags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISurface_Map>::Dispatch(
            manager,
            this,
            pLockedRect,
            MapFlags);

        result = GetWrappedObjectAs<IDXGISurface>()->Map(
            pLockedRect,
            MapFlags);

        Encode_IDXGISurface_Map(
            this,
            result,
            pLockedRect,
            MapFlags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISurface_Map>::Dispatch(
            manager,
            this,
            result,
            pLockedRect,
            MapFlags);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISurface>()->Map(
            pLockedRect,
            MapFlags);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISurface_Wrapper::Unmap()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISurface_Unmap>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<IDXGISurface>()->Unmap();

        Encode_IDXGISurface_Unmap(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISurface_Unmap>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISurface>()->Unmap();
    }

    manager->DecrementCallScope();

    return result;
}

IDXGISurface1_Wrapper::IDXGISurface1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGISurface_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGISurface1_Wrapper::GetDC(
    BOOL Discard,
    HDC* phdc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISurface1_GetDC>::Dispatch(
            manager,
            this,
            Discard,
            phdc);

        result = GetWrappedObjectAs<IDXGISurface1>()->GetDC(
            Discard,
            phdc);

        Encode_IDXGISurface1_GetDC(
            this,
            result,
            Discard,
            phdc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISurface1_GetDC>::Dispatch(
            manager,
            this,
            result,
            Discard,
            phdc);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISurface1>()->GetDC(
            Discard,
            phdc);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISurface1_Wrapper::ReleaseDC(
    RECT* pDirtyRect)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISurface1_ReleaseDC>::Dispatch(
            manager,
            this,
            pDirtyRect);

        result = GetWrappedObjectAs<IDXGISurface1>()->ReleaseDC(
            pDirtyRect);

        Encode_IDXGISurface1_ReleaseDC(
            this,
            result,
            pDirtyRect);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISurface1_ReleaseDC>::Dispatch(
            manager,
            this,
            result,
            pDirtyRect);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISurface1>()->ReleaseDC(
            pDirtyRect);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIAdapter_Wrapper::IDXGIAdapter_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIObject_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<IDXGIAdapterInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

IDXGIAdapter_Wrapper::~IDXGIAdapter_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<IDXGIAdapter>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

IDXGIAdapter_Wrapper* IDXGIAdapter_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<IDXGIAdapter_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE IDXGIAdapter_Wrapper::EnumOutputs(
    UINT Output,
    IDXGIOutput** ppOutput)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIAdapter_EnumOutputs>::Dispatch(
            manager,
            this,
            Output,
            ppOutput);

        result = GetWrappedObjectAs<IDXGIAdapter>()->EnumOutputs(
            Output,
            ppOutput);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGIOutput, reinterpret_cast<void**>(ppOutput), nullptr);
        }

        Encode_IDXGIAdapter_EnumOutputs(
            this,
            result,
            Output,
            ppOutput);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIAdapter_EnumOutputs>::Dispatch(
            manager,
            this,
            result,
            Output,
            ppOutput);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIAdapter>()->EnumOutputs(
            Output,
            ppOutput);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIAdapter_Wrapper::GetDesc(
    DXGI_ADAPTER_DESC* pDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIAdapter_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        result = GetWrappedObjectAs<IDXGIAdapter>()->GetDesc(
            pDesc);

        Encode_IDXGIAdapter_GetDesc(
            this,
            result,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIAdapter_GetDesc>::Dispatch(
            manager,
            this,
            result,
            pDesc);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIAdapter>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIAdapter_Wrapper::CheckInterfaceSupport(
    REFGUID InterfaceName,
    LARGE_INTEGER* pUMDVersion)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIAdapter_CheckInterfaceSupport>::Dispatch(
            manager,
            this,
            InterfaceName,
            pUMDVersion);

        result = GetWrappedObjectAs<IDXGIAdapter>()->CheckInterfaceSupport(
            InterfaceName,
            pUMDVersion);

        Encode_IDXGIAdapter_CheckInterfaceSupport(
            this,
            result,
            InterfaceName,
            pUMDVersion);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIAdapter_CheckInterfaceSupport>::Dispatch(
            manager,
            this,
            result,
            InterfaceName,
            pUMDVersion);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIAdapter>()->CheckInterfaceSupport(
            InterfaceName,
            pUMDVersion);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIOutput_Wrapper::IDXGIOutput_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIObject_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<IDXGIOutputInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

IDXGIOutput_Wrapper::~IDXGIOutput_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<IDXGIOutput>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

IDXGIOutput_Wrapper* IDXGIOutput_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<IDXGIOutput_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE IDXGIOutput_Wrapper::GetDesc(
    DXGI_OUTPUT_DESC* pDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        result = GetWrappedObjectAs<IDXGIOutput>()->GetDesc(
            pDesc);

        Encode_IDXGIOutput_GetDesc(
            this,
            result,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput_GetDesc>::Dispatch(
            manager,
            this,
            result,
            pDesc);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutput_Wrapper::GetDisplayModeList(
    DXGI_FORMAT EnumFormat,
    UINT Flags,
    UINT* pNumModes,
    DXGI_MODE_DESC* pDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput_GetDisplayModeList>::Dispatch(
            manager,
            this,
            EnumFormat,
            Flags,
            pNumModes,
            pDesc);

        result = GetWrappedObjectAs<IDXGIOutput>()->GetDisplayModeList(
            EnumFormat,
            Flags,
            pNumModes,
            pDesc);

        Encode_IDXGIOutput_GetDisplayModeList(
            this,
            result,
            EnumFormat,
            Flags,
            pNumModes,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput_GetDisplayModeList>::Dispatch(
            manager,
            this,
            result,
            EnumFormat,
            Flags,
            pNumModes,
            pDesc);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput>()->GetDisplayModeList(
            EnumFormat,
            Flags,
            pNumModes,
            pDesc);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutput_Wrapper::FindClosestMatchingMode(
    const DXGI_MODE_DESC* pModeToMatch,
    DXGI_MODE_DESC* pClosestMatch,
    IUnknown* pConcernedDevice)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput_FindClosestMatchingMode>::Dispatch(
            manager,
            this,
            pModeToMatch,
            pClosestMatch,
            pConcernedDevice);

        result = GetWrappedObjectAs<IDXGIOutput>()->FindClosestMatchingMode(
            pModeToMatch,
            pClosestMatch,
            encode::GetWrappedObject<IUnknown>(pConcernedDevice));

        Encode_IDXGIOutput_FindClosestMatchingMode(
            this,
            result,
            pModeToMatch,
            pClosestMatch,
            pConcernedDevice);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput_FindClosestMatchingMode>::Dispatch(
            manager,
            this,
            result,
            pModeToMatch,
            pClosestMatch,
            pConcernedDevice);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput>()->FindClosestMatchingMode(
            pModeToMatch,
            pClosestMatch,
            pConcernedDevice);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutput_Wrapper::WaitForVBlank()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput_WaitForVBlank>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<IDXGIOutput>()->WaitForVBlank();

        Encode_IDXGIOutput_WaitForVBlank(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput_WaitForVBlank>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput>()->WaitForVBlank();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutput_Wrapper::TakeOwnership(
    IUnknown* pDevice,
    BOOL Exclusive)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput_TakeOwnership>::Dispatch(
            manager,
            this,
            pDevice,
            Exclusive);

        result = GetWrappedObjectAs<IDXGIOutput>()->TakeOwnership(
            encode::GetWrappedObject<IUnknown>(pDevice),
            Exclusive);

        Encode_IDXGIOutput_TakeOwnership(
            this,
            result,
            pDevice,
            Exclusive);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput_TakeOwnership>::Dispatch(
            manager,
            this,
            result,
            pDevice,
            Exclusive);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput>()->TakeOwnership(
            pDevice,
            Exclusive);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE IDXGIOutput_Wrapper::ReleaseOwnership()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput_ReleaseOwnership>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<IDXGIOutput>()->ReleaseOwnership();

        Encode_IDXGIOutput_ReleaseOwnership(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput_ReleaseOwnership>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<IDXGIOutput>()->ReleaseOwnership();
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE IDXGIOutput_Wrapper::GetGammaControlCapabilities(
    DXGI_GAMMA_CONTROL_CAPABILITIES* pGammaCaps)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput_GetGammaControlCapabilities>::Dispatch(
            manager,
            this,
            pGammaCaps);

        result = GetWrappedObjectAs<IDXGIOutput>()->GetGammaControlCapabilities(
            pGammaCaps);

        Encode_IDXGIOutput_GetGammaControlCapabilities(
            this,
            result,
            pGammaCaps);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput_GetGammaControlCapabilities>::Dispatch(
            manager,
            this,
            result,
            pGammaCaps);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput>()->GetGammaControlCapabilities(
            pGammaCaps);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutput_Wrapper::SetGammaControl(
    const DXGI_GAMMA_CONTROL* pArray)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput_SetGammaControl>::Dispatch(
            manager,
            this,
            pArray);

        result = GetWrappedObjectAs<IDXGIOutput>()->SetGammaControl(
            pArray);

        Encode_IDXGIOutput_SetGammaControl(
            this,
            result,
            pArray);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput_SetGammaControl>::Dispatch(
            manager,
            this,
            result,
            pArray);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput>()->SetGammaControl(
            pArray);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutput_Wrapper::GetGammaControl(
    DXGI_GAMMA_CONTROL* pArray)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput_GetGammaControl>::Dispatch(
            manager,
            this,
            pArray);

        result = GetWrappedObjectAs<IDXGIOutput>()->GetGammaControl(
            pArray);

        Encode_IDXGIOutput_GetGammaControl(
            this,
            result,
            pArray);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput_GetGammaControl>::Dispatch(
            manager,
            this,
            result,
            pArray);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput>()->GetGammaControl(
            pArray);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutput_Wrapper::SetDisplaySurface(
    IDXGISurface* pScanoutSurface)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput_SetDisplaySurface>::Dispatch(
            manager,
            this,
            pScanoutSurface);

        result = GetWrappedObjectAs<IDXGIOutput>()->SetDisplaySurface(
            encode::GetWrappedObject<IDXGISurface>(pScanoutSurface));

        Encode_IDXGIOutput_SetDisplaySurface(
            this,
            result,
            pScanoutSurface);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput_SetDisplaySurface>::Dispatch(
            manager,
            this,
            result,
            pScanoutSurface);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput>()->SetDisplaySurface(
            pScanoutSurface);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutput_Wrapper::GetDisplaySurfaceData(
    IDXGISurface* pDestination)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput_GetDisplaySurfaceData>::Dispatch(
            manager,
            this,
            pDestination);

        result = GetWrappedObjectAs<IDXGIOutput>()->GetDisplaySurfaceData(
            encode::GetWrappedObject<IDXGISurface>(pDestination));

        Encode_IDXGIOutput_GetDisplaySurfaceData(
            this,
            result,
            pDestination);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput_GetDisplaySurfaceData>::Dispatch(
            manager,
            this,
            result,
            pDestination);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput>()->GetDisplaySurfaceData(
            pDestination);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutput_Wrapper::GetFrameStatistics(
    DXGI_FRAME_STATISTICS* pStats)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput_GetFrameStatistics>::Dispatch(
            manager,
            this,
            pStats);

        result = GetWrappedObjectAs<IDXGIOutput>()->GetFrameStatistics(
            pStats);

        Encode_IDXGIOutput_GetFrameStatistics(
            this,
            result,
            pStats);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput_GetFrameStatistics>::Dispatch(
            manager,
            this,
            result,
            pStats);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput>()->GetFrameStatistics(
            pStats);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGISwapChain_Wrapper::IDXGISwapChain_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIDeviceSubObject_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<IDXGISwapChainInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

IDXGISwapChain_Wrapper::~IDXGISwapChain_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<IDXGISwapChain>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

IDXGISwapChain_Wrapper* IDXGISwapChain_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<IDXGISwapChain_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain_Wrapper::Present(
    UINT SyncInterval,
    UINT Flags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain_Present>::Dispatch(
            manager,
            this,
            SyncInterval,
            Flags);

        result = GetWrappedObjectAs<IDXGISwapChain>()->Present(
            SyncInterval,
            Flags);

        Encode_IDXGISwapChain_Present(
            this,
            result,
            SyncInterval,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain_Present>::Dispatch(
            manager,
            shared_api_call_lock,
            this,
            result,
            SyncInterval,
            Flags);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain>()->Present(
            SyncInterval,
            Flags);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain_Wrapper::GetBuffer(
    UINT Buffer,
    REFIID riid,
    void** ppSurface)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain_GetBuffer>::Dispatch(
            manager,
            this,
            Buffer,
            riid,
            ppSurface);

        result = GetWrappedObjectAs<IDXGISwapChain>()->GetBuffer(
            Buffer,
            riid,
            ppSurface);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppSurface, nullptr);
        }

        Encode_IDXGISwapChain_GetBuffer(
            this,
            result,
            Buffer,
            riid,
            ppSurface);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain_GetBuffer>::Dispatch(
            manager,
            this,
            result,
            Buffer,
            riid,
            ppSurface);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain>()->GetBuffer(
            Buffer,
            riid,
            ppSurface);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain_Wrapper::SetFullscreenState(
    BOOL Fullscreen,
    IDXGIOutput* pTarget)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain_SetFullscreenState>::Dispatch(
            manager,
            this,
            Fullscreen,
            pTarget);

        result = GetWrappedObjectAs<IDXGISwapChain>()->SetFullscreenState(
            Fullscreen,
            encode::GetWrappedObject<IDXGIOutput>(pTarget));

        Encode_IDXGISwapChain_SetFullscreenState(
            this,
            result,
            Fullscreen,
            pTarget);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain_SetFullscreenState>::Dispatch(
            manager,
            this,
            result,
            Fullscreen,
            pTarget);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain>()->SetFullscreenState(
            Fullscreen,
            pTarget);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain_Wrapper::GetFullscreenState(
    BOOL* pFullscreen,
    IDXGIOutput** ppTarget)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain_GetFullscreenState>::Dispatch(
            manager,
            this,
            pFullscreen,
            ppTarget);

        result = GetWrappedObjectAs<IDXGISwapChain>()->GetFullscreenState(
            pFullscreen,
            ppTarget);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGIOutput, reinterpret_cast<void**>(ppTarget), nullptr);
        }

        Encode_IDXGISwapChain_GetFullscreenState(
            this,
            result,
            pFullscreen,
            ppTarget);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain_GetFullscreenState>::Dispatch(
            manager,
            this,
            result,
            pFullscreen,
            ppTarget);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain>()->GetFullscreenState(
            pFullscreen,
            ppTarget);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain_Wrapper::GetDesc(
    DXGI_SWAP_CHAIN_DESC* pDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        result = GetWrappedObjectAs<IDXGISwapChain>()->GetDesc(
            pDesc);

        Encode_IDXGISwapChain_GetDesc(
            this,
            result,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain_GetDesc>::Dispatch(
            manager,
            this,
            result,
            pDesc);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain_Wrapper::ResizeBuffers(
    UINT BufferCount,
    UINT Width,
    UINT Height,
    DXGI_FORMAT NewFormat,
    UINT SwapChainFlags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain_ResizeBuffers>::Dispatch(
            manager,
            this,
            BufferCount,
            Width,
            Height,
            NewFormat,
            SwapChainFlags);

        result = GetWrappedObjectAs<IDXGISwapChain>()->ResizeBuffers(
            BufferCount,
            Width,
            Height,
            NewFormat,
            SwapChainFlags);

        Encode_IDXGISwapChain_ResizeBuffers(
            this,
            result,
            BufferCount,
            Width,
            Height,
            NewFormat,
            SwapChainFlags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain_ResizeBuffers>::Dispatch(
            manager,
            this,
            result,
            BufferCount,
            Width,
            Height,
            NewFormat,
            SwapChainFlags);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain>()->ResizeBuffers(
            BufferCount,
            Width,
            Height,
            NewFormat,
            SwapChainFlags);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain_Wrapper::ResizeTarget(
    const DXGI_MODE_DESC* pNewTargetParameters)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain_ResizeTarget>::Dispatch(
            manager,
            this,
            pNewTargetParameters);

        result = GetWrappedObjectAs<IDXGISwapChain>()->ResizeTarget(
            pNewTargetParameters);

        Encode_IDXGISwapChain_ResizeTarget(
            this,
            result,
            pNewTargetParameters);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain_ResizeTarget>::Dispatch(
            manager,
            this,
            result,
            pNewTargetParameters);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain>()->ResizeTarget(
            pNewTargetParameters);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain_Wrapper::GetContainingOutput(
    IDXGIOutput** ppOutput)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain_GetContainingOutput>::Dispatch(
            manager,
            this,
            ppOutput);

        result = GetWrappedObjectAs<IDXGISwapChain>()->GetContainingOutput(
            ppOutput);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGIOutput, reinterpret_cast<void**>(ppOutput), nullptr);
        }

        Encode_IDXGISwapChain_GetContainingOutput(
            this,
            result,
            ppOutput);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain_GetContainingOutput>::Dispatch(
            manager,
            this,
            result,
            ppOutput);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain>()->GetContainingOutput(
            ppOutput);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain_Wrapper::GetFrameStatistics(
    DXGI_FRAME_STATISTICS* pStats)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain_GetFrameStatistics>::Dispatch(
            manager,
            this,
            pStats);

        result = GetWrappedObjectAs<IDXGISwapChain>()->GetFrameStatistics(
            pStats);

        Encode_IDXGISwapChain_GetFrameStatistics(
            this,
            result,
            pStats);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain_GetFrameStatistics>::Dispatch(
            manager,
            this,
            result,
            pStats);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain>()->GetFrameStatistics(
            pStats);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain_Wrapper::GetLastPresentCount(
    UINT* pLastPresentCount)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain_GetLastPresentCount>::Dispatch(
            manager,
            this,
            pLastPresentCount);

        result = GetWrappedObjectAs<IDXGISwapChain>()->GetLastPresentCount(
            pLastPresentCount);

        Encode_IDXGISwapChain_GetLastPresentCount(
            this,
            result,
            pLastPresentCount);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain_GetLastPresentCount>::Dispatch(
            manager,
            this,
            result,
            pLastPresentCount);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain>()->GetLastPresentCount(
            pLastPresentCount);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIFactory_Wrapper::IDXGIFactory_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIObject_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<IDXGIFactoryInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

IDXGIFactory_Wrapper::~IDXGIFactory_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<IDXGIFactory>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

IDXGIFactory_Wrapper* IDXGIFactory_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<IDXGIFactory_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE IDXGIFactory_Wrapper::EnumAdapters(
    UINT Adapter,
    IDXGIAdapter** ppAdapter)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory_EnumAdapters>::Dispatch(
            manager,
            this,
            Adapter,
            ppAdapter);

        result = GetWrappedObjectAs<IDXGIFactory>()->EnumAdapters(
            Adapter,
            ppAdapter);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGIAdapter, reinterpret_cast<void**>(ppAdapter), nullptr);
        }

        Encode_IDXGIFactory_EnumAdapters(
            this,
            result,
            Adapter,
            ppAdapter);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory_EnumAdapters>::Dispatch(
            manager,
            this,
            result,
            Adapter,
            ppAdapter);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory>()->EnumAdapters(
            Adapter,
            ppAdapter);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIFactory_Wrapper::MakeWindowAssociation(
    HWND WindowHandle,
    UINT Flags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory_MakeWindowAssociation>::Dispatch(
            manager,
            this,
            WindowHandle,
            Flags);

        result = GetWrappedObjectAs<IDXGIFactory>()->MakeWindowAssociation(
            WindowHandle,
            Flags);

        Encode_IDXGIFactory_MakeWindowAssociation(
            this,
            result,
            WindowHandle,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory_MakeWindowAssociation>::Dispatch(
            manager,
            this,
            result,
            WindowHandle,
            Flags);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory>()->MakeWindowAssociation(
            WindowHandle,
            Flags);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIFactory_Wrapper::GetWindowAssociation(
    HWND* pWindowHandle)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory_GetWindowAssociation>::Dispatch(
            manager,
            this,
            pWindowHandle);

        result = GetWrappedObjectAs<IDXGIFactory>()->GetWindowAssociation(
            pWindowHandle);

        Encode_IDXGIFactory_GetWindowAssociation(
            this,
            result,
            pWindowHandle);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory_GetWindowAssociation>::Dispatch(
            manager,
            this,
            result,
            pWindowHandle);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory>()->GetWindowAssociation(
            pWindowHandle);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIFactory_Wrapper::CreateSwapChain(
    IUnknown* pDevice,
    DXGI_SWAP_CHAIN_DESC* pDesc,
    IDXGISwapChain** ppSwapChain)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory_CreateSwapChain>::Dispatch(
            manager,
            this,
            pDevice,
            pDesc,
            ppSwapChain);

        result = GetWrappedObjectAs<IDXGIFactory>()->CreateSwapChain(
            encode::GetWrappedObject<IUnknown>(pDevice),
            pDesc,
            ppSwapChain);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGISwapChain, reinterpret_cast<void**>(ppSwapChain), nullptr);
        }

        Encode_IDXGIFactory_CreateSwapChain(
            this,
            result,
            pDevice,
            pDesc,
            ppSwapChain);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory_CreateSwapChain>::Dispatch(
            manager,
            this,
            result,
            pDevice,
            pDesc,
            ppSwapChain);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory>()->CreateSwapChain(
            pDevice,
            pDesc,
            ppSwapChain);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIFactory_Wrapper::CreateSoftwareAdapter(
    HMODULE Module,
    IDXGIAdapter** ppAdapter)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory_CreateSoftwareAdapter>::Dispatch(
            manager,
            this,
            Module,
            ppAdapter);

        result = GetWrappedObjectAs<IDXGIFactory>()->CreateSoftwareAdapter(
            Module,
            ppAdapter);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGIAdapter, reinterpret_cast<void**>(ppAdapter), nullptr);
        }

        Encode_IDXGIFactory_CreateSoftwareAdapter(
            this,
            result,
            Module,
            ppAdapter);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory_CreateSoftwareAdapter>::Dispatch(
            manager,
            this,
            result,
            Module,
            ppAdapter);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory>()->CreateSoftwareAdapter(
            Module,
            ppAdapter);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIDevice_Wrapper::IDXGIDevice_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIObject_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<IDXGIDeviceInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

IDXGIDevice_Wrapper::~IDXGIDevice_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<IDXGIDevice>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

IDXGIDevice_Wrapper* IDXGIDevice_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<IDXGIDevice_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE IDXGIDevice_Wrapper::GetAdapter(
    IDXGIAdapter** pAdapter)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDevice_GetAdapter>::Dispatch(
            manager,
            this,
            pAdapter);

        result = GetWrappedObjectAs<IDXGIDevice>()->GetAdapter(
            pAdapter);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGIAdapter, reinterpret_cast<void**>(pAdapter), nullptr);
        }

        Encode_IDXGIDevice_GetAdapter(
            this,
            result,
            pAdapter);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDevice_GetAdapter>::Dispatch(
            manager,
            this,
            result,
            pAdapter);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDevice>()->GetAdapter(
            pAdapter);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDevice_Wrapper::CreateSurface(
    const DXGI_SURFACE_DESC* pDesc,
    UINT NumSurfaces,
    DXGI_USAGE Usage,
    const DXGI_SHARED_RESOURCE* pSharedResource,
    IDXGISurface** ppSurface)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDevice_CreateSurface>::Dispatch(
            manager,
            this,
            pDesc,
            NumSurfaces,
            Usage,
            pSharedResource,
            ppSurface);

        result = GetWrappedObjectAs<IDXGIDevice>()->CreateSurface(
            pDesc,
            NumSurfaces,
            Usage,
            pSharedResource,
            ppSurface);

        if (SUCCEEDED(result))
        {
            WrapObjectArray(IID_IDXGISurface, reinterpret_cast<void**>(ppSurface), NumSurfaces, nullptr);
        }

        Encode_IDXGIDevice_CreateSurface(
            this,
            result,
            pDesc,
            NumSurfaces,
            Usage,
            pSharedResource,
            ppSurface);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDevice_CreateSurface>::Dispatch(
            manager,
            this,
            result,
            pDesc,
            NumSurfaces,
            Usage,
            pSharedResource,
            ppSurface);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDevice>()->CreateSurface(
            pDesc,
            NumSurfaces,
            Usage,
            pSharedResource,
            ppSurface);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDevice_Wrapper::QueryResourceResidency(
    IUnknown* const* ppResources,
    DXGI_RESIDENCY* pResidencyStatus,
    UINT NumResources)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDevice_QueryResourceResidency>::Dispatch(
            manager,
            this,
            ppResources,
            pResidencyStatus,
            NumResources);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<IDXGIDevice>()->QueryResourceResidency(
            UnwrapObjects<IUnknown>(ppResources, NumResources, unwrap_memory),
            pResidencyStatus,
            NumResources);

        Encode_IDXGIDevice_QueryResourceResidency(
            this,
            result,
            ppResources,
            pResidencyStatus,
            NumResources);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDevice_QueryResourceResidency>::Dispatch(
            manager,
            this,
            result,
            ppResources,
            pResidencyStatus,
            NumResources);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDevice>()->QueryResourceResidency(
            ppResources,
            pResidencyStatus,
            NumResources);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDevice_Wrapper::SetGPUThreadPriority(
    INT Priority)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDevice_SetGPUThreadPriority>::Dispatch(
            manager,
            this,
            Priority);

        result = GetWrappedObjectAs<IDXGIDevice>()->SetGPUThreadPriority(
            Priority);

        Encode_IDXGIDevice_SetGPUThreadPriority(
            this,
            result,
            Priority);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDevice_SetGPUThreadPriority>::Dispatch(
            manager,
            this,
            result,
            Priority);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDevice>()->SetGPUThreadPriority(
            Priority);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDevice_Wrapper::GetGPUThreadPriority(
    INT* pPriority)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDevice_GetGPUThreadPriority>::Dispatch(
            manager,
            this,
            pPriority);

        result = GetWrappedObjectAs<IDXGIDevice>()->GetGPUThreadPriority(
            pPriority);

        Encode_IDXGIDevice_GetGPUThreadPriority(
            this,
            result,
            pPriority);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDevice_GetGPUThreadPriority>::Dispatch(
            manager,
            this,
            result,
            pPriority);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDevice>()->GetGPUThreadPriority(
            pPriority);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIFactory1_Wrapper::IDXGIFactory1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIFactory_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIFactory1_Wrapper::EnumAdapters1(
    UINT Adapter,
    IDXGIAdapter1** ppAdapter)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory1_EnumAdapters1>::Dispatch(
            manager,
            this,
            Adapter,
            ppAdapter);

        result = GetWrappedObjectAs<IDXGIFactory1>()->EnumAdapters1(
            Adapter,
            ppAdapter);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGIAdapter1, reinterpret_cast<void**>(ppAdapter), nullptr);
        }

        Encode_IDXGIFactory1_EnumAdapters1(
            this,
            result,
            Adapter,
            ppAdapter);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory1_EnumAdapters1>::Dispatch(
            manager,
            this,
            result,
            Adapter,
            ppAdapter);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory1>()->EnumAdapters1(
            Adapter,
            ppAdapter);
    }

    manager->DecrementCallScope();

    return result;
}

BOOL STDMETHODCALLTYPE IDXGIFactory1_Wrapper::IsCurrent()
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory1_IsCurrent>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<IDXGIFactory1>()->IsCurrent();

        Encode_IDXGIFactory1_IsCurrent(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory1_IsCurrent>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory1>()->IsCurrent();
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIAdapter1_Wrapper::IDXGIAdapter1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIAdapter_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIAdapter1_Wrapper::GetDesc1(
    DXGI_ADAPTER_DESC1* pDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIAdapter1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc);

        result = GetWrappedObjectAs<IDXGIAdapter1>()->GetDesc1(
            pDesc);

        Encode_IDXGIAdapter1_GetDesc1(
            this,
            result,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIAdapter1_GetDesc1>::Dispatch(
            manager,
            this,
            result,
            pDesc);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIAdapter1>()->GetDesc1(
            pDesc);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIDevice1_Wrapper::IDXGIDevice1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIDevice_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIDevice1_Wrapper::SetMaximumFrameLatency(
    UINT MaxLatency)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDevice1_SetMaximumFrameLatency>::Dispatch(
            manager,
            this,
            MaxLatency);

        result = GetWrappedObjectAs<IDXGIDevice1>()->SetMaximumFrameLatency(
            MaxLatency);

        Encode_IDXGIDevice1_SetMaximumFrameLatency(
            this,
            result,
            MaxLatency);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDevice1_SetMaximumFrameLatency>::Dispatch(
            manager,
            this,
            result,
            MaxLatency);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDevice1>()->SetMaximumFrameLatency(
            MaxLatency);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDevice1_Wrapper::GetMaximumFrameLatency(
    UINT* pMaxLatency)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDevice1_GetMaximumFrameLatency>::Dispatch(
            manager,
            this,
            pMaxLatency);

        result = GetWrappedObjectAs<IDXGIDevice1>()->GetMaximumFrameLatency(
            pMaxLatency);

        Encode_IDXGIDevice1_GetMaximumFrameLatency(
            this,
            result,
            pMaxLatency);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDevice1_GetMaximumFrameLatency>::Dispatch(
            manager,
            this,
            result,
            pMaxLatency);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDevice1>()->GetMaximumFrameLatency(
            pMaxLatency);
    }

    manager->DecrementCallScope();

    return result;
}


/*
** This part is generated from dxgi1_2.h in Windows SDK: 10.0.20348.0
**
*/

IDXGIDisplayControl_Wrapper::IDXGIDisplayControl_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<IDXGIDisplayControlInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

IDXGIDisplayControl_Wrapper::~IDXGIDisplayControl_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<IDXGIDisplayControl>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

IDXGIDisplayControl_Wrapper* IDXGIDisplayControl_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<IDXGIDisplayControl_Wrapper>(object, object_map_, object_map_lock_);
}

BOOL STDMETHODCALLTYPE IDXGIDisplayControl_Wrapper::IsStereoEnabled()
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDisplayControl_IsStereoEnabled>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<IDXGIDisplayControl>()->IsStereoEnabled();

        Encode_IDXGIDisplayControl_IsStereoEnabled(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDisplayControl_IsStereoEnabled>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDisplayControl>()->IsStereoEnabled();
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE IDXGIDisplayControl_Wrapper::SetStereoEnabled(
    BOOL enabled)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDisplayControl_SetStereoEnabled>::Dispatch(
            manager,
            this,
            enabled);

        GetWrappedObjectAs<IDXGIDisplayControl>()->SetStereoEnabled(
            enabled);

        Encode_IDXGIDisplayControl_SetStereoEnabled(
            this,
            enabled);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDisplayControl_SetStereoEnabled>::Dispatch(
            manager,
            this,
            enabled);
    }
    else
    {
        GetWrappedObjectAs<IDXGIDisplayControl>()->SetStereoEnabled(
            enabled);
    }

    manager->DecrementCallScope();
}

IDXGIOutputDuplication_Wrapper::IDXGIOutputDuplication_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIObject_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<IDXGIOutputDuplicationInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

IDXGIOutputDuplication_Wrapper::~IDXGIOutputDuplication_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<IDXGIOutputDuplication>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

IDXGIOutputDuplication_Wrapper* IDXGIOutputDuplication_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<IDXGIOutputDuplication_Wrapper>(object, object_map_, object_map_lock_);
}

void STDMETHODCALLTYPE IDXGIOutputDuplication_Wrapper::GetDesc(
    DXGI_OUTDUPL_DESC* pDesc)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);

        GetWrappedObjectAs<IDXGIOutputDuplication>()->GetDesc(
            pDesc);

        Encode_IDXGIOutputDuplication_GetDesc(
            this,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_GetDesc>::Dispatch(
            manager,
            this,
            pDesc);
    }
    else
    {
        GetWrappedObjectAs<IDXGIOutputDuplication>()->GetDesc(
            pDesc);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE IDXGIOutputDuplication_Wrapper::AcquireNextFrame(
    UINT TimeoutInMilliseconds,
    DXGI_OUTDUPL_FRAME_INFO* pFrameInfo,
    IDXGIResource** ppDesktopResource)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_AcquireNextFrame>::Dispatch(
            manager,
            this,
            TimeoutInMilliseconds,
            pFrameInfo,
            ppDesktopResource);

        result = GetWrappedObjectAs<IDXGIOutputDuplication>()->AcquireNextFrame(
            TimeoutInMilliseconds,
            pFrameInfo,
            ppDesktopResource);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGIResource, reinterpret_cast<void**>(ppDesktopResource), nullptr);
        }

        Encode_IDXGIOutputDuplication_AcquireNextFrame(
            this,
            result,
            TimeoutInMilliseconds,
            pFrameInfo,
            ppDesktopResource);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_AcquireNextFrame>::Dispatch(
            manager,
            this,
            result,
            TimeoutInMilliseconds,
            pFrameInfo,
            ppDesktopResource);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutputDuplication>()->AcquireNextFrame(
            TimeoutInMilliseconds,
            pFrameInfo,
            ppDesktopResource);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutputDuplication_Wrapper::GetFrameDirtyRects(
    UINT DirtyRectsBufferSize,
    RECT* pDirtyRectsBuffer,
    UINT* pDirtyRectsBufferSizeRequired)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_GetFrameDirtyRects>::Dispatch(
            manager,
            this,
            DirtyRectsBufferSize,
            pDirtyRectsBuffer,
            pDirtyRectsBufferSizeRequired);

        result = GetWrappedObjectAs<IDXGIOutputDuplication>()->GetFrameDirtyRects(
            DirtyRectsBufferSize,
            pDirtyRectsBuffer,
            pDirtyRectsBufferSizeRequired);

        Encode_IDXGIOutputDuplication_GetFrameDirtyRects(
            this,
            result,
            DirtyRectsBufferSize,
            pDirtyRectsBuffer,
            pDirtyRectsBufferSizeRequired);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_GetFrameDirtyRects>::Dispatch(
            manager,
            this,
            result,
            DirtyRectsBufferSize,
            pDirtyRectsBuffer,
            pDirtyRectsBufferSizeRequired);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutputDuplication>()->GetFrameDirtyRects(
            DirtyRectsBufferSize,
            pDirtyRectsBuffer,
            pDirtyRectsBufferSizeRequired);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutputDuplication_Wrapper::GetFrameMoveRects(
    UINT MoveRectsBufferSize,
    DXGI_OUTDUPL_MOVE_RECT* pMoveRectBuffer,
    UINT* pMoveRectsBufferSizeRequired)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_GetFrameMoveRects>::Dispatch(
            manager,
            this,
            MoveRectsBufferSize,
            pMoveRectBuffer,
            pMoveRectsBufferSizeRequired);

        result = GetWrappedObjectAs<IDXGIOutputDuplication>()->GetFrameMoveRects(
            MoveRectsBufferSize,
            pMoveRectBuffer,
            pMoveRectsBufferSizeRequired);

        Encode_IDXGIOutputDuplication_GetFrameMoveRects(
            this,
            result,
            MoveRectsBufferSize,
            pMoveRectBuffer,
            pMoveRectsBufferSizeRequired);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_GetFrameMoveRects>::Dispatch(
            manager,
            this,
            result,
            MoveRectsBufferSize,
            pMoveRectBuffer,
            pMoveRectsBufferSizeRequired);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutputDuplication>()->GetFrameMoveRects(
            MoveRectsBufferSize,
            pMoveRectBuffer,
            pMoveRectsBufferSizeRequired);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutputDuplication_Wrapper::GetFramePointerShape(
    UINT PointerShapeBufferSize,
    void* pPointerShapeBuffer,
    UINT* pPointerShapeBufferSizeRequired,
    DXGI_OUTDUPL_POINTER_SHAPE_INFO* pPointerShapeInfo)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_GetFramePointerShape>::Dispatch(
            manager,
            this,
            PointerShapeBufferSize,
            pPointerShapeBuffer,
            pPointerShapeBufferSizeRequired,
            pPointerShapeInfo);

        result = GetWrappedObjectAs<IDXGIOutputDuplication>()->GetFramePointerShape(
            PointerShapeBufferSize,
            pPointerShapeBuffer,
            pPointerShapeBufferSizeRequired,
            pPointerShapeInfo);

        Encode_IDXGIOutputDuplication_GetFramePointerShape(
            this,
            result,
            PointerShapeBufferSize,
            pPointerShapeBuffer,
            pPointerShapeBufferSizeRequired,
            pPointerShapeInfo);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_GetFramePointerShape>::Dispatch(
            manager,
            this,
            result,
            PointerShapeBufferSize,
            pPointerShapeBuffer,
            pPointerShapeBufferSizeRequired,
            pPointerShapeInfo);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutputDuplication>()->GetFramePointerShape(
            PointerShapeBufferSize,
            pPointerShapeBuffer,
            pPointerShapeBufferSizeRequired,
            pPointerShapeInfo);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutputDuplication_Wrapper::MapDesktopSurface(
    DXGI_MAPPED_RECT* pLockedRect)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_MapDesktopSurface>::Dispatch(
            manager,
            this,
            pLockedRect);

        result = GetWrappedObjectAs<IDXGIOutputDuplication>()->MapDesktopSurface(
            pLockedRect);

        Encode_IDXGIOutputDuplication_MapDesktopSurface(
            this,
            result,
            pLockedRect);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_MapDesktopSurface>::Dispatch(
            manager,
            this,
            result,
            pLockedRect);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutputDuplication>()->MapDesktopSurface(
            pLockedRect);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutputDuplication_Wrapper::UnMapDesktopSurface()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_UnMapDesktopSurface>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<IDXGIOutputDuplication>()->UnMapDesktopSurface();

        Encode_IDXGIOutputDuplication_UnMapDesktopSurface(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_UnMapDesktopSurface>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutputDuplication>()->UnMapDesktopSurface();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutputDuplication_Wrapper::ReleaseFrame()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_ReleaseFrame>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<IDXGIOutputDuplication>()->ReleaseFrame();

        Encode_IDXGIOutputDuplication_ReleaseFrame(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutputDuplication_ReleaseFrame>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutputDuplication>()->ReleaseFrame();
    }

    manager->DecrementCallScope();

    return result;
}

IDXGISurface2_Wrapper::IDXGISurface2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGISurface1_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGISurface2_Wrapper::GetResource(
    REFIID riid,
    void** ppParentResource,
    UINT* pSubresourceIndex)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISurface2_GetResource>::Dispatch(
            manager,
            this,
            riid,
            ppParentResource,
            pSubresourceIndex);

        result = GetWrappedObjectAs<IDXGISurface2>()->GetResource(
            riid,
            ppParentResource,
            pSubresourceIndex);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppParentResource, nullptr);
        }

        Encode_IDXGISurface2_GetResource(
            this,
            result,
            riid,
            ppParentResource,
            pSubresourceIndex);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISurface2_GetResource>::Dispatch(
            manager,
            this,
            result,
            riid,
            ppParentResource,
            pSubresourceIndex);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISurface2>()->GetResource(
            riid,
            ppParentResource,
            pSubresourceIndex);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIResource1_Wrapper::IDXGIResource1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIResource_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIResource1_Wrapper::CreateSubresourceSurface(
    UINT index,
    IDXGISurface2** ppSurface)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIResource1_CreateSubresourceSurface>::Dispatch(
            manager,
            this,
            index,
            ppSurface);

        result = GetWrappedObjectAs<IDXGIResource1>()->CreateSubresourceSurface(
            index,
            ppSurface);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGISurface2, reinterpret_cast<void**>(ppSurface), nullptr);
        }

        Encode_IDXGIResource1_CreateSubresourceSurface(
            this,
            result,
            index,
            ppSurface);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIResource1_CreateSubresourceSurface>::Dispatch(
            manager,
            this,
            result,
            index,
            ppSurface);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIResource1>()->CreateSubresourceSurface(
            index,
            ppSurface);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIResource1_Wrapper::CreateSharedHandle(
    const SECURITY_ATTRIBUTES* pAttributes,
    DWORD dwAccess,
    LPCWSTR lpName,
    HANDLE* pHandle)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIResource1_CreateSharedHandle>::Dispatch(
            manager,
            this,
            pAttributes,
            dwAccess,
            lpName,
            pHandle);

        result = GetWrappedObjectAs<IDXGIResource1>()->CreateSharedHandle(
            pAttributes,
            dwAccess,
            lpName,
            pHandle);

        Encode_IDXGIResource1_CreateSharedHandle(
            this,
            result,
            pAttributes,
            dwAccess,
            lpName,
            pHandle);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIResource1_CreateSharedHandle>::Dispatch(
            manager,
            this,
            result,
            pAttributes,
            dwAccess,
            lpName,
            pHandle);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIResource1>()->CreateSharedHandle(
            pAttributes,
            dwAccess,
            lpName,
            pHandle);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIDevice2_Wrapper::IDXGIDevice2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIDevice1_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIDevice2_Wrapper::OfferResources(
    UINT NumResources,
    IDXGIResource* const* ppResources,
    DXGI_OFFER_RESOURCE_PRIORITY Priority)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDevice2_OfferResources>::Dispatch(
            manager,
            this,
            NumResources,
            ppResources,
            Priority);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<IDXGIDevice2>()->OfferResources(
            NumResources,
            UnwrapObjects<IDXGIResource>(ppResources, NumResources, unwrap_memory),
            Priority);

        Encode_IDXGIDevice2_OfferResources(
            this,
            result,
            NumResources,
            ppResources,
            Priority);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDevice2_OfferResources>::Dispatch(
            manager,
            this,
            result,
            NumResources,
            ppResources,
            Priority);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDevice2>()->OfferResources(
            NumResources,
            ppResources,
            Priority);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDevice2_Wrapper::ReclaimResources(
    UINT NumResources,
    IDXGIResource* const* ppResources,
    BOOL* pDiscarded)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDevice2_ReclaimResources>::Dispatch(
            manager,
            this,
            NumResources,
            ppResources,
            pDiscarded);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<IDXGIDevice2>()->ReclaimResources(
            NumResources,
            UnwrapObjects<IDXGIResource>(ppResources, NumResources, unwrap_memory),
            pDiscarded);

        Encode_IDXGIDevice2_ReclaimResources(
            this,
            result,
            NumResources,
            ppResources,
            pDiscarded);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDevice2_ReclaimResources>::Dispatch(
            manager,
            this,
            result,
            NumResources,
            ppResources,
            pDiscarded);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDevice2>()->ReclaimResources(
            NumResources,
            ppResources,
            pDiscarded);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDevice2_Wrapper::EnqueueSetEvent(
    HANDLE hEvent)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDevice2_EnqueueSetEvent>::Dispatch(
            manager,
            this,
            hEvent);

        result = GetWrappedObjectAs<IDXGIDevice2>()->EnqueueSetEvent(
            hEvent);

        Encode_IDXGIDevice2_EnqueueSetEvent(
            this,
            result,
            hEvent);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDevice2_EnqueueSetEvent>::Dispatch(
            manager,
            this,
            result,
            hEvent);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDevice2>()->EnqueueSetEvent(
            hEvent);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGISwapChain1_Wrapper::IDXGISwapChain1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGISwapChain_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain1_Wrapper::GetDesc1(
    DXGI_SWAP_CHAIN_DESC1* pDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain1_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc);

        result = GetWrappedObjectAs<IDXGISwapChain1>()->GetDesc1(
            pDesc);

        Encode_IDXGISwapChain1_GetDesc1(
            this,
            result,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain1_GetDesc1>::Dispatch(
            manager,
            this,
            result,
            pDesc);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain1>()->GetDesc1(
            pDesc);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain1_Wrapper::GetFullscreenDesc(
    DXGI_SWAP_CHAIN_FULLSCREEN_DESC* pDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain1_GetFullscreenDesc>::Dispatch(
            manager,
            this,
            pDesc);

        result = GetWrappedObjectAs<IDXGISwapChain1>()->GetFullscreenDesc(
            pDesc);

        Encode_IDXGISwapChain1_GetFullscreenDesc(
            this,
            result,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain1_GetFullscreenDesc>::Dispatch(
            manager,
            this,
            result,
            pDesc);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain1>()->GetFullscreenDesc(
            pDesc);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain1_Wrapper::GetHwnd(
    HWND* pHwnd)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain1_GetHwnd>::Dispatch(
            manager,
            this,
            pHwnd);

        result = GetWrappedObjectAs<IDXGISwapChain1>()->GetHwnd(
            pHwnd);

        Encode_IDXGISwapChain1_GetHwnd(
            this,
            result,
            pHwnd);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain1_GetHwnd>::Dispatch(
            manager,
            this,
            result,
            pHwnd);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain1>()->GetHwnd(
            pHwnd);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain1_Wrapper::GetCoreWindow(
    REFIID refiid,
    void** ppUnk)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain1_GetCoreWindow>::Dispatch(
            manager,
            this,
            refiid,
            ppUnk);

        result = GetWrappedObjectAs<IDXGISwapChain1>()->GetCoreWindow(
            refiid,
            ppUnk);

        if (SUCCEEDED(result))
        {
            WrapObject(refiid, ppUnk, nullptr);
        }

        Encode_IDXGISwapChain1_GetCoreWindow(
            this,
            result,
            refiid,
            ppUnk);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain1_GetCoreWindow>::Dispatch(
            manager,
            this,
            result,
            refiid,
            ppUnk);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain1>()->GetCoreWindow(
            refiid,
            ppUnk);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain1_Wrapper::Present1(
    UINT SyncInterval,
    UINT PresentFlags,
    const DXGI_PRESENT_PARAMETERS* pPresentParameters)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain1_Present1>::Dispatch(
            manager,
            this,
            SyncInterval,
            PresentFlags,
            pPresentParameters);

        result = GetWrappedObjectAs<IDXGISwapChain1>()->Present1(
            SyncInterval,
            PresentFlags,
            pPresentParameters);

        Encode_IDXGISwapChain1_Present1(
            this,
            result,
            SyncInterval,
            PresentFlags,
            pPresentParameters);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain1_Present1>::Dispatch(
            manager,
            shared_api_call_lock,
            this,
            result,
            SyncInterval,
            PresentFlags,
            pPresentParameters);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain1>()->Present1(
            SyncInterval,
            PresentFlags,
            pPresentParameters);
    }

    manager->DecrementCallScope();

    return result;
}

BOOL STDMETHODCALLTYPE IDXGISwapChain1_Wrapper::IsTemporaryMonoSupported()
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain1_IsTemporaryMonoSupported>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<IDXGISwapChain1>()->IsTemporaryMonoSupported();

        Encode_IDXGISwapChain1_IsTemporaryMonoSupported(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain1_IsTemporaryMonoSupported>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain1>()->IsTemporaryMonoSupported();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain1_Wrapper::GetRestrictToOutput(
    IDXGIOutput** ppRestrictToOutput)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain1_GetRestrictToOutput>::Dispatch(
            manager,
            this,
            ppRestrictToOutput);

        result = GetWrappedObjectAs<IDXGISwapChain1>()->GetRestrictToOutput(
            ppRestrictToOutput);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGIOutput, reinterpret_cast<void**>(ppRestrictToOutput), nullptr);
        }

        Encode_IDXGISwapChain1_GetRestrictToOutput(
            this,
            result,
            ppRestrictToOutput);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain1_GetRestrictToOutput>::Dispatch(
            manager,
            this,
            result,
            ppRestrictToOutput);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain1>()->GetRestrictToOutput(
            ppRestrictToOutput);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain1_Wrapper::SetBackgroundColor(
    const DXGI_RGBA* pColor)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain1_SetBackgroundColor>::Dispatch(
            manager,
            this,
            pColor);

        result = GetWrappedObjectAs<IDXGISwapChain1>()->SetBackgroundColor(
            pColor);

        Encode_IDXGISwapChain1_SetBackgroundColor(
            this,
            result,
            pColor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain1_SetBackgroundColor>::Dispatch(
            manager,
            this,
            result,
            pColor);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain1>()->SetBackgroundColor(
            pColor);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain1_Wrapper::GetBackgroundColor(
    DXGI_RGBA* pColor)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain1_GetBackgroundColor>::Dispatch(
            manager,
            this,
            pColor);

        result = GetWrappedObjectAs<IDXGISwapChain1>()->GetBackgroundColor(
            pColor);

        Encode_IDXGISwapChain1_GetBackgroundColor(
            this,
            result,
            pColor);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain1_GetBackgroundColor>::Dispatch(
            manager,
            this,
            result,
            pColor);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain1>()->GetBackgroundColor(
            pColor);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain1_Wrapper::SetRotation(
    DXGI_MODE_ROTATION Rotation)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain1_SetRotation>::Dispatch(
            manager,
            this,
            Rotation);

        result = GetWrappedObjectAs<IDXGISwapChain1>()->SetRotation(
            Rotation);

        Encode_IDXGISwapChain1_SetRotation(
            this,
            result,
            Rotation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain1_SetRotation>::Dispatch(
            manager,
            this,
            result,
            Rotation);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain1>()->SetRotation(
            Rotation);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain1_Wrapper::GetRotation(
    DXGI_MODE_ROTATION* pRotation)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain1_GetRotation>::Dispatch(
            manager,
            this,
            pRotation);

        result = GetWrappedObjectAs<IDXGISwapChain1>()->GetRotation(
            pRotation);

        Encode_IDXGISwapChain1_GetRotation(
            this,
            result,
            pRotation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain1_GetRotation>::Dispatch(
            manager,
            this,
            result,
            pRotation);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain1>()->GetRotation(
            pRotation);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIFactory2_Wrapper::IDXGIFactory2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIFactory1_Wrapper(riid, object, resources, destructor)
{
}

BOOL STDMETHODCALLTYPE IDXGIFactory2_Wrapper::IsWindowedStereoEnabled()
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory2_IsWindowedStereoEnabled>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<IDXGIFactory2>()->IsWindowedStereoEnabled();

        Encode_IDXGIFactory2_IsWindowedStereoEnabled(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory2_IsWindowedStereoEnabled>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory2>()->IsWindowedStereoEnabled();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIFactory2_Wrapper::CreateSwapChainForHwnd(
    IUnknown* pDevice,
    HWND hWnd,
    const DXGI_SWAP_CHAIN_DESC1* pDesc,
    const DXGI_SWAP_CHAIN_FULLSCREEN_DESC* pFullscreenDesc,
    IDXGIOutput* pRestrictToOutput,
    IDXGISwapChain1** ppSwapChain)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory2_CreateSwapChainForHwnd>::Dispatch(
            manager,
            this,
            pDevice,
            hWnd,
            pDesc,
            pFullscreenDesc,
            pRestrictToOutput,
            ppSwapChain);

        result = D3D12CaptureManager::Get()->OverrideIDXGIFactory2_CreateSwapChainForHwnd(
            this,
            pDevice,
            hWnd,
            pDesc,
            pFullscreenDesc,
            pRestrictToOutput,
            ppSwapChain);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGISwapChain1, reinterpret_cast<void**>(ppSwapChain), nullptr);
        }

        Encode_IDXGIFactory2_CreateSwapChainForHwnd(
            this,
            result,
            pDevice,
            hWnd,
            pDesc,
            pFullscreenDesc,
            pRestrictToOutput,
            ppSwapChain);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory2_CreateSwapChainForHwnd>::Dispatch(
            manager,
            this,
            result,
            pDevice,
            hWnd,
            pDesc,
            pFullscreenDesc,
            pRestrictToOutput,
            ppSwapChain);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory2>()->CreateSwapChainForHwnd(
            pDevice,
            hWnd,
            pDesc,
            pFullscreenDesc,
            pRestrictToOutput,
            ppSwapChain);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIFactory2_Wrapper::CreateSwapChainForCoreWindow(
    IUnknown* pDevice,
    IUnknown* pWindow,
    const DXGI_SWAP_CHAIN_DESC1* pDesc,
    IDXGIOutput* pRestrictToOutput,
    IDXGISwapChain1** ppSwapChain)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory2_CreateSwapChainForCoreWindow>::Dispatch(
            manager,
            this,
            pDevice,
            pWindow,
            pDesc,
            pRestrictToOutput,
            ppSwapChain);

        result = D3D12CaptureManager::Get()->OverrideIDXGIFactory2_CreateSwapChainForCoreWindow(
            this,
            pDevice,
            pWindow,
            pDesc,
            pRestrictToOutput,
            ppSwapChain);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGISwapChain1, reinterpret_cast<void**>(ppSwapChain), nullptr);
        }

        Encode_IDXGIFactory2_CreateSwapChainForCoreWindow(
            this,
            result,
            pDevice,
            pWindow,
            pDesc,
            pRestrictToOutput,
            ppSwapChain);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory2_CreateSwapChainForCoreWindow>::Dispatch(
            manager,
            this,
            result,
            pDevice,
            pWindow,
            pDesc,
            pRestrictToOutput,
            ppSwapChain);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory2>()->CreateSwapChainForCoreWindow(
            pDevice,
            pWindow,
            pDesc,
            pRestrictToOutput,
            ppSwapChain);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIFactory2_Wrapper::GetSharedResourceAdapterLuid(
    HANDLE hResource,
    LUID* pLuid)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory2_GetSharedResourceAdapterLuid>::Dispatch(
            manager,
            this,
            hResource,
            pLuid);

        result = GetWrappedObjectAs<IDXGIFactory2>()->GetSharedResourceAdapterLuid(
            hResource,
            pLuid);

        Encode_IDXGIFactory2_GetSharedResourceAdapterLuid(
            this,
            result,
            hResource,
            pLuid);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory2_GetSharedResourceAdapterLuid>::Dispatch(
            manager,
            this,
            result,
            hResource,
            pLuid);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory2>()->GetSharedResourceAdapterLuid(
            hResource,
            pLuid);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIFactory2_Wrapper::RegisterStereoStatusWindow(
    HWND WindowHandle,
    UINT wMsg,
    DWORD* pdwCookie)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory2_RegisterStereoStatusWindow>::Dispatch(
            manager,
            this,
            WindowHandle,
            wMsg,
            pdwCookie);

        result = GetWrappedObjectAs<IDXGIFactory2>()->RegisterStereoStatusWindow(
            WindowHandle,
            wMsg,
            pdwCookie);

        Encode_IDXGIFactory2_RegisterStereoStatusWindow(
            this,
            result,
            WindowHandle,
            wMsg,
            pdwCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory2_RegisterStereoStatusWindow>::Dispatch(
            manager,
            this,
            result,
            WindowHandle,
            wMsg,
            pdwCookie);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory2>()->RegisterStereoStatusWindow(
            WindowHandle,
            wMsg,
            pdwCookie);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIFactory2_Wrapper::RegisterStereoStatusEvent(
    HANDLE hEvent,
    DWORD* pdwCookie)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory2_RegisterStereoStatusEvent>::Dispatch(
            manager,
            this,
            hEvent,
            pdwCookie);

        result = GetWrappedObjectAs<IDXGIFactory2>()->RegisterStereoStatusEvent(
            hEvent,
            pdwCookie);

        Encode_IDXGIFactory2_RegisterStereoStatusEvent(
            this,
            result,
            hEvent,
            pdwCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory2_RegisterStereoStatusEvent>::Dispatch(
            manager,
            this,
            result,
            hEvent,
            pdwCookie);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory2>()->RegisterStereoStatusEvent(
            hEvent,
            pdwCookie);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE IDXGIFactory2_Wrapper::UnregisterStereoStatus(
    DWORD dwCookie)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory2_UnregisterStereoStatus>::Dispatch(
            manager,
            this,
            dwCookie);

        GetWrappedObjectAs<IDXGIFactory2>()->UnregisterStereoStatus(
            dwCookie);

        Encode_IDXGIFactory2_UnregisterStereoStatus(
            this,
            dwCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory2_UnregisterStereoStatus>::Dispatch(
            manager,
            this,
            dwCookie);
    }
    else
    {
        GetWrappedObjectAs<IDXGIFactory2>()->UnregisterStereoStatus(
            dwCookie);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE IDXGIFactory2_Wrapper::RegisterOcclusionStatusWindow(
    HWND WindowHandle,
    UINT wMsg,
    DWORD* pdwCookie)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory2_RegisterOcclusionStatusWindow>::Dispatch(
            manager,
            this,
            WindowHandle,
            wMsg,
            pdwCookie);

        result = GetWrappedObjectAs<IDXGIFactory2>()->RegisterOcclusionStatusWindow(
            WindowHandle,
            wMsg,
            pdwCookie);

        Encode_IDXGIFactory2_RegisterOcclusionStatusWindow(
            this,
            result,
            WindowHandle,
            wMsg,
            pdwCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory2_RegisterOcclusionStatusWindow>::Dispatch(
            manager,
            this,
            result,
            WindowHandle,
            wMsg,
            pdwCookie);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory2>()->RegisterOcclusionStatusWindow(
            WindowHandle,
            wMsg,
            pdwCookie);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIFactory2_Wrapper::RegisterOcclusionStatusEvent(
    HANDLE hEvent,
    DWORD* pdwCookie)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory2_RegisterOcclusionStatusEvent>::Dispatch(
            manager,
            this,
            hEvent,
            pdwCookie);

        result = GetWrappedObjectAs<IDXGIFactory2>()->RegisterOcclusionStatusEvent(
            hEvent,
            pdwCookie);

        Encode_IDXGIFactory2_RegisterOcclusionStatusEvent(
            this,
            result,
            hEvent,
            pdwCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory2_RegisterOcclusionStatusEvent>::Dispatch(
            manager,
            this,
            result,
            hEvent,
            pdwCookie);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory2>()->RegisterOcclusionStatusEvent(
            hEvent,
            pdwCookie);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE IDXGIFactory2_Wrapper::UnregisterOcclusionStatus(
    DWORD dwCookie)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory2_UnregisterOcclusionStatus>::Dispatch(
            manager,
            this,
            dwCookie);

        GetWrappedObjectAs<IDXGIFactory2>()->UnregisterOcclusionStatus(
            dwCookie);

        Encode_IDXGIFactory2_UnregisterOcclusionStatus(
            this,
            dwCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory2_UnregisterOcclusionStatus>::Dispatch(
            manager,
            this,
            dwCookie);
    }
    else
    {
        GetWrappedObjectAs<IDXGIFactory2>()->UnregisterOcclusionStatus(
            dwCookie);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE IDXGIFactory2_Wrapper::CreateSwapChainForComposition(
    IUnknown* pDevice,
    const DXGI_SWAP_CHAIN_DESC1* pDesc,
    IDXGIOutput* pRestrictToOutput,
    IDXGISwapChain1** ppSwapChain)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory2_CreateSwapChainForComposition>::Dispatch(
            manager,
            this,
            pDevice,
            pDesc,
            pRestrictToOutput,
            ppSwapChain);

        result = D3D12CaptureManager::Get()->OverrideIDXGIFactory2_CreateSwapChainForComposition(
            this,
            pDevice,
            pDesc,
            pRestrictToOutput,
            ppSwapChain);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGISwapChain1, reinterpret_cast<void**>(ppSwapChain), nullptr);
        }

        Encode_IDXGIFactory2_CreateSwapChainForComposition(
            this,
            result,
            pDevice,
            pDesc,
            pRestrictToOutput,
            ppSwapChain);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory2_CreateSwapChainForComposition>::Dispatch(
            manager,
            this,
            result,
            pDevice,
            pDesc,
            pRestrictToOutput,
            ppSwapChain);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory2>()->CreateSwapChainForComposition(
            pDevice,
            pDesc,
            pRestrictToOutput,
            ppSwapChain);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIAdapter2_Wrapper::IDXGIAdapter2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIAdapter1_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIAdapter2_Wrapper::GetDesc2(
    DXGI_ADAPTER_DESC2* pDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIAdapter2_GetDesc2>::Dispatch(
            manager,
            this,
            pDesc);

        result = GetWrappedObjectAs<IDXGIAdapter2>()->GetDesc2(
            pDesc);

        Encode_IDXGIAdapter2_GetDesc2(
            this,
            result,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIAdapter2_GetDesc2>::Dispatch(
            manager,
            this,
            result,
            pDesc);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIAdapter2>()->GetDesc2(
            pDesc);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIOutput1_Wrapper::IDXGIOutput1_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIOutput_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIOutput1_Wrapper::GetDisplayModeList1(
    DXGI_FORMAT EnumFormat,
    UINT Flags,
    UINT* pNumModes,
    DXGI_MODE_DESC1* pDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput1_GetDisplayModeList1>::Dispatch(
            manager,
            this,
            EnumFormat,
            Flags,
            pNumModes,
            pDesc);

        result = GetWrappedObjectAs<IDXGIOutput1>()->GetDisplayModeList1(
            EnumFormat,
            Flags,
            pNumModes,
            pDesc);

        Encode_IDXGIOutput1_GetDisplayModeList1(
            this,
            result,
            EnumFormat,
            Flags,
            pNumModes,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput1_GetDisplayModeList1>::Dispatch(
            manager,
            this,
            result,
            EnumFormat,
            Flags,
            pNumModes,
            pDesc);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput1>()->GetDisplayModeList1(
            EnumFormat,
            Flags,
            pNumModes,
            pDesc);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutput1_Wrapper::FindClosestMatchingMode1(
    const DXGI_MODE_DESC1* pModeToMatch,
    DXGI_MODE_DESC1* pClosestMatch,
    IUnknown* pConcernedDevice)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput1_FindClosestMatchingMode1>::Dispatch(
            manager,
            this,
            pModeToMatch,
            pClosestMatch,
            pConcernedDevice);

        result = GetWrappedObjectAs<IDXGIOutput1>()->FindClosestMatchingMode1(
            pModeToMatch,
            pClosestMatch,
            encode::GetWrappedObject<IUnknown>(pConcernedDevice));

        Encode_IDXGIOutput1_FindClosestMatchingMode1(
            this,
            result,
            pModeToMatch,
            pClosestMatch,
            pConcernedDevice);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput1_FindClosestMatchingMode1>::Dispatch(
            manager,
            this,
            result,
            pModeToMatch,
            pClosestMatch,
            pConcernedDevice);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput1>()->FindClosestMatchingMode1(
            pModeToMatch,
            pClosestMatch,
            pConcernedDevice);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutput1_Wrapper::GetDisplaySurfaceData1(
    IDXGIResource* pDestination)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput1_GetDisplaySurfaceData1>::Dispatch(
            manager,
            this,
            pDestination);

        result = GetWrappedObjectAs<IDXGIOutput1>()->GetDisplaySurfaceData1(
            encode::GetWrappedObject<IDXGIResource>(pDestination));

        Encode_IDXGIOutput1_GetDisplaySurfaceData1(
            this,
            result,
            pDestination);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput1_GetDisplaySurfaceData1>::Dispatch(
            manager,
            this,
            result,
            pDestination);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput1>()->GetDisplaySurfaceData1(
            pDestination);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutput1_Wrapper::DuplicateOutput(
    IUnknown* pDevice,
    IDXGIOutputDuplication** ppOutputDuplication)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput1_DuplicateOutput>::Dispatch(
            manager,
            this,
            pDevice,
            ppOutputDuplication);

        result = GetWrappedObjectAs<IDXGIOutput1>()->DuplicateOutput(
            encode::GetWrappedObject<IUnknown>(pDevice),
            ppOutputDuplication);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGIOutputDuplication, reinterpret_cast<void**>(ppOutputDuplication), nullptr);
        }

        Encode_IDXGIOutput1_DuplicateOutput(
            this,
            result,
            pDevice,
            ppOutputDuplication);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput1_DuplicateOutput>::Dispatch(
            manager,
            this,
            result,
            pDevice,
            ppOutputDuplication);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput1>()->DuplicateOutput(
            pDevice,
            ppOutputDuplication);
    }

    manager->DecrementCallScope();

    return result;
}


/*
** This part is generated from dxgi1_3.h in Windows SDK: 10.0.20348.0
**
*/

HRESULT WINAPI CreateDXGIFactory2(
    UINT Flags,
    REFIID riid,
    void** ppFactory)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_CreateDXGIFactory2>::Dispatch(
            manager,
            Flags,
            riid,
            ppFactory);

        result = D3D12CaptureManager::Get()->OverrideCreateDXGIFactory2(
            Flags,
            riid,
            ppFactory);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppFactory, nullptr);
        }

        Encode_CreateDXGIFactory2(
            result,
            Flags,
            riid,
            ppFactory);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_CreateDXGIFactory2>::Dispatch(
            manager,
            result,
            Flags,
            riid,
            ppFactory);
    }
    else
    {
        result = manager->GetDxgiDispatchTable().CreateDXGIFactory2(
            Flags,
            riid,
            ppFactory);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT WINAPI DXGIGetDebugInterface1(
    UINT Flags,
    REFIID riid,
    void** pDebug)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_DXGIGetDebugInterface1>::Dispatch(
            manager,
            Flags,
            riid,
            pDebug);

        result = manager->GetDxgiDispatchTable().DXGIGetDebugInterface1(
            Flags,
            riid,
            pDebug);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, pDebug, nullptr);
        }

        Encode_DXGIGetDebugInterface1(
            result,
            Flags,
            riid,
            pDebug);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_DXGIGetDebugInterface1>::Dispatch(
            manager,
            result,
            Flags,
            riid,
            pDebug);
    }
    else
    {
        result = manager->GetDxgiDispatchTable().DXGIGetDebugInterface1(
            Flags,
            riid,
            pDebug);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIDevice3_Wrapper::IDXGIDevice3_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIDevice2_Wrapper(riid, object, resources, destructor)
{
}

void STDMETHODCALLTYPE IDXGIDevice3_Wrapper::Trim()
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDevice3_Trim>::Dispatch(
            manager,
            this);

        GetWrappedObjectAs<IDXGIDevice3>()->Trim();

        Encode_IDXGIDevice3_Trim(
            this);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDevice3_Trim>::Dispatch(
            manager,
            this);
    }
    else
    {
        GetWrappedObjectAs<IDXGIDevice3>()->Trim();
    }

    manager->DecrementCallScope();
}

IDXGISwapChain2_Wrapper::IDXGISwapChain2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGISwapChain1_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain2_Wrapper::SetSourceSize(
    UINT Width,
    UINT Height)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain2_SetSourceSize>::Dispatch(
            manager,
            this,
            Width,
            Height);

        result = GetWrappedObjectAs<IDXGISwapChain2>()->SetSourceSize(
            Width,
            Height);

        Encode_IDXGISwapChain2_SetSourceSize(
            this,
            result,
            Width,
            Height);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain2_SetSourceSize>::Dispatch(
            manager,
            this,
            result,
            Width,
            Height);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain2>()->SetSourceSize(
            Width,
            Height);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain2_Wrapper::GetSourceSize(
    UINT* pWidth,
    UINT* pHeight)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain2_GetSourceSize>::Dispatch(
            manager,
            this,
            pWidth,
            pHeight);

        result = GetWrappedObjectAs<IDXGISwapChain2>()->GetSourceSize(
            pWidth,
            pHeight);

        Encode_IDXGISwapChain2_GetSourceSize(
            this,
            result,
            pWidth,
            pHeight);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain2_GetSourceSize>::Dispatch(
            manager,
            this,
            result,
            pWidth,
            pHeight);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain2>()->GetSourceSize(
            pWidth,
            pHeight);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain2_Wrapper::SetMaximumFrameLatency(
    UINT MaxLatency)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain2_SetMaximumFrameLatency>::Dispatch(
            manager,
            this,
            MaxLatency);

        result = GetWrappedObjectAs<IDXGISwapChain2>()->SetMaximumFrameLatency(
            MaxLatency);

        Encode_IDXGISwapChain2_SetMaximumFrameLatency(
            this,
            result,
            MaxLatency);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain2_SetMaximumFrameLatency>::Dispatch(
            manager,
            this,
            result,
            MaxLatency);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain2>()->SetMaximumFrameLatency(
            MaxLatency);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain2_Wrapper::GetMaximumFrameLatency(
    UINT* pMaxLatency)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain2_GetMaximumFrameLatency>::Dispatch(
            manager,
            this,
            pMaxLatency);

        result = GetWrappedObjectAs<IDXGISwapChain2>()->GetMaximumFrameLatency(
            pMaxLatency);

        Encode_IDXGISwapChain2_GetMaximumFrameLatency(
            this,
            result,
            pMaxLatency);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain2_GetMaximumFrameLatency>::Dispatch(
            manager,
            this,
            result,
            pMaxLatency);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain2>()->GetMaximumFrameLatency(
            pMaxLatency);
    }

    manager->DecrementCallScope();

    return result;
}

HANDLE STDMETHODCALLTYPE IDXGISwapChain2_Wrapper::GetFrameLatencyWaitableObject()
{
    HANDLE result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain2_GetFrameLatencyWaitableObject>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<IDXGISwapChain2>()->GetFrameLatencyWaitableObject();

        Encode_IDXGISwapChain2_GetFrameLatencyWaitableObject(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain2_GetFrameLatencyWaitableObject>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain2>()->GetFrameLatencyWaitableObject();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain2_Wrapper::SetMatrixTransform(
    const DXGI_MATRIX_3X2_F* pMatrix)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain2_SetMatrixTransform>::Dispatch(
            manager,
            this,
            pMatrix);

        result = GetWrappedObjectAs<IDXGISwapChain2>()->SetMatrixTransform(
            pMatrix);

        Encode_IDXGISwapChain2_SetMatrixTransform(
            this,
            result,
            pMatrix);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain2_SetMatrixTransform>::Dispatch(
            manager,
            this,
            result,
            pMatrix);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain2>()->SetMatrixTransform(
            pMatrix);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain2_Wrapper::GetMatrixTransform(
    DXGI_MATRIX_3X2_F* pMatrix)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain2_GetMatrixTransform>::Dispatch(
            manager,
            this,
            pMatrix);

        result = GetWrappedObjectAs<IDXGISwapChain2>()->GetMatrixTransform(
            pMatrix);

        Encode_IDXGISwapChain2_GetMatrixTransform(
            this,
            result,
            pMatrix);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain2_GetMatrixTransform>::Dispatch(
            manager,
            this,
            result,
            pMatrix);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain2>()->GetMatrixTransform(
            pMatrix);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIOutput2_Wrapper::IDXGIOutput2_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIOutput1_Wrapper(riid, object, resources, destructor)
{
}

BOOL STDMETHODCALLTYPE IDXGIOutput2_Wrapper::SupportsOverlays()
{
    BOOL result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput2_SupportsOverlays>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<IDXGIOutput2>()->SupportsOverlays();

        Encode_IDXGIOutput2_SupportsOverlays(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput2_SupportsOverlays>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput2>()->SupportsOverlays();
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIFactory3_Wrapper::IDXGIFactory3_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIFactory2_Wrapper(riid, object, resources, destructor)
{
}

UINT STDMETHODCALLTYPE IDXGIFactory3_Wrapper::GetCreationFlags()
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory3_GetCreationFlags>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<IDXGIFactory3>()->GetCreationFlags();

        Encode_IDXGIFactory3_GetCreationFlags(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory3_GetCreationFlags>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory3>()->GetCreationFlags();
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIDecodeSwapChain_Wrapper::IDXGIDecodeSwapChain_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<IDXGIDecodeSwapChainInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

IDXGIDecodeSwapChain_Wrapper::~IDXGIDecodeSwapChain_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<IDXGIDecodeSwapChain>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

IDXGIDecodeSwapChain_Wrapper* IDXGIDecodeSwapChain_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<IDXGIDecodeSwapChain_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE IDXGIDecodeSwapChain_Wrapper::PresentBuffer(
    UINT BufferToPresent,
    UINT SyncInterval,
    UINT Flags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_PresentBuffer>::Dispatch(
            manager,
            this,
            BufferToPresent,
            SyncInterval,
            Flags);

        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->PresentBuffer(
            BufferToPresent,
            SyncInterval,
            Flags);

        Encode_IDXGIDecodeSwapChain_PresentBuffer(
            this,
            result,
            BufferToPresent,
            SyncInterval,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_PresentBuffer>::Dispatch(
            manager,
            this,
            result,
            BufferToPresent,
            SyncInterval,
            Flags);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->PresentBuffer(
            BufferToPresent,
            SyncInterval,
            Flags);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDecodeSwapChain_Wrapper::SetSourceRect(
    const RECT* pRect)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_SetSourceRect>::Dispatch(
            manager,
            this,
            pRect);

        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->SetSourceRect(
            pRect);

        Encode_IDXGIDecodeSwapChain_SetSourceRect(
            this,
            result,
            pRect);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_SetSourceRect>::Dispatch(
            manager,
            this,
            result,
            pRect);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->SetSourceRect(
            pRect);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDecodeSwapChain_Wrapper::SetTargetRect(
    const RECT* pRect)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_SetTargetRect>::Dispatch(
            manager,
            this,
            pRect);

        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->SetTargetRect(
            pRect);

        Encode_IDXGIDecodeSwapChain_SetTargetRect(
            this,
            result,
            pRect);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_SetTargetRect>::Dispatch(
            manager,
            this,
            result,
            pRect);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->SetTargetRect(
            pRect);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDecodeSwapChain_Wrapper::SetDestSize(
    UINT Width,
    UINT Height)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_SetDestSize>::Dispatch(
            manager,
            this,
            Width,
            Height);

        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->SetDestSize(
            Width,
            Height);

        Encode_IDXGIDecodeSwapChain_SetDestSize(
            this,
            result,
            Width,
            Height);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_SetDestSize>::Dispatch(
            manager,
            this,
            result,
            Width,
            Height);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->SetDestSize(
            Width,
            Height);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDecodeSwapChain_Wrapper::GetSourceRect(
    RECT* pRect)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_GetSourceRect>::Dispatch(
            manager,
            this,
            pRect);

        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->GetSourceRect(
            pRect);

        Encode_IDXGIDecodeSwapChain_GetSourceRect(
            this,
            result,
            pRect);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_GetSourceRect>::Dispatch(
            manager,
            this,
            result,
            pRect);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->GetSourceRect(
            pRect);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDecodeSwapChain_Wrapper::GetTargetRect(
    RECT* pRect)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_GetTargetRect>::Dispatch(
            manager,
            this,
            pRect);

        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->GetTargetRect(
            pRect);

        Encode_IDXGIDecodeSwapChain_GetTargetRect(
            this,
            result,
            pRect);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_GetTargetRect>::Dispatch(
            manager,
            this,
            result,
            pRect);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->GetTargetRect(
            pRect);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDecodeSwapChain_Wrapper::GetDestSize(
    UINT* pWidth,
    UINT* pHeight)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_GetDestSize>::Dispatch(
            manager,
            this,
            pWidth,
            pHeight);

        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->GetDestSize(
            pWidth,
            pHeight);

        Encode_IDXGIDecodeSwapChain_GetDestSize(
            this,
            result,
            pWidth,
            pHeight);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_GetDestSize>::Dispatch(
            manager,
            this,
            result,
            pWidth,
            pHeight);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->GetDestSize(
            pWidth,
            pHeight);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDecodeSwapChain_Wrapper::SetColorSpace(
    DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS ColorSpace)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_SetColorSpace>::Dispatch(
            manager,
            this,
            ColorSpace);

        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->SetColorSpace(
            ColorSpace);

        Encode_IDXGIDecodeSwapChain_SetColorSpace(
            this,
            result,
            ColorSpace);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_SetColorSpace>::Dispatch(
            manager,
            this,
            result,
            ColorSpace);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->SetColorSpace(
            ColorSpace);
    }

    manager->DecrementCallScope();

    return result;
}

DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS STDMETHODCALLTYPE IDXGIDecodeSwapChain_Wrapper::GetColorSpace()
{
    DXGI_MULTIPLANE_OVERLAY_YCbCr_FLAGS result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_GetColorSpace>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->GetColorSpace();

        Encode_IDXGIDecodeSwapChain_GetColorSpace(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDecodeSwapChain_GetColorSpace>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDecodeSwapChain>()->GetColorSpace();
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIFactoryMedia_Wrapper::IDXGIFactoryMedia_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<IDXGIFactoryMediaInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

IDXGIFactoryMedia_Wrapper::~IDXGIFactoryMedia_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<IDXGIFactoryMedia>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

IDXGIFactoryMedia_Wrapper* IDXGIFactoryMedia_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<IDXGIFactoryMedia_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE IDXGIFactoryMedia_Wrapper::CreateSwapChainForCompositionSurfaceHandle(
    IUnknown* pDevice,
    HANDLE hSurface,
    const DXGI_SWAP_CHAIN_DESC1* pDesc,
    IDXGIOutput* pRestrictToOutput,
    IDXGISwapChain1** ppSwapChain)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactoryMedia_CreateSwapChainForCompositionSurfaceHandle>::Dispatch(
            manager,
            this,
            pDevice,
            hSurface,
            pDesc,
            pRestrictToOutput,
            ppSwapChain);

        result = GetWrappedObjectAs<IDXGIFactoryMedia>()->CreateSwapChainForCompositionSurfaceHandle(
            encode::GetWrappedObject<IUnknown>(pDevice),
            hSurface,
            pDesc,
            encode::GetWrappedObject<IDXGIOutput>(pRestrictToOutput),
            ppSwapChain);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGISwapChain1, reinterpret_cast<void**>(ppSwapChain), nullptr);
        }

        Encode_IDXGIFactoryMedia_CreateSwapChainForCompositionSurfaceHandle(
            this,
            result,
            pDevice,
            hSurface,
            pDesc,
            pRestrictToOutput,
            ppSwapChain);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactoryMedia_CreateSwapChainForCompositionSurfaceHandle>::Dispatch(
            manager,
            this,
            result,
            pDevice,
            hSurface,
            pDesc,
            pRestrictToOutput,
            ppSwapChain);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactoryMedia>()->CreateSwapChainForCompositionSurfaceHandle(
            pDevice,
            hSurface,
            pDesc,
            pRestrictToOutput,
            ppSwapChain);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIFactoryMedia_Wrapper::CreateDecodeSwapChainForCompositionSurfaceHandle(
    IUnknown* pDevice,
    HANDLE hSurface,
    DXGI_DECODE_SWAP_CHAIN_DESC* pDesc,
    IDXGIResource* pYuvDecodeBuffers,
    IDXGIOutput* pRestrictToOutput,
    IDXGIDecodeSwapChain** ppSwapChain)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactoryMedia_CreateDecodeSwapChainForCompositionSurfaceHandle>::Dispatch(
            manager,
            this,
            pDevice,
            hSurface,
            pDesc,
            pYuvDecodeBuffers,
            pRestrictToOutput,
            ppSwapChain);

        result = GetWrappedObjectAs<IDXGIFactoryMedia>()->CreateDecodeSwapChainForCompositionSurfaceHandle(
            encode::GetWrappedObject<IUnknown>(pDevice),
            hSurface,
            pDesc,
            encode::GetWrappedObject<IDXGIResource>(pYuvDecodeBuffers),
            encode::GetWrappedObject<IDXGIOutput>(pRestrictToOutput),
            ppSwapChain);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGIDecodeSwapChain, reinterpret_cast<void**>(ppSwapChain), nullptr);
        }

        Encode_IDXGIFactoryMedia_CreateDecodeSwapChainForCompositionSurfaceHandle(
            this,
            result,
            pDevice,
            hSurface,
            pDesc,
            pYuvDecodeBuffers,
            pRestrictToOutput,
            ppSwapChain);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactoryMedia_CreateDecodeSwapChainForCompositionSurfaceHandle>::Dispatch(
            manager,
            this,
            result,
            pDevice,
            hSurface,
            pDesc,
            pYuvDecodeBuffers,
            pRestrictToOutput,
            ppSwapChain);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactoryMedia>()->CreateDecodeSwapChainForCompositionSurfaceHandle(
            pDevice,
            hSurface,
            pDesc,
            pYuvDecodeBuffers,
            pRestrictToOutput,
            ppSwapChain);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGISwapChainMedia_Wrapper::IDXGISwapChainMedia_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IUnknown_Wrapper(riid, object, resources, destructor)
{
    info_ = std::make_shared<IDXGISwapChainMediaInfo>();
    info_->SetWrapper(this);
    AddWrapperMapEntry(object, this, object_map_, object_map_lock_);
}

IDXGISwapChainMedia_Wrapper::~IDXGISwapChainMedia_Wrapper()
{
    CustomWrapperDestroyCall(this);
    RemoveWrapperMapEntry(GetWrappedObjectAs<IDXGISwapChainMedia>(), object_map_, object_map_lock_);
    D3D12CaptureManager::Get()->ProcessWrapperDestroy(this);
    info_->SetWrapper(nullptr);
}

IDXGISwapChainMedia_Wrapper* IDXGISwapChainMedia_Wrapper::GetExistingWrapper(IUnknown* object)
{
    return FindMapEntry<IDXGISwapChainMedia_Wrapper>(object, object_map_, object_map_lock_);
}

HRESULT STDMETHODCALLTYPE IDXGISwapChainMedia_Wrapper::GetFrameStatisticsMedia(
    DXGI_FRAME_STATISTICS_MEDIA* pStats)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChainMedia_GetFrameStatisticsMedia>::Dispatch(
            manager,
            this,
            pStats);

        result = GetWrappedObjectAs<IDXGISwapChainMedia>()->GetFrameStatisticsMedia(
            pStats);

        Encode_IDXGISwapChainMedia_GetFrameStatisticsMedia(
            this,
            result,
            pStats);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChainMedia_GetFrameStatisticsMedia>::Dispatch(
            manager,
            this,
            result,
            pStats);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChainMedia>()->GetFrameStatisticsMedia(
            pStats);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChainMedia_Wrapper::SetPresentDuration(
    UINT Duration)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChainMedia_SetPresentDuration>::Dispatch(
            manager,
            this,
            Duration);

        result = GetWrappedObjectAs<IDXGISwapChainMedia>()->SetPresentDuration(
            Duration);

        Encode_IDXGISwapChainMedia_SetPresentDuration(
            this,
            result,
            Duration);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChainMedia_SetPresentDuration>::Dispatch(
            manager,
            this,
            result,
            Duration);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChainMedia>()->SetPresentDuration(
            Duration);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChainMedia_Wrapper::CheckPresentDurationSupport(
    UINT DesiredPresentDuration,
    UINT* pClosestSmallerPresentDuration,
    UINT* pClosestLargerPresentDuration)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChainMedia_CheckPresentDurationSupport>::Dispatch(
            manager,
            this,
            DesiredPresentDuration,
            pClosestSmallerPresentDuration,
            pClosestLargerPresentDuration);

        result = GetWrappedObjectAs<IDXGISwapChainMedia>()->CheckPresentDurationSupport(
            DesiredPresentDuration,
            pClosestSmallerPresentDuration,
            pClosestLargerPresentDuration);

        Encode_IDXGISwapChainMedia_CheckPresentDurationSupport(
            this,
            result,
            DesiredPresentDuration,
            pClosestSmallerPresentDuration,
            pClosestLargerPresentDuration);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChainMedia_CheckPresentDurationSupport>::Dispatch(
            manager,
            this,
            result,
            DesiredPresentDuration,
            pClosestSmallerPresentDuration,
            pClosestLargerPresentDuration);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChainMedia>()->CheckPresentDurationSupport(
            DesiredPresentDuration,
            pClosestSmallerPresentDuration,
            pClosestLargerPresentDuration);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIOutput3_Wrapper::IDXGIOutput3_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIOutput2_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIOutput3_Wrapper::CheckOverlaySupport(
    DXGI_FORMAT EnumFormat,
    IUnknown* pConcernedDevice,
    UINT* pFlags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput3_CheckOverlaySupport>::Dispatch(
            manager,
            this,
            EnumFormat,
            pConcernedDevice,
            pFlags);

        result = GetWrappedObjectAs<IDXGIOutput3>()->CheckOverlaySupport(
            EnumFormat,
            encode::GetWrappedObject<IUnknown>(pConcernedDevice),
            pFlags);

        Encode_IDXGIOutput3_CheckOverlaySupport(
            this,
            result,
            EnumFormat,
            pConcernedDevice,
            pFlags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput3_CheckOverlaySupport>::Dispatch(
            manager,
            this,
            result,
            EnumFormat,
            pConcernedDevice,
            pFlags);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput3>()->CheckOverlaySupport(
            EnumFormat,
            pConcernedDevice,
            pFlags);
    }

    manager->DecrementCallScope();

    return result;
}


/*
** This part is generated from dxgi1_4.h in Windows SDK: 10.0.20348.0
**
*/

IDXGISwapChain3_Wrapper::IDXGISwapChain3_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGISwapChain2_Wrapper(riid, object, resources, destructor)
{
}

UINT STDMETHODCALLTYPE IDXGISwapChain3_Wrapper::GetCurrentBackBufferIndex()
{
    UINT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain3_GetCurrentBackBufferIndex>::Dispatch(
            manager,
            this);

        result = GetWrappedObjectAs<IDXGISwapChain3>()->GetCurrentBackBufferIndex();

        Encode_IDXGISwapChain3_GetCurrentBackBufferIndex(
            this,
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain3_GetCurrentBackBufferIndex>::Dispatch(
            manager,
            this,
            result);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain3>()->GetCurrentBackBufferIndex();
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain3_Wrapper::CheckColorSpaceSupport(
    DXGI_COLOR_SPACE_TYPE ColorSpace,
    UINT* pColorSpaceSupport)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain3_CheckColorSpaceSupport>::Dispatch(
            manager,
            this,
            ColorSpace,
            pColorSpaceSupport);

        result = GetWrappedObjectAs<IDXGISwapChain3>()->CheckColorSpaceSupport(
            ColorSpace,
            pColorSpaceSupport);

        Encode_IDXGISwapChain3_CheckColorSpaceSupport(
            this,
            result,
            ColorSpace,
            pColorSpaceSupport);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain3_CheckColorSpaceSupport>::Dispatch(
            manager,
            this,
            result,
            ColorSpace,
            pColorSpaceSupport);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain3>()->CheckColorSpaceSupport(
            ColorSpace,
            pColorSpaceSupport);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain3_Wrapper::SetColorSpace1(
    DXGI_COLOR_SPACE_TYPE ColorSpace)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain3_SetColorSpace1>::Dispatch(
            manager,
            this,
            ColorSpace);

        result = GetWrappedObjectAs<IDXGISwapChain3>()->SetColorSpace1(
            ColorSpace);

        Encode_IDXGISwapChain3_SetColorSpace1(
            this,
            result,
            ColorSpace);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain3_SetColorSpace1>::Dispatch(
            manager,
            this,
            result,
            ColorSpace);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain3>()->SetColorSpace1(
            ColorSpace);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain3_Wrapper::ResizeBuffers1(
    UINT BufferCount,
    UINT Width,
    UINT Height,
    DXGI_FORMAT Format,
    UINT SwapChainFlags,
    const UINT* pCreationNodeMask,
    IUnknown* const* ppPresentQueue)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain3_ResizeBuffers1>::Dispatch(
            manager,
            this,
            BufferCount,
            Width,
            Height,
            Format,
            SwapChainFlags,
            pCreationNodeMask,
            ppPresentQueue);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<IDXGISwapChain3>()->ResizeBuffers1(
            BufferCount,
            Width,
            Height,
            Format,
            SwapChainFlags,
            pCreationNodeMask,
            UnwrapObjects<IUnknown>(ppPresentQueue, BufferCount, unwrap_memory));

        Encode_IDXGISwapChain3_ResizeBuffers1(
            this,
            result,
            BufferCount,
            Width,
            Height,
            Format,
            SwapChainFlags,
            pCreationNodeMask,
            ppPresentQueue);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain3_ResizeBuffers1>::Dispatch(
            manager,
            this,
            result,
            BufferCount,
            Width,
            Height,
            Format,
            SwapChainFlags,
            pCreationNodeMask,
            ppPresentQueue);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain3>()->ResizeBuffers1(
            BufferCount,
            Width,
            Height,
            Format,
            SwapChainFlags,
            pCreationNodeMask,
            ppPresentQueue);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIOutput4_Wrapper::IDXGIOutput4_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIOutput3_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIOutput4_Wrapper::CheckOverlayColorSpaceSupport(
    DXGI_FORMAT Format,
    DXGI_COLOR_SPACE_TYPE ColorSpace,
    IUnknown* pConcernedDevice,
    UINT* pFlags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput4_CheckOverlayColorSpaceSupport>::Dispatch(
            manager,
            this,
            Format,
            ColorSpace,
            pConcernedDevice,
            pFlags);

        result = GetWrappedObjectAs<IDXGIOutput4>()->CheckOverlayColorSpaceSupport(
            Format,
            ColorSpace,
            encode::GetWrappedObject<IUnknown>(pConcernedDevice),
            pFlags);

        Encode_IDXGIOutput4_CheckOverlayColorSpaceSupport(
            this,
            result,
            Format,
            ColorSpace,
            pConcernedDevice,
            pFlags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput4_CheckOverlayColorSpaceSupport>::Dispatch(
            manager,
            this,
            result,
            Format,
            ColorSpace,
            pConcernedDevice,
            pFlags);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput4>()->CheckOverlayColorSpaceSupport(
            Format,
            ColorSpace,
            pConcernedDevice,
            pFlags);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIFactory4_Wrapper::IDXGIFactory4_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIFactory3_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIFactory4_Wrapper::EnumAdapterByLuid(
    LUID AdapterLuid,
    REFIID riid,
    void** ppvAdapter)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory4_EnumAdapterByLuid>::Dispatch(
            manager,
            this,
            AdapterLuid,
            riid,
            ppvAdapter);

        result = GetWrappedObjectAs<IDXGIFactory4>()->EnumAdapterByLuid(
            AdapterLuid,
            riid,
            ppvAdapter);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvAdapter, nullptr);
        }

        Encode_IDXGIFactory4_EnumAdapterByLuid(
            this,
            result,
            AdapterLuid,
            riid,
            ppvAdapter);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory4_EnumAdapterByLuid>::Dispatch(
            manager,
            this,
            result,
            AdapterLuid,
            riid,
            ppvAdapter);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory4>()->EnumAdapterByLuid(
            AdapterLuid,
            riid,
            ppvAdapter);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIFactory4_Wrapper::EnumWarpAdapter(
    REFIID riid,
    void** ppvAdapter)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory4_EnumWarpAdapter>::Dispatch(
            manager,
            this,
            riid,
            ppvAdapter);

        result = GetWrappedObjectAs<IDXGIFactory4>()->EnumWarpAdapter(
            riid,
            ppvAdapter);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvAdapter, nullptr);
        }

        Encode_IDXGIFactory4_EnumWarpAdapter(
            this,
            result,
            riid,
            ppvAdapter);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory4_EnumWarpAdapter>::Dispatch(
            manager,
            this,
            result,
            riid,
            ppvAdapter);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory4>()->EnumWarpAdapter(
            riid,
            ppvAdapter);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIAdapter3_Wrapper::IDXGIAdapter3_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIAdapter2_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIAdapter3_Wrapper::RegisterHardwareContentProtectionTeardownStatusEvent(
    HANDLE hEvent,
    DWORD* pdwCookie)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIAdapter3_RegisterHardwareContentProtectionTeardownStatusEvent>::Dispatch(
            manager,
            this,
            hEvent,
            pdwCookie);

        result = GetWrappedObjectAs<IDXGIAdapter3>()->RegisterHardwareContentProtectionTeardownStatusEvent(
            hEvent,
            pdwCookie);

        Encode_IDXGIAdapter3_RegisterHardwareContentProtectionTeardownStatusEvent(
            this,
            result,
            hEvent,
            pdwCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIAdapter3_RegisterHardwareContentProtectionTeardownStatusEvent>::Dispatch(
            manager,
            this,
            result,
            hEvent,
            pdwCookie);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIAdapter3>()->RegisterHardwareContentProtectionTeardownStatusEvent(
            hEvent,
            pdwCookie);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE IDXGIAdapter3_Wrapper::UnregisterHardwareContentProtectionTeardownStatus(
    DWORD dwCookie)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIAdapter3_UnregisterHardwareContentProtectionTeardownStatus>::Dispatch(
            manager,
            this,
            dwCookie);

        GetWrappedObjectAs<IDXGIAdapter3>()->UnregisterHardwareContentProtectionTeardownStatus(
            dwCookie);

        Encode_IDXGIAdapter3_UnregisterHardwareContentProtectionTeardownStatus(
            this,
            dwCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIAdapter3_UnregisterHardwareContentProtectionTeardownStatus>::Dispatch(
            manager,
            this,
            dwCookie);
    }
    else
    {
        GetWrappedObjectAs<IDXGIAdapter3>()->UnregisterHardwareContentProtectionTeardownStatus(
            dwCookie);
    }

    manager->DecrementCallScope();
}

HRESULT STDMETHODCALLTYPE IDXGIAdapter3_Wrapper::QueryVideoMemoryInfo(
    UINT NodeIndex,
    DXGI_MEMORY_SEGMENT_GROUP MemorySegmentGroup,
    DXGI_QUERY_VIDEO_MEMORY_INFO* pVideoMemoryInfo)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIAdapter3_QueryVideoMemoryInfo>::Dispatch(
            manager,
            this,
            NodeIndex,
            MemorySegmentGroup,
            pVideoMemoryInfo);

        result = GetWrappedObjectAs<IDXGIAdapter3>()->QueryVideoMemoryInfo(
            NodeIndex,
            MemorySegmentGroup,
            pVideoMemoryInfo);

        Encode_IDXGIAdapter3_QueryVideoMemoryInfo(
            this,
            result,
            NodeIndex,
            MemorySegmentGroup,
            pVideoMemoryInfo);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIAdapter3_QueryVideoMemoryInfo>::Dispatch(
            manager,
            this,
            result,
            NodeIndex,
            MemorySegmentGroup,
            pVideoMemoryInfo);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIAdapter3>()->QueryVideoMemoryInfo(
            NodeIndex,
            MemorySegmentGroup,
            pVideoMemoryInfo);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIAdapter3_Wrapper::SetVideoMemoryReservation(
    UINT NodeIndex,
    DXGI_MEMORY_SEGMENT_GROUP MemorySegmentGroup,
    UINT64 Reservation)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIAdapter3_SetVideoMemoryReservation>::Dispatch(
            manager,
            this,
            NodeIndex,
            MemorySegmentGroup,
            Reservation);

        result = GetWrappedObjectAs<IDXGIAdapter3>()->SetVideoMemoryReservation(
            NodeIndex,
            MemorySegmentGroup,
            Reservation);

        Encode_IDXGIAdapter3_SetVideoMemoryReservation(
            this,
            result,
            NodeIndex,
            MemorySegmentGroup,
            Reservation);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIAdapter3_SetVideoMemoryReservation>::Dispatch(
            manager,
            this,
            result,
            NodeIndex,
            MemorySegmentGroup,
            Reservation);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIAdapter3>()->SetVideoMemoryReservation(
            NodeIndex,
            MemorySegmentGroup,
            Reservation);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIAdapter3_Wrapper::RegisterVideoMemoryBudgetChangeNotificationEvent(
    HANDLE hEvent,
    DWORD* pdwCookie)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIAdapter3_RegisterVideoMemoryBudgetChangeNotificationEvent>::Dispatch(
            manager,
            this,
            hEvent,
            pdwCookie);

        result = GetWrappedObjectAs<IDXGIAdapter3>()->RegisterVideoMemoryBudgetChangeNotificationEvent(
            hEvent,
            pdwCookie);

        Encode_IDXGIAdapter3_RegisterVideoMemoryBudgetChangeNotificationEvent(
            this,
            result,
            hEvent,
            pdwCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIAdapter3_RegisterVideoMemoryBudgetChangeNotificationEvent>::Dispatch(
            manager,
            this,
            result,
            hEvent,
            pdwCookie);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIAdapter3>()->RegisterVideoMemoryBudgetChangeNotificationEvent(
            hEvent,
            pdwCookie);
    }

    manager->DecrementCallScope();

    return result;
}

void STDMETHODCALLTYPE IDXGIAdapter3_Wrapper::UnregisterVideoMemoryBudgetChangeNotification(
    DWORD dwCookie)
{
    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIAdapter3_UnregisterVideoMemoryBudgetChangeNotification>::Dispatch(
            manager,
            this,
            dwCookie);

        GetWrappedObjectAs<IDXGIAdapter3>()->UnregisterVideoMemoryBudgetChangeNotification(
            dwCookie);

        Encode_IDXGIAdapter3_UnregisterVideoMemoryBudgetChangeNotification(
            this,
            dwCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIAdapter3_UnregisterVideoMemoryBudgetChangeNotification>::Dispatch(
            manager,
            this,
            dwCookie);
    }
    else
    {
        GetWrappedObjectAs<IDXGIAdapter3>()->UnregisterVideoMemoryBudgetChangeNotification(
            dwCookie);
    }

    manager->DecrementCallScope();
}


/*
** This part is generated from dxgi1_5.h in Windows SDK: 10.0.20348.0
**
*/

IDXGIOutput5_Wrapper::IDXGIOutput5_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIOutput4_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIOutput5_Wrapper::DuplicateOutput1(
    IUnknown* pDevice,
    UINT Flags,
    UINT SupportedFormatsCount,
    const DXGI_FORMAT* pSupportedFormats,
    IDXGIOutputDuplication** ppOutputDuplication)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput5_DuplicateOutput1>::Dispatch(
            manager,
            this,
            pDevice,
            Flags,
            SupportedFormatsCount,
            pSupportedFormats,
            ppOutputDuplication);

        result = GetWrappedObjectAs<IDXGIOutput5>()->DuplicateOutput1(
            encode::GetWrappedObject<IUnknown>(pDevice),
            Flags,
            SupportedFormatsCount,
            pSupportedFormats,
            ppOutputDuplication);

        if (SUCCEEDED(result))
        {
            WrapObject(IID_IDXGIOutputDuplication, reinterpret_cast<void**>(ppOutputDuplication), nullptr);
        }

        Encode_IDXGIOutput5_DuplicateOutput1(
            this,
            result,
            pDevice,
            Flags,
            SupportedFormatsCount,
            pSupportedFormats,
            ppOutputDuplication);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput5_DuplicateOutput1>::Dispatch(
            manager,
            this,
            result,
            pDevice,
            Flags,
            SupportedFormatsCount,
            pSupportedFormats,
            ppOutputDuplication);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput5>()->DuplicateOutput1(
            pDevice,
            Flags,
            SupportedFormatsCount,
            pSupportedFormats,
            ppOutputDuplication);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGISwapChain4_Wrapper::IDXGISwapChain4_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGISwapChain3_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGISwapChain4_Wrapper::SetHDRMetaData(
    DXGI_HDR_METADATA_TYPE Type,
    UINT Size,
    void* pMetaData)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGISwapChain4_SetHDRMetaData>::Dispatch(
            manager,
            this,
            Type,
            Size,
            pMetaData);

        result = GetWrappedObjectAs<IDXGISwapChain4>()->SetHDRMetaData(
            Type,
            Size,
            pMetaData);

        Encode_IDXGISwapChain4_SetHDRMetaData(
            this,
            result,
            Type,
            Size,
            pMetaData);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGISwapChain4_SetHDRMetaData>::Dispatch(
            manager,
            this,
            result,
            Type,
            Size,
            pMetaData);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGISwapChain4>()->SetHDRMetaData(
            Type,
            Size,
            pMetaData);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIDevice4_Wrapper::IDXGIDevice4_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIDevice3_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIDevice4_Wrapper::OfferResources1(
    UINT NumResources,
    IDXGIResource* const* ppResources,
    DXGI_OFFER_RESOURCE_PRIORITY Priority,
    UINT Flags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDevice4_OfferResources1>::Dispatch(
            manager,
            this,
            NumResources,
            ppResources,
            Priority,
            Flags);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<IDXGIDevice4>()->OfferResources1(
            NumResources,
            UnwrapObjects<IDXGIResource>(ppResources, NumResources, unwrap_memory),
            Priority,
            Flags);

        Encode_IDXGIDevice4_OfferResources1(
            this,
            result,
            NumResources,
            ppResources,
            Priority,
            Flags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDevice4_OfferResources1>::Dispatch(
            manager,
            this,
            result,
            NumResources,
            ppResources,
            Priority,
            Flags);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDevice4>()->OfferResources1(
            NumResources,
            ppResources,
            Priority,
            Flags);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIDevice4_Wrapper::ReclaimResources1(
    UINT NumResources,
    IDXGIResource* const* ppResources,
    DXGI_RECLAIM_RESOURCE_RESULTS* pResults)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIDevice4_ReclaimResources1>::Dispatch(
            manager,
            this,
            NumResources,
            ppResources,
            pResults);

        auto unwrap_memory = manager->GetHandleUnwrapMemory();

        result = GetWrappedObjectAs<IDXGIDevice4>()->ReclaimResources1(
            NumResources,
            UnwrapObjects<IDXGIResource>(ppResources, NumResources, unwrap_memory),
            pResults);

        Encode_IDXGIDevice4_ReclaimResources1(
            this,
            result,
            NumResources,
            ppResources,
            pResults);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIDevice4_ReclaimResources1>::Dispatch(
            manager,
            this,
            result,
            NumResources,
            ppResources,
            pResults);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIDevice4>()->ReclaimResources1(
            NumResources,
            ppResources,
            pResults);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIFactory5_Wrapper::IDXGIFactory5_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIFactory4_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIFactory5_Wrapper::CheckFeatureSupport(
    DXGI_FEATURE Feature,
    void* pFeatureSupportData,
    UINT FeatureSupportDataSize)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory5_CheckFeatureSupport>::Dispatch(
            manager,
            this,
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);

        result = GetWrappedObjectAs<IDXGIFactory5>()->CheckFeatureSupport(
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);

        Encode_IDXGIFactory5_CheckFeatureSupport(
            this,
            result,
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory5_CheckFeatureSupport>::Dispatch(
            manager,
            this,
            result,
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory5>()->CheckFeatureSupport(
            Feature,
            pFeatureSupportData,
            FeatureSupportDataSize);
    }

    manager->DecrementCallScope();

    return result;
}


/*
** This part is generated from dxgi1_6.h in Windows SDK: 10.0.20348.0
**
*/

HRESULT WINAPI DXGIDeclareAdapterRemovalSupport()
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_DXGIDeclareAdapterRemovalSupport>::Dispatch(
            manager);

        result = manager->GetDxgiDispatchTable().DXGIDeclareAdapterRemovalSupport();

        Encode_DXGIDeclareAdapterRemovalSupport(
            result);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_DXGIDeclareAdapterRemovalSupport>::Dispatch(
            manager,
            result);
    }
    else
    {
        result = manager->GetDxgiDispatchTable().DXGIDeclareAdapterRemovalSupport();
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIAdapter4_Wrapper::IDXGIAdapter4_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIAdapter3_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIAdapter4_Wrapper::GetDesc3(
    DXGI_ADAPTER_DESC3* pDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIAdapter4_GetDesc3>::Dispatch(
            manager,
            this,
            pDesc);

        result = GetWrappedObjectAs<IDXGIAdapter4>()->GetDesc3(
            pDesc);

        Encode_IDXGIAdapter4_GetDesc3(
            this,
            result,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIAdapter4_GetDesc3>::Dispatch(
            manager,
            this,
            result,
            pDesc);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIAdapter4>()->GetDesc3(
            pDesc);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIOutput6_Wrapper::IDXGIOutput6_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIOutput5_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIOutput6_Wrapper::GetDesc1(
    DXGI_OUTPUT_DESC1* pDesc)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput6_GetDesc1>::Dispatch(
            manager,
            this,
            pDesc);

        result = GetWrappedObjectAs<IDXGIOutput6>()->GetDesc1(
            pDesc);

        Encode_IDXGIOutput6_GetDesc1(
            this,
            result,
            pDesc);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput6_GetDesc1>::Dispatch(
            manager,
            this,
            result,
            pDesc);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput6>()->GetDesc1(
            pDesc);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIOutput6_Wrapper::CheckHardwareCompositionSupport(
    UINT* pFlags)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIOutput6_CheckHardwareCompositionSupport>::Dispatch(
            manager,
            this,
            pFlags);

        result = GetWrappedObjectAs<IDXGIOutput6>()->CheckHardwareCompositionSupport(
            pFlags);

        Encode_IDXGIOutput6_CheckHardwareCompositionSupport(
            this,
            result,
            pFlags);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIOutput6_CheckHardwareCompositionSupport>::Dispatch(
            manager,
            this,
            result,
            pFlags);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIOutput6>()->CheckHardwareCompositionSupport(
            pFlags);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIFactory6_Wrapper::IDXGIFactory6_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIFactory5_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIFactory6_Wrapper::EnumAdapterByGpuPreference(
    UINT Adapter,
    DXGI_GPU_PREFERENCE GpuPreference,
    REFIID riid,
    void** ppvAdapter)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory6_EnumAdapterByGpuPreference>::Dispatch(
            manager,
            this,
            Adapter,
            GpuPreference,
            riid,
            ppvAdapter);

        result = GetWrappedObjectAs<IDXGIFactory6>()->EnumAdapterByGpuPreference(
            Adapter,
            GpuPreference,
            riid,
            ppvAdapter);

        if (SUCCEEDED(result))
        {
            WrapObject(riid, ppvAdapter, nullptr);
        }

        Encode_IDXGIFactory6_EnumAdapterByGpuPreference(
            this,
            result,
            Adapter,
            GpuPreference,
            riid,
            ppvAdapter);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory6_EnumAdapterByGpuPreference>::Dispatch(
            manager,
            this,
            result,
            Adapter,
            GpuPreference,
            riid,
            ppvAdapter);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory6>()->EnumAdapterByGpuPreference(
            Adapter,
            GpuPreference,
            riid,
            ppvAdapter);
    }

    manager->DecrementCallScope();

    return result;
}

IDXGIFactory7_Wrapper::IDXGIFactory7_Wrapper(REFIID riid, IUnknown* object, DxWrapperResources* resources, const std::function<void(IUnknown_Wrapper*)>& destructor) : IDXGIFactory6_Wrapper(riid, object, resources, destructor)
{
}

HRESULT STDMETHODCALLTYPE IDXGIFactory7_Wrapper::RegisterAdaptersChangedEvent(
    HANDLE hEvent,
    DWORD* pdwCookie)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory7_RegisterAdaptersChangedEvent>::Dispatch(
            manager,
            this,
            hEvent,
            pdwCookie);

        result = GetWrappedObjectAs<IDXGIFactory7>()->RegisterAdaptersChangedEvent(
            hEvent,
            pdwCookie);

        Encode_IDXGIFactory7_RegisterAdaptersChangedEvent(
            this,
            result,
            hEvent,
            pdwCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory7_RegisterAdaptersChangedEvent>::Dispatch(
            manager,
            this,
            result,
            hEvent,
            pdwCookie);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory7>()->RegisterAdaptersChangedEvent(
            hEvent,
            pdwCookie);
    }

    manager->DecrementCallScope();

    return result;
}

HRESULT STDMETHODCALLTYPE IDXGIFactory7_Wrapper::UnregisterAdaptersChangedEvent(
    DWORD dwCookie)
{
    HRESULT result{};

    auto manager = D3D12CaptureManager::Get();
    auto call_scope = manager->IncrementCallScope();

    if (call_scope == 1)
    {
        auto force_command_serialization = D3D12CaptureManager::Get()->GetForceCommandSerialization();
        std::shared_lock<CommonCaptureManager::ApiCallMutexT> shared_api_call_lock;
        std::unique_lock<CommonCaptureManager::ApiCallMutexT> exclusive_api_call_lock;
        if (force_command_serialization)
        {
            exclusive_api_call_lock = D3D12CaptureManager::AcquireExclusiveApiCallLock();
        }
        else
        {
            shared_api_call_lock = D3D12CaptureManager::AcquireSharedApiCallLock();
        }

        CustomWrapperPreCall<format::ApiCallId::ApiCall_IDXGIFactory7_UnregisterAdaptersChangedEvent>::Dispatch(
            manager,
            this,
            dwCookie);

        result = GetWrappedObjectAs<IDXGIFactory7>()->UnregisterAdaptersChangedEvent(
            dwCookie);

        Encode_IDXGIFactory7_UnregisterAdaptersChangedEvent(
            this,
            result,
            dwCookie);

        CustomWrapperPostCall<format::ApiCallId::ApiCall_IDXGIFactory7_UnregisterAdaptersChangedEvent>::Dispatch(
            manager,
            this,
            result,
            dwCookie);
    }
    else
    {
        result = GetWrappedObjectAs<IDXGIFactory7>()->UnregisterAdaptersChangedEvent(
            dwCookie);
    }

    manager->DecrementCallScope();

    return result;
}


/*
** This part is generated from dxgicommon.h in Windows SDK: 10.0.20348.0
**
*/


/*
** This part is generated from dxgitype.h in Windows SDK: 10.0.20348.0
**
*/


/*
** This part is generated from Unknwnbase.h in Windows SDK: 10.0.20348.0
**
*/


/*
** This part is generated from guiddef.h in Windows SDK: 10.0.20348.0
**
*/


/*
** This part is generated from windef.h in Windows SDK: 10.0.20348.0
**
*/


/*
** This part is generated from minwinbase.h in Windows SDK: 10.0.20348.0
**
*/

GFXRECON_END_NAMESPACE(encode)
GFXRECON_END_NAMESPACE(gfxrecon)
