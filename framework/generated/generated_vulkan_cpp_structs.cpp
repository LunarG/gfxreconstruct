/*
** Copyright (c) 2021 Samsung
** Copyright (c) 2023 Google
** Copyright (c) 2023 LunarG, Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following conditions:
**
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
** FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
*/

/*
** This file is generated from the Khronos Vulkan XML API Registry.
**
*/

#include "decode/vulkan_cpp_structs.h"
#include "generated/generated_vulkan_cpp_structs.h"
#include "generated/generated_vulkan_cpp_consumer.h"
#include "generated/generated_vulkan_cpp_consumer_extension.h"
#include "generated/generated_vulkan_enum_to_string.h"
GFXRECON_BEGIN_NAMESPACE(gfxrecon)
GFXRECON_BEGIN_NAMESPACE(decode)

std::string GenerateStruct_StdVideoDecodeH264PictureInfo(std::ostream &out, const StdVideoDecodeH264PictureInfo* structInfo, Decoded_StdVideoDecodeH264PictureInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoDecodeH264PictureInfoFlags(out,
                                                                                   &structInfo->flags,
                                                                                   metaInfo->flags,
                                                                                   consumer);
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// seq_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->seq_parameter_set_id) << "," << std::endl;
// pic_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->pic_parameter_set_id) << "," << std::endl;
// reserved1
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
// reserved2
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved2) << "," << std::endl;
// frame_num
    struct_body << "\t\t\t" << structInfo->frame_num << "," << std::endl;
// idr_pic_id
    struct_body << "\t\t\t" << structInfo->idr_pic_id << "," << std::endl;
// PicOrderCnt
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int32_t*>(&structInfo->PicOrderCnt[0]), STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeH264PictureInfo");
    out << "\t\t" << "StdVideoDecodeH264PictureInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeH264PictureInfoFlags(std::ostream &out, const StdVideoDecodeH264PictureInfoFlags* structInfo, Decoded_StdVideoDecodeH264PictureInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// field_pic_flag
    struct_body << "\t" << structInfo->field_pic_flag << "," << std::endl;
// is_intra
    struct_body << "\t\t\t" << structInfo->is_intra << "," << std::endl;
// IdrPicFlag
    struct_body << "\t\t\t" << structInfo->IdrPicFlag << "," << std::endl;
// bottom_field_flag
    struct_body << "\t\t\t" << structInfo->bottom_field_flag << "," << std::endl;
// is_reference
    struct_body << "\t\t\t" << structInfo->is_reference << "," << std::endl;
// complementary_field_pair
    struct_body << "\t\t\t" << structInfo->complementary_field_pair << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeH264PictureInfoFlags");
    out << "\t\t" << "StdVideoDecodeH264PictureInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeH264ReferenceInfo(std::ostream &out, const StdVideoDecodeH264ReferenceInfo* structInfo, Decoded_StdVideoDecodeH264ReferenceInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoDecodeH264ReferenceInfoFlags(out,
                                                                                     &structInfo->flags,
                                                                                     metaInfo->flags,
                                                                                     consumer);
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// FrameNum
    struct_body << "\t\t\t" << structInfo->FrameNum << "," << std::endl;
// reserved
    struct_body << "\t\t\t" << structInfo->reserved << "," << std::endl;
// PicOrderCnt
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int32_t*>(&structInfo->PicOrderCnt[0]), STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeH264ReferenceInfo");
    out << "\t\t" << "StdVideoDecodeH264ReferenceInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeH264ReferenceInfoFlags(std::ostream &out, const StdVideoDecodeH264ReferenceInfoFlags* structInfo, Decoded_StdVideoDecodeH264ReferenceInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// top_field_flag
    struct_body << "\t" << structInfo->top_field_flag << "," << std::endl;
// bottom_field_flag
    struct_body << "\t\t\t" << structInfo->bottom_field_flag << "," << std::endl;
// used_for_long_term_reference
    struct_body << "\t\t\t" << structInfo->used_for_long_term_reference << "," << std::endl;
// is_non_existing
    struct_body << "\t\t\t" << structInfo->is_non_existing << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeH264ReferenceInfoFlags");
    out << "\t\t" << "StdVideoDecodeH264ReferenceInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeH265PictureInfo(std::ostream &out, const StdVideoDecodeH265PictureInfo* structInfo, Decoded_StdVideoDecodeH265PictureInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoDecodeH265PictureInfoFlags(out,
                                                                                   &structInfo->flags,
                                                                                   metaInfo->flags,
                                                                                   consumer);
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// sps_video_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->sps_video_parameter_set_id) << "," << std::endl;
// pps_seq_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->pps_seq_parameter_set_id) << "," << std::endl;
// pps_pic_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->pps_pic_parameter_set_id) << "," << std::endl;
// NumDeltaPocsOfRefRpsIdx
    struct_body << "\t\t\t" << std::to_string(structInfo->NumDeltaPocsOfRefRpsIdx) << "," << std::endl;
// PicOrderCntVal
    struct_body << "\t\t\t" << structInfo->PicOrderCntVal << "," << std::endl;
// NumBitsForSTRefPicSetInSlice
    struct_body << "\t\t\t" << structInfo->NumBitsForSTRefPicSetInSlice << "," << std::endl;
// reserved
    struct_body << "\t\t\t" << structInfo->reserved << "," << std::endl;
// RefPicSetStCurrBefore
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicSetStCurrBefore[0]), STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE) << "," << std::endl;
// RefPicSetStCurrAfter
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicSetStCurrAfter[0]), STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE) << "," << std::endl;
// RefPicSetLtCurr
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicSetLtCurr[0]), STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeH265PictureInfo");
    out << "\t\t" << "StdVideoDecodeH265PictureInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeH265PictureInfoFlags(std::ostream &out, const StdVideoDecodeH265PictureInfoFlags* structInfo, Decoded_StdVideoDecodeH265PictureInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// IrapPicFlag
    struct_body << "\t" << structInfo->IrapPicFlag << "," << std::endl;
// IdrPicFlag
    struct_body << "\t\t\t" << structInfo->IdrPicFlag << "," << std::endl;
// IsReference
    struct_body << "\t\t\t" << structInfo->IsReference << "," << std::endl;
// short_term_ref_pic_set_sps_flag
    struct_body << "\t\t\t" << structInfo->short_term_ref_pic_set_sps_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeH265PictureInfoFlags");
    out << "\t\t" << "StdVideoDecodeH265PictureInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeH265ReferenceInfo(std::ostream &out, const StdVideoDecodeH265ReferenceInfo* structInfo, Decoded_StdVideoDecodeH265ReferenceInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoDecodeH265ReferenceInfoFlags(out,
                                                                                     &structInfo->flags,
                                                                                     metaInfo->flags,
                                                                                     consumer);
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// PicOrderCntVal
    struct_body << "\t\t\t" << structInfo->PicOrderCntVal << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeH265ReferenceInfo");
    out << "\t\t" << "StdVideoDecodeH265ReferenceInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeH265ReferenceInfoFlags(std::ostream &out, const StdVideoDecodeH265ReferenceInfoFlags* structInfo, Decoded_StdVideoDecodeH265ReferenceInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// used_for_long_term_reference
    struct_body << "\t" << structInfo->used_for_long_term_reference << "," << std::endl;
// unused_for_reference
    struct_body << "\t\t\t" << structInfo->unused_for_reference << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeH265ReferenceInfoFlags");
    out << "\t\t" << "StdVideoDecodeH265ReferenceInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264PictureInfo(std::ostream &out, const StdVideoEncodeH264PictureInfo* structInfo, Decoded_StdVideoEncodeH264PictureInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH264PictureInfoFlags(out,
                                                                                   &structInfo->flags,
                                                                                   metaInfo->flags,
                                                                                   consumer);
    std::string pref_lists_struct = "NULL";
    if (structInfo->pRefLists != NULL) {
        pref_lists_struct = GenerateStruct_StdVideoEncodeH264ReferenceListsInfo(out,
                                                                                structInfo->pRefLists,
                                                                                metaInfo->pRefLists->GetMetaStructPointer(),
                                                                                consumer);
        pref_lists_struct.insert(0, "&");
    }
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// seq_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->seq_parameter_set_id) << "," << std::endl;
// pic_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->pic_parameter_set_id) << "," << std::endl;
// idr_pic_id
    struct_body << "\t\t\t" << structInfo->idr_pic_id << "," << std::endl;
// primary_pic_type
    struct_body << "\t\t\t" << "StdVideoH264PictureType(" << structInfo->primary_pic_type << ")" << "," << std::endl;
// frame_num
    struct_body << "\t\t\t" << structInfo->frame_num << "," << std::endl;
// PicOrderCnt
    struct_body << "\t\t\t" << structInfo->PicOrderCnt << "," << std::endl;
// temporal_id
    struct_body << "\t\t\t" << std::to_string(structInfo->temporal_id) << "," << std::endl;
// reserved1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->reserved1[0]), 3) << "," << std::endl;
// pRefLists
    struct_body << "\t\t\t" << pref_lists_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264PictureInfo");
    out << "\t\t" << "StdVideoEncodeH264PictureInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264PictureInfoFlags(std::ostream &out, const StdVideoEncodeH264PictureInfoFlags* structInfo, Decoded_StdVideoEncodeH264PictureInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// IdrPicFlag
    struct_body << "\t" << structInfo->IdrPicFlag << "," << std::endl;
// is_reference
    struct_body << "\t\t\t" << structInfo->is_reference << "," << std::endl;
// no_output_of_prior_pics_flag
    struct_body << "\t\t\t" << structInfo->no_output_of_prior_pics_flag << "," << std::endl;
// long_term_reference_flag
    struct_body << "\t\t\t" << structInfo->long_term_reference_flag << "," << std::endl;
// adaptive_ref_pic_marking_mode_flag
    struct_body << "\t\t\t" << structInfo->adaptive_ref_pic_marking_mode_flag << "," << std::endl;
// reserved
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264PictureInfoFlags");
    out << "\t\t" << "StdVideoEncodeH264PictureInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264RefListModEntry(std::ostream &out, const StdVideoEncodeH264RefListModEntry* structInfo, Decoded_StdVideoEncodeH264RefListModEntry* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// modification_of_pic_nums_idc
    struct_body << "\t" << "StdVideoH264ModificationOfPicNumsIdc(" << structInfo->modification_of_pic_nums_idc << ")" << "," << std::endl;
// abs_diff_pic_num_minus1
    struct_body << "\t\t\t" << structInfo->abs_diff_pic_num_minus1 << "," << std::endl;
// long_term_pic_num
    struct_body << "\t\t\t" << structInfo->long_term_pic_num << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264RefListModEntry");
    out << "\t\t" << "StdVideoEncodeH264RefListModEntry " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264RefPicMarkingEntry(std::ostream &out, const StdVideoEncodeH264RefPicMarkingEntry* structInfo, Decoded_StdVideoEncodeH264RefPicMarkingEntry* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// memory_management_control_operation
    struct_body << "\t" << "StdVideoH264MemMgmtControlOp(" << structInfo->memory_management_control_operation << ")" << "," << std::endl;
// difference_of_pic_nums_minus1
    struct_body << "\t\t\t" << structInfo->difference_of_pic_nums_minus1 << "," << std::endl;
// long_term_pic_num
    struct_body << "\t\t\t" << structInfo->long_term_pic_num << "," << std::endl;
// long_term_frame_idx
    struct_body << "\t\t\t" << structInfo->long_term_frame_idx << "," << std::endl;
// max_long_term_frame_idx_plus1
    struct_body << "\t\t\t" << structInfo->max_long_term_frame_idx_plus1 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264RefPicMarkingEntry");
    out << "\t\t" << "StdVideoEncodeH264RefPicMarkingEntry " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264ReferenceInfo(std::ostream &out, const StdVideoEncodeH264ReferenceInfo* structInfo, Decoded_StdVideoEncodeH264ReferenceInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH264ReferenceInfoFlags(out,
                                                                                     &structInfo->flags,
                                                                                     metaInfo->flags,
                                                                                     consumer);
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// primary_pic_type
    struct_body << "\t\t\t" << "StdVideoH264PictureType(" << structInfo->primary_pic_type << ")" << "," << std::endl;
// FrameNum
    struct_body << "\t\t\t" << structInfo->FrameNum << "," << std::endl;
// PicOrderCnt
    struct_body << "\t\t\t" << structInfo->PicOrderCnt << "," << std::endl;
// long_term_pic_num
    struct_body << "\t\t\t" << structInfo->long_term_pic_num << "," << std::endl;
// long_term_frame_idx
    struct_body << "\t\t\t" << structInfo->long_term_frame_idx << "," << std::endl;
// temporal_id
    struct_body << "\t\t\t" << std::to_string(structInfo->temporal_id) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264ReferenceInfo");
    out << "\t\t" << "StdVideoEncodeH264ReferenceInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264ReferenceInfoFlags(std::ostream &out, const StdVideoEncodeH264ReferenceInfoFlags* structInfo, Decoded_StdVideoEncodeH264ReferenceInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// used_for_long_term_reference
    struct_body << "\t" << structInfo->used_for_long_term_reference << "," << std::endl;
// reserved
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264ReferenceInfoFlags");
    out << "\t\t" << "StdVideoEncodeH264ReferenceInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264ReferenceListsInfo(std::ostream &out, const StdVideoEncodeH264ReferenceListsInfo* structInfo, Decoded_StdVideoEncodeH264ReferenceListsInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH264ReferenceListsInfoFlags(out,
                                                                                          &structInfo->flags,
                                                                                          metaInfo->flags,
                                                                                          consumer);
    std::string pref_list0_mod_operations_struct = "NULL";
    if (structInfo->pRefList0ModOperations != NULL) {
        pref_list0_mod_operations_struct = GenerateStruct_StdVideoEncodeH264RefListModEntry(out,
                                                                                            structInfo->pRefList0ModOperations,
                                                                                            metaInfo->pRefList0ModOperations->GetMetaStructPointer(),
                                                                                            consumer);
        pref_list0_mod_operations_struct.insert(0, "&");
    }
    std::string pref_list1_mod_operations_struct = "NULL";
    if (structInfo->pRefList1ModOperations != NULL) {
        pref_list1_mod_operations_struct = GenerateStruct_StdVideoEncodeH264RefListModEntry(out,
                                                                                            structInfo->pRefList1ModOperations,
                                                                                            metaInfo->pRefList1ModOperations->GetMetaStructPointer(),
                                                                                            consumer);
        pref_list1_mod_operations_struct.insert(0, "&");
    }
    std::string pref_pic_marking_operations_struct = "NULL";
    if (structInfo->pRefPicMarkingOperations != NULL) {
        pref_pic_marking_operations_struct = GenerateStruct_StdVideoEncodeH264RefPicMarkingEntry(out,
                                                                                                 structInfo->pRefPicMarkingOperations,
                                                                                                 metaInfo->pRefPicMarkingOperations->GetMetaStructPointer(),
                                                                                                 consumer);
        pref_pic_marking_operations_struct.insert(0, "&");
    }
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// num_ref_idx_l0_active_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->num_ref_idx_l0_active_minus1) << "," << std::endl;
// num_ref_idx_l1_active_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->num_ref_idx_l1_active_minus1) << "," << std::endl;
// RefPicList0
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicList0[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
// RefPicList1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicList1[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
// refList0ModOpCount
    struct_body << "\t\t\t" << std::to_string(structInfo->refList0ModOpCount) << "," << std::endl;
// refList1ModOpCount
    struct_body << "\t\t\t" << std::to_string(structInfo->refList1ModOpCount) << "," << std::endl;
// refPicMarkingOpCount
    struct_body << "\t\t\t" << std::to_string(structInfo->refPicMarkingOpCount) << "," << std::endl;
// reserved1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->reserved1[0]), 7) << "," << std::endl;
// pRefList0ModOperations
    struct_body << "\t\t\t" << pref_list0_mod_operations_struct << "," << std::endl;
// pRefList1ModOperations
    struct_body << "\t\t\t" << pref_list1_mod_operations_struct << "," << std::endl;
// pRefPicMarkingOperations
    struct_body << "\t\t\t" << pref_pic_marking_operations_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264ReferenceListsInfo");
    out << "\t\t" << "StdVideoEncodeH264ReferenceListsInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264ReferenceListsInfoFlags(std::ostream &out, const StdVideoEncodeH264ReferenceListsInfoFlags* structInfo, Decoded_StdVideoEncodeH264ReferenceListsInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// ref_pic_list_modification_flag_l0
    struct_body << "\t" << structInfo->ref_pic_list_modification_flag_l0 << "," << std::endl;
// ref_pic_list_modification_flag_l1
    struct_body << "\t\t\t" << structInfo->ref_pic_list_modification_flag_l1 << "," << std::endl;
// reserved
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264ReferenceListsInfoFlags");
    out << "\t\t" << "StdVideoEncodeH264ReferenceListsInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264SliceHeader(std::ostream &out, const StdVideoEncodeH264SliceHeader* structInfo, Decoded_StdVideoEncodeH264SliceHeader* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH264SliceHeaderFlags(out,
                                                                                   &structInfo->flags,
                                                                                   metaInfo->flags,
                                                                                   consumer);
    std::string pweight_table_struct = "NULL";
    if (structInfo->pWeightTable != NULL) {
        pweight_table_struct = GenerateStruct_StdVideoEncodeH264WeightTable(out,
                                                                            structInfo->pWeightTable,
                                                                            metaInfo->pWeightTable->GetMetaStructPointer(),
                                                                            consumer);
        pweight_table_struct.insert(0, "&");
    }
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// first_mb_in_slice
    struct_body << "\t\t\t" << structInfo->first_mb_in_slice << "," << std::endl;
// slice_type
    struct_body << "\t\t\t" << "StdVideoH264SliceType(" << structInfo->slice_type << ")" << "," << std::endl;
// slice_alpha_c0_offset_div2
    struct_body << "\t\t\t" << std::to_string(structInfo->slice_alpha_c0_offset_div2) << "," << std::endl;
// slice_beta_offset_div2
    struct_body << "\t\t\t" << std::to_string(structInfo->slice_beta_offset_div2) << "," << std::endl;
// slice_qp_delta
    struct_body << "\t\t\t" << std::to_string(structInfo->slice_qp_delta) << "," << std::endl;
// reserved1
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
// cabac_init_idc
    struct_body << "\t\t\t" << "StdVideoH264CabacInitIdc(" << structInfo->cabac_init_idc << ")" << "," << std::endl;
// disable_deblocking_filter_idc
    struct_body << "\t\t\t" << "StdVideoH264DisableDeblockingFilterIdc(" << structInfo->disable_deblocking_filter_idc << ")" << "," << std::endl;
// pWeightTable
    struct_body << "\t\t\t" << pweight_table_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264SliceHeader");
    out << "\t\t" << "StdVideoEncodeH264SliceHeader " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264SliceHeaderFlags(std::ostream &out, const StdVideoEncodeH264SliceHeaderFlags* structInfo, Decoded_StdVideoEncodeH264SliceHeaderFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// direct_spatial_mv_pred_flag
    struct_body << "\t" << structInfo->direct_spatial_mv_pred_flag << "," << std::endl;
// num_ref_idx_active_override_flag
    struct_body << "\t\t\t" << structInfo->num_ref_idx_active_override_flag << "," << std::endl;
// reserved
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264SliceHeaderFlags");
    out << "\t\t" << "StdVideoEncodeH264SliceHeaderFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264WeightTable(std::ostream &out, const StdVideoEncodeH264WeightTable* structInfo, Decoded_StdVideoEncodeH264WeightTable* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH264WeightTableFlags(out,
                                                                                   &structInfo->flags,
                                                                                   metaInfo->flags,
                                                                                   consumer);
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// luma_log2_weight_denom
    struct_body << "\t\t\t" << std::to_string(structInfo->luma_log2_weight_denom) << "," << std::endl;
// chroma_log2_weight_denom
    struct_body << "\t\t\t" << std::to_string(structInfo->chroma_log2_weight_denom) << "," << std::endl;
// luma_weight_l0
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_weight_l0[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
// luma_offset_l0
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_offset_l0[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
// chroma_weight_l0
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->chroma_weight_l0[0][0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
// chroma_offset_l0
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->chroma_offset_l0[0][0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
// luma_weight_l1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_weight_l1[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
// luma_offset_l1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_offset_l1[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
// chroma_weight_l1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->chroma_weight_l1[0][0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
// chroma_offset_l1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->chroma_offset_l1[0][0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264WeightTable");
    out << "\t\t" << "StdVideoEncodeH264WeightTable " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264WeightTableFlags(std::ostream &out, const StdVideoEncodeH264WeightTableFlags* structInfo, Decoded_StdVideoEncodeH264WeightTableFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// luma_weight_l0_flag
    struct_body << "\t" << structInfo->luma_weight_l0_flag << "," << std::endl;
// chroma_weight_l0_flag
    struct_body << "\t\t\t" << structInfo->chroma_weight_l0_flag << "," << std::endl;
// luma_weight_l1_flag
    struct_body << "\t\t\t" << structInfo->luma_weight_l1_flag << "," << std::endl;
// chroma_weight_l1_flag
    struct_body << "\t\t\t" << structInfo->chroma_weight_l1_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264WeightTableFlags");
    out << "\t\t" << "StdVideoEncodeH264WeightTableFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH265LongTermRefPics(std::ostream &out, const StdVideoEncodeH265LongTermRefPics* structInfo, Decoded_StdVideoEncodeH265LongTermRefPics* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// num_long_term_sps
    struct_body << "\t" << std::to_string(structInfo->num_long_term_sps) << "," << std::endl;
// num_long_term_pics
    struct_body << "\t\t\t" << std::to_string(structInfo->num_long_term_pics) << "," << std::endl;
// lt_idx_sps
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->lt_idx_sps[0]), STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS) << "," << std::endl;
// poc_lsb_lt
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->poc_lsb_lt[0]), STD_VIDEO_H265_MAX_LONG_TERM_PICS) << "," << std::endl;
// used_by_curr_pic_lt_flag
    struct_body << "\t\t\t" << structInfo->used_by_curr_pic_lt_flag << "," << std::endl;
// delta_poc_msb_present_flag
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->delta_poc_msb_present_flag[0]), STD_VIDEO_H265_MAX_DELTA_POC) << "," << std::endl;
// delta_poc_msb_cycle_lt
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->delta_poc_msb_cycle_lt[0]), STD_VIDEO_H265_MAX_DELTA_POC) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH265LongTermRefPics");
    out << "\t\t" << "StdVideoEncodeH265LongTermRefPics " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH265PictureInfo(std::ostream &out, const StdVideoEncodeH265PictureInfo* structInfo, Decoded_StdVideoEncodeH265PictureInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH265PictureInfoFlags(out,
                                                                                   &structInfo->flags,
                                                                                   metaInfo->flags,
                                                                                   consumer);
    std::string pref_lists_struct = "NULL";
    if (structInfo->pRefLists != NULL) {
        pref_lists_struct = GenerateStruct_StdVideoEncodeH265ReferenceListsInfo(out,
                                                                                structInfo->pRefLists,
                                                                                metaInfo->pRefLists->GetMetaStructPointer(),
                                                                                consumer);
        pref_lists_struct.insert(0, "&");
    }
    std::string pshort_term_ref_pic_set_struct = "NULL";
    if (structInfo->pShortTermRefPicSet != NULL) {
        pshort_term_ref_pic_set_struct = GenerateStruct_StdVideoH265ShortTermRefPicSet(out,
                                                                                       structInfo->pShortTermRefPicSet,
                                                                                       metaInfo->pShortTermRefPicSet->GetMetaStructPointer(),
                                                                                       consumer);
        pshort_term_ref_pic_set_struct.insert(0, "&");
    }
    std::string plong_term_ref_pics_struct = "NULL";
    if (structInfo->pLongTermRefPics != NULL) {
        plong_term_ref_pics_struct = GenerateStruct_StdVideoEncodeH265LongTermRefPics(out,
                                                                                      structInfo->pLongTermRefPics,
                                                                                      metaInfo->pLongTermRefPics->GetMetaStructPointer(),
                                                                                      consumer);
        plong_term_ref_pics_struct.insert(0, "&");
    }
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// pic_type
    struct_body << "\t\t\t" << "StdVideoH265PictureType(" << structInfo->pic_type << ")" << "," << std::endl;
// sps_video_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->sps_video_parameter_set_id) << "," << std::endl;
// pps_seq_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->pps_seq_parameter_set_id) << "," << std::endl;
// pps_pic_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->pps_pic_parameter_set_id) << "," << std::endl;
// short_term_ref_pic_set_idx
    struct_body << "\t\t\t" << std::to_string(structInfo->short_term_ref_pic_set_idx) << "," << std::endl;
// PicOrderCntVal
    struct_body << "\t\t\t" << structInfo->PicOrderCntVal << "," << std::endl;
// TemporalId
    struct_body << "\t\t\t" << std::to_string(structInfo->TemporalId) << "," << std::endl;
// reserved1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->reserved1[0]), 7) << "," << std::endl;
// pRefLists
    struct_body << "\t\t\t" << pref_lists_struct << "," << std::endl;
// pShortTermRefPicSet
    struct_body << "\t\t\t" << pshort_term_ref_pic_set_struct << "," << std::endl;
// pLongTermRefPics
    struct_body << "\t\t\t" << plong_term_ref_pics_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH265PictureInfo");
    out << "\t\t" << "StdVideoEncodeH265PictureInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH265PictureInfoFlags(std::ostream &out, const StdVideoEncodeH265PictureInfoFlags* structInfo, Decoded_StdVideoEncodeH265PictureInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// is_reference
    struct_body << "\t" << structInfo->is_reference << "," << std::endl;
// IrapPicFlag
    struct_body << "\t\t\t" << structInfo->IrapPicFlag << "," << std::endl;
// used_for_long_term_reference
    struct_body << "\t\t\t" << structInfo->used_for_long_term_reference << "," << std::endl;
// discardable_flag
    struct_body << "\t\t\t" << structInfo->discardable_flag << "," << std::endl;
// cross_layer_bla_flag
    struct_body << "\t\t\t" << structInfo->cross_layer_bla_flag << "," << std::endl;
// pic_output_flag
    struct_body << "\t\t\t" << structInfo->pic_output_flag << "," << std::endl;
// no_output_of_prior_pics_flag
    struct_body << "\t\t\t" << structInfo->no_output_of_prior_pics_flag << "," << std::endl;
// short_term_ref_pic_set_sps_flag
    struct_body << "\t\t\t" << structInfo->short_term_ref_pic_set_sps_flag << "," << std::endl;
// slice_temporal_mvp_enabled_flag
    struct_body << "\t\t\t" << structInfo->slice_temporal_mvp_enabled_flag << "," << std::endl;
// reserved
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH265PictureInfoFlags");
    out << "\t\t" << "StdVideoEncodeH265PictureInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH265ReferenceInfo(std::ostream &out, const StdVideoEncodeH265ReferenceInfo* structInfo, Decoded_StdVideoEncodeH265ReferenceInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH265ReferenceInfoFlags(out,
                                                                                     &structInfo->flags,
                                                                                     metaInfo->flags,
                                                                                     consumer);
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// pic_type
    struct_body << "\t\t\t" << "StdVideoH265PictureType(" << structInfo->pic_type << ")" << "," << std::endl;
// PicOrderCntVal
    struct_body << "\t\t\t" << structInfo->PicOrderCntVal << "," << std::endl;
// TemporalId
    struct_body << "\t\t\t" << std::to_string(structInfo->TemporalId) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH265ReferenceInfo");
    out << "\t\t" << "StdVideoEncodeH265ReferenceInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH265ReferenceInfoFlags(std::ostream &out, const StdVideoEncodeH265ReferenceInfoFlags* structInfo, Decoded_StdVideoEncodeH265ReferenceInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// used_for_long_term_reference
    struct_body << "\t" << structInfo->used_for_long_term_reference << "," << std::endl;
// unused_for_reference
    struct_body << "\t\t\t" << structInfo->unused_for_reference << "," << std::endl;
// reserved
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH265ReferenceInfoFlags");
    out << "\t\t" << "StdVideoEncodeH265ReferenceInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH265ReferenceListsInfo(std::ostream &out, const StdVideoEncodeH265ReferenceListsInfo* structInfo, Decoded_StdVideoEncodeH265ReferenceListsInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH265ReferenceListsInfoFlags(out,
                                                                                          &structInfo->flags,
                                                                                          metaInfo->flags,
                                                                                          consumer);
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// num_ref_idx_l0_active_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->num_ref_idx_l0_active_minus1) << "," << std::endl;
// num_ref_idx_l1_active_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->num_ref_idx_l1_active_minus1) << "," << std::endl;
// RefPicList0
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicList0[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
// RefPicList1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicList1[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
// list_entry_l0
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->list_entry_l0[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
// list_entry_l1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->list_entry_l1[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH265ReferenceListsInfo");
    out << "\t\t" << "StdVideoEncodeH265ReferenceListsInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH265ReferenceListsInfoFlags(std::ostream &out, const StdVideoEncodeH265ReferenceListsInfoFlags* structInfo, Decoded_StdVideoEncodeH265ReferenceListsInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// ref_pic_list_modification_flag_l0
    struct_body << "\t" << structInfo->ref_pic_list_modification_flag_l0 << "," << std::endl;
// ref_pic_list_modification_flag_l1
    struct_body << "\t\t\t" << structInfo->ref_pic_list_modification_flag_l1 << "," << std::endl;
// reserved
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH265ReferenceListsInfoFlags");
    out << "\t\t" << "StdVideoEncodeH265ReferenceListsInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH265SliceSegmentHeader(std::ostream &out, const StdVideoEncodeH265SliceSegmentHeader* structInfo, Decoded_StdVideoEncodeH265SliceSegmentHeader* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH265SliceSegmentHeaderFlags(out,
                                                                                          &structInfo->flags,
                                                                                          metaInfo->flags,
                                                                                          consumer);
    std::string pweight_table_struct = "NULL";
    if (structInfo->pWeightTable != NULL) {
        pweight_table_struct = GenerateStruct_StdVideoEncodeH265WeightTable(out,
                                                                            structInfo->pWeightTable,
                                                                            metaInfo->pWeightTable->GetMetaStructPointer(),
                                                                            consumer);
        pweight_table_struct.insert(0, "&");
    }
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// slice_type
    struct_body << "\t\t\t" << "StdVideoH265SliceType(" << structInfo->slice_type << ")" << "," << std::endl;
// slice_segment_address
    struct_body << "\t\t\t" << structInfo->slice_segment_address << "," << std::endl;
// collocated_ref_idx
    struct_body << "\t\t\t" << std::to_string(structInfo->collocated_ref_idx) << "," << std::endl;
// MaxNumMergeCand
    struct_body << "\t\t\t" << std::to_string(structInfo->MaxNumMergeCand) << "," << std::endl;
// slice_cb_qp_offset
    struct_body << "\t\t\t" << std::to_string(structInfo->slice_cb_qp_offset) << "," << std::endl;
// slice_cr_qp_offset
    struct_body << "\t\t\t" << std::to_string(structInfo->slice_cr_qp_offset) << "," << std::endl;
// slice_beta_offset_div2
    struct_body << "\t\t\t" << std::to_string(structInfo->slice_beta_offset_div2) << "," << std::endl;
// slice_tc_offset_div2
    struct_body << "\t\t\t" << std::to_string(structInfo->slice_tc_offset_div2) << "," << std::endl;
// slice_act_y_qp_offset
    struct_body << "\t\t\t" << std::to_string(structInfo->slice_act_y_qp_offset) << "," << std::endl;
// slice_act_cb_qp_offset
    struct_body << "\t\t\t" << std::to_string(structInfo->slice_act_cb_qp_offset) << "," << std::endl;
// slice_act_cr_qp_offset
    struct_body << "\t\t\t" << std::to_string(structInfo->slice_act_cr_qp_offset) << "," << std::endl;
// slice_qp_delta
    struct_body << "\t\t\t" << std::to_string(structInfo->slice_qp_delta) << "," << std::endl;
// reserved1
    struct_body << "\t\t\t" << structInfo->reserved1 << "," << std::endl;
// pWeightTable
    struct_body << "\t\t\t" << pweight_table_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH265SliceSegmentHeader");
    out << "\t\t" << "StdVideoEncodeH265SliceSegmentHeader " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH265SliceSegmentHeaderFlags(std::ostream &out, const StdVideoEncodeH265SliceSegmentHeaderFlags* structInfo, Decoded_StdVideoEncodeH265SliceSegmentHeaderFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// first_slice_segment_in_pic_flag
    struct_body << "\t" << structInfo->first_slice_segment_in_pic_flag << "," << std::endl;
// dependent_slice_segment_flag
    struct_body << "\t\t\t" << structInfo->dependent_slice_segment_flag << "," << std::endl;
// slice_sao_luma_flag
    struct_body << "\t\t\t" << structInfo->slice_sao_luma_flag << "," << std::endl;
// slice_sao_chroma_flag
    struct_body << "\t\t\t" << structInfo->slice_sao_chroma_flag << "," << std::endl;
// num_ref_idx_active_override_flag
    struct_body << "\t\t\t" << structInfo->num_ref_idx_active_override_flag << "," << std::endl;
// mvd_l1_zero_flag
    struct_body << "\t\t\t" << structInfo->mvd_l1_zero_flag << "," << std::endl;
// cabac_init_flag
    struct_body << "\t\t\t" << structInfo->cabac_init_flag << "," << std::endl;
// cu_chroma_qp_offset_enabled_flag
    struct_body << "\t\t\t" << structInfo->cu_chroma_qp_offset_enabled_flag << "," << std::endl;
// deblocking_filter_override_flag
    struct_body << "\t\t\t" << structInfo->deblocking_filter_override_flag << "," << std::endl;
// slice_deblocking_filter_disabled_flag
    struct_body << "\t\t\t" << structInfo->slice_deblocking_filter_disabled_flag << "," << std::endl;
// collocated_from_l0_flag
    struct_body << "\t\t\t" << structInfo->collocated_from_l0_flag << "," << std::endl;
// slice_loop_filter_across_slices_enabled_flag
    struct_body << "\t\t\t" << structInfo->slice_loop_filter_across_slices_enabled_flag << "," << std::endl;
// reserved
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH265SliceSegmentHeaderFlags");
    out << "\t\t" << "StdVideoEncodeH265SliceSegmentHeaderFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH265WeightTable(std::ostream &out, const StdVideoEncodeH265WeightTable* structInfo, Decoded_StdVideoEncodeH265WeightTable* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH265WeightTableFlags(out,
                                                                                   &structInfo->flags,
                                                                                   metaInfo->flags,
                                                                                   consumer);
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// luma_log2_weight_denom
    struct_body << "\t\t\t" << std::to_string(structInfo->luma_log2_weight_denom) << "," << std::endl;
// delta_chroma_log2_weight_denom
    struct_body << "\t\t\t" << std::to_string(structInfo->delta_chroma_log2_weight_denom) << "," << std::endl;
// delta_luma_weight_l0
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->delta_luma_weight_l0[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
// luma_offset_l0
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_offset_l0[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
// delta_chroma_weight_l0
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->delta_chroma_weight_l0[0][0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
// delta_chroma_offset_l0
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->delta_chroma_offset_l0[0][0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
// delta_luma_weight_l1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->delta_luma_weight_l1[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
// luma_offset_l1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_offset_l1[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
// delta_chroma_weight_l1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->delta_chroma_weight_l1[0][0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
// delta_chroma_offset_l1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->delta_chroma_offset_l1[0][0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH265WeightTable");
    out << "\t\t" << "StdVideoEncodeH265WeightTable " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH265WeightTableFlags(std::ostream &out, const StdVideoEncodeH265WeightTableFlags* structInfo, Decoded_StdVideoEncodeH265WeightTableFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// luma_weight_l0_flag
    struct_body << "\t" << structInfo->luma_weight_l0_flag << "," << std::endl;
// chroma_weight_l0_flag
    struct_body << "\t\t\t" << structInfo->chroma_weight_l0_flag << "," << std::endl;
// luma_weight_l1_flag
    struct_body << "\t\t\t" << structInfo->luma_weight_l1_flag << "," << std::endl;
// chroma_weight_l1_flag
    struct_body << "\t\t\t" << structInfo->chroma_weight_l1_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH265WeightTableFlags");
    out << "\t\t" << "StdVideoEncodeH265WeightTableFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264HrdParameters(std::ostream &out, const StdVideoH264HrdParameters* structInfo, Decoded_StdVideoH264HrdParameters* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// cpb_cnt_minus1
    struct_body << "\t" << std::to_string(structInfo->cpb_cnt_minus1) << "," << std::endl;
// bit_rate_scale
    struct_body << "\t\t\t" << std::to_string(structInfo->bit_rate_scale) << "," << std::endl;
// cpb_size_scale
    struct_body << "\t\t\t" << std::to_string(structInfo->cpb_size_scale) << "," << std::endl;
// reserved1
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
// bit_rate_value_minus1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->bit_rate_value_minus1[0]), STD_VIDEO_H264_CPB_CNT_LIST_SIZE) << "," << std::endl;
// cpb_size_value_minus1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->cpb_size_value_minus1[0]), STD_VIDEO_H264_CPB_CNT_LIST_SIZE) << "," << std::endl;
// cbr_flag
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->cbr_flag[0]), STD_VIDEO_H264_CPB_CNT_LIST_SIZE) << "," << std::endl;
// initial_cpb_removal_delay_length_minus1
    struct_body << "\t\t\t" << structInfo->initial_cpb_removal_delay_length_minus1 << "," << std::endl;
// cpb_removal_delay_length_minus1
    struct_body << "\t\t\t" << structInfo->cpb_removal_delay_length_minus1 << "," << std::endl;
// dpb_output_delay_length_minus1
    struct_body << "\t\t\t" << structInfo->dpb_output_delay_length_minus1 << "," << std::endl;
// time_offset_length
    struct_body << "\t\t\t" << structInfo->time_offset_length << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264HrdParameters");
    out << "\t\t" << "StdVideoH264HrdParameters " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264PictureParameterSet(std::ostream &out, const StdVideoH264PictureParameterSet* structInfo, Decoded_StdVideoH264PictureParameterSet* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoH264PpsFlags(out,
                                                                     &structInfo->flags,
                                                                     metaInfo->flags,
                                                                     consumer);
    std::string pscaling_lists_struct = "NULL";
    if (structInfo->pScalingLists != NULL) {
        pscaling_lists_struct = GenerateStruct_StdVideoH264ScalingLists(out,
                                                                        structInfo->pScalingLists,
                                                                        metaInfo->pScalingLists->GetMetaStructPointer(),
                                                                        consumer);
        pscaling_lists_struct.insert(0, "&");
    }
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// seq_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->seq_parameter_set_id) << "," << std::endl;
// pic_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->pic_parameter_set_id) << "," << std::endl;
// num_ref_idx_l0_default_active_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->num_ref_idx_l0_default_active_minus1) << "," << std::endl;
// num_ref_idx_l1_default_active_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->num_ref_idx_l1_default_active_minus1) << "," << std::endl;
// weighted_bipred_idc
    struct_body << "\t\t\t" << "StdVideoH264WeightedBipredIdc(" << structInfo->weighted_bipred_idc << ")" << "," << std::endl;
// pic_init_qp_minus26
    struct_body << "\t\t\t" << std::to_string(structInfo->pic_init_qp_minus26) << "," << std::endl;
// pic_init_qs_minus26
    struct_body << "\t\t\t" << std::to_string(structInfo->pic_init_qs_minus26) << "," << std::endl;
// chroma_qp_index_offset
    struct_body << "\t\t\t" << std::to_string(structInfo->chroma_qp_index_offset) << "," << std::endl;
// second_chroma_qp_index_offset
    struct_body << "\t\t\t" << std::to_string(structInfo->second_chroma_qp_index_offset) << "," << std::endl;
// pScalingLists
    struct_body << "\t\t\t" << pscaling_lists_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264PictureParameterSet");
    out << "\t\t" << "StdVideoH264PictureParameterSet " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264PpsFlags(std::ostream &out, const StdVideoH264PpsFlags* structInfo, Decoded_StdVideoH264PpsFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// transform_8x8_mode_flag
    struct_body << "\t" << structInfo->transform_8x8_mode_flag << "," << std::endl;
// redundant_pic_cnt_present_flag
    struct_body << "\t\t\t" << structInfo->redundant_pic_cnt_present_flag << "," << std::endl;
// constrained_intra_pred_flag
    struct_body << "\t\t\t" << structInfo->constrained_intra_pred_flag << "," << std::endl;
// deblocking_filter_control_present_flag
    struct_body << "\t\t\t" << structInfo->deblocking_filter_control_present_flag << "," << std::endl;
// weighted_pred_flag
    struct_body << "\t\t\t" << structInfo->weighted_pred_flag << "," << std::endl;
// bottom_field_pic_order_in_frame_present_flag
    struct_body << "\t\t\t" << structInfo->bottom_field_pic_order_in_frame_present_flag << "," << std::endl;
// entropy_coding_mode_flag
    struct_body << "\t\t\t" << structInfo->entropy_coding_mode_flag << "," << std::endl;
// pic_scaling_matrix_present_flag
    struct_body << "\t\t\t" << structInfo->pic_scaling_matrix_present_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264PpsFlags");
    out << "\t\t" << "StdVideoH264PpsFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264ScalingLists(std::ostream &out, const StdVideoH264ScalingLists* structInfo, Decoded_StdVideoH264ScalingLists* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// scaling_list_present_mask
    struct_body << "\t" << structInfo->scaling_list_present_mask << "," << std::endl;
// use_default_scaling_matrix_mask
    struct_body << "\t\t\t" << structInfo->use_default_scaling_matrix_mask << "," << std::endl;
// ScalingList4x4
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingList4x4[0][0]), STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS) << "," << std::endl;
// ScalingList8x8
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingList8x8[0][0]), STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264ScalingLists");
    out << "\t\t" << "StdVideoH264ScalingLists " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264SequenceParameterSet(std::ostream &out, const StdVideoH264SequenceParameterSet* structInfo, Decoded_StdVideoH264SequenceParameterSet* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoH264SpsFlags(out,
                                                                     &structInfo->flags,
                                                                     metaInfo->flags,
                                                                     consumer);
    std::string poffset_for_ref_frame_array = "NULL";
    if (structInfo->pOffsetForRefFrame != NULL) {
        poffset_for_ref_frame_array = "pOffsetForRefFrame_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "int32_t " << poffset_for_ref_frame_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pOffsetForRefFrame, structInfo->num_ref_frames_in_pic_order_cnt_cycle) << ";" << std::endl;
    }
    std::string pscaling_lists_struct = "NULL";
    if (structInfo->pScalingLists != NULL) {
        pscaling_lists_struct = GenerateStruct_StdVideoH264ScalingLists(out,
                                                                        structInfo->pScalingLists,
                                                                        metaInfo->pScalingLists->GetMetaStructPointer(),
                                                                        consumer);
        pscaling_lists_struct.insert(0, "&");
    }
    std::string psequence_parameter_set_vui_struct = "NULL";
    if (structInfo->pSequenceParameterSetVui != NULL) {
        psequence_parameter_set_vui_struct = GenerateStruct_StdVideoH264SequenceParameterSetVui(out,
                                                                                                structInfo->pSequenceParameterSetVui,
                                                                                                metaInfo->pSequenceParameterSetVui->GetMetaStructPointer(),
                                                                                                consumer);
        psequence_parameter_set_vui_struct.insert(0, "&");
    }
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// profile_idc
    struct_body << "\t\t\t" << "StdVideoH264ProfileIdc(" << structInfo->profile_idc << ")" << "," << std::endl;
// level_idc
    struct_body << "\t\t\t" << "StdVideoH264LevelIdc(" << structInfo->level_idc << ")" << "," << std::endl;
// chroma_format_idc
    struct_body << "\t\t\t" << "StdVideoH264ChromaFormatIdc(" << structInfo->chroma_format_idc << ")" << "," << std::endl;
// seq_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->seq_parameter_set_id) << "," << std::endl;
// bit_depth_luma_minus8
    struct_body << "\t\t\t" << std::to_string(structInfo->bit_depth_luma_minus8) << "," << std::endl;
// bit_depth_chroma_minus8
    struct_body << "\t\t\t" << std::to_string(structInfo->bit_depth_chroma_minus8) << "," << std::endl;
// log2_max_frame_num_minus4
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_max_frame_num_minus4) << "," << std::endl;
// pic_order_cnt_type
    struct_body << "\t\t\t" << "StdVideoH264PocType(" << structInfo->pic_order_cnt_type << ")" << "," << std::endl;
// offset_for_non_ref_pic
    struct_body << "\t\t\t" << structInfo->offset_for_non_ref_pic << "," << std::endl;
// offset_for_top_to_bottom_field
    struct_body << "\t\t\t" << structInfo->offset_for_top_to_bottom_field << "," << std::endl;
// log2_max_pic_order_cnt_lsb_minus4
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_max_pic_order_cnt_lsb_minus4) << "," << std::endl;
// num_ref_frames_in_pic_order_cnt_cycle
    struct_body << "\t\t\t" << std::to_string(structInfo->num_ref_frames_in_pic_order_cnt_cycle) << "," << std::endl;
// max_num_ref_frames
    struct_body << "\t\t\t" << std::to_string(structInfo->max_num_ref_frames) << "," << std::endl;
// reserved1
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
// pic_width_in_mbs_minus1
    struct_body << "\t\t\t" << structInfo->pic_width_in_mbs_minus1 << "," << std::endl;
// pic_height_in_map_units_minus1
    struct_body << "\t\t\t" << structInfo->pic_height_in_map_units_minus1 << "," << std::endl;
// frame_crop_left_offset
    struct_body << "\t\t\t" << structInfo->frame_crop_left_offset << "," << std::endl;
// frame_crop_right_offset
    struct_body << "\t\t\t" << structInfo->frame_crop_right_offset << "," << std::endl;
// frame_crop_top_offset
    struct_body << "\t\t\t" << structInfo->frame_crop_top_offset << "," << std::endl;
// frame_crop_bottom_offset
    struct_body << "\t\t\t" << structInfo->frame_crop_bottom_offset << "," << std::endl;
// reserved2
    struct_body << "\t\t\t" << structInfo->reserved2 << "," << std::endl;
// pOffsetForRefFrame
    struct_body << "\t\t\t" << poffset_for_ref_frame_array << "," << std::endl;
// pScalingLists
    struct_body << "\t\t\t" << pscaling_lists_struct << "," << std::endl;
// pSequenceParameterSetVui
    struct_body << "\t\t\t" << psequence_parameter_set_vui_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264SequenceParameterSet");
    out << "\t\t" << "StdVideoH264SequenceParameterSet " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264SequenceParameterSetVui(std::ostream &out, const StdVideoH264SequenceParameterSetVui* structInfo, Decoded_StdVideoH264SequenceParameterSetVui* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoH264SpsVuiFlags(out,
                                                                        &structInfo->flags,
                                                                        metaInfo->flags,
                                                                        consumer);
    std::string phrd_parameters_struct = "NULL";
    if (structInfo->pHrdParameters != NULL) {
        phrd_parameters_struct = GenerateStruct_StdVideoH264HrdParameters(out,
                                                                          structInfo->pHrdParameters,
                                                                          metaInfo->pHrdParameters->GetMetaStructPointer(),
                                                                          consumer);
        phrd_parameters_struct.insert(0, "&");
    }
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// aspect_ratio_idc
    struct_body << "\t\t\t" << "StdVideoH264AspectRatioIdc(" << structInfo->aspect_ratio_idc << ")" << "," << std::endl;
// sar_width
    struct_body << "\t\t\t" << structInfo->sar_width << "," << std::endl;
// sar_height
    struct_body << "\t\t\t" << structInfo->sar_height << "," << std::endl;
// video_format
    struct_body << "\t\t\t" << std::to_string(structInfo->video_format) << "," << std::endl;
// colour_primaries
    struct_body << "\t\t\t" << std::to_string(structInfo->colour_primaries) << "," << std::endl;
// transfer_characteristics
    struct_body << "\t\t\t" << std::to_string(structInfo->transfer_characteristics) << "," << std::endl;
// matrix_coefficients
    struct_body << "\t\t\t" << std::to_string(structInfo->matrix_coefficients) << "," << std::endl;
// num_units_in_tick
    struct_body << "\t\t\t" << structInfo->num_units_in_tick << "," << std::endl;
// time_scale
    struct_body << "\t\t\t" << structInfo->time_scale << "," << std::endl;
// max_num_reorder_frames
    struct_body << "\t\t\t" << std::to_string(structInfo->max_num_reorder_frames) << "," << std::endl;
// max_dec_frame_buffering
    struct_body << "\t\t\t" << std::to_string(structInfo->max_dec_frame_buffering) << "," << std::endl;
// chroma_sample_loc_type_top_field
    struct_body << "\t\t\t" << std::to_string(structInfo->chroma_sample_loc_type_top_field) << "," << std::endl;
// chroma_sample_loc_type_bottom_field
    struct_body << "\t\t\t" << std::to_string(structInfo->chroma_sample_loc_type_bottom_field) << "," << std::endl;
// reserved1
    struct_body << "\t\t\t" << structInfo->reserved1 << "," << std::endl;
// pHrdParameters
    struct_body << "\t\t\t" << phrd_parameters_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264SequenceParameterSetVui");
    out << "\t\t" << "StdVideoH264SequenceParameterSetVui " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264SpsFlags(std::ostream &out, const StdVideoH264SpsFlags* structInfo, Decoded_StdVideoH264SpsFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// constraint_set0_flag
    struct_body << "\t" << structInfo->constraint_set0_flag << "," << std::endl;
// constraint_set1_flag
    struct_body << "\t\t\t" << structInfo->constraint_set1_flag << "," << std::endl;
// constraint_set2_flag
    struct_body << "\t\t\t" << structInfo->constraint_set2_flag << "," << std::endl;
// constraint_set3_flag
    struct_body << "\t\t\t" << structInfo->constraint_set3_flag << "," << std::endl;
// constraint_set4_flag
    struct_body << "\t\t\t" << structInfo->constraint_set4_flag << "," << std::endl;
// constraint_set5_flag
    struct_body << "\t\t\t" << structInfo->constraint_set5_flag << "," << std::endl;
// direct_8x8_inference_flag
    struct_body << "\t\t\t" << structInfo->direct_8x8_inference_flag << "," << std::endl;
// mb_adaptive_frame_field_flag
    struct_body << "\t\t\t" << structInfo->mb_adaptive_frame_field_flag << "," << std::endl;
// frame_mbs_only_flag
    struct_body << "\t\t\t" << structInfo->frame_mbs_only_flag << "," << std::endl;
// delta_pic_order_always_zero_flag
    struct_body << "\t\t\t" << structInfo->delta_pic_order_always_zero_flag << "," << std::endl;
// separate_colour_plane_flag
    struct_body << "\t\t\t" << structInfo->separate_colour_plane_flag << "," << std::endl;
// gaps_in_frame_num_value_allowed_flag
    struct_body << "\t\t\t" << structInfo->gaps_in_frame_num_value_allowed_flag << "," << std::endl;
// qpprime_y_zero_transform_bypass_flag
    struct_body << "\t\t\t" << structInfo->qpprime_y_zero_transform_bypass_flag << "," << std::endl;
// frame_cropping_flag
    struct_body << "\t\t\t" << structInfo->frame_cropping_flag << "," << std::endl;
// seq_scaling_matrix_present_flag
    struct_body << "\t\t\t" << structInfo->seq_scaling_matrix_present_flag << "," << std::endl;
// vui_parameters_present_flag
    struct_body << "\t\t\t" << structInfo->vui_parameters_present_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264SpsFlags");
    out << "\t\t" << "StdVideoH264SpsFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264SpsVuiFlags(std::ostream &out, const StdVideoH264SpsVuiFlags* structInfo, Decoded_StdVideoH264SpsVuiFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// aspect_ratio_info_present_flag
    struct_body << "\t" << structInfo->aspect_ratio_info_present_flag << "," << std::endl;
// overscan_info_present_flag
    struct_body << "\t\t\t" << structInfo->overscan_info_present_flag << "," << std::endl;
// overscan_appropriate_flag
    struct_body << "\t\t\t" << structInfo->overscan_appropriate_flag << "," << std::endl;
// video_signal_type_present_flag
    struct_body << "\t\t\t" << structInfo->video_signal_type_present_flag << "," << std::endl;
// video_full_range_flag
    struct_body << "\t\t\t" << structInfo->video_full_range_flag << "," << std::endl;
// color_description_present_flag
    struct_body << "\t\t\t" << structInfo->color_description_present_flag << "," << std::endl;
// chroma_loc_info_present_flag
    struct_body << "\t\t\t" << structInfo->chroma_loc_info_present_flag << "," << std::endl;
// timing_info_present_flag
    struct_body << "\t\t\t" << structInfo->timing_info_present_flag << "," << std::endl;
// fixed_frame_rate_flag
    struct_body << "\t\t\t" << structInfo->fixed_frame_rate_flag << "," << std::endl;
// bitstream_restriction_flag
    struct_body << "\t\t\t" << structInfo->bitstream_restriction_flag << "," << std::endl;
// nal_hrd_parameters_present_flag
    struct_body << "\t\t\t" << structInfo->nal_hrd_parameters_present_flag << "," << std::endl;
// vcl_hrd_parameters_present_flag
    struct_body << "\t\t\t" << structInfo->vcl_hrd_parameters_present_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264SpsVuiFlags");
    out << "\t\t" << "StdVideoH264SpsVuiFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265DecPicBufMgr(std::ostream &out, const StdVideoH265DecPicBufMgr* structInfo, Decoded_StdVideoH265DecPicBufMgr* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// max_latency_increase_plus1
    struct_body << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->max_latency_increase_plus1[0]), STD_VIDEO_H265_SUBLAYERS_LIST_SIZE) << "," << std::endl;
// max_dec_pic_buffering_minus1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->max_dec_pic_buffering_minus1[0]), STD_VIDEO_H265_SUBLAYERS_LIST_SIZE) << "," << std::endl;
// max_num_reorder_pics
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->max_num_reorder_pics[0]), STD_VIDEO_H265_SUBLAYERS_LIST_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265DecPicBufMgr");
    out << "\t\t" << "StdVideoH265DecPicBufMgr " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265HrdFlags(std::ostream &out, const StdVideoH265HrdFlags* structInfo, Decoded_StdVideoH265HrdFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// nal_hrd_parameters_present_flag
    struct_body << "\t" << structInfo->nal_hrd_parameters_present_flag << "," << std::endl;
// vcl_hrd_parameters_present_flag
    struct_body << "\t\t\t" << structInfo->vcl_hrd_parameters_present_flag << "," << std::endl;
// sub_pic_hrd_params_present_flag
    struct_body << "\t\t\t" << structInfo->sub_pic_hrd_params_present_flag << "," << std::endl;
// sub_pic_cpb_params_in_pic_timing_sei_flag
    struct_body << "\t\t\t" << structInfo->sub_pic_cpb_params_in_pic_timing_sei_flag << "," << std::endl;
// fixed_pic_rate_general_flag
    struct_body << "\t\t\t" << structInfo->fixed_pic_rate_general_flag << "," << std::endl;
// fixed_pic_rate_within_cvs_flag
    struct_body << "\t\t\t" << structInfo->fixed_pic_rate_within_cvs_flag << "," << std::endl;
// low_delay_hrd_flag
    struct_body << "\t\t\t" << structInfo->low_delay_hrd_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265HrdFlags");
    out << "\t\t" << "StdVideoH265HrdFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265HrdParameters(std::ostream &out, const StdVideoH265HrdParameters* structInfo, Decoded_StdVideoH265HrdParameters* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoH265HrdFlags(out,
                                                                     &structInfo->flags,
                                                                     metaInfo->flags,
                                                                     consumer);
    std::string psub_layer_hrd_parameters_nal_struct = "NULL";
    if (structInfo->pSubLayerHrdParametersNal != NULL) {
        psub_layer_hrd_parameters_nal_struct = GenerateStruct_StdVideoH265SubLayerHrdParameters(out,
                                                                                                structInfo->pSubLayerHrdParametersNal,
                                                                                                metaInfo->pSubLayerHrdParametersNal->GetMetaStructPointer(),
                                                                                                consumer);
        psub_layer_hrd_parameters_nal_struct.insert(0, "&");
    }
    std::string psub_layer_hrd_parameters_vcl_struct = "NULL";
    if (structInfo->pSubLayerHrdParametersVcl != NULL) {
        psub_layer_hrd_parameters_vcl_struct = GenerateStruct_StdVideoH265SubLayerHrdParameters(out,
                                                                                                structInfo->pSubLayerHrdParametersVcl,
                                                                                                metaInfo->pSubLayerHrdParametersVcl->GetMetaStructPointer(),
                                                                                                consumer);
        psub_layer_hrd_parameters_vcl_struct.insert(0, "&");
    }
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// tick_divisor_minus2
    struct_body << "\t\t\t" << std::to_string(structInfo->tick_divisor_minus2) << "," << std::endl;
// du_cpb_removal_delay_increment_length_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->du_cpb_removal_delay_increment_length_minus1) << "," << std::endl;
// dpb_output_delay_du_length_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->dpb_output_delay_du_length_minus1) << "," << std::endl;
// bit_rate_scale
    struct_body << "\t\t\t" << std::to_string(structInfo->bit_rate_scale) << "," << std::endl;
// cpb_size_scale
    struct_body << "\t\t\t" << std::to_string(structInfo->cpb_size_scale) << "," << std::endl;
// cpb_size_du_scale
    struct_body << "\t\t\t" << std::to_string(structInfo->cpb_size_du_scale) << "," << std::endl;
// initial_cpb_removal_delay_length_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->initial_cpb_removal_delay_length_minus1) << "," << std::endl;
// au_cpb_removal_delay_length_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->au_cpb_removal_delay_length_minus1) << "," << std::endl;
// dpb_output_delay_length_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->dpb_output_delay_length_minus1) << "," << std::endl;
// cpb_cnt_minus1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->cpb_cnt_minus1[0]), STD_VIDEO_H265_SUBLAYERS_LIST_SIZE) << "," << std::endl;
// elemental_duration_in_tc_minus1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->elemental_duration_in_tc_minus1[0]), STD_VIDEO_H265_SUBLAYERS_LIST_SIZE) << "," << std::endl;
// reserved
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->reserved[0]), 3) << "," << std::endl;
// pSubLayerHrdParametersNal
    struct_body << "\t\t\t" << psub_layer_hrd_parameters_nal_struct << "," << std::endl;
// pSubLayerHrdParametersVcl
    struct_body << "\t\t\t" << psub_layer_hrd_parameters_vcl_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265HrdParameters");
    out << "\t\t" << "StdVideoH265HrdParameters " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265LongTermRefPicsSps(std::ostream &out, const StdVideoH265LongTermRefPicsSps* structInfo, Decoded_StdVideoH265LongTermRefPicsSps* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// used_by_curr_pic_lt_sps_flag
    struct_body << "\t" << structInfo->used_by_curr_pic_lt_sps_flag << "," << std::endl;
// lt_ref_pic_poc_lsb_sps
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->lt_ref_pic_poc_lsb_sps[0]), STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265LongTermRefPicsSps");
    out << "\t\t" << "StdVideoH265LongTermRefPicsSps " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265PictureParameterSet(std::ostream &out, const StdVideoH265PictureParameterSet* structInfo, Decoded_StdVideoH265PictureParameterSet* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoH265PpsFlags(out,
                                                                     &structInfo->flags,
                                                                     metaInfo->flags,
                                                                     consumer);
    std::string pscaling_lists_struct = "NULL";
    if (structInfo->pScalingLists != NULL) {
        pscaling_lists_struct = GenerateStruct_StdVideoH265ScalingLists(out,
                                                                        structInfo->pScalingLists,
                                                                        metaInfo->pScalingLists->GetMetaStructPointer(),
                                                                        consumer);
        pscaling_lists_struct.insert(0, "&");
    }
    std::string ppredictor_palette_entries_struct = "NULL";
    if (structInfo->pPredictorPaletteEntries != NULL) {
        ppredictor_palette_entries_struct = GenerateStruct_StdVideoH265PredictorPaletteEntries(out,
                                                                                               structInfo->pPredictorPaletteEntries,
                                                                                               metaInfo->pPredictorPaletteEntries->GetMetaStructPointer(),
                                                                                               consumer);
        ppredictor_palette_entries_struct.insert(0, "&");
    }
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// pps_pic_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->pps_pic_parameter_set_id) << "," << std::endl;
// pps_seq_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->pps_seq_parameter_set_id) << "," << std::endl;
// sps_video_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->sps_video_parameter_set_id) << "," << std::endl;
// num_extra_slice_header_bits
    struct_body << "\t\t\t" << std::to_string(structInfo->num_extra_slice_header_bits) << "," << std::endl;
// num_ref_idx_l0_default_active_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->num_ref_idx_l0_default_active_minus1) << "," << std::endl;
// num_ref_idx_l1_default_active_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->num_ref_idx_l1_default_active_minus1) << "," << std::endl;
// init_qp_minus26
    struct_body << "\t\t\t" << std::to_string(structInfo->init_qp_minus26) << "," << std::endl;
// diff_cu_qp_delta_depth
    struct_body << "\t\t\t" << std::to_string(structInfo->diff_cu_qp_delta_depth) << "," << std::endl;
// pps_cb_qp_offset
    struct_body << "\t\t\t" << std::to_string(structInfo->pps_cb_qp_offset) << "," << std::endl;
// pps_cr_qp_offset
    struct_body << "\t\t\t" << std::to_string(structInfo->pps_cr_qp_offset) << "," << std::endl;
// pps_beta_offset_div2
    struct_body << "\t\t\t" << std::to_string(structInfo->pps_beta_offset_div2) << "," << std::endl;
// pps_tc_offset_div2
    struct_body << "\t\t\t" << std::to_string(structInfo->pps_tc_offset_div2) << "," << std::endl;
// log2_parallel_merge_level_minus2
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_parallel_merge_level_minus2) << "," << std::endl;
// log2_max_transform_skip_block_size_minus2
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_max_transform_skip_block_size_minus2) << "," << std::endl;
// diff_cu_chroma_qp_offset_depth
    struct_body << "\t\t\t" << std::to_string(structInfo->diff_cu_chroma_qp_offset_depth) << "," << std::endl;
// chroma_qp_offset_list_len_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->chroma_qp_offset_list_len_minus1) << "," << std::endl;
// cb_qp_offset_list
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->cb_qp_offset_list[0]), STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE) << "," << std::endl;
// cr_qp_offset_list
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->cr_qp_offset_list[0]), STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE) << "," << std::endl;
// log2_sao_offset_scale_luma
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_sao_offset_scale_luma) << "," << std::endl;
// log2_sao_offset_scale_chroma
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_sao_offset_scale_chroma) << "," << std::endl;
// pps_act_y_qp_offset_plus5
    struct_body << "\t\t\t" << std::to_string(structInfo->pps_act_y_qp_offset_plus5) << "," << std::endl;
// pps_act_cb_qp_offset_plus5
    struct_body << "\t\t\t" << std::to_string(structInfo->pps_act_cb_qp_offset_plus5) << "," << std::endl;
// pps_act_cr_qp_offset_plus3
    struct_body << "\t\t\t" << std::to_string(structInfo->pps_act_cr_qp_offset_plus3) << "," << std::endl;
// pps_num_palette_predictor_initializers
    struct_body << "\t\t\t" << std::to_string(structInfo->pps_num_palette_predictor_initializers) << "," << std::endl;
// luma_bit_depth_entry_minus8
    struct_body << "\t\t\t" << std::to_string(structInfo->luma_bit_depth_entry_minus8) << "," << std::endl;
// chroma_bit_depth_entry_minus8
    struct_body << "\t\t\t" << std::to_string(structInfo->chroma_bit_depth_entry_minus8) << "," << std::endl;
// num_tile_columns_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->num_tile_columns_minus1) << "," << std::endl;
// num_tile_rows_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->num_tile_rows_minus1) << "," << std::endl;
// reserved1
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
// reserved2
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved2) << "," << std::endl;
// column_width_minus1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->column_width_minus1[0]), STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE) << "," << std::endl;
// row_height_minus1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->row_height_minus1[0]), STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE) << "," << std::endl;
// reserved3
    struct_body << "\t\t\t" << structInfo->reserved3 << "," << std::endl;
// pScalingLists
    struct_body << "\t\t\t" << pscaling_lists_struct << "," << std::endl;
// pPredictorPaletteEntries
    struct_body << "\t\t\t" << ppredictor_palette_entries_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265PictureParameterSet");
    out << "\t\t" << "StdVideoH265PictureParameterSet " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265PpsFlags(std::ostream &out, const StdVideoH265PpsFlags* structInfo, Decoded_StdVideoH265PpsFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// dependent_slice_segments_enabled_flag
    struct_body << "\t" << structInfo->dependent_slice_segments_enabled_flag << "," << std::endl;
// output_flag_present_flag
    struct_body << "\t\t\t" << structInfo->output_flag_present_flag << "," << std::endl;
// sign_data_hiding_enabled_flag
    struct_body << "\t\t\t" << structInfo->sign_data_hiding_enabled_flag << "," << std::endl;
// cabac_init_present_flag
    struct_body << "\t\t\t" << structInfo->cabac_init_present_flag << "," << std::endl;
// constrained_intra_pred_flag
    struct_body << "\t\t\t" << structInfo->constrained_intra_pred_flag << "," << std::endl;
// transform_skip_enabled_flag
    struct_body << "\t\t\t" << structInfo->transform_skip_enabled_flag << "," << std::endl;
// cu_qp_delta_enabled_flag
    struct_body << "\t\t\t" << structInfo->cu_qp_delta_enabled_flag << "," << std::endl;
// pps_slice_chroma_qp_offsets_present_flag
    struct_body << "\t\t\t" << structInfo->pps_slice_chroma_qp_offsets_present_flag << "," << std::endl;
// weighted_pred_flag
    struct_body << "\t\t\t" << structInfo->weighted_pred_flag << "," << std::endl;
// weighted_bipred_flag
    struct_body << "\t\t\t" << structInfo->weighted_bipred_flag << "," << std::endl;
// transquant_bypass_enabled_flag
    struct_body << "\t\t\t" << structInfo->transquant_bypass_enabled_flag << "," << std::endl;
// tiles_enabled_flag
    struct_body << "\t\t\t" << structInfo->tiles_enabled_flag << "," << std::endl;
// entropy_coding_sync_enabled_flag
    struct_body << "\t\t\t" << structInfo->entropy_coding_sync_enabled_flag << "," << std::endl;
// uniform_spacing_flag
    struct_body << "\t\t\t" << structInfo->uniform_spacing_flag << "," << std::endl;
// loop_filter_across_tiles_enabled_flag
    struct_body << "\t\t\t" << structInfo->loop_filter_across_tiles_enabled_flag << "," << std::endl;
// pps_loop_filter_across_slices_enabled_flag
    struct_body << "\t\t\t" << structInfo->pps_loop_filter_across_slices_enabled_flag << "," << std::endl;
// deblocking_filter_control_present_flag
    struct_body << "\t\t\t" << structInfo->deblocking_filter_control_present_flag << "," << std::endl;
// deblocking_filter_override_enabled_flag
    struct_body << "\t\t\t" << structInfo->deblocking_filter_override_enabled_flag << "," << std::endl;
// pps_deblocking_filter_disabled_flag
    struct_body << "\t\t\t" << structInfo->pps_deblocking_filter_disabled_flag << "," << std::endl;
// pps_scaling_list_data_present_flag
    struct_body << "\t\t\t" << structInfo->pps_scaling_list_data_present_flag << "," << std::endl;
// lists_modification_present_flag
    struct_body << "\t\t\t" << structInfo->lists_modification_present_flag << "," << std::endl;
// slice_segment_header_extension_present_flag
    struct_body << "\t\t\t" << structInfo->slice_segment_header_extension_present_flag << "," << std::endl;
// pps_extension_present_flag
    struct_body << "\t\t\t" << structInfo->pps_extension_present_flag << "," << std::endl;
// cross_component_prediction_enabled_flag
    struct_body << "\t\t\t" << structInfo->cross_component_prediction_enabled_flag << "," << std::endl;
// chroma_qp_offset_list_enabled_flag
    struct_body << "\t\t\t" << structInfo->chroma_qp_offset_list_enabled_flag << "," << std::endl;
// pps_curr_pic_ref_enabled_flag
    struct_body << "\t\t\t" << structInfo->pps_curr_pic_ref_enabled_flag << "," << std::endl;
// residual_adaptive_colour_transform_enabled_flag
    struct_body << "\t\t\t" << structInfo->residual_adaptive_colour_transform_enabled_flag << "," << std::endl;
// pps_slice_act_qp_offsets_present_flag
    struct_body << "\t\t\t" << structInfo->pps_slice_act_qp_offsets_present_flag << "," << std::endl;
// pps_palette_predictor_initializers_present_flag
    struct_body << "\t\t\t" << structInfo->pps_palette_predictor_initializers_present_flag << "," << std::endl;
// monochrome_palette_flag
    struct_body << "\t\t\t" << structInfo->monochrome_palette_flag << "," << std::endl;
// pps_range_extension_flag
    struct_body << "\t\t\t" << structInfo->pps_range_extension_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265PpsFlags");
    out << "\t\t" << "StdVideoH265PpsFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265PredictorPaletteEntries(std::ostream &out, const StdVideoH265PredictorPaletteEntries* structInfo, Decoded_StdVideoH265PredictorPaletteEntries* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// PredictorPaletteEntries
    struct_body << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->PredictorPaletteEntries[0][0]), STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265PredictorPaletteEntries");
    out << "\t\t" << "StdVideoH265PredictorPaletteEntries " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265ProfileTierLevel(std::ostream &out, const StdVideoH265ProfileTierLevel* structInfo, Decoded_StdVideoH265ProfileTierLevel* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoH265ProfileTierLevelFlags(out,
                                                                                  &structInfo->flags,
                                                                                  metaInfo->flags,
                                                                                  consumer);
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// general_profile_idc
    struct_body << "\t\t\t" << "StdVideoH265ProfileIdc(" << structInfo->general_profile_idc << ")" << "," << std::endl;
// general_level_idc
    struct_body << "\t\t\t" << "StdVideoH265LevelIdc(" << structInfo->general_level_idc << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265ProfileTierLevel");
    out << "\t\t" << "StdVideoH265ProfileTierLevel " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265ProfileTierLevelFlags(std::ostream &out, const StdVideoH265ProfileTierLevelFlags* structInfo, Decoded_StdVideoH265ProfileTierLevelFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// general_tier_flag
    struct_body << "\t" << structInfo->general_tier_flag << "," << std::endl;
// general_progressive_source_flag
    struct_body << "\t\t\t" << structInfo->general_progressive_source_flag << "," << std::endl;
// general_interlaced_source_flag
    struct_body << "\t\t\t" << structInfo->general_interlaced_source_flag << "," << std::endl;
// general_non_packed_constraint_flag
    struct_body << "\t\t\t" << structInfo->general_non_packed_constraint_flag << "," << std::endl;
// general_frame_only_constraint_flag
    struct_body << "\t\t\t" << structInfo->general_frame_only_constraint_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265ProfileTierLevelFlags");
    out << "\t\t" << "StdVideoH265ProfileTierLevelFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265ScalingLists(std::ostream &out, const StdVideoH265ScalingLists* structInfo, Decoded_StdVideoH265ScalingLists* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// ScalingList4x4
    struct_body << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingList4x4[0][0]), STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS) << "," << std::endl;
// ScalingList8x8
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingList8x8[0][0]), STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS) << "," << std::endl;
// ScalingList16x16
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingList16x16[0][0]), STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS) << "," << std::endl;
// ScalingList32x32
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingList32x32[0][0]), STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS) << "," << std::endl;
// ScalingListDCCoef16x16
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingListDCCoef16x16[0]), STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS) << "," << std::endl;
// ScalingListDCCoef32x32
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingListDCCoef32x32[0]), STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265ScalingLists");
    out << "\t\t" << "StdVideoH265ScalingLists " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265SequenceParameterSet(std::ostream &out, const StdVideoH265SequenceParameterSet* structInfo, Decoded_StdVideoH265SequenceParameterSet* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoH265SpsFlags(out,
                                                                     &structInfo->flags,
                                                                     metaInfo->flags,
                                                                     consumer);
    std::string pprofile_tier_level_struct = "NULL";
    if (structInfo->pProfileTierLevel != NULL) {
        pprofile_tier_level_struct = GenerateStruct_StdVideoH265ProfileTierLevel(out,
                                                                                 structInfo->pProfileTierLevel,
                                                                                 metaInfo->pProfileTierLevel->GetMetaStructPointer(),
                                                                                 consumer);
        pprofile_tier_level_struct.insert(0, "&");
    }
    std::string pdec_pic_buf_mgr_struct = "NULL";
    if (structInfo->pDecPicBufMgr != NULL) {
        pdec_pic_buf_mgr_struct = GenerateStruct_StdVideoH265DecPicBufMgr(out,
                                                                          structInfo->pDecPicBufMgr,
                                                                          metaInfo->pDecPicBufMgr->GetMetaStructPointer(),
                                                                          consumer);
        pdec_pic_buf_mgr_struct.insert(0, "&");
    }
    std::string pscaling_lists_struct = "NULL";
    if (structInfo->pScalingLists != NULL) {
        pscaling_lists_struct = GenerateStruct_StdVideoH265ScalingLists(out,
                                                                        structInfo->pScalingLists,
                                                                        metaInfo->pScalingLists->GetMetaStructPointer(),
                                                                        consumer);
        pscaling_lists_struct.insert(0, "&");
    }
    std::string pshort_term_ref_pic_set_struct = "NULL";
    if (structInfo->pShortTermRefPicSet != NULL) {
        pshort_term_ref_pic_set_struct = GenerateStruct_StdVideoH265ShortTermRefPicSet(out,
                                                                                       structInfo->pShortTermRefPicSet,
                                                                                       metaInfo->pShortTermRefPicSet->GetMetaStructPointer(),
                                                                                       consumer);
        pshort_term_ref_pic_set_struct.insert(0, "&");
    }
    std::string plong_term_ref_pics_sps_struct = "NULL";
    if (structInfo->pLongTermRefPicsSps != NULL) {
        plong_term_ref_pics_sps_struct = GenerateStruct_StdVideoH265LongTermRefPicsSps(out,
                                                                                       structInfo->pLongTermRefPicsSps,
                                                                                       metaInfo->pLongTermRefPicsSps->GetMetaStructPointer(),
                                                                                       consumer);
        plong_term_ref_pics_sps_struct.insert(0, "&");
    }
    std::string psequence_parameter_set_vui_struct = "NULL";
    if (structInfo->pSequenceParameterSetVui != NULL) {
        psequence_parameter_set_vui_struct = GenerateStruct_StdVideoH265SequenceParameterSetVui(out,
                                                                                                structInfo->pSequenceParameterSetVui,
                                                                                                metaInfo->pSequenceParameterSetVui->GetMetaStructPointer(),
                                                                                                consumer);
        psequence_parameter_set_vui_struct.insert(0, "&");
    }
    std::string ppredictor_palette_entries_struct = "NULL";
    if (structInfo->pPredictorPaletteEntries != NULL) {
        ppredictor_palette_entries_struct = GenerateStruct_StdVideoH265PredictorPaletteEntries(out,
                                                                                               structInfo->pPredictorPaletteEntries,
                                                                                               metaInfo->pPredictorPaletteEntries->GetMetaStructPointer(),
                                                                                               consumer);
        ppredictor_palette_entries_struct.insert(0, "&");
    }
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// chroma_format_idc
    struct_body << "\t\t\t" << "StdVideoH265ChromaFormatIdc(" << structInfo->chroma_format_idc << ")" << "," << std::endl;
// pic_width_in_luma_samples
    struct_body << "\t\t\t" << structInfo->pic_width_in_luma_samples << "," << std::endl;
// pic_height_in_luma_samples
    struct_body << "\t\t\t" << structInfo->pic_height_in_luma_samples << "," << std::endl;
// sps_video_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->sps_video_parameter_set_id) << "," << std::endl;
// sps_max_sub_layers_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->sps_max_sub_layers_minus1) << "," << std::endl;
// sps_seq_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->sps_seq_parameter_set_id) << "," << std::endl;
// bit_depth_luma_minus8
    struct_body << "\t\t\t" << std::to_string(structInfo->bit_depth_luma_minus8) << "," << std::endl;
// bit_depth_chroma_minus8
    struct_body << "\t\t\t" << std::to_string(structInfo->bit_depth_chroma_minus8) << "," << std::endl;
// log2_max_pic_order_cnt_lsb_minus4
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_max_pic_order_cnt_lsb_minus4) << "," << std::endl;
// log2_min_luma_coding_block_size_minus3
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_min_luma_coding_block_size_minus3) << "," << std::endl;
// log2_diff_max_min_luma_coding_block_size
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_diff_max_min_luma_coding_block_size) << "," << std::endl;
// log2_min_luma_transform_block_size_minus2
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_min_luma_transform_block_size_minus2) << "," << std::endl;
// log2_diff_max_min_luma_transform_block_size
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_diff_max_min_luma_transform_block_size) << "," << std::endl;
// max_transform_hierarchy_depth_inter
    struct_body << "\t\t\t" << std::to_string(structInfo->max_transform_hierarchy_depth_inter) << "," << std::endl;
// max_transform_hierarchy_depth_intra
    struct_body << "\t\t\t" << std::to_string(structInfo->max_transform_hierarchy_depth_intra) << "," << std::endl;
// num_short_term_ref_pic_sets
    struct_body << "\t\t\t" << std::to_string(structInfo->num_short_term_ref_pic_sets) << "," << std::endl;
// num_long_term_ref_pics_sps
    struct_body << "\t\t\t" << std::to_string(structInfo->num_long_term_ref_pics_sps) << "," << std::endl;
// pcm_sample_bit_depth_luma_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->pcm_sample_bit_depth_luma_minus1) << "," << std::endl;
// pcm_sample_bit_depth_chroma_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->pcm_sample_bit_depth_chroma_minus1) << "," << std::endl;
// log2_min_pcm_luma_coding_block_size_minus3
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_min_pcm_luma_coding_block_size_minus3) << "," << std::endl;
// log2_diff_max_min_pcm_luma_coding_block_size
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_diff_max_min_pcm_luma_coding_block_size) << "," << std::endl;
// reserved1
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
// reserved2
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved2) << "," << std::endl;
// palette_max_size
    struct_body << "\t\t\t" << std::to_string(structInfo->palette_max_size) << "," << std::endl;
// delta_palette_max_predictor_size
    struct_body << "\t\t\t" << std::to_string(structInfo->delta_palette_max_predictor_size) << "," << std::endl;
// motion_vector_resolution_control_idc
    struct_body << "\t\t\t" << std::to_string(structInfo->motion_vector_resolution_control_idc) << "," << std::endl;
// sps_num_palette_predictor_initializers_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->sps_num_palette_predictor_initializers_minus1) << "," << std::endl;
// conf_win_left_offset
    struct_body << "\t\t\t" << structInfo->conf_win_left_offset << "," << std::endl;
// conf_win_right_offset
    struct_body << "\t\t\t" << structInfo->conf_win_right_offset << "," << std::endl;
// conf_win_top_offset
    struct_body << "\t\t\t" << structInfo->conf_win_top_offset << "," << std::endl;
// conf_win_bottom_offset
    struct_body << "\t\t\t" << structInfo->conf_win_bottom_offset << "," << std::endl;
// pProfileTierLevel
    struct_body << "\t\t\t" << pprofile_tier_level_struct << "," << std::endl;
// pDecPicBufMgr
    struct_body << "\t\t\t" << pdec_pic_buf_mgr_struct << "," << std::endl;
// pScalingLists
    struct_body << "\t\t\t" << pscaling_lists_struct << "," << std::endl;
// pShortTermRefPicSet
    struct_body << "\t\t\t" << pshort_term_ref_pic_set_struct << "," << std::endl;
// pLongTermRefPicsSps
    struct_body << "\t\t\t" << plong_term_ref_pics_sps_struct << "," << std::endl;
// pSequenceParameterSetVui
    struct_body << "\t\t\t" << psequence_parameter_set_vui_struct << "," << std::endl;
// pPredictorPaletteEntries
    struct_body << "\t\t\t" << ppredictor_palette_entries_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265SequenceParameterSet");
    out << "\t\t" << "StdVideoH265SequenceParameterSet " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265SequenceParameterSetVui(std::ostream &out, const StdVideoH265SequenceParameterSetVui* structInfo, Decoded_StdVideoH265SequenceParameterSetVui* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoH265SpsVuiFlags(out,
                                                                        &structInfo->flags,
                                                                        metaInfo->flags,
                                                                        consumer);
    std::string phrd_parameters_struct = "NULL";
    if (structInfo->pHrdParameters != NULL) {
        phrd_parameters_struct = GenerateStruct_StdVideoH265HrdParameters(out,
                                                                          structInfo->pHrdParameters,
                                                                          metaInfo->pHrdParameters->GetMetaStructPointer(),
                                                                          consumer);
        phrd_parameters_struct.insert(0, "&");
    }
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// aspect_ratio_idc
    struct_body << "\t\t\t" << "StdVideoH265AspectRatioIdc(" << structInfo->aspect_ratio_idc << ")" << "," << std::endl;
// sar_width
    struct_body << "\t\t\t" << structInfo->sar_width << "," << std::endl;
// sar_height
    struct_body << "\t\t\t" << structInfo->sar_height << "," << std::endl;
// video_format
    struct_body << "\t\t\t" << std::to_string(structInfo->video_format) << "," << std::endl;
// colour_primaries
    struct_body << "\t\t\t" << std::to_string(structInfo->colour_primaries) << "," << std::endl;
// transfer_characteristics
    struct_body << "\t\t\t" << std::to_string(structInfo->transfer_characteristics) << "," << std::endl;
// matrix_coeffs
    struct_body << "\t\t\t" << std::to_string(structInfo->matrix_coeffs) << "," << std::endl;
// chroma_sample_loc_type_top_field
    struct_body << "\t\t\t" << std::to_string(structInfo->chroma_sample_loc_type_top_field) << "," << std::endl;
// chroma_sample_loc_type_bottom_field
    struct_body << "\t\t\t" << std::to_string(structInfo->chroma_sample_loc_type_bottom_field) << "," << std::endl;
// reserved1
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
// reserved2
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved2) << "," << std::endl;
// def_disp_win_left_offset
    struct_body << "\t\t\t" << structInfo->def_disp_win_left_offset << "," << std::endl;
// def_disp_win_right_offset
    struct_body << "\t\t\t" << structInfo->def_disp_win_right_offset << "," << std::endl;
// def_disp_win_top_offset
    struct_body << "\t\t\t" << structInfo->def_disp_win_top_offset << "," << std::endl;
// def_disp_win_bottom_offset
    struct_body << "\t\t\t" << structInfo->def_disp_win_bottom_offset << "," << std::endl;
// vui_num_units_in_tick
    struct_body << "\t\t\t" << structInfo->vui_num_units_in_tick << "," << std::endl;
// vui_time_scale
    struct_body << "\t\t\t" << structInfo->vui_time_scale << "," << std::endl;
// vui_num_ticks_poc_diff_one_minus1
    struct_body << "\t\t\t" << structInfo->vui_num_ticks_poc_diff_one_minus1 << "," << std::endl;
// min_spatial_segmentation_idc
    struct_body << "\t\t\t" << structInfo->min_spatial_segmentation_idc << "," << std::endl;
// reserved3
    struct_body << "\t\t\t" << structInfo->reserved3 << "," << std::endl;
// max_bytes_per_pic_denom
    struct_body << "\t\t\t" << std::to_string(structInfo->max_bytes_per_pic_denom) << "," << std::endl;
// max_bits_per_min_cu_denom
    struct_body << "\t\t\t" << std::to_string(structInfo->max_bits_per_min_cu_denom) << "," << std::endl;
// log2_max_mv_length_horizontal
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_max_mv_length_horizontal) << "," << std::endl;
// log2_max_mv_length_vertical
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_max_mv_length_vertical) << "," << std::endl;
// pHrdParameters
    struct_body << "\t\t\t" << phrd_parameters_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265SequenceParameterSetVui");
    out << "\t\t" << "StdVideoH265SequenceParameterSetVui " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265ShortTermRefPicSet(std::ostream &out, const StdVideoH265ShortTermRefPicSet* structInfo, Decoded_StdVideoH265ShortTermRefPicSet* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoH265ShortTermRefPicSetFlags(out,
                                                                                    &structInfo->flags,
                                                                                    metaInfo->flags,
                                                                                    consumer);
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// delta_idx_minus1
    struct_body << "\t\t\t" << structInfo->delta_idx_minus1 << "," << std::endl;
// use_delta_flag
    struct_body << "\t\t\t" << structInfo->use_delta_flag << "," << std::endl;
// abs_delta_rps_minus1
    struct_body << "\t\t\t" << structInfo->abs_delta_rps_minus1 << "," << std::endl;
// used_by_curr_pic_flag
    struct_body << "\t\t\t" << structInfo->used_by_curr_pic_flag << "," << std::endl;
// used_by_curr_pic_s0_flag
    struct_body << "\t\t\t" << structInfo->used_by_curr_pic_s0_flag << "," << std::endl;
// used_by_curr_pic_s1_flag
    struct_body << "\t\t\t" << structInfo->used_by_curr_pic_s1_flag << "," << std::endl;
// reserved1
    struct_body << "\t\t\t" << structInfo->reserved1 << "," << std::endl;
// reserved2
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved2) << "," << std::endl;
// reserved3
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved3) << "," << std::endl;
// num_negative_pics
    struct_body << "\t\t\t" << std::to_string(structInfo->num_negative_pics) << "," << std::endl;
// num_positive_pics
    struct_body << "\t\t\t" << std::to_string(structInfo->num_positive_pics) << "," << std::endl;
// delta_poc_s0_minus1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->delta_poc_s0_minus1[0]), STD_VIDEO_H265_MAX_DPB_SIZE) << "," << std::endl;
// delta_poc_s1_minus1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->delta_poc_s1_minus1[0]), STD_VIDEO_H265_MAX_DPB_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265ShortTermRefPicSet");
    out << "\t\t" << "StdVideoH265ShortTermRefPicSet " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265ShortTermRefPicSetFlags(std::ostream &out, const StdVideoH265ShortTermRefPicSetFlags* structInfo, Decoded_StdVideoH265ShortTermRefPicSetFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// inter_ref_pic_set_prediction_flag
    struct_body << "\t" << structInfo->inter_ref_pic_set_prediction_flag << "," << std::endl;
// delta_rps_sign
    struct_body << "\t\t\t" << structInfo->delta_rps_sign << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265ShortTermRefPicSetFlags");
    out << "\t\t" << "StdVideoH265ShortTermRefPicSetFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265SpsFlags(std::ostream &out, const StdVideoH265SpsFlags* structInfo, Decoded_StdVideoH265SpsFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// sps_temporal_id_nesting_flag
    struct_body << "\t" << structInfo->sps_temporal_id_nesting_flag << "," << std::endl;
// separate_colour_plane_flag
    struct_body << "\t\t\t" << structInfo->separate_colour_plane_flag << "," << std::endl;
// conformance_window_flag
    struct_body << "\t\t\t" << structInfo->conformance_window_flag << "," << std::endl;
// sps_sub_layer_ordering_info_present_flag
    struct_body << "\t\t\t" << structInfo->sps_sub_layer_ordering_info_present_flag << "," << std::endl;
// scaling_list_enabled_flag
    struct_body << "\t\t\t" << structInfo->scaling_list_enabled_flag << "," << std::endl;
// sps_scaling_list_data_present_flag
    struct_body << "\t\t\t" << structInfo->sps_scaling_list_data_present_flag << "," << std::endl;
// amp_enabled_flag
    struct_body << "\t\t\t" << structInfo->amp_enabled_flag << "," << std::endl;
// sample_adaptive_offset_enabled_flag
    struct_body << "\t\t\t" << structInfo->sample_adaptive_offset_enabled_flag << "," << std::endl;
// pcm_enabled_flag
    struct_body << "\t\t\t" << structInfo->pcm_enabled_flag << "," << std::endl;
// pcm_loop_filter_disabled_flag
    struct_body << "\t\t\t" << structInfo->pcm_loop_filter_disabled_flag << "," << std::endl;
// long_term_ref_pics_present_flag
    struct_body << "\t\t\t" << structInfo->long_term_ref_pics_present_flag << "," << std::endl;
// sps_temporal_mvp_enabled_flag
    struct_body << "\t\t\t" << structInfo->sps_temporal_mvp_enabled_flag << "," << std::endl;
// strong_intra_smoothing_enabled_flag
    struct_body << "\t\t\t" << structInfo->strong_intra_smoothing_enabled_flag << "," << std::endl;
// vui_parameters_present_flag
    struct_body << "\t\t\t" << structInfo->vui_parameters_present_flag << "," << std::endl;
// sps_extension_present_flag
    struct_body << "\t\t\t" << structInfo->sps_extension_present_flag << "," << std::endl;
// sps_range_extension_flag
    struct_body << "\t\t\t" << structInfo->sps_range_extension_flag << "," << std::endl;
// transform_skip_rotation_enabled_flag
    struct_body << "\t\t\t" << structInfo->transform_skip_rotation_enabled_flag << "," << std::endl;
// transform_skip_context_enabled_flag
    struct_body << "\t\t\t" << structInfo->transform_skip_context_enabled_flag << "," << std::endl;
// implicit_rdpcm_enabled_flag
    struct_body << "\t\t\t" << structInfo->implicit_rdpcm_enabled_flag << "," << std::endl;
// explicit_rdpcm_enabled_flag
    struct_body << "\t\t\t" << structInfo->explicit_rdpcm_enabled_flag << "," << std::endl;
// extended_precision_processing_flag
    struct_body << "\t\t\t" << structInfo->extended_precision_processing_flag << "," << std::endl;
// intra_smoothing_disabled_flag
    struct_body << "\t\t\t" << structInfo->intra_smoothing_disabled_flag << "," << std::endl;
// high_precision_offsets_enabled_flag
    struct_body << "\t\t\t" << structInfo->high_precision_offsets_enabled_flag << "," << std::endl;
// persistent_rice_adaptation_enabled_flag
    struct_body << "\t\t\t" << structInfo->persistent_rice_adaptation_enabled_flag << "," << std::endl;
// cabac_bypass_alignment_enabled_flag
    struct_body << "\t\t\t" << structInfo->cabac_bypass_alignment_enabled_flag << "," << std::endl;
// sps_scc_extension_flag
    struct_body << "\t\t\t" << structInfo->sps_scc_extension_flag << "," << std::endl;
// sps_curr_pic_ref_enabled_flag
    struct_body << "\t\t\t" << structInfo->sps_curr_pic_ref_enabled_flag << "," << std::endl;
// palette_mode_enabled_flag
    struct_body << "\t\t\t" << structInfo->palette_mode_enabled_flag << "," << std::endl;
// sps_palette_predictor_initializers_present_flag
    struct_body << "\t\t\t" << structInfo->sps_palette_predictor_initializers_present_flag << "," << std::endl;
// intra_boundary_filtering_disabled_flag
    struct_body << "\t\t\t" << structInfo->intra_boundary_filtering_disabled_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265SpsFlags");
    out << "\t\t" << "StdVideoH265SpsFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265SpsVuiFlags(std::ostream &out, const StdVideoH265SpsVuiFlags* structInfo, Decoded_StdVideoH265SpsVuiFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// aspect_ratio_info_present_flag
    struct_body << "\t" << structInfo->aspect_ratio_info_present_flag << "," << std::endl;
// overscan_info_present_flag
    struct_body << "\t\t\t" << structInfo->overscan_info_present_flag << "," << std::endl;
// overscan_appropriate_flag
    struct_body << "\t\t\t" << structInfo->overscan_appropriate_flag << "," << std::endl;
// video_signal_type_present_flag
    struct_body << "\t\t\t" << structInfo->video_signal_type_present_flag << "," << std::endl;
// video_full_range_flag
    struct_body << "\t\t\t" << structInfo->video_full_range_flag << "," << std::endl;
// colour_description_present_flag
    struct_body << "\t\t\t" << structInfo->colour_description_present_flag << "," << std::endl;
// chroma_loc_info_present_flag
    struct_body << "\t\t\t" << structInfo->chroma_loc_info_present_flag << "," << std::endl;
// neutral_chroma_indication_flag
    struct_body << "\t\t\t" << structInfo->neutral_chroma_indication_flag << "," << std::endl;
// field_seq_flag
    struct_body << "\t\t\t" << structInfo->field_seq_flag << "," << std::endl;
// frame_field_info_present_flag
    struct_body << "\t\t\t" << structInfo->frame_field_info_present_flag << "," << std::endl;
// default_display_window_flag
    struct_body << "\t\t\t" << structInfo->default_display_window_flag << "," << std::endl;
// vui_timing_info_present_flag
    struct_body << "\t\t\t" << structInfo->vui_timing_info_present_flag << "," << std::endl;
// vui_poc_proportional_to_timing_flag
    struct_body << "\t\t\t" << structInfo->vui_poc_proportional_to_timing_flag << "," << std::endl;
// vui_hrd_parameters_present_flag
    struct_body << "\t\t\t" << structInfo->vui_hrd_parameters_present_flag << "," << std::endl;
// bitstream_restriction_flag
    struct_body << "\t\t\t" << structInfo->bitstream_restriction_flag << "," << std::endl;
// tiles_fixed_structure_flag
    struct_body << "\t\t\t" << structInfo->tiles_fixed_structure_flag << "," << std::endl;
// motion_vectors_over_pic_boundaries_flag
    struct_body << "\t\t\t" << structInfo->motion_vectors_over_pic_boundaries_flag << "," << std::endl;
// restricted_ref_pic_lists_flag
    struct_body << "\t\t\t" << structInfo->restricted_ref_pic_lists_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265SpsVuiFlags");
    out << "\t\t" << "StdVideoH265SpsVuiFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265SubLayerHrdParameters(std::ostream &out, const StdVideoH265SubLayerHrdParameters* structInfo, Decoded_StdVideoH265SubLayerHrdParameters* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// bit_rate_value_minus1
    struct_body << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->bit_rate_value_minus1[0]), STD_VIDEO_H265_CPB_CNT_LIST_SIZE) << "," << std::endl;
// cpb_size_value_minus1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->cpb_size_value_minus1[0]), STD_VIDEO_H265_CPB_CNT_LIST_SIZE) << "," << std::endl;
// cpb_size_du_value_minus1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->cpb_size_du_value_minus1[0]), STD_VIDEO_H265_CPB_CNT_LIST_SIZE) << "," << std::endl;
// bit_rate_du_value_minus1
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->bit_rate_du_value_minus1[0]), STD_VIDEO_H265_CPB_CNT_LIST_SIZE) << "," << std::endl;
// cbr_flag
    struct_body << "\t\t\t" << structInfo->cbr_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265SubLayerHrdParameters");
    out << "\t\t" << "StdVideoH265SubLayerHrdParameters " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265VideoParameterSet(std::ostream &out, const StdVideoH265VideoParameterSet* structInfo, Decoded_StdVideoH265VideoParameterSet* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoH265VpsFlags(out,
                                                                     &structInfo->flags,
                                                                     metaInfo->flags,
                                                                     consumer);
    std::string pdec_pic_buf_mgr_struct = "NULL";
    if (structInfo->pDecPicBufMgr != NULL) {
        pdec_pic_buf_mgr_struct = GenerateStruct_StdVideoH265DecPicBufMgr(out,
                                                                          structInfo->pDecPicBufMgr,
                                                                          metaInfo->pDecPicBufMgr->GetMetaStructPointer(),
                                                                          consumer);
        pdec_pic_buf_mgr_struct.insert(0, "&");
    }
    std::string phrd_parameters_struct = "NULL";
    if (structInfo->pHrdParameters != NULL) {
        phrd_parameters_struct = GenerateStruct_StdVideoH265HrdParameters(out,
                                                                          structInfo->pHrdParameters,
                                                                          metaInfo->pHrdParameters->GetMetaStructPointer(),
                                                                          consumer);
        phrd_parameters_struct.insert(0, "&");
    }
    std::string pprofile_tier_level_struct = "NULL";
    if (structInfo->pProfileTierLevel != NULL) {
        pprofile_tier_level_struct = GenerateStruct_StdVideoH265ProfileTierLevel(out,
                                                                                 structInfo->pProfileTierLevel,
                                                                                 metaInfo->pProfileTierLevel->GetMetaStructPointer(),
                                                                                 consumer);
        pprofile_tier_level_struct.insert(0, "&");
    }
// flags
    struct_body << "\t" << flags_info_var << "," << std::endl;
// vps_video_parameter_set_id
    struct_body << "\t\t\t" << std::to_string(structInfo->vps_video_parameter_set_id) << "," << std::endl;
// vps_max_sub_layers_minus1
    struct_body << "\t\t\t" << std::to_string(structInfo->vps_max_sub_layers_minus1) << "," << std::endl;
// reserved1
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
// reserved2
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved2) << "," << std::endl;
// vps_num_units_in_tick
    struct_body << "\t\t\t" << structInfo->vps_num_units_in_tick << "," << std::endl;
// vps_time_scale
    struct_body << "\t\t\t" << structInfo->vps_time_scale << "," << std::endl;
// vps_num_ticks_poc_diff_one_minus1
    struct_body << "\t\t\t" << structInfo->vps_num_ticks_poc_diff_one_minus1 << "," << std::endl;
// reserved3
    struct_body << "\t\t\t" << structInfo->reserved3 << "," << std::endl;
// pDecPicBufMgr
    struct_body << "\t\t\t" << pdec_pic_buf_mgr_struct << "," << std::endl;
// pHrdParameters
    struct_body << "\t\t\t" << phrd_parameters_struct << "," << std::endl;
// pProfileTierLevel
    struct_body << "\t\t\t" << pprofile_tier_level_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265VideoParameterSet");
    out << "\t\t" << "StdVideoH265VideoParameterSet " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH265VpsFlags(std::ostream &out, const StdVideoH265VpsFlags* structInfo, Decoded_StdVideoH265VpsFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// vps_temporal_id_nesting_flag
    struct_body << "\t" << structInfo->vps_temporal_id_nesting_flag << "," << std::endl;
// vps_sub_layer_ordering_info_present_flag
    struct_body << "\t\t\t" << structInfo->vps_sub_layer_ordering_info_present_flag << "," << std::endl;
// vps_timing_info_present_flag
    struct_body << "\t\t\t" << structInfo->vps_timing_info_present_flag << "," << std::endl;
// vps_poc_proportional_to_timing_flag
    struct_body << "\t\t\t" << structInfo->vps_poc_proportional_to_timing_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH265VpsFlags");
    out << "\t\t" << "StdVideoH265VpsFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAllocationCallbacks(std::ostream &out, const VkAllocationCallbacks* structInfo, Decoded_VkAllocationCallbacks* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// pUserData
    out << "\t\t" << "// TODO: Support pUserData (output?) argument." << std::endl;
// pfnAllocation
    struct_body << "\t\t\t" << structInfo->pfnAllocation << "," << std::endl;
// pfnReallocation
    struct_body << "\t\t\t" << structInfo->pfnReallocation << "," << std::endl;
// pfnFree
    struct_body << "\t\t\t" << structInfo->pfnFree << "," << std::endl;
// pfnInternalAllocation
    struct_body << "\t\t\t" << structInfo->pfnInternalAllocation << "," << std::endl;
// pfnInternalFree
    struct_body << "\t\t\t" << structInfo->pfnInternalFree << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "allocationCallbacks");
    out << "\t\t" << "VkAllocationCallbacks " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkApplicationInfo(std::ostream &out, const VkApplicationInfo* structInfo, Decoded_VkApplicationInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pApplicationName
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pApplicationName) << "," << std::endl;
// applicationVersion
    struct_body << "\t\t\t" << structInfo->applicationVersion << "," << std::endl;
// pEngineName
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pEngineName) << "," << std::endl;
// engineVersion
    struct_body << "\t\t\t" << structInfo->engineVersion << "," << std::endl;
// apiVersion
    struct_body << "\t\t\t" << structInfo->apiVersion << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "applicationInfo");
    out << "\t\t" << "VkApplicationInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentDescription(std::ostream &out, const VkAttachmentDescription* structInfo, Decoded_VkAttachmentDescription* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// flags
    struct_body << "\t" << "VkAttachmentDescriptionFlags(" << structInfo->flags << ")" << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
// samples
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->samples << ")" << "," << std::endl;
// loadOp
    struct_body << "\t\t\t" << "VkAttachmentLoadOp(" << structInfo->loadOp << ")" << "," << std::endl;
// storeOp
    struct_body << "\t\t\t" << "VkAttachmentStoreOp(" << structInfo->storeOp << ")" << "," << std::endl;
// stencilLoadOp
    struct_body << "\t\t\t" << "VkAttachmentLoadOp(" << structInfo->stencilLoadOp << ")" << "," << std::endl;
// stencilStoreOp
    struct_body << "\t\t\t" << "VkAttachmentStoreOp(" << structInfo->stencilStoreOp << ")" << "," << std::endl;
// initialLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->initialLayout << ")" << "," << std::endl;
// finalLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->finalLayout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentDescription");
    out << "\t\t" << "VkAttachmentDescription " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentReference(std::ostream &out, const VkAttachmentReference* structInfo, Decoded_VkAttachmentReference* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// attachment
    struct_body << "\t" << structInfo->attachment << "," << std::endl;
// layout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->layout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentReference");
    out << "\t\t" << "VkAttachmentReference " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferCopy(std::ostream &out, const VkBufferCopy* structInfo, Decoded_VkBufferCopy* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// srcOffset
    struct_body << "\t" << structInfo->srcOffset << "UL" << "," << std::endl;
// dstOffset
    struct_body << "\t\t\t" << structInfo->dstOffset << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferCopy");
    out << "\t\t" << "VkBufferCopy " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferCreateInfo(std::ostream &out, const VkBufferCreateInfo* structInfo, Decoded_VkBufferCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pqueue_family_indices_array = "NULL";
    if (structInfo->pQueueFamilyIndices != NULL) {
        pqueue_family_indices_array = "pQueueFamilyIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pqueue_family_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pQueueFamilyIndices, structInfo->queueFamilyIndexCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkBufferCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
// usage
    struct_body << "\t\t\t" << "VkBufferUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
// sharingMode
    struct_body << "\t\t\t" << "VkSharingMode(" << structInfo->sharingMode << ")" << "," << std::endl;
// queueFamilyIndexCount
    struct_body << "\t\t\t" << structInfo->queueFamilyIndexCount << "," << std::endl;
// pQueueFamilyIndices
    struct_body << "\t\t\t" << pqueue_family_indices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferCreateInfo");
    out << "\t\t" << "VkBufferCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferImageCopy(std::ostream &out, const VkBufferImageCopy* structInfo, Decoded_VkBufferImageCopy* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string image_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                     &structInfo->imageSubresource,
                                                                                     metaInfo->imageSubresource,
                                                                                     consumer);
    std::string image_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->imageOffset,
                                                                  metaInfo->imageOffset,
                                                                  consumer);
    std::string image_extent_info_var = GenerateStruct_VkExtent3D(out,
                                                                  &structInfo->imageExtent,
                                                                  metaInfo->imageExtent,
                                                                  consumer);
// bufferOffset
    struct_body << "\t" << structInfo->bufferOffset << "UL" << "," << std::endl;
// bufferRowLength
    struct_body << "\t\t\t" << structInfo->bufferRowLength << "," << std::endl;
// bufferImageHeight
    struct_body << "\t\t\t" << structInfo->bufferImageHeight << "," << std::endl;
// imageSubresource
    struct_body << "\t\t\t" << image_subresource_info_var << "," << std::endl;
// imageOffset
    struct_body << "\t\t\t" << image_offset_info_var << "," << std::endl;
// imageExtent
    struct_body << "\t\t\t" << image_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferImageCopy");
    out << "\t\t" << "VkBufferImageCopy " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferMemoryBarrier(std::ostream &out, const VkBufferMemoryBarrier* structInfo, Decoded_VkBufferMemoryBarrier* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
// dstAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << "," << std::endl;
// srcQueueFamilyIndex
    struct_body << "\t\t\t" << structInfo->srcQueueFamilyIndex << "," << std::endl;
// dstQueueFamilyIndex
    struct_body << "\t\t\t" << structInfo->dstQueueFamilyIndex << "," << std::endl;
// buffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferMemoryBarrier");
    out << "\t\t" << "VkBufferMemoryBarrier " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferViewCreateInfo(std::ostream &out, const VkBufferViewCreateInfo* structInfo, Decoded_VkBufferViewCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkBufferViewCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// buffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
// range
    struct_body << "\t\t\t" << structInfo->range << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferViewCreateInfo");
    out << "\t\t" << "VkBufferViewCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkClearAttachment(std::ostream &out, const VkClearAttachment* structInfo, Decoded_VkClearAttachment* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// aspectMask
    struct_body << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
// colorAttachment
    struct_body << "\t\t\t" << structInfo->colorAttachment << "," << std::endl;
// clearValue
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(structInfo->clearValue) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "clearAttachment");
    out << "\t\t" << "VkClearAttachment " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkClearDepthStencilValue(std::ostream &out, const VkClearDepthStencilValue* structInfo, Decoded_VkClearDepthStencilValue* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// depth
    struct_body << "\t" << structInfo->depth << "," << std::endl;
// stencil
    struct_body << "\t\t\t" << structInfo->stencil << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "clearDepthStencilValue");
    out << "\t\t" << "VkClearDepthStencilValue " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkClearRect(std::ostream &out, const VkClearRect* structInfo, Decoded_VkClearRect* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string rect_info_var = GenerateStruct_VkRect2D(out,
                                                        &structInfo->rect,
                                                        metaInfo->rect,
                                                        consumer);
// rect
    struct_body << "\t" << rect_info_var << "," << std::endl;
// baseArrayLayer
    struct_body << "\t\t\t" << structInfo->baseArrayLayer << "," << std::endl;
// layerCount
    struct_body << "\t\t\t" << structInfo->layerCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "clearRect");
    out << "\t\t" << "VkClearRect " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferAllocateInfo(std::ostream &out, const VkCommandBufferAllocateInfo* structInfo, Decoded_VkCommandBufferAllocateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// commandPool
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->commandPool) << "," << std::endl;
// level
    struct_body << "\t\t\t" << "VkCommandBufferLevel(" << structInfo->level << ")" << "," << std::endl;
// commandBufferCount
    struct_body << "\t\t\t" << structInfo->commandBufferCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferAllocateInfo");
    out << "\t\t" << "VkCommandBufferAllocateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferBeginInfo(std::ostream &out, const VkCommandBufferBeginInfo* structInfo, Decoded_VkCommandBufferBeginInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pinheritance_info_struct = "NULL";
    if (structInfo->pInheritanceInfo != NULL) {
        pinheritance_info_struct = GenerateStruct_VkCommandBufferInheritanceInfo(out,
                                                                                 structInfo->pInheritanceInfo,
                                                                                 metaInfo->pInheritanceInfo->GetMetaStructPointer(),
                                                                                 consumer);
        pinheritance_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkCommandBufferUsageFlags(" << structInfo->flags << ")" << "," << std::endl;
// pInheritanceInfo
    struct_body << "\t\t\t" << pinheritance_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferBeginInfo");
    out << "\t\t" << "VkCommandBufferBeginInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferInheritanceInfo(std::ostream &out, const VkCommandBufferInheritanceInfo* structInfo, Decoded_VkCommandBufferInheritanceInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// renderPass
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->renderPass) << "," << std::endl;
// subpass
    struct_body << "\t\t\t" << structInfo->subpass << "," << std::endl;
// framebuffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->framebuffer) << "," << std::endl;
// occlusionQueryEnable
    struct_body << "\t\t\t" << structInfo->occlusionQueryEnable << "," << std::endl;
// queryFlags
    struct_body << "\t\t\t" << "VkQueryControlFlags(" << structInfo->queryFlags << ")" << "," << std::endl;
// pipelineStatistics
    struct_body << "\t\t\t" << "VkQueryPipelineStatisticFlags(" << structInfo->pipelineStatistics << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferInheritanceInfo");
    out << "\t\t" << "VkCommandBufferInheritanceInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandPoolCreateInfo(std::ostream &out, const VkCommandPoolCreateInfo* structInfo, Decoded_VkCommandPoolCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkCommandPoolCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// queueFamilyIndex
    struct_body << "\t\t\t" << structInfo->queueFamilyIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandPoolCreateInfo");
    out << "\t\t" << "VkCommandPoolCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkComponentMapping(std::ostream &out, const VkComponentMapping* structInfo, Decoded_VkComponentMapping* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// r
    struct_body << "\t" << "VkComponentSwizzle(" << structInfo->r << ")" << "," << std::endl;
// g
    struct_body << "\t\t\t" << "VkComponentSwizzle(" << structInfo->g << ")" << "," << std::endl;
// b
    struct_body << "\t\t\t" << "VkComponentSwizzle(" << structInfo->b << ")" << "," << std::endl;
// a
    struct_body << "\t\t\t" << "VkComponentSwizzle(" << structInfo->a << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "componentMapping");
    out << "\t\t" << "VkComponentMapping " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkComputePipelineCreateInfo(std::ostream &out, const VkComputePipelineCreateInfo* structInfo, Decoded_VkComputePipelineCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string stage_info_var = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                                                &structInfo->stage,
                                                                                metaInfo->stage,
                                                                                consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// stage
    struct_body << "\t\t\t" << stage_info_var << "," << std::endl;
// layout
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->layout) << "," << std::endl;
// basePipelineHandle
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->basePipelineHandle) << "," << std::endl;
// basePipelineIndex
    struct_body << "\t\t\t" << structInfo->basePipelineIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "computePipelineCreateInfo");
    out << "\t\t" << "VkComputePipelineCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyDescriptorSet(std::ostream &out, const VkCopyDescriptorSet* structInfo, Decoded_VkCopyDescriptorSet* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcSet
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcSet) << "," << std::endl;
// srcBinding
    struct_body << "\t\t\t" << structInfo->srcBinding << "," << std::endl;
// srcArrayElement
    struct_body << "\t\t\t" << structInfo->srcArrayElement << "," << std::endl;
// dstSet
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstSet) << "," << std::endl;
// dstBinding
    struct_body << "\t\t\t" << structInfo->dstBinding << "," << std::endl;
// dstArrayElement
    struct_body << "\t\t\t" << structInfo->dstArrayElement << "," << std::endl;
// descriptorCount
    struct_body << "\t\t\t" << structInfo->descriptorCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyDescriptorSet");
    out << "\t\t" << "VkCopyDescriptorSet " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorBufferInfo(std::ostream &out, const VkDescriptorBufferInfo* structInfo, Decoded_VkDescriptorBufferInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// buffer
    struct_body << "\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
// range
    struct_body << "\t\t\t" << structInfo->range << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorBufferInfo");
    out << "\t\t" << "VkDescriptorBufferInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorPoolCreateInfo(std::ostream &out, const VkDescriptorPoolCreateInfo* structInfo, Decoded_VkDescriptorPoolCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppool_sizes_array = "NULL";
    if (structInfo->pPoolSizes != NULL) {
        ppool_sizes_array = "pPoolSizes_" + std::to_string(consumer.GetNextId());
        std::string ppool_sizes_names;
        for (uint32_t idx = 0; idx < structInfo->poolSizeCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPoolSizes + idx != NULL) {
                variable_name = GenerateStruct_VkDescriptorPoolSize(out,
                                                                    structInfo->pPoolSizes + idx,
                                                                    metaInfo->pPoolSizes->GetMetaStructPointer() + idx,
                                                                    consumer);
            }
            ppool_sizes_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDescriptorPoolSize " << ppool_sizes_array << "[] = {" << ppool_sizes_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDescriptorPoolCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// maxSets
    struct_body << "\t\t\t" << structInfo->maxSets << "," << std::endl;
// poolSizeCount
    struct_body << "\t\t\t" << structInfo->poolSizeCount << "," << std::endl;
// pPoolSizes
    struct_body << "\t\t\t" << ppool_sizes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorPoolCreateInfo");
    out << "\t\t" << "VkDescriptorPoolCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorPoolSize(std::ostream &out, const VkDescriptorPoolSize* structInfo, Decoded_VkDescriptorPoolSize* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// type
    struct_body << "\t" << "VkDescriptorType(" << structInfo->type << ")" << "," << std::endl;
// descriptorCount
    struct_body << "\t\t\t" << structInfo->descriptorCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorPoolSize");
    out << "\t\t" << "VkDescriptorPoolSize " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetAllocateInfo(std::ostream &out, const VkDescriptorSetAllocateInfo* structInfo, Decoded_VkDescriptorSetAllocateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pset_layouts_array = "NULL";
    if (metaInfo->pSetLayouts.GetPointer() != NULL && structInfo->descriptorSetCount > 0) {
        pset_layouts_array = "pset_layouts_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT));
        std::string pset_layouts_values = toStringJoin(metaInfo->pSetLayouts.GetPointer(),
                                                       metaInfo->pSetLayouts.GetPointer() + structInfo->descriptorSetCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->descriptorSetCount == 1) {
            pset_layouts_array = "&" + pset_layouts_values;
        } else if (structInfo->descriptorSetCount > 1) {
            out << "\t\t" << "VkDescriptorSetLayout " << pset_layouts_array << "[] = {" << pset_layouts_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// descriptorPool
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->descriptorPool) << "," << std::endl;
// descriptorSetCount
    struct_body << "\t\t\t" << structInfo->descriptorSetCount << "," << std::endl;
// pSetLayouts
    struct_body << "\t\t\t" << pset_layouts_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetAllocateInfo");
    out << "\t\t" << "VkDescriptorSetAllocateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetLayoutBinding(std::ostream &out, const VkDescriptorSetLayoutBinding* structInfo, Decoded_VkDescriptorSetLayoutBinding* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pimmutable_samplers_array = "NULL";
    if (metaInfo->pImmutableSamplers.GetPointer() != NULL && structInfo->descriptorCount > 0) {
        pimmutable_samplers_array = "pimmutable_samplers_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_SAMPLER));
        std::string pimmutable_samplers_values = toStringJoin(metaInfo->pImmutableSamplers.GetPointer(),
                                                              metaInfo->pImmutableSamplers.GetPointer() + structInfo->descriptorCount,
                                                              [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                              ", ");
        if (structInfo->descriptorCount == 1) {
            pimmutable_samplers_array = "&" + pimmutable_samplers_values;
        } else if (structInfo->descriptorCount > 1) {
            out << "\t\t" << "VkSampler " << pimmutable_samplers_array << "[] = {" << pimmutable_samplers_values << "};" << std::endl;
        }
    }
// binding
    struct_body << "\t" << structInfo->binding << "," << std::endl;
// descriptorType
    struct_body << "\t\t\t" << "VkDescriptorType(" << structInfo->descriptorType << ")" << "," << std::endl;
// descriptorCount
    struct_body << "\t\t\t" << structInfo->descriptorCount << "," << std::endl;
// stageFlags
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->stageFlags << ")" << "," << std::endl;
// pImmutableSamplers
    struct_body << "\t\t\t" << pimmutable_samplers_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetLayoutBinding");
    out << "\t\t" << "VkDescriptorSetLayoutBinding " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetLayoutCreateInfo(std::ostream &out, const VkDescriptorSetLayoutCreateInfo* structInfo, Decoded_VkDescriptorSetLayoutCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pbindings_array = "NULL";
    if (structInfo->pBindings != NULL) {
        pbindings_array = "pBindings_" + std::to_string(consumer.GetNextId());
        std::string pbindings_names;
        for (uint32_t idx = 0; idx < structInfo->bindingCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pBindings + idx != NULL) {
                variable_name = GenerateStruct_VkDescriptorSetLayoutBinding(out,
                                                                            structInfo->pBindings + idx,
                                                                            metaInfo->pBindings->GetMetaStructPointer() + idx,
                                                                            consumer);
            }
            pbindings_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDescriptorSetLayoutBinding " << pbindings_array << "[] = {" << pbindings_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDescriptorSetLayoutCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// bindingCount
    struct_body << "\t\t\t" << structInfo->bindingCount << "," << std::endl;
// pBindings
    struct_body << "\t\t\t" << pbindings_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetLayoutCreateInfo");
    out << "\t\t" << "VkDescriptorSetLayoutCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceCreateInfo(std::ostream &out, const VkDeviceCreateInfo* structInfo, Decoded_VkDeviceCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pqueue_create_infos_array = "NULL";
    if (structInfo->pQueueCreateInfos != NULL) {
        pqueue_create_infos_array = "pQueueCreateInfos_" + std::to_string(consumer.GetNextId());
        std::string pqueue_create_infos_names;
        for (uint32_t idx = 0; idx < structInfo->queueCreateInfoCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pQueueCreateInfos + idx != NULL) {
                variable_name = GenerateStruct_VkDeviceQueueCreateInfo(out,
                                                                       structInfo->pQueueCreateInfos + idx,
                                                                       metaInfo->pQueueCreateInfos->GetMetaStructPointer() + idx,
                                                                       consumer);
            }
            pqueue_create_infos_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDeviceQueueCreateInfo " << pqueue_create_infos_array << "[] = {" << pqueue_create_infos_names << "};" << std::endl;
    }
    std::string pp_enabled_layer_names_var = "NULL";
    if (structInfo->enabledLayerCount) {
    pp_enabled_layer_names_var = "ppEnabledLayerNames_" + std::to_string(consumer.GetNextId());
    out << "\t\t" << "const char* " << pp_enabled_layer_names_var << "[] = " << VulkanCppConsumerBase::EscapeStringArray(structInfo->ppEnabledLayerNames, structInfo->enabledLayerCount) << ";" << std::endl;
    }
    std::string pp_enabled_extension_names_var = "NULL";
    if (structInfo->enabledExtensionCount) {
    pp_enabled_extension_names_var = "ppEnabledExtensionNames_" + std::to_string(consumer.GetNextId());
    out << "\t\t" << "const char* " << pp_enabled_extension_names_var << "[] = " << VulkanCppConsumerBase::EscapeStringArray(structInfo->ppEnabledExtensionNames, structInfo->enabledExtensionCount) << ";" << std::endl;
    }
    std::string penabled_features_struct = "NULL";
    if (structInfo->pEnabledFeatures != NULL) {
        penabled_features_struct = GenerateStruct_VkPhysicalDeviceFeatures(out,
                                                                           structInfo->pEnabledFeatures,
                                                                           metaInfo->pEnabledFeatures->GetMetaStructPointer(),
                                                                           consumer);
        penabled_features_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDeviceCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// queueCreateInfoCount
    struct_body << "\t\t\t" << structInfo->queueCreateInfoCount << "," << std::endl;
// pQueueCreateInfos
    struct_body << "\t\t\t" << pqueue_create_infos_array << "," << std::endl;
// enabledLayerCount
    struct_body << "\t\t\t" << structInfo->enabledLayerCount << "," << std::endl;
// ppEnabledLayerNames
    struct_body << "\t\t\t" << pp_enabled_layer_names_var << "," << std::endl;
// enabledExtensionCount
    struct_body << "\t\t\t" << structInfo->enabledExtensionCount << "," << std::endl;
// ppEnabledExtensionNames
    struct_body << "\t\t\t" << pp_enabled_extension_names_var << "," << std::endl;
// pEnabledFeatures
    struct_body << "\t\t\t" << penabled_features_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceCreateInfo");
    out << "\t\t" << "VkDeviceCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceQueueCreateInfo(std::ostream &out, const VkDeviceQueueCreateInfo* structInfo, Decoded_VkDeviceQueueCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pqueue_priorities_array = "NULL";
    if (structInfo->pQueuePriorities != NULL) {
        pqueue_priorities_array = "pQueuePriorities_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "float " << pqueue_priorities_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pQueuePriorities, structInfo->queueCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDeviceQueueCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// queueFamilyIndex
    struct_body << "\t\t\t" << structInfo->queueFamilyIndex << "," << std::endl;
// queueCount
    struct_body << "\t\t\t" << structInfo->queueCount << "," << std::endl;
// pQueuePriorities
    struct_body << "\t\t\t" << pqueue_priorities_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceQueueCreateInfo");
    out << "\t\t" << "VkDeviceQueueCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDispatchIndirectCommand(std::ostream &out, const VkDispatchIndirectCommand* structInfo, Decoded_VkDispatchIndirectCommand* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// x
    struct_body << "\t" << structInfo->x << "," << std::endl;
// y
    struct_body << "\t\t\t" << structInfo->y << "," << std::endl;
// z
    struct_body << "\t\t\t" << structInfo->z << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dispatchIndirectCommand");
    out << "\t\t" << "VkDispatchIndirectCommand " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrawIndexedIndirectCommand(std::ostream &out, const VkDrawIndexedIndirectCommand* structInfo, Decoded_VkDrawIndexedIndirectCommand* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// indexCount
    struct_body << "\t" << structInfo->indexCount << "," << std::endl;
// instanceCount
    struct_body << "\t\t\t" << structInfo->instanceCount << "," << std::endl;
// firstIndex
    struct_body << "\t\t\t" << structInfo->firstIndex << "," << std::endl;
// vertexOffset
    struct_body << "\t\t\t" << structInfo->vertexOffset << "," << std::endl;
// firstInstance
    struct_body << "\t\t\t" << structInfo->firstInstance << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drawIndexedIndirectCommand");
    out << "\t\t" << "VkDrawIndexedIndirectCommand " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrawIndirectCommand(std::ostream &out, const VkDrawIndirectCommand* structInfo, Decoded_VkDrawIndirectCommand* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// vertexCount
    struct_body << "\t" << structInfo->vertexCount << "," << std::endl;
// instanceCount
    struct_body << "\t\t\t" << structInfo->instanceCount << "," << std::endl;
// firstVertex
    struct_body << "\t\t\t" << structInfo->firstVertex << "," << std::endl;
// firstInstance
    struct_body << "\t\t\t" << structInfo->firstInstance << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drawIndirectCommand");
    out << "\t\t" << "VkDrawIndirectCommand " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkEventCreateInfo(std::ostream &out, const VkEventCreateInfo* structInfo, Decoded_VkEventCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkEventCreateFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "eventCreateInfo");
    out << "\t\t" << "VkEventCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExtensionProperties(std::ostream &out, const VkExtensionProperties* structInfo, Decoded_VkExtensionProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// extensionName
    struct_body << "\t" << VulkanCppConsumerBase::ToEscape(structInfo->extensionName) << "," << std::endl;
// specVersion
    struct_body << "\t\t\t" << structInfo->specVersion << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "extensionProperties");
    out << "\t\t" << "VkExtensionProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExtent2D(std::ostream &out, const VkExtent2D* structInfo, Decoded_VkExtent2D* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// width
    struct_body << "\t" << structInfo->width << "," << std::endl;
// height
    struct_body << "\t\t\t" << structInfo->height << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "extent2D");
    out << "\t\t" << "VkExtent2D " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExtent3D(std::ostream &out, const VkExtent3D* structInfo, Decoded_VkExtent3D* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// width
    struct_body << "\t" << structInfo->width << "," << std::endl;
// height
    struct_body << "\t\t\t" << structInfo->height << "," << std::endl;
// depth
    struct_body << "\t\t\t" << structInfo->depth << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "extent3D");
    out << "\t\t" << "VkExtent3D " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFenceCreateInfo(std::ostream &out, const VkFenceCreateInfo* structInfo, Decoded_VkFenceCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkFenceCreateFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "fenceCreateInfo");
    out << "\t\t" << "VkFenceCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFormatProperties(std::ostream &out, const VkFormatProperties* structInfo, Decoded_VkFormatProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// linearTilingFeatures
    struct_body << "\t" << "VkFormatFeatureFlags(" << structInfo->linearTilingFeatures << ")" << "," << std::endl;
// optimalTilingFeatures
    struct_body << "\t\t\t" << "VkFormatFeatureFlags(" << structInfo->optimalTilingFeatures << ")" << "," << std::endl;
// bufferFeatures
    struct_body << "\t\t\t" << "VkFormatFeatureFlags(" << structInfo->bufferFeatures << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "formatProperties");
    out << "\t\t" << "VkFormatProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFramebufferCreateInfo(std::ostream &out, const VkFramebufferCreateInfo* structInfo, Decoded_VkFramebufferCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pattachments_array = "NULL";
    if (metaInfo->pAttachments.GetPointer() != NULL && structInfo->attachmentCount > 0) {
        pattachments_array = "pattachments_array_" + std::to_string(consumer.GetNextId());
        std::string pattachments_values = toStringJoin(metaInfo->pAttachments.GetPointer(),
                                                       metaInfo->pAttachments.GetPointer() + structInfo->attachmentCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->attachmentCount == 1) {
            pattachments_array = "&" + pattachments_values;
        } else if (structInfo->attachmentCount > 1) {
            out << "\t\t" << "VkImageView " << pattachments_array << "[] = {" << pattachments_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkFramebufferCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// renderPass
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->renderPass) << "," << std::endl;
// attachmentCount
    struct_body << "\t\t\t" << structInfo->attachmentCount << "," << std::endl;
// pAttachments
    struct_body << "\t\t\t" << pattachments_array << "," << std::endl;
// width
    struct_body << "\t\t\t" << structInfo->width << "," << std::endl;
// height
    struct_body << "\t\t\t" << structInfo->height << "," << std::endl;
// layers
    struct_body << "\t\t\t" << structInfo->layers << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "framebufferCreateInfo");
    out << "\t\t" << "VkFramebufferCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGraphicsPipelineCreateInfo(std::ostream &out, const VkGraphicsPipelineCreateInfo* structInfo, Decoded_VkGraphicsPipelineCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstages_array = "NULL";
    if (structInfo->pStages != NULL) {
        pstages_array = "pStages_" + std::to_string(consumer.GetNextId());
        std::string pstages_names;
        for (uint32_t idx = 0; idx < structInfo->stageCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStages + idx != NULL) {
                variable_name = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                                               structInfo->pStages + idx,
                                                                               metaInfo->pStages->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pstages_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPipelineShaderStageCreateInfo " << pstages_array << "[] = {" << pstages_names << "};" << std::endl;
    }
    std::string pvertex_input_state_struct = "NULL";
    if (structInfo->pVertexInputState != NULL) {
        pvertex_input_state_struct = GenerateStruct_VkPipelineVertexInputStateCreateInfo(out,
                                                                                         structInfo->pVertexInputState,
                                                                                         metaInfo->pVertexInputState->GetMetaStructPointer(),
                                                                                         consumer);
        pvertex_input_state_struct.insert(0, "&");
    }
    std::string pinput_assembly_state_struct = "NULL";
    if (structInfo->pInputAssemblyState != NULL) {
        pinput_assembly_state_struct = GenerateStruct_VkPipelineInputAssemblyStateCreateInfo(out,
                                                                                             structInfo->pInputAssemblyState,
                                                                                             metaInfo->pInputAssemblyState->GetMetaStructPointer(),
                                                                                             consumer);
        pinput_assembly_state_struct.insert(0, "&");
    }
    std::string ptessellation_state_struct = "NULL";
    if (structInfo->pTessellationState != NULL) {
        ptessellation_state_struct = GenerateStruct_VkPipelineTessellationStateCreateInfo(out,
                                                                                          structInfo->pTessellationState,
                                                                                          metaInfo->pTessellationState->GetMetaStructPointer(),
                                                                                          consumer);
        ptessellation_state_struct.insert(0, "&");
    }
    std::string pviewport_state_struct = "NULL";
    if (structInfo->pViewportState != NULL) {
        pviewport_state_struct = GenerateStruct_VkPipelineViewportStateCreateInfo(out,
                                                                                  structInfo->pViewportState,
                                                                                  metaInfo->pViewportState->GetMetaStructPointer(),
                                                                                  consumer);
        pviewport_state_struct.insert(0, "&");
    }
    std::string prasterization_state_struct = "NULL";
    if (structInfo->pRasterizationState != NULL) {
        prasterization_state_struct = GenerateStruct_VkPipelineRasterizationStateCreateInfo(out,
                                                                                            structInfo->pRasterizationState,
                                                                                            metaInfo->pRasterizationState->GetMetaStructPointer(),
                                                                                            consumer);
        prasterization_state_struct.insert(0, "&");
    }
    std::string pmultisample_state_struct = "NULL";
    if (structInfo->pMultisampleState != NULL) {
        pmultisample_state_struct = GenerateStruct_VkPipelineMultisampleStateCreateInfo(out,
                                                                                        structInfo->pMultisampleState,
                                                                                        metaInfo->pMultisampleState->GetMetaStructPointer(),
                                                                                        consumer);
        pmultisample_state_struct.insert(0, "&");
    }
    std::string pdepth_stencil_state_struct = "NULL";
    if (structInfo->pDepthStencilState != NULL) {
        pdepth_stencil_state_struct = GenerateStruct_VkPipelineDepthStencilStateCreateInfo(out,
                                                                                           structInfo->pDepthStencilState,
                                                                                           metaInfo->pDepthStencilState->GetMetaStructPointer(),
                                                                                           consumer);
        pdepth_stencil_state_struct.insert(0, "&");
    }
    std::string pcolor_blend_state_struct = "NULL";
    if (structInfo->pColorBlendState != NULL) {
        pcolor_blend_state_struct = GenerateStruct_VkPipelineColorBlendStateCreateInfo(out,
                                                                                       structInfo->pColorBlendState,
                                                                                       metaInfo->pColorBlendState->GetMetaStructPointer(),
                                                                                       consumer);
        pcolor_blend_state_struct.insert(0, "&");
    }
    std::string pdynamic_state_struct = "NULL";
    if (structInfo->pDynamicState != NULL) {
        pdynamic_state_struct = GenerateStruct_VkPipelineDynamicStateCreateInfo(out,
                                                                                structInfo->pDynamicState,
                                                                                metaInfo->pDynamicState->GetMetaStructPointer(),
                                                                                consumer);
        pdynamic_state_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// stageCount
    struct_body << "\t\t\t" << structInfo->stageCount << "," << std::endl;
// pStages
    struct_body << "\t\t\t" << pstages_array << "," << std::endl;
// pVertexInputState
    struct_body << "\t\t\t" << pvertex_input_state_struct << "," << std::endl;
// pInputAssemblyState
    struct_body << "\t\t\t" << pinput_assembly_state_struct << "," << std::endl;
// pTessellationState
    struct_body << "\t\t\t" << ptessellation_state_struct << "," << std::endl;
// pViewportState
    struct_body << "\t\t\t" << pviewport_state_struct << "," << std::endl;
// pRasterizationState
    struct_body << "\t\t\t" << prasterization_state_struct << "," << std::endl;
// pMultisampleState
    struct_body << "\t\t\t" << pmultisample_state_struct << "," << std::endl;
// pDepthStencilState
    struct_body << "\t\t\t" << pdepth_stencil_state_struct << "," << std::endl;
// pColorBlendState
    struct_body << "\t\t\t" << pcolor_blend_state_struct << "," << std::endl;
// pDynamicState
    struct_body << "\t\t\t" << pdynamic_state_struct << "," << std::endl;
// layout
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->layout) << "," << std::endl;
// renderPass
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->renderPass) << "," << std::endl;
// subpass
    struct_body << "\t\t\t" << structInfo->subpass << "," << std::endl;
// basePipelineHandle
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->basePipelineHandle) << "," << std::endl;
// basePipelineIndex
    struct_body << "\t\t\t" << structInfo->basePipelineIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "graphicsPipelineCreateInfo");
    out << "\t\t" << "VkGraphicsPipelineCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageBlit(std::ostream &out, const VkImageBlit* structInfo, Decoded_VkImageBlit* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string src_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->srcSubresource,
                                                                                   metaInfo->srcSubresource,
                                                                                   consumer);
    std::string dst_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->dstSubresource,
                                                                                   metaInfo->dstSubresource,
                                                                                   consumer);
// srcSubresource
    struct_body << "\t" << src_subresource_info_var << "," << std::endl;
// srcOffsets
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkOffset3D*>(&structInfo->srcOffsets[0]), 2) << "," << std::endl;
// dstSubresource
    struct_body << "\t\t\t" << dst_subresource_info_var << "," << std::endl;
// dstOffsets
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkOffset3D*>(&structInfo->dstOffsets[0]), 2) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageBlit");
    out << "\t\t" << "VkImageBlit " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageCopy(std::ostream &out, const VkImageCopy* structInfo, Decoded_VkImageCopy* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string src_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->srcSubresource,
                                                                                   metaInfo->srcSubresource,
                                                                                   consumer);
    std::string src_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->srcOffset,
                                                                metaInfo->srcOffset,
                                                                consumer);
    std::string dst_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->dstSubresource,
                                                                                   metaInfo->dstSubresource,
                                                                                   consumer);
    std::string dst_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->dstOffset,
                                                                metaInfo->dstOffset,
                                                                consumer);
    std::string extent_info_var = GenerateStruct_VkExtent3D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
// srcSubresource
    struct_body << "\t" << src_subresource_info_var << "," << std::endl;
// srcOffset
    struct_body << "\t\t\t" << src_offset_info_var << "," << std::endl;
// dstSubresource
    struct_body << "\t\t\t" << dst_subresource_info_var << "," << std::endl;
// dstOffset
    struct_body << "\t\t\t" << dst_offset_info_var << "," << std::endl;
// extent
    struct_body << "\t\t\t" << extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageCopy");
    out << "\t\t" << "VkImageCopy " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageCreateInfo(std::ostream &out, const VkImageCreateInfo* structInfo, Decoded_VkImageCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string extent_info_var = GenerateStruct_VkExtent3D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
    std::string pqueue_family_indices_array = "NULL";
    if (structInfo->pQueueFamilyIndices != NULL) {
        pqueue_family_indices_array = "pQueueFamilyIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pqueue_family_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pQueueFamilyIndices, structInfo->queueFamilyIndexCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkImageCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// imageType
    struct_body << "\t\t\t" << "VkImageType(" << structInfo->imageType << ")" << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
// extent
    struct_body << "\t\t\t" << extent_info_var << "," << std::endl;
// mipLevels
    struct_body << "\t\t\t" << structInfo->mipLevels << "," << std::endl;
// arrayLayers
    struct_body << "\t\t\t" << structInfo->arrayLayers << "," << std::endl;
// samples
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->samples << ")" << "," << std::endl;
// tiling
    struct_body << "\t\t\t" << "VkImageTiling(" << structInfo->tiling << ")" << "," << std::endl;
// usage
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
// sharingMode
    struct_body << "\t\t\t" << "VkSharingMode(" << structInfo->sharingMode << ")" << "," << std::endl;
// queueFamilyIndexCount
    struct_body << "\t\t\t" << structInfo->queueFamilyIndexCount << "," << std::endl;
// pQueueFamilyIndices
    struct_body << "\t\t\t" << pqueue_family_indices_array << "," << std::endl;
// initialLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->initialLayout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageCreateInfo");
    out << "\t\t" << "VkImageCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageFormatProperties(std::ostream &out, const VkImageFormatProperties* structInfo, Decoded_VkImageFormatProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string max_extent_info_var = GenerateStruct_VkExtent3D(out,
                                                                &structInfo->maxExtent,
                                                                metaInfo->maxExtent,
                                                                consumer);
// maxExtent
    struct_body << "\t" << max_extent_info_var << "," << std::endl;
// maxMipLevels
    struct_body << "\t\t\t" << structInfo->maxMipLevels << "," << std::endl;
// maxArrayLayers
    struct_body << "\t\t\t" << structInfo->maxArrayLayers << "," << std::endl;
// sampleCounts
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->sampleCounts << ")" << "," << std::endl;
// maxResourceSize
    struct_body << "\t\t\t" << structInfo->maxResourceSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageFormatProperties");
    out << "\t\t" << "VkImageFormatProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageMemoryBarrier(std::ostream &out, const VkImageMemoryBarrier* structInfo, Decoded_VkImageMemoryBarrier* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string subresource_range_info_var = GenerateStruct_VkImageSubresourceRange(out,
                                                                                    &structInfo->subresourceRange,
                                                                                    metaInfo->subresourceRange,
                                                                                    consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
// dstAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << "," << std::endl;
// oldLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->oldLayout << ")" << "," << std::endl;
// newLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->newLayout << ")" << "," << std::endl;
// srcQueueFamilyIndex
    struct_body << "\t\t\t" << structInfo->srcQueueFamilyIndex << "," << std::endl;
// dstQueueFamilyIndex
    struct_body << "\t\t\t" << structInfo->dstQueueFamilyIndex << "," << std::endl;
// image
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
// subresourceRange
    struct_body << "\t\t\t" << subresource_range_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageMemoryBarrier");
    out << "\t\t" << "VkImageMemoryBarrier " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageResolve(std::ostream &out, const VkImageResolve* structInfo, Decoded_VkImageResolve* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string src_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->srcSubresource,
                                                                                   metaInfo->srcSubresource,
                                                                                   consumer);
    std::string src_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->srcOffset,
                                                                metaInfo->srcOffset,
                                                                consumer);
    std::string dst_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->dstSubresource,
                                                                                   metaInfo->dstSubresource,
                                                                                   consumer);
    std::string dst_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->dstOffset,
                                                                metaInfo->dstOffset,
                                                                consumer);
    std::string extent_info_var = GenerateStruct_VkExtent3D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
// srcSubresource
    struct_body << "\t" << src_subresource_info_var << "," << std::endl;
// srcOffset
    struct_body << "\t\t\t" << src_offset_info_var << "," << std::endl;
// dstSubresource
    struct_body << "\t\t\t" << dst_subresource_info_var << "," << std::endl;
// dstOffset
    struct_body << "\t\t\t" << dst_offset_info_var << "," << std::endl;
// extent
    struct_body << "\t\t\t" << extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageResolve");
    out << "\t\t" << "VkImageResolve " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageSubresource(std::ostream &out, const VkImageSubresource* structInfo, Decoded_VkImageSubresource* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// aspectMask
    struct_body << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
// mipLevel
    struct_body << "\t\t\t" << structInfo->mipLevel << "," << std::endl;
// arrayLayer
    struct_body << "\t\t\t" << structInfo->arrayLayer << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageSubresource");
    out << "\t\t" << "VkImageSubresource " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageSubresourceLayers(std::ostream &out, const VkImageSubresourceLayers* structInfo, Decoded_VkImageSubresourceLayers* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// aspectMask
    struct_body << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
// mipLevel
    struct_body << "\t\t\t" << structInfo->mipLevel << "," << std::endl;
// baseArrayLayer
    struct_body << "\t\t\t" << structInfo->baseArrayLayer << "," << std::endl;
// layerCount
    struct_body << "\t\t\t" << structInfo->layerCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageSubresourceLayers");
    out << "\t\t" << "VkImageSubresourceLayers " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageSubresourceRange(std::ostream &out, const VkImageSubresourceRange* structInfo, Decoded_VkImageSubresourceRange* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// aspectMask
    struct_body << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
// baseMipLevel
    struct_body << "\t\t\t" << structInfo->baseMipLevel << "," << std::endl;
// levelCount
    struct_body << "\t\t\t" << structInfo->levelCount << "," << std::endl;
// baseArrayLayer
    struct_body << "\t\t\t" << structInfo->baseArrayLayer << "," << std::endl;
// layerCount
    struct_body << "\t\t\t" << structInfo->layerCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageSubresourceRange");
    out << "\t\t" << "VkImageSubresourceRange " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewCreateInfo(std::ostream &out, const VkImageViewCreateInfo* structInfo, Decoded_VkImageViewCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string components_info_var = GenerateStruct_VkComponentMapping(out,
                                                                        &structInfo->components,
                                                                        metaInfo->components,
                                                                        consumer);
    std::string subresource_range_info_var = GenerateStruct_VkImageSubresourceRange(out,
                                                                                    &structInfo->subresourceRange,
                                                                                    metaInfo->subresourceRange,
                                                                                    consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkImageViewCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// image
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
// viewType
    struct_body << "\t\t\t" << "VkImageViewType(" << structInfo->viewType << ")" << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
// components
    struct_body << "\t\t\t" << components_info_var << "," << std::endl;
// subresourceRange
    struct_body << "\t\t\t" << subresource_range_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewCreateInfo");
    out << "\t\t" << "VkImageViewCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkLayerProperties(std::ostream &out, const VkLayerProperties* structInfo, Decoded_VkLayerProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// layerName
    struct_body << "\t" << VulkanCppConsumerBase::ToEscape(structInfo->layerName) << "," << std::endl;
// specVersion
    struct_body << "\t\t\t" << structInfo->specVersion << "," << std::endl;
// implementationVersion
    struct_body << "\t\t\t" << structInfo->implementationVersion << "," << std::endl;
// description
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "layerProperties");
    out << "\t\t" << "VkLayerProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMappedMemoryRange(std::ostream &out, const VkMappedMemoryRange* structInfo, Decoded_VkMappedMemoryRange* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "mappedMemoryRange");
    out << "\t\t" << "VkMappedMemoryRange " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryBarrier(std::ostream &out, const VkMemoryBarrier* structInfo, Decoded_VkMemoryBarrier* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
// dstAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryBarrier");
    out << "\t\t" << "VkMemoryBarrier " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryHeap(std::ostream &out, const VkMemoryHeap* structInfo, Decoded_VkMemoryHeap* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// size
    struct_body << "\t" << structInfo->size << "UL" << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkMemoryHeapFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryHeap");
    out << "\t\t" << "VkMemoryHeap " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryRequirements(std::ostream &out, const VkMemoryRequirements* structInfo, Decoded_VkMemoryRequirements* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// size
    struct_body << "\t" << structInfo->size << "UL" << "," << std::endl;
// alignment
    struct_body << "\t\t\t" << structInfo->alignment << "UL" << "," << std::endl;
// memoryTypeBits
    struct_body << "\t\t\t" << structInfo->memoryTypeBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryRequirements");
    out << "\t\t" << "VkMemoryRequirements " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryType(std::ostream &out, const VkMemoryType* structInfo, Decoded_VkMemoryType* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// propertyFlags
    struct_body << "\t" << "VkMemoryPropertyFlags(" << structInfo->propertyFlags << ")" << "," << std::endl;
// heapIndex
    struct_body << "\t\t\t" << structInfo->heapIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryType");
    out << "\t\t" << "VkMemoryType " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOffset2D(std::ostream &out, const VkOffset2D* structInfo, Decoded_VkOffset2D* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// x
    struct_body << "\t" << structInfo->x << "," << std::endl;
// y
    struct_body << "\t\t\t" << structInfo->y << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "offset2D");
    out << "\t\t" << "VkOffset2D " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOffset3D(std::ostream &out, const VkOffset3D* structInfo, Decoded_VkOffset3D* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// x
    struct_body << "\t" << structInfo->x << "," << std::endl;
// y
    struct_body << "\t\t\t" << structInfo->y << "," << std::endl;
// z
    struct_body << "\t\t\t" << structInfo->z << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "offset3D");
    out << "\t\t" << "VkOffset3D " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFeatures(std::ostream &out, const VkPhysicalDeviceFeatures* structInfo, Decoded_VkPhysicalDeviceFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// robustBufferAccess
    struct_body << "\t" << structInfo->robustBufferAccess << "," << std::endl;
// fullDrawIndexUint32
    struct_body << "\t\t\t" << structInfo->fullDrawIndexUint32 << "," << std::endl;
// imageCubeArray
    struct_body << "\t\t\t" << structInfo->imageCubeArray << "," << std::endl;
// independentBlend
    struct_body << "\t\t\t" << structInfo->independentBlend << "," << std::endl;
// geometryShader
    struct_body << "\t\t\t" << structInfo->geometryShader << "," << std::endl;
// tessellationShader
    struct_body << "\t\t\t" << structInfo->tessellationShader << "," << std::endl;
// sampleRateShading
    struct_body << "\t\t\t" << structInfo->sampleRateShading << "," << std::endl;
// dualSrcBlend
    struct_body << "\t\t\t" << structInfo->dualSrcBlend << "," << std::endl;
// logicOp
    struct_body << "\t\t\t" << structInfo->logicOp << "," << std::endl;
// multiDrawIndirect
    struct_body << "\t\t\t" << structInfo->multiDrawIndirect << "," << std::endl;
// drawIndirectFirstInstance
    struct_body << "\t\t\t" << structInfo->drawIndirectFirstInstance << "," << std::endl;
// depthClamp
    struct_body << "\t\t\t" << structInfo->depthClamp << "," << std::endl;
// depthBiasClamp
    struct_body << "\t\t\t" << structInfo->depthBiasClamp << "," << std::endl;
// fillModeNonSolid
    struct_body << "\t\t\t" << structInfo->fillModeNonSolid << "," << std::endl;
// depthBounds
    struct_body << "\t\t\t" << structInfo->depthBounds << "," << std::endl;
// wideLines
    struct_body << "\t\t\t" << structInfo->wideLines << "," << std::endl;
// largePoints
    struct_body << "\t\t\t" << structInfo->largePoints << "," << std::endl;
// alphaToOne
    struct_body << "\t\t\t" << structInfo->alphaToOne << "," << std::endl;
// multiViewport
    struct_body << "\t\t\t" << structInfo->multiViewport << "," << std::endl;
// samplerAnisotropy
    struct_body << "\t\t\t" << structInfo->samplerAnisotropy << "," << std::endl;
// textureCompressionETC2
    struct_body << "\t\t\t" << structInfo->textureCompressionETC2 << "," << std::endl;
// textureCompressionASTC_LDR
    struct_body << "\t\t\t" << structInfo->textureCompressionASTC_LDR << "," << std::endl;
// textureCompressionBC
    struct_body << "\t\t\t" << structInfo->textureCompressionBC << "," << std::endl;
// occlusionQueryPrecise
    struct_body << "\t\t\t" << structInfo->occlusionQueryPrecise << "," << std::endl;
// pipelineStatisticsQuery
    struct_body << "\t\t\t" << structInfo->pipelineStatisticsQuery << "," << std::endl;
// vertexPipelineStoresAndAtomics
    struct_body << "\t\t\t" << structInfo->vertexPipelineStoresAndAtomics << "," << std::endl;
// fragmentStoresAndAtomics
    struct_body << "\t\t\t" << structInfo->fragmentStoresAndAtomics << "," << std::endl;
// shaderTessellationAndGeometryPointSize
    struct_body << "\t\t\t" << structInfo->shaderTessellationAndGeometryPointSize << "," << std::endl;
// shaderImageGatherExtended
    struct_body << "\t\t\t" << structInfo->shaderImageGatherExtended << "," << std::endl;
// shaderStorageImageExtendedFormats
    struct_body << "\t\t\t" << structInfo->shaderStorageImageExtendedFormats << "," << std::endl;
// shaderStorageImageMultisample
    struct_body << "\t\t\t" << structInfo->shaderStorageImageMultisample << "," << std::endl;
// shaderStorageImageReadWithoutFormat
    struct_body << "\t\t\t" << structInfo->shaderStorageImageReadWithoutFormat << "," << std::endl;
// shaderStorageImageWriteWithoutFormat
    struct_body << "\t\t\t" << structInfo->shaderStorageImageWriteWithoutFormat << "," << std::endl;
// shaderUniformBufferArrayDynamicIndexing
    struct_body << "\t\t\t" << structInfo->shaderUniformBufferArrayDynamicIndexing << "," << std::endl;
// shaderSampledImageArrayDynamicIndexing
    struct_body << "\t\t\t" << structInfo->shaderSampledImageArrayDynamicIndexing << "," << std::endl;
// shaderStorageBufferArrayDynamicIndexing
    struct_body << "\t\t\t" << structInfo->shaderStorageBufferArrayDynamicIndexing << "," << std::endl;
// shaderStorageImageArrayDynamicIndexing
    struct_body << "\t\t\t" << structInfo->shaderStorageImageArrayDynamicIndexing << "," << std::endl;
// shaderClipDistance
    struct_body << "\t\t\t" << structInfo->shaderClipDistance << "," << std::endl;
// shaderCullDistance
    struct_body << "\t\t\t" << structInfo->shaderCullDistance << "," << std::endl;
// shaderFloat64
    struct_body << "\t\t\t" << structInfo->shaderFloat64 << "," << std::endl;
// shaderInt64
    struct_body << "\t\t\t" << structInfo->shaderInt64 << "," << std::endl;
// shaderInt16
    struct_body << "\t\t\t" << structInfo->shaderInt16 << "," << std::endl;
// shaderResourceResidency
    struct_body << "\t\t\t" << structInfo->shaderResourceResidency << "," << std::endl;
// shaderResourceMinLod
    struct_body << "\t\t\t" << structInfo->shaderResourceMinLod << "," << std::endl;
// sparseBinding
    struct_body << "\t\t\t" << structInfo->sparseBinding << "," << std::endl;
// sparseResidencyBuffer
    struct_body << "\t\t\t" << structInfo->sparseResidencyBuffer << "," << std::endl;
// sparseResidencyImage2D
    struct_body << "\t\t\t" << structInfo->sparseResidencyImage2D << "," << std::endl;
// sparseResidencyImage3D
    struct_body << "\t\t\t" << structInfo->sparseResidencyImage3D << "," << std::endl;
// sparseResidency2Samples
    struct_body << "\t\t\t" << structInfo->sparseResidency2Samples << "," << std::endl;
// sparseResidency4Samples
    struct_body << "\t\t\t" << structInfo->sparseResidency4Samples << "," << std::endl;
// sparseResidency8Samples
    struct_body << "\t\t\t" << structInfo->sparseResidency8Samples << "," << std::endl;
// sparseResidency16Samples
    struct_body << "\t\t\t" << structInfo->sparseResidency16Samples << "," << std::endl;
// sparseResidencyAliased
    struct_body << "\t\t\t" << structInfo->sparseResidencyAliased << "," << std::endl;
// variableMultisampleRate
    struct_body << "\t\t\t" << structInfo->variableMultisampleRate << "," << std::endl;
// inheritedQueries
    struct_body << "\t\t\t" << structInfo->inheritedQueries << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFeatures");
    out << "\t\t" << "VkPhysicalDeviceFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLimits(std::ostream &out, const VkPhysicalDeviceLimits* structInfo, Decoded_VkPhysicalDeviceLimits* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// maxImageDimension1D
    struct_body << "\t" << structInfo->maxImageDimension1D << "," << std::endl;
// maxImageDimension2D
    struct_body << "\t\t\t" << structInfo->maxImageDimension2D << "," << std::endl;
// maxImageDimension3D
    struct_body << "\t\t\t" << structInfo->maxImageDimension3D << "," << std::endl;
// maxImageDimensionCube
    struct_body << "\t\t\t" << structInfo->maxImageDimensionCube << "," << std::endl;
// maxImageArrayLayers
    struct_body << "\t\t\t" << structInfo->maxImageArrayLayers << "," << std::endl;
// maxTexelBufferElements
    struct_body << "\t\t\t" << structInfo->maxTexelBufferElements << "," << std::endl;
// maxUniformBufferRange
    struct_body << "\t\t\t" << structInfo->maxUniformBufferRange << "," << std::endl;
// maxStorageBufferRange
    struct_body << "\t\t\t" << structInfo->maxStorageBufferRange << "," << std::endl;
// maxPushConstantsSize
    struct_body << "\t\t\t" << structInfo->maxPushConstantsSize << "," << std::endl;
// maxMemoryAllocationCount
    struct_body << "\t\t\t" << structInfo->maxMemoryAllocationCount << "," << std::endl;
// maxSamplerAllocationCount
    struct_body << "\t\t\t" << structInfo->maxSamplerAllocationCount << "," << std::endl;
// bufferImageGranularity
    struct_body << "\t\t\t" << structInfo->bufferImageGranularity << "UL" << "," << std::endl;
// sparseAddressSpaceSize
    struct_body << "\t\t\t" << structInfo->sparseAddressSpaceSize << "UL" << "," << std::endl;
// maxBoundDescriptorSets
    struct_body << "\t\t\t" << structInfo->maxBoundDescriptorSets << "," << std::endl;
// maxPerStageDescriptorSamplers
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorSamplers << "," << std::endl;
// maxPerStageDescriptorUniformBuffers
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUniformBuffers << "," << std::endl;
// maxPerStageDescriptorStorageBuffers
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorStorageBuffers << "," << std::endl;
// maxPerStageDescriptorSampledImages
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorSampledImages << "," << std::endl;
// maxPerStageDescriptorStorageImages
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorStorageImages << "," << std::endl;
// maxPerStageDescriptorInputAttachments
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorInputAttachments << "," << std::endl;
// maxPerStageResources
    struct_body << "\t\t\t" << structInfo->maxPerStageResources << "," << std::endl;
// maxDescriptorSetSamplers
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetSamplers << "," << std::endl;
// maxDescriptorSetUniformBuffers
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUniformBuffers << "," << std::endl;
// maxDescriptorSetUniformBuffersDynamic
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUniformBuffersDynamic << "," << std::endl;
// maxDescriptorSetStorageBuffers
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetStorageBuffers << "," << std::endl;
// maxDescriptorSetStorageBuffersDynamic
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetStorageBuffersDynamic << "," << std::endl;
// maxDescriptorSetSampledImages
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetSampledImages << "," << std::endl;
// maxDescriptorSetStorageImages
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetStorageImages << "," << std::endl;
// maxDescriptorSetInputAttachments
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetInputAttachments << "," << std::endl;
// maxVertexInputAttributes
    struct_body << "\t\t\t" << structInfo->maxVertexInputAttributes << "," << std::endl;
// maxVertexInputBindings
    struct_body << "\t\t\t" << structInfo->maxVertexInputBindings << "," << std::endl;
// maxVertexInputAttributeOffset
    struct_body << "\t\t\t" << structInfo->maxVertexInputAttributeOffset << "," << std::endl;
// maxVertexInputBindingStride
    struct_body << "\t\t\t" << structInfo->maxVertexInputBindingStride << "," << std::endl;
// maxVertexOutputComponents
    struct_body << "\t\t\t" << structInfo->maxVertexOutputComponents << "," << std::endl;
// maxTessellationGenerationLevel
    struct_body << "\t\t\t" << structInfo->maxTessellationGenerationLevel << "," << std::endl;
// maxTessellationPatchSize
    struct_body << "\t\t\t" << structInfo->maxTessellationPatchSize << "," << std::endl;
// maxTessellationControlPerVertexInputComponents
    struct_body << "\t\t\t" << structInfo->maxTessellationControlPerVertexInputComponents << "," << std::endl;
// maxTessellationControlPerVertexOutputComponents
    struct_body << "\t\t\t" << structInfo->maxTessellationControlPerVertexOutputComponents << "," << std::endl;
// maxTessellationControlPerPatchOutputComponents
    struct_body << "\t\t\t" << structInfo->maxTessellationControlPerPatchOutputComponents << "," << std::endl;
// maxTessellationControlTotalOutputComponents
    struct_body << "\t\t\t" << structInfo->maxTessellationControlTotalOutputComponents << "," << std::endl;
// maxTessellationEvaluationInputComponents
    struct_body << "\t\t\t" << structInfo->maxTessellationEvaluationInputComponents << "," << std::endl;
// maxTessellationEvaluationOutputComponents
    struct_body << "\t\t\t" << structInfo->maxTessellationEvaluationOutputComponents << "," << std::endl;
// maxGeometryShaderInvocations
    struct_body << "\t\t\t" << structInfo->maxGeometryShaderInvocations << "," << std::endl;
// maxGeometryInputComponents
    struct_body << "\t\t\t" << structInfo->maxGeometryInputComponents << "," << std::endl;
// maxGeometryOutputComponents
    struct_body << "\t\t\t" << structInfo->maxGeometryOutputComponents << "," << std::endl;
// maxGeometryOutputVertices
    struct_body << "\t\t\t" << structInfo->maxGeometryOutputVertices << "," << std::endl;
// maxGeometryTotalOutputComponents
    struct_body << "\t\t\t" << structInfo->maxGeometryTotalOutputComponents << "," << std::endl;
// maxFragmentInputComponents
    struct_body << "\t\t\t" << structInfo->maxFragmentInputComponents << "," << std::endl;
// maxFragmentOutputAttachments
    struct_body << "\t\t\t" << structInfo->maxFragmentOutputAttachments << "," << std::endl;
// maxFragmentDualSrcAttachments
    struct_body << "\t\t\t" << structInfo->maxFragmentDualSrcAttachments << "," << std::endl;
// maxFragmentCombinedOutputResources
    struct_body << "\t\t\t" << structInfo->maxFragmentCombinedOutputResources << "," << std::endl;
// maxComputeSharedMemorySize
    struct_body << "\t\t\t" << structInfo->maxComputeSharedMemorySize << "," << std::endl;
// maxComputeWorkGroupCount
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxComputeWorkGroupCount[0]), 3) << "," << std::endl;
// maxComputeWorkGroupInvocations
    struct_body << "\t\t\t" << structInfo->maxComputeWorkGroupInvocations << "," << std::endl;
// maxComputeWorkGroupSize
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxComputeWorkGroupSize[0]), 3) << "," << std::endl;
// subPixelPrecisionBits
    struct_body << "\t\t\t" << structInfo->subPixelPrecisionBits << "," << std::endl;
// subTexelPrecisionBits
    struct_body << "\t\t\t" << structInfo->subTexelPrecisionBits << "," << std::endl;
// mipmapPrecisionBits
    struct_body << "\t\t\t" << structInfo->mipmapPrecisionBits << "," << std::endl;
// maxDrawIndexedIndexValue
    struct_body << "\t\t\t" << structInfo->maxDrawIndexedIndexValue << "," << std::endl;
// maxDrawIndirectCount
    struct_body << "\t\t\t" << structInfo->maxDrawIndirectCount << "," << std::endl;
// maxSamplerLodBias
    struct_body << "\t\t\t" << structInfo->maxSamplerLodBias << "," << std::endl;
// maxSamplerAnisotropy
    struct_body << "\t\t\t" << structInfo->maxSamplerAnisotropy << "," << std::endl;
// maxViewports
    struct_body << "\t\t\t" << structInfo->maxViewports << "," << std::endl;
// maxViewportDimensions
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxViewportDimensions[0]), 2) << "," << std::endl;
// viewportBoundsRange
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->viewportBoundsRange[0]), 2) << "," << std::endl;
// viewportSubPixelBits
    struct_body << "\t\t\t" << structInfo->viewportSubPixelBits << "," << std::endl;
// minMemoryMapAlignment
    struct_body << "\t\t\t" << structInfo->minMemoryMapAlignment << "," << std::endl;
// minTexelBufferOffsetAlignment
    struct_body << "\t\t\t" << structInfo->minTexelBufferOffsetAlignment << "UL" << "," << std::endl;
// minUniformBufferOffsetAlignment
    struct_body << "\t\t\t" << structInfo->minUniformBufferOffsetAlignment << "UL" << "," << std::endl;
// minStorageBufferOffsetAlignment
    struct_body << "\t\t\t" << structInfo->minStorageBufferOffsetAlignment << "UL" << "," << std::endl;
// minTexelOffset
    struct_body << "\t\t\t" << structInfo->minTexelOffset << "," << std::endl;
// maxTexelOffset
    struct_body << "\t\t\t" << structInfo->maxTexelOffset << "," << std::endl;
// minTexelGatherOffset
    struct_body << "\t\t\t" << structInfo->minTexelGatherOffset << "," << std::endl;
// maxTexelGatherOffset
    struct_body << "\t\t\t" << structInfo->maxTexelGatherOffset << "," << std::endl;
// minInterpolationOffset
    struct_body << "\t\t\t" << structInfo->minInterpolationOffset << "," << std::endl;
// maxInterpolationOffset
    struct_body << "\t\t\t" << structInfo->maxInterpolationOffset << "," << std::endl;
// subPixelInterpolationOffsetBits
    struct_body << "\t\t\t" << structInfo->subPixelInterpolationOffsetBits << "," << std::endl;
// maxFramebufferWidth
    struct_body << "\t\t\t" << structInfo->maxFramebufferWidth << "," << std::endl;
// maxFramebufferHeight
    struct_body << "\t\t\t" << structInfo->maxFramebufferHeight << "," << std::endl;
// maxFramebufferLayers
    struct_body << "\t\t\t" << structInfo->maxFramebufferLayers << "," << std::endl;
// framebufferColorSampleCounts
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->framebufferColorSampleCounts << ")" << "," << std::endl;
// framebufferDepthSampleCounts
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->framebufferDepthSampleCounts << ")" << "," << std::endl;
// framebufferStencilSampleCounts
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->framebufferStencilSampleCounts << ")" << "," << std::endl;
// framebufferNoAttachmentsSampleCounts
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->framebufferNoAttachmentsSampleCounts << ")" << "," << std::endl;
// maxColorAttachments
    struct_body << "\t\t\t" << structInfo->maxColorAttachments << "," << std::endl;
// sampledImageColorSampleCounts
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->sampledImageColorSampleCounts << ")" << "," << std::endl;
// sampledImageIntegerSampleCounts
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->sampledImageIntegerSampleCounts << ")" << "," << std::endl;
// sampledImageDepthSampleCounts
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->sampledImageDepthSampleCounts << ")" << "," << std::endl;
// sampledImageStencilSampleCounts
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->sampledImageStencilSampleCounts << ")" << "," << std::endl;
// storageImageSampleCounts
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->storageImageSampleCounts << ")" << "," << std::endl;
// maxSampleMaskWords
    struct_body << "\t\t\t" << structInfo->maxSampleMaskWords << "," << std::endl;
// timestampComputeAndGraphics
    struct_body << "\t\t\t" << structInfo->timestampComputeAndGraphics << "," << std::endl;
// timestampPeriod
    struct_body << "\t\t\t" << structInfo->timestampPeriod << "," << std::endl;
// maxClipDistances
    struct_body << "\t\t\t" << structInfo->maxClipDistances << "," << std::endl;
// maxCullDistances
    struct_body << "\t\t\t" << structInfo->maxCullDistances << "," << std::endl;
// maxCombinedClipAndCullDistances
    struct_body << "\t\t\t" << structInfo->maxCombinedClipAndCullDistances << "," << std::endl;
// discreteQueuePriorities
    struct_body << "\t\t\t" << structInfo->discreteQueuePriorities << "," << std::endl;
// pointSizeRange
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->pointSizeRange[0]), 2) << "," << std::endl;
// lineWidthRange
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->lineWidthRange[0]), 2) << "," << std::endl;
// pointSizeGranularity
    struct_body << "\t\t\t" << structInfo->pointSizeGranularity << "," << std::endl;
// lineWidthGranularity
    struct_body << "\t\t\t" << structInfo->lineWidthGranularity << "," << std::endl;
// strictLines
    struct_body << "\t\t\t" << structInfo->strictLines << "," << std::endl;
// standardSampleLocations
    struct_body << "\t\t\t" << structInfo->standardSampleLocations << "," << std::endl;
// optimalBufferCopyOffsetAlignment
    struct_body << "\t\t\t" << structInfo->optimalBufferCopyOffsetAlignment << "UL" << "," << std::endl;
// optimalBufferCopyRowPitchAlignment
    struct_body << "\t\t\t" << structInfo->optimalBufferCopyRowPitchAlignment << "UL" << "," << std::endl;
// nonCoherentAtomSize
    struct_body << "\t\t\t" << structInfo->nonCoherentAtomSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLimits");
    out << "\t\t" << "VkPhysicalDeviceLimits " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMemoryProperties(std::ostream &out, const VkPhysicalDeviceMemoryProperties* structInfo, Decoded_VkPhysicalDeviceMemoryProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// memoryTypeCount
    struct_body << "\t" << structInfo->memoryTypeCount << "," << std::endl;
// memoryTypes
	struct_body << "\t\t\t{}," << std::endl;
// memoryHeapCount
    struct_body << "\t\t\t" << structInfo->memoryHeapCount << "," << std::endl;
// memoryHeaps
	struct_body << "\t\t\t{}," << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMemoryProperties");
    out << "\t\t" << "VkPhysicalDeviceMemoryProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceProperties(std::ostream &out, const VkPhysicalDeviceProperties* structInfo, Decoded_VkPhysicalDeviceProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string limits_info_var = GenerateStruct_VkPhysicalDeviceLimits(out,
                                                                        &structInfo->limits,
                                                                        metaInfo->limits,
                                                                        consumer);
    std::string sparse_properties_info_var = GenerateStruct_VkPhysicalDeviceSparseProperties(out,
                                                                                             &structInfo->sparseProperties,
                                                                                             metaInfo->sparseProperties,
                                                                                             consumer);
// apiVersion
    struct_body << "\t" << structInfo->apiVersion << "," << std::endl;
// driverVersion
    struct_body << "\t\t\t" << structInfo->driverVersion << "," << std::endl;
// vendorID
    struct_body << "\t\t\t" << structInfo->vendorID << "," << std::endl;
// deviceID
    struct_body << "\t\t\t" << structInfo->deviceID << "," << std::endl;
// deviceType
    struct_body << "\t\t\t" << "VkPhysicalDeviceType(" << structInfo->deviceType << ")" << "," << std::endl;
// deviceName
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->deviceName) << "," << std::endl;
// pipelineCacheUUID
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->pipelineCacheUUID[0]), VK_UUID_SIZE) << "," << std::endl;
// limits
    struct_body << "\t\t\t" << limits_info_var << "," << std::endl;
// sparseProperties
    struct_body << "\t\t\t" << sparse_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceProperties");
    out << "\t\t" << "VkPhysicalDeviceProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSparseProperties(std::ostream &out, const VkPhysicalDeviceSparseProperties* structInfo, Decoded_VkPhysicalDeviceSparseProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// residencyStandard2DBlockShape
    struct_body << "\t" << structInfo->residencyStandard2DBlockShape << "," << std::endl;
// residencyStandard2DMultisampleBlockShape
    struct_body << "\t\t\t" << structInfo->residencyStandard2DMultisampleBlockShape << "," << std::endl;
// residencyStandard3DBlockShape
    struct_body << "\t\t\t" << structInfo->residencyStandard3DBlockShape << "," << std::endl;
// residencyAlignedMipSize
    struct_body << "\t\t\t" << structInfo->residencyAlignedMipSize << "," << std::endl;
// residencyNonResidentStrict
    struct_body << "\t\t\t" << structInfo->residencyNonResidentStrict << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSparseProperties");
    out << "\t\t" << "VkPhysicalDeviceSparseProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCacheCreateInfo(std::ostream &out, const VkPipelineCacheCreateInfo* structInfo, Decoded_VkPipelineCacheCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pinitial_data_array = "NULL";
    if (structInfo->pInitialData != NULL) {
        std::string pinitial_data_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->initialDataSize; ++idx0) {
            pinitial_data_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pInitialData)[idx0]) + ", ";
        }
        pinitial_data_array = "pInitialData_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pinitial_data_array << "[] = {" << pinitial_data_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineCacheCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// initialDataSize
    struct_body << "\t\t\t" << structInfo->initialDataSize << "," << std::endl;
// pInitialData
    struct_body << "\t\t\t" << pinitial_data_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCacheCreateInfo");
    out << "\t\t" << "VkPipelineCacheCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCacheHeaderVersionOne(std::ostream &out, const VkPipelineCacheHeaderVersionOne* structInfo, Decoded_VkPipelineCacheHeaderVersionOne* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// headerSize
    struct_body << "\t" << structInfo->headerSize << "," << std::endl;
// headerVersion
    struct_body << "\t\t\t" << "VkPipelineCacheHeaderVersion(" << structInfo->headerVersion << ")" << "," << std::endl;
// vendorID
    struct_body << "\t\t\t" << structInfo->vendorID << "," << std::endl;
// deviceID
    struct_body << "\t\t\t" << structInfo->deviceID << "," << std::endl;
// pipelineCacheUUID
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->pipelineCacheUUID[0]), VK_UUID_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCacheHeaderVersionOne");
    out << "\t\t" << "VkPipelineCacheHeaderVersionOne " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineColorBlendAttachmentState(std::ostream &out, const VkPipelineColorBlendAttachmentState* structInfo, Decoded_VkPipelineColorBlendAttachmentState* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// blendEnable
    struct_body << "\t" << structInfo->blendEnable << "," << std::endl;
// srcColorBlendFactor
    struct_body << "\t\t\t" << "VkBlendFactor(" << structInfo->srcColorBlendFactor << ")" << "," << std::endl;
// dstColorBlendFactor
    struct_body << "\t\t\t" << "VkBlendFactor(" << structInfo->dstColorBlendFactor << ")" << "," << std::endl;
// colorBlendOp
    struct_body << "\t\t\t" << "VkBlendOp(" << structInfo->colorBlendOp << ")" << "," << std::endl;
// srcAlphaBlendFactor
    struct_body << "\t\t\t" << "VkBlendFactor(" << structInfo->srcAlphaBlendFactor << ")" << "," << std::endl;
// dstAlphaBlendFactor
    struct_body << "\t\t\t" << "VkBlendFactor(" << structInfo->dstAlphaBlendFactor << ")" << "," << std::endl;
// alphaBlendOp
    struct_body << "\t\t\t" << "VkBlendOp(" << structInfo->alphaBlendOp << ")" << "," << std::endl;
// colorWriteMask
    struct_body << "\t\t\t" << "VkColorComponentFlags(" << structInfo->colorWriteMask << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineColorBlendAttachmentState");
    out << "\t\t" << "VkPipelineColorBlendAttachmentState " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineColorBlendStateCreateInfo(std::ostream &out, const VkPipelineColorBlendStateCreateInfo* structInfo, Decoded_VkPipelineColorBlendStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pattachments_array = "NULL";
    if (structInfo->pAttachments != NULL) {
        pattachments_array = "pAttachments_" + std::to_string(consumer.GetNextId());
        std::string pattachments_names;
        for (uint32_t idx = 0; idx < structInfo->attachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkPipelineColorBlendAttachmentState(out,
                                                                                   structInfo->pAttachments + idx,
                                                                                   metaInfo->pAttachments->GetMetaStructPointer() + idx,
                                                                                   consumer);
            }
            pattachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPipelineColorBlendAttachmentState " << pattachments_array << "[] = {" << pattachments_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineColorBlendStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// logicOpEnable
    struct_body << "\t\t\t" << structInfo->logicOpEnable << "," << std::endl;
// logicOp
    struct_body << "\t\t\t" << "VkLogicOp(" << structInfo->logicOp << ")" << "," << std::endl;
// attachmentCount
    struct_body << "\t\t\t" << structInfo->attachmentCount << "," << std::endl;
// pAttachments
    struct_body << "\t\t\t" << pattachments_array << "," << std::endl;
// blendConstants
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->blendConstants[0]), 4) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineColorBlendStateCreateInfo");
    out << "\t\t" << "VkPipelineColorBlendStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineDepthStencilStateCreateInfo(std::ostream &out, const VkPipelineDepthStencilStateCreateInfo* structInfo, Decoded_VkPipelineDepthStencilStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string front_info_var = GenerateStruct_VkStencilOpState(out,
                                                                 &structInfo->front,
                                                                 metaInfo->front,
                                                                 consumer);
    std::string back_info_var = GenerateStruct_VkStencilOpState(out,
                                                                &structInfo->back,
                                                                metaInfo->back,
                                                                consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineDepthStencilStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// depthTestEnable
    struct_body << "\t\t\t" << structInfo->depthTestEnable << "," << std::endl;
// depthWriteEnable
    struct_body << "\t\t\t" << structInfo->depthWriteEnable << "," << std::endl;
// depthCompareOp
    struct_body << "\t\t\t" << "VkCompareOp(" << structInfo->depthCompareOp << ")" << "," << std::endl;
// depthBoundsTestEnable
    struct_body << "\t\t\t" << structInfo->depthBoundsTestEnable << "," << std::endl;
// stencilTestEnable
    struct_body << "\t\t\t" << structInfo->stencilTestEnable << "," << std::endl;
// front
    struct_body << "\t\t\t" << front_info_var << "," << std::endl;
// back
    struct_body << "\t\t\t" << back_info_var << "," << std::endl;
// minDepthBounds
    struct_body << "\t\t\t" << structInfo->minDepthBounds << "," << std::endl;
// maxDepthBounds
    struct_body << "\t\t\t" << structInfo->maxDepthBounds << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineDepthStencilStateCreateInfo");
    out << "\t\t" << "VkPipelineDepthStencilStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineDynamicStateCreateInfo(std::ostream &out, const VkPipelineDynamicStateCreateInfo* structInfo, Decoded_VkPipelineDynamicStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdynamic_states_values;
    std::string pdynamic_states_array = "NULL";
    if (structInfo->pDynamicStates != NULL) {
        for (uint32_t idx = 0; idx < structInfo->dynamicStateCount; idx++) {
            pdynamic_states_values += util::ToString<VkDynamicState>(structInfo->pDynamicStates[idx]) + ", ";
        }
        pdynamic_states_array = "pDynamicStates_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkDynamicState " << pdynamic_states_array << "[] = {" << pdynamic_states_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineDynamicStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// dynamicStateCount
    struct_body << "\t\t\t" << structInfo->dynamicStateCount << "," << std::endl;
// pDynamicStates
    struct_body << "\t\t\t" << pdynamic_states_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineDynamicStateCreateInfo");
    out << "\t\t" << "VkPipelineDynamicStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineInputAssemblyStateCreateInfo(std::ostream &out, const VkPipelineInputAssemblyStateCreateInfo* structInfo, Decoded_VkPipelineInputAssemblyStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineInputAssemblyStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// topology
    struct_body << "\t\t\t" << "VkPrimitiveTopology(" << structInfo->topology << ")" << "," << std::endl;
// primitiveRestartEnable
    struct_body << "\t\t\t" << structInfo->primitiveRestartEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineInputAssemblyStateCreateInfo");
    out << "\t\t" << "VkPipelineInputAssemblyStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineLayoutCreateInfo(std::ostream &out, const VkPipelineLayoutCreateInfo* structInfo, Decoded_VkPipelineLayoutCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pset_layouts_array = "NULL";
    if (metaInfo->pSetLayouts.GetPointer() != NULL && structInfo->setLayoutCount > 0) {
        pset_layouts_array = "pset_layouts_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT));
        std::string pset_layouts_values = toStringJoin(metaInfo->pSetLayouts.GetPointer(),
                                                       metaInfo->pSetLayouts.GetPointer() + structInfo->setLayoutCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->setLayoutCount == 1) {
            pset_layouts_array = "&" + pset_layouts_values;
        } else if (structInfo->setLayoutCount > 1) {
            out << "\t\t" << "VkDescriptorSetLayout " << pset_layouts_array << "[] = {" << pset_layouts_values << "};" << std::endl;
        }
    }
    std::string ppush_constant_ranges_array = "NULL";
    if (structInfo->pPushConstantRanges != NULL) {
        ppush_constant_ranges_array = "pPushConstantRanges_" + std::to_string(consumer.GetNextId());
        std::string ppush_constant_ranges_names;
        for (uint32_t idx = 0; idx < structInfo->pushConstantRangeCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPushConstantRanges + idx != NULL) {
                variable_name = GenerateStruct_VkPushConstantRange(out,
                                                                   structInfo->pPushConstantRanges + idx,
                                                                   metaInfo->pPushConstantRanges->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            ppush_constant_ranges_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPushConstantRange " << ppush_constant_ranges_array << "[] = {" << ppush_constant_ranges_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineLayoutCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// setLayoutCount
    struct_body << "\t\t\t" << structInfo->setLayoutCount << "," << std::endl;
// pSetLayouts
    struct_body << "\t\t\t" << pset_layouts_array << "," << std::endl;
// pushConstantRangeCount
    struct_body << "\t\t\t" << structInfo->pushConstantRangeCount << "," << std::endl;
// pPushConstantRanges
    struct_body << "\t\t\t" << ppush_constant_ranges_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineLayoutCreateInfo");
    out << "\t\t" << "VkPipelineLayoutCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineMultisampleStateCreateInfo(std::ostream &out, const VkPipelineMultisampleStateCreateInfo* structInfo, Decoded_VkPipelineMultisampleStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string psample_mask_array = "NULL";
    if (structInfo->pSampleMask != NULL) {
        std::string psample_mask_values;
        for (uint32_t idx0 = 0; idx0 < (structInfo->rasterizationSamples + 31) / 32; ++idx0) {
            psample_mask_values += std::to_string(structInfo->pSampleMask[idx0]) + ", ";
        }
        psample_mask_array = "pSampleMask_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkSampleMask " << psample_mask_array << "[] = {" << psample_mask_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineMultisampleStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// rasterizationSamples
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->rasterizationSamples << ")" << "," << std::endl;
// sampleShadingEnable
    struct_body << "\t\t\t" << structInfo->sampleShadingEnable << "," << std::endl;
// minSampleShading
    struct_body << "\t\t\t" << structInfo->minSampleShading << "," << std::endl;
// pSampleMask
    struct_body << "\t\t\t" << psample_mask_array << "," << std::endl;
// alphaToCoverageEnable
    struct_body << "\t\t\t" << structInfo->alphaToCoverageEnable << "," << std::endl;
// alphaToOneEnable
    struct_body << "\t\t\t" << structInfo->alphaToOneEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineMultisampleStateCreateInfo");
    out << "\t\t" << "VkPipelineMultisampleStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRasterizationStateCreateInfo(std::ostream &out, const VkPipelineRasterizationStateCreateInfo* structInfo, Decoded_VkPipelineRasterizationStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineRasterizationStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// depthClampEnable
    struct_body << "\t\t\t" << structInfo->depthClampEnable << "," << std::endl;
// rasterizerDiscardEnable
    struct_body << "\t\t\t" << structInfo->rasterizerDiscardEnable << "," << std::endl;
// polygonMode
    struct_body << "\t\t\t" << "VkPolygonMode(" << structInfo->polygonMode << ")" << "," << std::endl;
// cullMode
    struct_body << "\t\t\t" << "VkCullModeFlags(" << structInfo->cullMode << ")" << "," << std::endl;
// frontFace
    struct_body << "\t\t\t" << "VkFrontFace(" << structInfo->frontFace << ")" << "," << std::endl;
// depthBiasEnable
    struct_body << "\t\t\t" << structInfo->depthBiasEnable << "," << std::endl;
// depthBiasConstantFactor
    struct_body << "\t\t\t" << structInfo->depthBiasConstantFactor << "," << std::endl;
// depthBiasClamp
    struct_body << "\t\t\t" << structInfo->depthBiasClamp << "," << std::endl;
// depthBiasSlopeFactor
    struct_body << "\t\t\t" << structInfo->depthBiasSlopeFactor << "," << std::endl;
// lineWidth
    struct_body << "\t\t\t" << structInfo->lineWidth << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRasterizationStateCreateInfo");
    out << "\t\t" << "VkPipelineRasterizationStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineShaderStageCreateInfo(std::ostream &out, const VkPipelineShaderStageCreateInfo* structInfo, Decoded_VkPipelineShaderStageCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pspecialization_info_struct = "NULL";
    if (structInfo->pSpecializationInfo != NULL) {
        pspecialization_info_struct = GenerateStruct_VkSpecializationInfo(out,
                                                                          structInfo->pSpecializationInfo,
                                                                          metaInfo->pSpecializationInfo->GetMetaStructPointer(),
                                                                          consumer);
        pspecialization_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineShaderStageCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// stage
    struct_body << "\t\t\t" << "VkShaderStageFlagBits(" << structInfo->stage << ")" << "," << std::endl;
// module
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->module) << "," << std::endl;
// pName
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pName) << "," << std::endl;
// pSpecializationInfo
    struct_body << "\t\t\t" << pspecialization_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineShaderStageCreateInfo");
    out << "\t\t" << "VkPipelineShaderStageCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineTessellationStateCreateInfo(std::ostream &out, const VkPipelineTessellationStateCreateInfo* structInfo, Decoded_VkPipelineTessellationStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineTessellationStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// patchControlPoints
    struct_body << "\t\t\t" << structInfo->patchControlPoints << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineTessellationStateCreateInfo");
    out << "\t\t" << "VkPipelineTessellationStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineVertexInputStateCreateInfo(std::ostream &out, const VkPipelineVertexInputStateCreateInfo* structInfo, Decoded_VkPipelineVertexInputStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pvertex_binding_descriptions_array = "NULL";
    if (structInfo->pVertexBindingDescriptions != NULL) {
        pvertex_binding_descriptions_array = "pVertexBindingDescriptions_" + std::to_string(consumer.GetNextId());
        std::string pvertex_binding_descriptions_names;
        for (uint32_t idx = 0; idx < structInfo->vertexBindingDescriptionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pVertexBindingDescriptions + idx != NULL) {
                variable_name = GenerateStruct_VkVertexInputBindingDescription(out,
                                                                               structInfo->pVertexBindingDescriptions + idx,
                                                                               metaInfo->pVertexBindingDescriptions->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pvertex_binding_descriptions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVertexInputBindingDescription " << pvertex_binding_descriptions_array << "[] = {" << pvertex_binding_descriptions_names << "};" << std::endl;
    }
    std::string pvertex_attribute_descriptions_array = "NULL";
    if (structInfo->pVertexAttributeDescriptions != NULL) {
        pvertex_attribute_descriptions_array = "pVertexAttributeDescriptions_" + std::to_string(consumer.GetNextId());
        std::string pvertex_attribute_descriptions_names;
        for (uint32_t idx = 0; idx < structInfo->vertexAttributeDescriptionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pVertexAttributeDescriptions + idx != NULL) {
                variable_name = GenerateStruct_VkVertexInputAttributeDescription(out,
                                                                                 structInfo->pVertexAttributeDescriptions + idx,
                                                                                 metaInfo->pVertexAttributeDescriptions->GetMetaStructPointer() + idx,
                                                                                 consumer);
            }
            pvertex_attribute_descriptions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVertexInputAttributeDescription " << pvertex_attribute_descriptions_array << "[] = {" << pvertex_attribute_descriptions_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineVertexInputStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// vertexBindingDescriptionCount
    struct_body << "\t\t\t" << structInfo->vertexBindingDescriptionCount << "," << std::endl;
// pVertexBindingDescriptions
    struct_body << "\t\t\t" << pvertex_binding_descriptions_array << "," << std::endl;
// vertexAttributeDescriptionCount
    struct_body << "\t\t\t" << structInfo->vertexAttributeDescriptionCount << "," << std::endl;
// pVertexAttributeDescriptions
    struct_body << "\t\t\t" << pvertex_attribute_descriptions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineVertexInputStateCreateInfo");
    out << "\t\t" << "VkPipelineVertexInputStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportStateCreateInfo(std::ostream &out, const VkPipelineViewportStateCreateInfo* structInfo, Decoded_VkPipelineViewportStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pviewports_array = "NULL";
    if (structInfo->pViewports != NULL) {
        pviewports_array = "pViewports_" + std::to_string(consumer.GetNextId());
        std::string pviewports_names;
        for (uint32_t idx = 0; idx < structInfo->viewportCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pViewports + idx != NULL) {
                variable_name = GenerateStruct_VkViewport(out,
                                                          structInfo->pViewports + idx,
                                                          metaInfo->pViewports->GetMetaStructPointer() + idx,
                                                          consumer);
            }
            pviewports_names += variable_name + ", ";
        }
        out << "\t\t" << "VkViewport " << pviewports_array << "[] = {" << pviewports_names << "};" << std::endl;
    }
    std::string pscissors_array = "NULL";
    if (structInfo->pScissors != NULL) {
        pscissors_array = "pScissors_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkRect2D " << pscissors_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pScissors, structInfo->scissorCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineViewportStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// viewportCount
    struct_body << "\t\t\t" << structInfo->viewportCount << "," << std::endl;
// pViewports
    struct_body << "\t\t\t" << pviewports_array << "," << std::endl;
// scissorCount
    struct_body << "\t\t\t" << structInfo->scissorCount << "," << std::endl;
// pScissors
    struct_body << "\t\t\t" << pscissors_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportStateCreateInfo");
    out << "\t\t" << "VkPipelineViewportStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPushConstantRange(std::ostream &out, const VkPushConstantRange* structInfo, Decoded_VkPushConstantRange* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// stageFlags
    struct_body << "\t" << "VkShaderStageFlags(" << structInfo->stageFlags << ")" << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pushConstantRange");
    out << "\t\t" << "VkPushConstantRange " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueryPoolCreateInfo(std::ostream &out, const VkQueryPoolCreateInfo* structInfo, Decoded_VkQueryPoolCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkQueryPoolCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// queryType
    struct_body << "\t\t\t" << "VkQueryType(" << structInfo->queryType << ")" << "," << std::endl;
// queryCount
    struct_body << "\t\t\t" << structInfo->queryCount << "," << std::endl;
// pipelineStatistics
    struct_body << "\t\t\t" << "VkQueryPipelineStatisticFlags(" << structInfo->pipelineStatistics << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queryPoolCreateInfo");
    out << "\t\t" << "VkQueryPoolCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyProperties(std::ostream &out, const VkQueueFamilyProperties* structInfo, Decoded_VkQueueFamilyProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string min_image_transfer_granularity_info_var = GenerateStruct_VkExtent3D(out,
                                                                                    &structInfo->minImageTransferGranularity,
                                                                                    metaInfo->minImageTransferGranularity,
                                                                                    consumer);
// queueFlags
    struct_body << "\t" << "VkQueueFlags(" << structInfo->queueFlags << ")" << "," << std::endl;
// queueCount
    struct_body << "\t\t\t" << structInfo->queueCount << "," << std::endl;
// timestampValidBits
    struct_body << "\t\t\t" << structInfo->timestampValidBits << "," << std::endl;
// minImageTransferGranularity
    struct_body << "\t\t\t" << min_image_transfer_granularity_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyProperties");
    out << "\t\t" << "VkQueueFamilyProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRect2D(std::ostream &out, const VkRect2D* structInfo, Decoded_VkRect2D* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string offset_info_var = GenerateStruct_VkOffset2D(out,
                                                            &structInfo->offset,
                                                            metaInfo->offset,
                                                            consumer);
    std::string extent_info_var = GenerateStruct_VkExtent2D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
// offset
    struct_body << "\t" << offset_info_var << "," << std::endl;
// extent
    struct_body << "\t\t\t" << extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "rect2D");
    out << "\t\t" << "VkRect2D " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassBeginInfo(std::ostream &out, const VkRenderPassBeginInfo* structInfo, Decoded_VkRenderPassBeginInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string render_area_info_var = GenerateStruct_VkRect2D(out,
                                                               &structInfo->renderArea,
                                                               metaInfo->renderArea,
                                                               consumer);
    std::string pclear_values_array = "NULL";
    if (structInfo->pClearValues != NULL) {
        pclear_values_array = "pClearValues_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkClearValue " << pclear_values_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pClearValues, structInfo->clearValueCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// renderPass
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->renderPass) << "," << std::endl;
// framebuffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->framebuffer) << "," << std::endl;
// renderArea
    struct_body << "\t\t\t" << render_area_info_var << "," << std::endl;
// clearValueCount
    struct_body << "\t\t\t" << structInfo->clearValueCount << "," << std::endl;
// pClearValues
    struct_body << "\t\t\t" << pclear_values_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassBeginInfo");
    out << "\t\t" << "VkRenderPassBeginInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassCreateInfo(std::ostream &out, const VkRenderPassCreateInfo* structInfo, Decoded_VkRenderPassCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pattachments_array = "NULL";
    if (structInfo->pAttachments != NULL) {
        pattachments_array = "pAttachments_" + std::to_string(consumer.GetNextId());
        std::string pattachments_names;
        for (uint32_t idx = 0; idx < structInfo->attachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentDescription(out,
                                                                       structInfo->pAttachments + idx,
                                                                       metaInfo->pAttachments->GetMetaStructPointer() + idx,
                                                                       consumer);
            }
            pattachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentDescription " << pattachments_array << "[] = {" << pattachments_names << "};" << std::endl;
    }
    std::string psubpasses_array = "NULL";
    if (structInfo->pSubpasses != NULL) {
        psubpasses_array = "pSubpasses_" + std::to_string(consumer.GetNextId());
        std::string psubpasses_names;
        for (uint32_t idx = 0; idx < structInfo->subpassCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pSubpasses + idx != NULL) {
                variable_name = GenerateStruct_VkSubpassDescription(out,
                                                                    structInfo->pSubpasses + idx,
                                                                    metaInfo->pSubpasses->GetMetaStructPointer() + idx,
                                                                    consumer);
            }
            psubpasses_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSubpassDescription " << psubpasses_array << "[] = {" << psubpasses_names << "};" << std::endl;
    }
    std::string pdependencies_array = "NULL";
    if (structInfo->pDependencies != NULL) {
        pdependencies_array = "pDependencies_" + std::to_string(consumer.GetNextId());
        std::string pdependencies_names;
        for (uint32_t idx = 0; idx < structInfo->dependencyCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pDependencies + idx != NULL) {
                variable_name = GenerateStruct_VkSubpassDependency(out,
                                                                   structInfo->pDependencies + idx,
                                                                   metaInfo->pDependencies->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            pdependencies_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSubpassDependency " << pdependencies_array << "[] = {" << pdependencies_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkRenderPassCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// attachmentCount
    struct_body << "\t\t\t" << structInfo->attachmentCount << "," << std::endl;
// pAttachments
    struct_body << "\t\t\t" << pattachments_array << "," << std::endl;
// subpassCount
    struct_body << "\t\t\t" << structInfo->subpassCount << "," << std::endl;
// pSubpasses
    struct_body << "\t\t\t" << psubpasses_array << "," << std::endl;
// dependencyCount
    struct_body << "\t\t\t" << structInfo->dependencyCount << "," << std::endl;
// pDependencies
    struct_body << "\t\t\t" << pdependencies_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassCreateInfo");
    out << "\t\t" << "VkRenderPassCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerCreateInfo(std::ostream &out, const VkSamplerCreateInfo* structInfo, Decoded_VkSamplerCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkSamplerCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// magFilter
    struct_body << "\t\t\t" << "VkFilter(" << structInfo->magFilter << ")" << "," << std::endl;
// minFilter
    struct_body << "\t\t\t" << "VkFilter(" << structInfo->minFilter << ")" << "," << std::endl;
// mipmapMode
    struct_body << "\t\t\t" << "VkSamplerMipmapMode(" << structInfo->mipmapMode << ")" << "," << std::endl;
// addressModeU
    struct_body << "\t\t\t" << "VkSamplerAddressMode(" << structInfo->addressModeU << ")" << "," << std::endl;
// addressModeV
    struct_body << "\t\t\t" << "VkSamplerAddressMode(" << structInfo->addressModeV << ")" << "," << std::endl;
// addressModeW
    struct_body << "\t\t\t" << "VkSamplerAddressMode(" << structInfo->addressModeW << ")" << "," << std::endl;
// mipLodBias
    struct_body << "\t\t\t" << structInfo->mipLodBias << "," << std::endl;
// anisotropyEnable
    struct_body << "\t\t\t" << structInfo->anisotropyEnable << "," << std::endl;
// maxAnisotropy
    struct_body << "\t\t\t" << structInfo->maxAnisotropy << "," << std::endl;
// compareEnable
    struct_body << "\t\t\t" << structInfo->compareEnable << "," << std::endl;
// compareOp
    struct_body << "\t\t\t" << "VkCompareOp(" << structInfo->compareOp << ")" << "," << std::endl;
// minLod
    struct_body << "\t\t\t" << structInfo->minLod << "," << std::endl;
// maxLod
    struct_body << "\t\t\t" << structInfo->maxLod << "," << std::endl;
// borderColor
    struct_body << "\t\t\t" << "VkBorderColor(" << structInfo->borderColor << ")" << "," << std::endl;
// unnormalizedCoordinates
    struct_body << "\t\t\t" << structInfo->unnormalizedCoordinates << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerCreateInfo");
    out << "\t\t" << "VkSamplerCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreCreateInfo(std::ostream &out, const VkSemaphoreCreateInfo* structInfo, Decoded_VkSemaphoreCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkSemaphoreCreateFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreCreateInfo");
    out << "\t\t" << "VkSemaphoreCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkShaderModuleCreateInfo(std::ostream &out, const VkShaderModuleCreateInfo* structInfo, Decoded_VkShaderModuleCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcode_array = "NULL";
    if (structInfo->pCode != NULL) {
        pcode_array = "pCode_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pcode_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCode, structInfo->codeSize / 4) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkShaderModuleCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// codeSize
    struct_body << "\t\t\t" << structInfo->codeSize << "," << std::endl;
// pCode
    struct_body << "\t\t\t" << pcode_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "shaderModuleCreateInfo");
    out << "\t\t" << "VkShaderModuleCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseBufferMemoryBindInfo(std::ostream &out, const VkSparseBufferMemoryBindInfo* structInfo, Decoded_VkSparseBufferMemoryBindInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pbinds_array = "NULL";
    if (structInfo->pBinds != NULL) {
        pbinds_array = "pBinds_" + std::to_string(consumer.GetNextId());
        std::string pbinds_names;
        for (uint32_t idx = 0; idx < structInfo->bindCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pBinds + idx != NULL) {
                variable_name = GenerateStruct_VkSparseMemoryBind(out,
                                                                  structInfo->pBinds + idx,
                                                                  metaInfo->pBinds->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pbinds_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSparseMemoryBind " << pbinds_array << "[] = {" << pbinds_names << "};" << std::endl;
    }
// buffer
    struct_body << "\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
// bindCount
    struct_body << "\t\t\t" << structInfo->bindCount << "," << std::endl;
// pBinds
    struct_body << "\t\t\t" << pbinds_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseBufferMemoryBindInfo");
    out << "\t\t" << "VkSparseBufferMemoryBindInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseImageFormatProperties(std::ostream &out, const VkSparseImageFormatProperties* structInfo, Decoded_VkSparseImageFormatProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string image_granularity_info_var = GenerateStruct_VkExtent3D(out,
                                                                       &structInfo->imageGranularity,
                                                                       metaInfo->imageGranularity,
                                                                       consumer);
// aspectMask
    struct_body << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
// imageGranularity
    struct_body << "\t\t\t" << image_granularity_info_var << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkSparseImageFormatFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseImageFormatProperties");
    out << "\t\t" << "VkSparseImageFormatProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseImageMemoryBind(std::ostream &out, const VkSparseImageMemoryBind* structInfo, Decoded_VkSparseImageMemoryBind* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string subresource_info_var = GenerateStruct_VkImageSubresource(out,
                                                                         &structInfo->subresource,
                                                                         metaInfo->subresource,
                                                                         consumer);
    std::string offset_info_var = GenerateStruct_VkOffset3D(out,
                                                            &structInfo->offset,
                                                            metaInfo->offset,
                                                            consumer);
    std::string extent_info_var = GenerateStruct_VkExtent3D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
// subresource
    struct_body << "\t" << subresource_info_var << "," << std::endl;
// offset
    struct_body << "\t\t\t" << offset_info_var << "," << std::endl;
// extent
    struct_body << "\t\t\t" << extent_info_var << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
// memoryOffset
    struct_body << "\t\t\t" << structInfo->memoryOffset << "UL" << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkSparseMemoryBindFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseImageMemoryBind");
    out << "\t\t" << "VkSparseImageMemoryBind " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseImageMemoryBindInfo(std::ostream &out, const VkSparseImageMemoryBindInfo* structInfo, Decoded_VkSparseImageMemoryBindInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pbinds_array = "NULL";
    if (structInfo->pBinds != NULL) {
        pbinds_array = "pBinds_" + std::to_string(consumer.GetNextId());
        std::string pbinds_names;
        for (uint32_t idx = 0; idx < structInfo->bindCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pBinds + idx != NULL) {
                variable_name = GenerateStruct_VkSparseImageMemoryBind(out,
                                                                       structInfo->pBinds + idx,
                                                                       metaInfo->pBinds->GetMetaStructPointer() + idx,
                                                                       consumer);
            }
            pbinds_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSparseImageMemoryBind " << pbinds_array << "[] = {" << pbinds_names << "};" << std::endl;
    }
// image
    struct_body << "\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
// bindCount
    struct_body << "\t\t\t" << structInfo->bindCount << "," << std::endl;
// pBinds
    struct_body << "\t\t\t" << pbinds_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseImageMemoryBindInfo");
    out << "\t\t" << "VkSparseImageMemoryBindInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseImageMemoryRequirements(std::ostream &out, const VkSparseImageMemoryRequirements* structInfo, Decoded_VkSparseImageMemoryRequirements* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string format_properties_info_var = GenerateStruct_VkSparseImageFormatProperties(out,
                                                                                          &structInfo->formatProperties,
                                                                                          metaInfo->formatProperties,
                                                                                          consumer);
// formatProperties
    struct_body << "\t" << format_properties_info_var << "," << std::endl;
// imageMipTailFirstLod
    struct_body << "\t\t\t" << structInfo->imageMipTailFirstLod << "," << std::endl;
// imageMipTailSize
    struct_body << "\t\t\t" << structInfo->imageMipTailSize << "UL" << "," << std::endl;
// imageMipTailOffset
    struct_body << "\t\t\t" << structInfo->imageMipTailOffset << "UL" << "," << std::endl;
// imageMipTailStride
    struct_body << "\t\t\t" << structInfo->imageMipTailStride << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseImageMemoryRequirements");
    out << "\t\t" << "VkSparseImageMemoryRequirements " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseImageOpaqueMemoryBindInfo(std::ostream &out, const VkSparseImageOpaqueMemoryBindInfo* structInfo, Decoded_VkSparseImageOpaqueMemoryBindInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pbinds_array = "NULL";
    if (structInfo->pBinds != NULL) {
        pbinds_array = "pBinds_" + std::to_string(consumer.GetNextId());
        std::string pbinds_names;
        for (uint32_t idx = 0; idx < structInfo->bindCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pBinds + idx != NULL) {
                variable_name = GenerateStruct_VkSparseMemoryBind(out,
                                                                  structInfo->pBinds + idx,
                                                                  metaInfo->pBinds->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pbinds_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSparseMemoryBind " << pbinds_array << "[] = {" << pbinds_names << "};" << std::endl;
    }
// image
    struct_body << "\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
// bindCount
    struct_body << "\t\t\t" << structInfo->bindCount << "," << std::endl;
// pBinds
    struct_body << "\t\t\t" << pbinds_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseImageOpaqueMemoryBindInfo");
    out << "\t\t" << "VkSparseImageOpaqueMemoryBindInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseMemoryBind(std::ostream &out, const VkSparseMemoryBind* structInfo, Decoded_VkSparseMemoryBind* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// resourceOffset
    struct_body << "\t" << structInfo->resourceOffset << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
// memoryOffset
    struct_body << "\t\t\t" << structInfo->memoryOffset << "UL" << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkSparseMemoryBindFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseMemoryBind");
    out << "\t\t" << "VkSparseMemoryBind " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSpecializationInfo(std::ostream &out, const VkSpecializationInfo* structInfo, Decoded_VkSpecializationInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pmap_entries_array = "NULL";
    if (structInfo->pMapEntries != NULL) {
        pmap_entries_array = "pMapEntries_" + std::to_string(consumer.GetNextId());
        std::string pmap_entries_names;
        for (uint32_t idx = 0; idx < structInfo->mapEntryCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pMapEntries + idx != NULL) {
                variable_name = GenerateStruct_VkSpecializationMapEntry(out,
                                                                        structInfo->pMapEntries + idx,
                                                                        metaInfo->pMapEntries->GetMetaStructPointer() + idx,
                                                                        consumer);
            }
            pmap_entries_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSpecializationMapEntry " << pmap_entries_array << "[] = {" << pmap_entries_names << "};" << std::endl;
    }
    std::string pdata_array = "NULL";
    if (structInfo->pData != NULL) {
        std::string pdata_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->dataSize; ++idx0) {
            pdata_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pData)[idx0]) + ", ";
        }
        pdata_array = "pData_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pdata_array << "[] = {" << pdata_values << "};" << std::endl;
    }
// mapEntryCount
    struct_body << "\t" << structInfo->mapEntryCount << "," << std::endl;
// pMapEntries
    struct_body << "\t\t\t" << pmap_entries_array << "," << std::endl;
// dataSize
    struct_body << "\t\t\t" << structInfo->dataSize << "," << std::endl;
// pData
    struct_body << "\t\t\t" << pdata_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "specializationInfo");
    out << "\t\t" << "VkSpecializationInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSpecializationMapEntry(std::ostream &out, const VkSpecializationMapEntry* structInfo, Decoded_VkSpecializationMapEntry* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// constantID
    struct_body << "\t" << structInfo->constantID << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "specializationMapEntry");
    out << "\t\t" << "VkSpecializationMapEntry " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkStencilOpState(std::ostream &out, const VkStencilOpState* structInfo, Decoded_VkStencilOpState* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// failOp
    struct_body << "\t" << "VkStencilOp(" << structInfo->failOp << ")" << "," << std::endl;
// passOp
    struct_body << "\t\t\t" << "VkStencilOp(" << structInfo->passOp << ")" << "," << std::endl;
// depthFailOp
    struct_body << "\t\t\t" << "VkStencilOp(" << structInfo->depthFailOp << ")" << "," << std::endl;
// compareOp
    struct_body << "\t\t\t" << "VkCompareOp(" << structInfo->compareOp << ")" << "," << std::endl;
// compareMask
    struct_body << "\t\t\t" << structInfo->compareMask << "," << std::endl;
// writeMask
    struct_body << "\t\t\t" << structInfo->writeMask << "," << std::endl;
// reference
    struct_body << "\t\t\t" << structInfo->reference << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stencilOpState");
    out << "\t\t" << "VkStencilOpState " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassDependency(std::ostream &out, const VkSubpassDependency* structInfo, Decoded_VkSubpassDependency* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// srcSubpass
    struct_body << "\t" << structInfo->srcSubpass << "," << std::endl;
// dstSubpass
    struct_body << "\t\t\t" << structInfo->dstSubpass << "," << std::endl;
// srcStageMask
    struct_body << "\t\t\t" << "VkPipelineStageFlags(" << structInfo->srcStageMask << ")" << "," << std::endl;
// dstStageMask
    struct_body << "\t\t\t" << "VkPipelineStageFlags(" << structInfo->dstStageMask << ")" << "," << std::endl;
// srcAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
// dstAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << "," << std::endl;
// dependencyFlags
    struct_body << "\t\t\t" << "VkDependencyFlags(" << structInfo->dependencyFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassDependency");
    out << "\t\t" << "VkSubpassDependency " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassDescription(std::ostream &out, const VkSubpassDescription* structInfo, Decoded_VkSubpassDescription* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pinput_attachments_array = "NULL";
    if (structInfo->pInputAttachments != NULL) {
        pinput_attachments_array = "pInputAttachments_" + std::to_string(consumer.GetNextId());
        std::string pinput_attachments_names;
        for (uint32_t idx = 0; idx < structInfo->inputAttachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pInputAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentReference(out,
                                                                     structInfo->pInputAttachments + idx,
                                                                     metaInfo->pInputAttachments->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            pinput_attachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentReference " << pinput_attachments_array << "[] = {" << pinput_attachments_names << "};" << std::endl;
    }
    std::string pcolor_attachments_array = "NULL";
    if (structInfo->pColorAttachments != NULL) {
        pcolor_attachments_array = "pColorAttachments_" + std::to_string(consumer.GetNextId());
        std::string pcolor_attachments_names;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pColorAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentReference(out,
                                                                     structInfo->pColorAttachments + idx,
                                                                     metaInfo->pColorAttachments->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            pcolor_attachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentReference " << pcolor_attachments_array << "[] = {" << pcolor_attachments_names << "};" << std::endl;
    }
    std::string presolve_attachments_array = "NULL";
    if (structInfo->pResolveAttachments != NULL) {
        presolve_attachments_array = "pResolveAttachments_" + std::to_string(consumer.GetNextId());
        std::string presolve_attachments_names;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pResolveAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentReference(out,
                                                                     structInfo->pResolveAttachments + idx,
                                                                     metaInfo->pResolveAttachments->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            presolve_attachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentReference " << presolve_attachments_array << "[] = {" << presolve_attachments_names << "};" << std::endl;
    }
    std::string pdepth_stencil_attachment_struct = "NULL";
    if (structInfo->pDepthStencilAttachment != NULL) {
        pdepth_stencil_attachment_struct = GenerateStruct_VkAttachmentReference(out,
                                                                                structInfo->pDepthStencilAttachment,
                                                                                metaInfo->pDepthStencilAttachment->GetMetaStructPointer(),
                                                                                consumer);
        pdepth_stencil_attachment_struct.insert(0, "&");
    }
    std::string ppreserve_attachments_array = "NULL";
    if (structInfo->pPreserveAttachments != NULL) {
        ppreserve_attachments_array = "pPreserveAttachments_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << ppreserve_attachments_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pPreserveAttachments, structInfo->preserveAttachmentCount) << ";" << std::endl;
    }
// flags
    struct_body << "\t" << "VkSubpassDescriptionFlags(" << structInfo->flags << ")" << "," << std::endl;
// pipelineBindPoint
    struct_body << "\t\t\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
// inputAttachmentCount
    struct_body << "\t\t\t" << structInfo->inputAttachmentCount << "," << std::endl;
// pInputAttachments
    struct_body << "\t\t\t" << pinput_attachments_array << "," << std::endl;
// colorAttachmentCount
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
// pColorAttachments
    struct_body << "\t\t\t" << pcolor_attachments_array << "," << std::endl;
// pResolveAttachments
    struct_body << "\t\t\t" << presolve_attachments_array << "," << std::endl;
// pDepthStencilAttachment
    struct_body << "\t\t\t" << pdepth_stencil_attachment_struct << "," << std::endl;
// preserveAttachmentCount
    struct_body << "\t\t\t" << structInfo->preserveAttachmentCount << "," << std::endl;
// pPreserveAttachments
    struct_body << "\t\t\t" << ppreserve_attachments_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassDescription");
    out << "\t\t" << "VkSubpassDescription " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubresourceLayout(std::ostream &out, const VkSubresourceLayout* structInfo, Decoded_VkSubresourceLayout* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// offset
    struct_body << "\t" << structInfo->offset << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
// rowPitch
    struct_body << "\t\t\t" << structInfo->rowPitch << "UL" << "," << std::endl;
// arrayPitch
    struct_body << "\t\t\t" << structInfo->arrayPitch << "UL" << "," << std::endl;
// depthPitch
    struct_body << "\t\t\t" << structInfo->depthPitch << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subresourceLayout");
    out << "\t\t" << "VkSubresourceLayout " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVertexInputAttributeDescription(std::ostream &out, const VkVertexInputAttributeDescription* structInfo, Decoded_VkVertexInputAttributeDescription* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// location
    struct_body << "\t" << structInfo->location << "," << std::endl;
// binding
    struct_body << "\t\t\t" << structInfo->binding << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "vertexInputAttributeDescription");
    out << "\t\t" << "VkVertexInputAttributeDescription " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVertexInputBindingDescription(std::ostream &out, const VkVertexInputBindingDescription* structInfo, Decoded_VkVertexInputBindingDescription* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// binding
    struct_body << "\t" << structInfo->binding << "," << std::endl;
// stride
    struct_body << "\t\t\t" << structInfo->stride << "," << std::endl;
// inputRate
    struct_body << "\t\t\t" << "VkVertexInputRate(" << structInfo->inputRate << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "vertexInputBindingDescription");
    out << "\t\t" << "VkVertexInputBindingDescription " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkViewport(std::ostream &out, const VkViewport* structInfo, Decoded_VkViewport* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// x
    struct_body << "\t" << structInfo->x << "," << std::endl;
// y
    struct_body << "\t\t\t" << structInfo->y << "," << std::endl;
// width
    struct_body << "\t\t\t" << structInfo->width << "," << std::endl;
// height
    struct_body << "\t\t\t" << structInfo->height << "," << std::endl;
// minDepth
    struct_body << "\t\t\t" << structInfo->minDepth << "," << std::endl;
// maxDepth
    struct_body << "\t\t\t" << structInfo->maxDepth << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "viewport");
    out << "\t\t" << "VkViewport " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindBufferMemoryDeviceGroupInfo(std::ostream &out, const VkBindBufferMemoryDeviceGroupInfo* structInfo, Decoded_VkBindBufferMemoryDeviceGroupInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdevice_indices_array = "NULL";
    if (structInfo->pDeviceIndices != NULL) {
        pdevice_indices_array = "pDeviceIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pdevice_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceIndices, structInfo->deviceIndexCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceIndexCount
    struct_body << "\t\t\t" << structInfo->deviceIndexCount << "," << std::endl;
// pDeviceIndices
    struct_body << "\t\t\t" << pdevice_indices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindBufferMemoryDeviceGroupInfo");
    out << "\t\t" << "VkBindBufferMemoryDeviceGroupInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindBufferMemoryInfo(std::ostream &out, const VkBindBufferMemoryInfo* structInfo, Decoded_VkBindBufferMemoryInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// buffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
// memoryOffset
    struct_body << "\t\t\t" << structInfo->memoryOffset << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindBufferMemoryInfo");
    out << "\t\t" << "VkBindBufferMemoryInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindImageMemoryDeviceGroupInfo(std::ostream &out, const VkBindImageMemoryDeviceGroupInfo* structInfo, Decoded_VkBindImageMemoryDeviceGroupInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdevice_indices_array = "NULL";
    if (structInfo->pDeviceIndices != NULL) {
        pdevice_indices_array = "pDeviceIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pdevice_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceIndices, structInfo->deviceIndexCount) << ";" << std::endl;
    }
    std::string psplit_instance_bind_regions_array = "NULL";
    if (structInfo->pSplitInstanceBindRegions != NULL) {
        psplit_instance_bind_regions_array = "pSplitInstanceBindRegions_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkRect2D " << psplit_instance_bind_regions_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pSplitInstanceBindRegions, structInfo->splitInstanceBindRegionCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceIndexCount
    struct_body << "\t\t\t" << structInfo->deviceIndexCount << "," << std::endl;
// pDeviceIndices
    struct_body << "\t\t\t" << pdevice_indices_array << "," << std::endl;
// splitInstanceBindRegionCount
    struct_body << "\t\t\t" << structInfo->splitInstanceBindRegionCount << "," << std::endl;
// pSplitInstanceBindRegions
    struct_body << "\t\t\t" << psplit_instance_bind_regions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindImageMemoryDeviceGroupInfo");
    out << "\t\t" << "VkBindImageMemoryDeviceGroupInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindImageMemoryInfo(std::ostream &out, const VkBindImageMemoryInfo* structInfo, Decoded_VkBindImageMemoryInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// image
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
// memoryOffset
    struct_body << "\t\t\t" << structInfo->memoryOffset << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindImageMemoryInfo");
    out << "\t\t" << "VkBindImageMemoryInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindImagePlaneMemoryInfo(std::ostream &out, const VkBindImagePlaneMemoryInfo* structInfo, Decoded_VkBindImagePlaneMemoryInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// planeAspect
    struct_body << "\t\t\t" << "VkImageAspectFlagBits(" << structInfo->planeAspect << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindImagePlaneMemoryInfo");
    out << "\t\t" << "VkBindImagePlaneMemoryInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferMemoryRequirementsInfo2(std::ostream &out, const VkBufferMemoryRequirementsInfo2* structInfo, Decoded_VkBufferMemoryRequirementsInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// buffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferMemoryRequirementsInfo2");
    out << "\t\t" << "VkBufferMemoryRequirementsInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetLayoutSupport(std::ostream &out, const VkDescriptorSetLayoutSupport* structInfo, Decoded_VkDescriptorSetLayoutSupport* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// supported
    struct_body << "\t\t\t" << structInfo->supported << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetLayoutSupport");
    out << "\t\t" << "VkDescriptorSetLayoutSupport " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorUpdateTemplateCreateInfo(std::ostream &out, const VkDescriptorUpdateTemplateCreateInfo* structInfo, Decoded_VkDescriptorUpdateTemplateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdescriptor_update_entries_array = "NULL";
    if (structInfo->pDescriptorUpdateEntries != NULL) {
        pdescriptor_update_entries_array = "pDescriptorUpdateEntries_" + std::to_string(consumer.GetNextId());
        std::string pdescriptor_update_entries_names;
        for (uint32_t idx = 0; idx < structInfo->descriptorUpdateEntryCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pDescriptorUpdateEntries + idx != NULL) {
                variable_name = GenerateStruct_VkDescriptorUpdateTemplateEntry(out,
                                                                               structInfo->pDescriptorUpdateEntries + idx,
                                                                               metaInfo->pDescriptorUpdateEntries->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pdescriptor_update_entries_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDescriptorUpdateTemplateEntry " << pdescriptor_update_entries_array << "[] = {" << pdescriptor_update_entries_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDescriptorUpdateTemplateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// descriptorUpdateEntryCount
    struct_body << "\t\t\t" << structInfo->descriptorUpdateEntryCount << "," << std::endl;
// pDescriptorUpdateEntries
    struct_body << "\t\t\t" << pdescriptor_update_entries_array << "," << std::endl;
// templateType
    struct_body << "\t\t\t" << "VkDescriptorUpdateTemplateType(" << structInfo->templateType << ")" << "," << std::endl;
// descriptorSetLayout
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->descriptorSetLayout) << "," << std::endl;
// pipelineBindPoint
    struct_body << "\t\t\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
// pipelineLayout
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipelineLayout) << "," << std::endl;
// set
    struct_body << "\t\t\t" << structInfo->set << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorUpdateTemplateCreateInfo");
    out << "\t\t" << "VkDescriptorUpdateTemplateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupBindSparseInfo(std::ostream &out, const VkDeviceGroupBindSparseInfo* structInfo, Decoded_VkDeviceGroupBindSparseInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// resourceDeviceIndex
    struct_body << "\t\t\t" << structInfo->resourceDeviceIndex << "," << std::endl;
// memoryDeviceIndex
    struct_body << "\t\t\t" << structInfo->memoryDeviceIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupBindSparseInfo");
    out << "\t\t" << "VkDeviceGroupBindSparseInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupCommandBufferBeginInfo(std::ostream &out, const VkDeviceGroupCommandBufferBeginInfo* structInfo, Decoded_VkDeviceGroupCommandBufferBeginInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceMask
    struct_body << "\t\t\t" << structInfo->deviceMask << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupCommandBufferBeginInfo");
    out << "\t\t" << "VkDeviceGroupCommandBufferBeginInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupDeviceCreateInfo(std::ostream &out, const VkDeviceGroupDeviceCreateInfo* structInfo, Decoded_VkDeviceGroupDeviceCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pphysical_devices_array = "NULL";
    if (metaInfo->pPhysicalDevices.GetPointer() != NULL && structInfo->physicalDeviceCount > 0) {
        pphysical_devices_array = "pphysical_devices_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_PHYSICAL_DEVICE));
        std::string pphysical_devices_values = toStringJoin(metaInfo->pPhysicalDevices.GetPointer(),
                                                            metaInfo->pPhysicalDevices.GetPointer() + structInfo->physicalDeviceCount,
                                                            [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                            ", ");
        if (structInfo->physicalDeviceCount == 1) {
            pphysical_devices_array = "&" + pphysical_devices_values;
        } else if (structInfo->physicalDeviceCount > 1) {
            out << "\t\t" << "VkPhysicalDevice " << pphysical_devices_array << "[] = {" << pphysical_devices_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// physicalDeviceCount
    struct_body << "\t\t\t" << structInfo->physicalDeviceCount << "," << std::endl;
// pPhysicalDevices
    struct_body << "\t\t\t" << pphysical_devices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupDeviceCreateInfo");
    out << "\t\t" << "VkDeviceGroupDeviceCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupRenderPassBeginInfo(std::ostream &out, const VkDeviceGroupRenderPassBeginInfo* structInfo, Decoded_VkDeviceGroupRenderPassBeginInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdevice_render_areas_array = "NULL";
    if (structInfo->pDeviceRenderAreas != NULL) {
        pdevice_render_areas_array = "pDeviceRenderAreas_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkRect2D " << pdevice_render_areas_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceRenderAreas, structInfo->deviceRenderAreaCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceMask
    struct_body << "\t\t\t" << structInfo->deviceMask << "," << std::endl;
// deviceRenderAreaCount
    struct_body << "\t\t\t" << structInfo->deviceRenderAreaCount << "," << std::endl;
// pDeviceRenderAreas
    struct_body << "\t\t\t" << pdevice_render_areas_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupRenderPassBeginInfo");
    out << "\t\t" << "VkDeviceGroupRenderPassBeginInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupSubmitInfo(std::ostream &out, const VkDeviceGroupSubmitInfo* structInfo, Decoded_VkDeviceGroupSubmitInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pwait_semaphore_device_indices_array = "NULL";
    if (structInfo->pWaitSemaphoreDeviceIndices != NULL) {
        pwait_semaphore_device_indices_array = "pWaitSemaphoreDeviceIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pwait_semaphore_device_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pWaitSemaphoreDeviceIndices, structInfo->waitSemaphoreCount) << ";" << std::endl;
    }
    std::string pcommand_buffer_device_masks_array = "NULL";
    if (structInfo->pCommandBufferDeviceMasks != NULL) {
        pcommand_buffer_device_masks_array = "pCommandBufferDeviceMasks_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pcommand_buffer_device_masks_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCommandBufferDeviceMasks, structInfo->commandBufferCount) << ";" << std::endl;
    }
    std::string psignal_semaphore_device_indices_array = "NULL";
    if (structInfo->pSignalSemaphoreDeviceIndices != NULL) {
        psignal_semaphore_device_indices_array = "pSignalSemaphoreDeviceIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << psignal_semaphore_device_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pSignalSemaphoreDeviceIndices, structInfo->signalSemaphoreCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// waitSemaphoreCount
    struct_body << "\t\t\t" << structInfo->waitSemaphoreCount << "," << std::endl;
// pWaitSemaphoreDeviceIndices
    struct_body << "\t\t\t" << pwait_semaphore_device_indices_array << "," << std::endl;
// commandBufferCount
    struct_body << "\t\t\t" << structInfo->commandBufferCount << "," << std::endl;
// pCommandBufferDeviceMasks
    struct_body << "\t\t\t" << pcommand_buffer_device_masks_array << "," << std::endl;
// signalSemaphoreCount
    struct_body << "\t\t\t" << structInfo->signalSemaphoreCount << "," << std::endl;
// pSignalSemaphoreDeviceIndices
    struct_body << "\t\t\t" << psignal_semaphore_device_indices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupSubmitInfo");
    out << "\t\t" << "VkDeviceGroupSubmitInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceQueueInfo2(std::ostream &out, const VkDeviceQueueInfo2* structInfo, Decoded_VkDeviceQueueInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDeviceQueueCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// queueFamilyIndex
    struct_body << "\t\t\t" << structInfo->queueFamilyIndex << "," << std::endl;
// queueIndex
    struct_body << "\t\t\t" << structInfo->queueIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceQueueInfo2");
    out << "\t\t" << "VkDeviceQueueInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportFenceCreateInfo(std::ostream &out, const VkExportFenceCreateInfo* structInfo, Decoded_VkExportFenceCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// handleTypes
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlags(" << structInfo->handleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportFenceCreateInfo");
    out << "\t\t" << "VkExportFenceCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportMemoryAllocateInfo(std::ostream &out, const VkExportMemoryAllocateInfo* structInfo, Decoded_VkExportMemoryAllocateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// handleTypes
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->handleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportMemoryAllocateInfo");
    out << "\t\t" << "VkExportMemoryAllocateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportSemaphoreCreateInfo(std::ostream &out, const VkExportSemaphoreCreateInfo* structInfo, Decoded_VkExportSemaphoreCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// handleTypes
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlags(" << structInfo->handleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportSemaphoreCreateInfo");
    out << "\t\t" << "VkExportSemaphoreCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalBufferProperties(std::ostream &out, const VkExternalBufferProperties* structInfo, Decoded_VkExternalBufferProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string external_memory_properties_info_var = GenerateStruct_VkExternalMemoryProperties(out,
                                                                                                &structInfo->externalMemoryProperties,
                                                                                                metaInfo->externalMemoryProperties,
                                                                                                consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// externalMemoryProperties
    struct_body << "\t\t\t" << external_memory_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalBufferProperties");
    out << "\t\t" << "VkExternalBufferProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalFenceProperties(std::ostream &out, const VkExternalFenceProperties* structInfo, Decoded_VkExternalFenceProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// exportFromImportedHandleTypes
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlags(" << structInfo->exportFromImportedHandleTypes << ")" << "," << std::endl;
// compatibleHandleTypes
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlags(" << structInfo->compatibleHandleTypes << ")" << "," << std::endl;
// externalFenceFeatures
    struct_body << "\t\t\t" << "VkExternalFenceFeatureFlags(" << structInfo->externalFenceFeatures << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalFenceProperties");
    out << "\t\t" << "VkExternalFenceProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalImageFormatProperties(std::ostream &out, const VkExternalImageFormatProperties* structInfo, Decoded_VkExternalImageFormatProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string external_memory_properties_info_var = GenerateStruct_VkExternalMemoryProperties(out,
                                                                                                &structInfo->externalMemoryProperties,
                                                                                                metaInfo->externalMemoryProperties,
                                                                                                consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// externalMemoryProperties
    struct_body << "\t\t\t" << external_memory_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalImageFormatProperties");
    out << "\t\t" << "VkExternalImageFormatProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalMemoryBufferCreateInfo(std::ostream &out, const VkExternalMemoryBufferCreateInfo* structInfo, Decoded_VkExternalMemoryBufferCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// handleTypes
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->handleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalMemoryBufferCreateInfo");
    out << "\t\t" << "VkExternalMemoryBufferCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalMemoryImageCreateInfo(std::ostream &out, const VkExternalMemoryImageCreateInfo* structInfo, Decoded_VkExternalMemoryImageCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// handleTypes
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->handleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalMemoryImageCreateInfo");
    out << "\t\t" << "VkExternalMemoryImageCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalMemoryProperties(std::ostream &out, const VkExternalMemoryProperties* structInfo, Decoded_VkExternalMemoryProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// externalMemoryFeatures
    struct_body << "\t" << "VkExternalMemoryFeatureFlags(" << structInfo->externalMemoryFeatures << ")" << "," << std::endl;
// exportFromImportedHandleTypes
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->exportFromImportedHandleTypes << ")" << "," << std::endl;
// compatibleHandleTypes
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->compatibleHandleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalMemoryProperties");
    out << "\t\t" << "VkExternalMemoryProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalSemaphoreProperties(std::ostream &out, const VkExternalSemaphoreProperties* structInfo, Decoded_VkExternalSemaphoreProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// exportFromImportedHandleTypes
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlags(" << structInfo->exportFromImportedHandleTypes << ")" << "," << std::endl;
// compatibleHandleTypes
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlags(" << structInfo->compatibleHandleTypes << ")" << "," << std::endl;
// externalSemaphoreFeatures
    struct_body << "\t\t\t" << "VkExternalSemaphoreFeatureFlags(" << structInfo->externalSemaphoreFeatures << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalSemaphoreProperties");
    out << "\t\t" << "VkExternalSemaphoreProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFormatProperties2(std::ostream &out, const VkFormatProperties2* structInfo, Decoded_VkFormatProperties2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string format_properties_info_var = GenerateStruct_VkFormatProperties(out,
                                                                               &structInfo->formatProperties,
                                                                               metaInfo->formatProperties,
                                                                               consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// formatProperties
    struct_body << "\t\t\t" << format_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "formatProperties2");
    out << "\t\t" << "VkFormatProperties2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageFormatProperties2(std::ostream &out, const VkImageFormatProperties2* structInfo, Decoded_VkImageFormatProperties2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string image_format_properties_info_var = GenerateStruct_VkImageFormatProperties(out,
                                                                                          &structInfo->imageFormatProperties,
                                                                                          metaInfo->imageFormatProperties,
                                                                                          consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// imageFormatProperties
    struct_body << "\t\t\t" << image_format_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageFormatProperties2");
    out << "\t\t" << "VkImageFormatProperties2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageMemoryRequirementsInfo2(std::ostream &out, const VkImageMemoryRequirementsInfo2* structInfo, Decoded_VkImageMemoryRequirementsInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// image
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageMemoryRequirementsInfo2");
    out << "\t\t" << "VkImageMemoryRequirementsInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImagePlaneMemoryRequirementsInfo(std::ostream &out, const VkImagePlaneMemoryRequirementsInfo* structInfo, Decoded_VkImagePlaneMemoryRequirementsInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// planeAspect
    struct_body << "\t\t\t" << "VkImageAspectFlagBits(" << structInfo->planeAspect << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imagePlaneMemoryRequirementsInfo");
    out << "\t\t" << "VkImagePlaneMemoryRequirementsInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageSparseMemoryRequirementsInfo2(std::ostream &out, const VkImageSparseMemoryRequirementsInfo2* structInfo, Decoded_VkImageSparseMemoryRequirementsInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// image
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageSparseMemoryRequirementsInfo2");
    out << "\t\t" << "VkImageSparseMemoryRequirementsInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewUsageCreateInfo(std::ostream &out, const VkImageViewUsageCreateInfo* structInfo, Decoded_VkImageViewUsageCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// usage
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewUsageCreateInfo");
    out << "\t\t" << "VkImageViewUsageCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkInputAttachmentAspectReference(std::ostream &out, const VkInputAttachmentAspectReference* structInfo, Decoded_VkInputAttachmentAspectReference* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// subpass
    struct_body << "\t" << structInfo->subpass << "," << std::endl;
// inputAttachmentIndex
    struct_body << "\t\t\t" << structInfo->inputAttachmentIndex << "," << std::endl;
// aspectMask
    struct_body << "\t\t\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "inputAttachmentAspectReference");
    out << "\t\t" << "VkInputAttachmentAspectReference " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryDedicatedAllocateInfo(std::ostream &out, const VkMemoryDedicatedAllocateInfo* structInfo, Decoded_VkMemoryDedicatedAllocateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// image
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
// buffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryDedicatedAllocateInfo");
    out << "\t\t" << "VkMemoryDedicatedAllocateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryDedicatedRequirements(std::ostream &out, const VkMemoryDedicatedRequirements* structInfo, Decoded_VkMemoryDedicatedRequirements* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// prefersDedicatedAllocation
    struct_body << "\t\t\t" << structInfo->prefersDedicatedAllocation << "," << std::endl;
// requiresDedicatedAllocation
    struct_body << "\t\t\t" << structInfo->requiresDedicatedAllocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryDedicatedRequirements");
    out << "\t\t" << "VkMemoryDedicatedRequirements " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryRequirements2(std::ostream &out, const VkMemoryRequirements2* structInfo, Decoded_VkMemoryRequirements2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string memory_requirements_info_var = GenerateStruct_VkMemoryRequirements(out,
                                                                                   &structInfo->memoryRequirements,
                                                                                   metaInfo->memoryRequirements,
                                                                                   consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memoryRequirements
    struct_body << "\t\t\t" << memory_requirements_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryRequirements2");
    out << "\t\t" << variable_name << " = {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevice16BitStorageFeatures(std::ostream &out, const VkPhysicalDevice16BitStorageFeatures* structInfo, Decoded_VkPhysicalDevice16BitStorageFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// storageBuffer16BitAccess
    struct_body << "\t\t\t" << structInfo->storageBuffer16BitAccess << "," << std::endl;
// uniformAndStorageBuffer16BitAccess
    struct_body << "\t\t\t" << structInfo->uniformAndStorageBuffer16BitAccess << "," << std::endl;
// storagePushConstant16
    struct_body << "\t\t\t" << structInfo->storagePushConstant16 << "," << std::endl;
// storageInputOutput16
    struct_body << "\t\t\t" << structInfo->storageInputOutput16 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevice16BitStorageFeatures");
    out << "\t\t" << "VkPhysicalDevice16BitStorageFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalBufferInfo(std::ostream &out, const VkPhysicalDeviceExternalBufferInfo* structInfo, Decoded_VkPhysicalDeviceExternalBufferInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkBufferCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// usage
    struct_body << "\t\t\t" << "VkBufferUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalBufferInfo");
    out << "\t\t" << "VkPhysicalDeviceExternalBufferInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalFenceInfo(std::ostream &out, const VkPhysicalDeviceExternalFenceInfo* structInfo, Decoded_VkPhysicalDeviceExternalFenceInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalFenceInfo");
    out << "\t\t" << "VkPhysicalDeviceExternalFenceInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalImageFormatInfo(std::ostream &out, const VkPhysicalDeviceExternalImageFormatInfo* structInfo, Decoded_VkPhysicalDeviceExternalImageFormatInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalImageFormatInfo");
    out << "\t\t" << "VkPhysicalDeviceExternalImageFormatInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalSemaphoreInfo(std::ostream &out, const VkPhysicalDeviceExternalSemaphoreInfo* structInfo, Decoded_VkPhysicalDeviceExternalSemaphoreInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalSemaphoreInfo");
    out << "\t\t" << "VkPhysicalDeviceExternalSemaphoreInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFeatures2(std::ostream &out, const VkPhysicalDeviceFeatures2* structInfo, Decoded_VkPhysicalDeviceFeatures2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string features_info_var = GenerateStruct_VkPhysicalDeviceFeatures(out,
                                                                            &structInfo->features,
                                                                            metaInfo->features,
                                                                            consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// features
    struct_body << "\t\t\t" << features_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFeatures2");
    out << "\t\t" << "VkPhysicalDeviceFeatures2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceGroupProperties(std::ostream &out, const VkPhysicalDeviceGroupProperties* structInfo, Decoded_VkPhysicalDeviceGroupProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// physicalDeviceCount
    struct_body << "\t\t\t" << structInfo->physicalDeviceCount << "," << std::endl;
// physicalDevices
    out << "\t\t" << "// TODO: Support physicalDevices (output with array length value?) argument." << std::endl;
// subsetAllocation
    struct_body << "\t\t\t" << structInfo->subsetAllocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceGroupProperties");
    out << "\t\t" << "VkPhysicalDeviceGroupProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceIDProperties(std::ostream &out, const VkPhysicalDeviceIDProperties* structInfo, Decoded_VkPhysicalDeviceIDProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceUUID
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->deviceUUID[0]), VK_UUID_SIZE) << "," << std::endl;
// driverUUID
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->driverUUID[0]), VK_UUID_SIZE) << "," << std::endl;
// deviceLUID
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->deviceLUID[0]), VK_LUID_SIZE) << "," << std::endl;
// deviceNodeMask
    struct_body << "\t\t\t" << structInfo->deviceNodeMask << "," << std::endl;
// deviceLUIDValid
    struct_body << "\t\t\t" << structInfo->deviceLUIDValid << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceIDProperties");
    out << "\t\t" << "VkPhysicalDeviceIDProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageFormatInfo2(std::ostream &out, const VkPhysicalDeviceImageFormatInfo2* structInfo, Decoded_VkPhysicalDeviceImageFormatInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
// type
    struct_body << "\t\t\t" << "VkImageType(" << structInfo->type << ")" << "," << std::endl;
// tiling
    struct_body << "\t\t\t" << "VkImageTiling(" << structInfo->tiling << ")" << "," << std::endl;
// usage
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkImageCreateFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageFormatInfo2");
    out << "\t\t" << "VkPhysicalDeviceImageFormatInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance3Properties(std::ostream &out, const VkPhysicalDeviceMaintenance3Properties* structInfo, Decoded_VkPhysicalDeviceMaintenance3Properties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxPerSetDescriptors
    struct_body << "\t\t\t" << structInfo->maxPerSetDescriptors << "," << std::endl;
// maxMemoryAllocationSize
    struct_body << "\t\t\t" << structInfo->maxMemoryAllocationSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance3Properties");
    out << "\t\t" << "VkPhysicalDeviceMaintenance3Properties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMemoryProperties2(std::ostream &out, const VkPhysicalDeviceMemoryProperties2* structInfo, Decoded_VkPhysicalDeviceMemoryProperties2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string memory_properties_info_var = GenerateStruct_VkPhysicalDeviceMemoryProperties(out,
                                                                                             &structInfo->memoryProperties,
                                                                                             metaInfo->memoryProperties,
                                                                                             consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memoryProperties
    struct_body << "\t\t\t" << memory_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMemoryProperties2");
    out << "\t\t" << "VkPhysicalDeviceMemoryProperties2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewFeatures(std::ostream &out, const VkPhysicalDeviceMultiviewFeatures* structInfo, Decoded_VkPhysicalDeviceMultiviewFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// multiview
    struct_body << "\t\t\t" << structInfo->multiview << "," << std::endl;
// multiviewGeometryShader
    struct_body << "\t\t\t" << structInfo->multiviewGeometryShader << "," << std::endl;
// multiviewTessellationShader
    struct_body << "\t\t\t" << structInfo->multiviewTessellationShader << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultiviewFeatures");
    out << "\t\t" << "VkPhysicalDeviceMultiviewFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewProperties(std::ostream &out, const VkPhysicalDeviceMultiviewProperties* structInfo, Decoded_VkPhysicalDeviceMultiviewProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxMultiviewViewCount
    struct_body << "\t\t\t" << structInfo->maxMultiviewViewCount << "," << std::endl;
// maxMultiviewInstanceIndex
    struct_body << "\t\t\t" << structInfo->maxMultiviewInstanceIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultiviewProperties");
    out << "\t\t" << "VkPhysicalDeviceMultiviewProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePointClippingProperties(std::ostream &out, const VkPhysicalDevicePointClippingProperties* structInfo, Decoded_VkPhysicalDevicePointClippingProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pointClippingBehavior
    struct_body << "\t\t\t" << "VkPointClippingBehavior(" << structInfo->pointClippingBehavior << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePointClippingProperties");
    out << "\t\t" << "VkPhysicalDevicePointClippingProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceProperties2(std::ostream &out, const VkPhysicalDeviceProperties2* structInfo, Decoded_VkPhysicalDeviceProperties2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string properties_info_var = GenerateStruct_VkPhysicalDeviceProperties(out,
                                                                                &structInfo->properties,
                                                                                metaInfo->properties,
                                                                                consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// properties
    struct_body << "\t\t\t" << properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceProperties2");
    out << "\t\t" << "VkPhysicalDeviceProperties2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceProtectedMemoryFeatures(std::ostream &out, const VkPhysicalDeviceProtectedMemoryFeatures* structInfo, Decoded_VkPhysicalDeviceProtectedMemoryFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// protectedMemory
    struct_body << "\t\t\t" << structInfo->protectedMemory << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceProtectedMemoryFeatures");
    out << "\t\t" << "VkPhysicalDeviceProtectedMemoryFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceProtectedMemoryProperties(std::ostream &out, const VkPhysicalDeviceProtectedMemoryProperties* structInfo, Decoded_VkPhysicalDeviceProtectedMemoryProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// protectedNoFault
    struct_body << "\t\t\t" << structInfo->protectedNoFault << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceProtectedMemoryProperties");
    out << "\t\t" << "VkPhysicalDeviceProtectedMemoryProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSamplerYcbcrConversionFeatures(std::ostream &out, const VkPhysicalDeviceSamplerYcbcrConversionFeatures* structInfo, Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// samplerYcbcrConversion
    struct_body << "\t\t\t" << structInfo->samplerYcbcrConversion << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSamplerYcbcrConversionFeatures");
    out << "\t\t" << "VkPhysicalDeviceSamplerYcbcrConversionFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderDrawParametersFeatures(std::ostream &out, const VkPhysicalDeviceShaderDrawParametersFeatures* structInfo, Decoded_VkPhysicalDeviceShaderDrawParametersFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderDrawParameters
    struct_body << "\t\t\t" << structInfo->shaderDrawParameters << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderDrawParametersFeatures");
    out << "\t\t" << "VkPhysicalDeviceShaderDrawParametersFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSparseImageFormatInfo2(std::ostream &out, const VkPhysicalDeviceSparseImageFormatInfo2* structInfo, Decoded_VkPhysicalDeviceSparseImageFormatInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
// type
    struct_body << "\t\t\t" << "VkImageType(" << structInfo->type << ")" << "," << std::endl;
// samples
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->samples << ")" << "," << std::endl;
// usage
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
// tiling
    struct_body << "\t\t\t" << "VkImageTiling(" << structInfo->tiling << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSparseImageFormatInfo2");
    out << "\t\t" << "VkPhysicalDeviceSparseImageFormatInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSubgroupProperties(std::ostream &out, const VkPhysicalDeviceSubgroupProperties* structInfo, Decoded_VkPhysicalDeviceSubgroupProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// subgroupSize
    struct_body << "\t\t\t" << structInfo->subgroupSize << "," << std::endl;
// supportedStages
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->supportedStages << ")" << "," << std::endl;
// supportedOperations
    struct_body << "\t\t\t" << "VkSubgroupFeatureFlags(" << structInfo->supportedOperations << ")" << "," << std::endl;
// quadOperationsInAllStages
    struct_body << "\t\t\t" << structInfo->quadOperationsInAllStages << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSubgroupProperties");
    out << "\t\t" << "VkPhysicalDeviceSubgroupProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVariablePointersFeatures(std::ostream &out, const VkPhysicalDeviceVariablePointersFeatures* structInfo, Decoded_VkPhysicalDeviceVariablePointersFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// variablePointersStorageBuffer
    struct_body << "\t\t\t" << structInfo->variablePointersStorageBuffer << "," << std::endl;
// variablePointers
    struct_body << "\t\t\t" << structInfo->variablePointers << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVariablePointersFeatures");
    out << "\t\t" << "VkPhysicalDeviceVariablePointersFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineTessellationDomainOriginStateCreateInfo(std::ostream &out, const VkPipelineTessellationDomainOriginStateCreateInfo* structInfo, Decoded_VkPipelineTessellationDomainOriginStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// domainOrigin
    struct_body << "\t\t\t" << "VkTessellationDomainOrigin(" << structInfo->domainOrigin << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineTessellationDomainOriginStateCreateInfo");
    out << "\t\t" << "VkPipelineTessellationDomainOriginStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkProtectedSubmitInfo(std::ostream &out, const VkProtectedSubmitInfo* structInfo, Decoded_VkProtectedSubmitInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// protectedSubmit
    struct_body << "\t\t\t" << structInfo->protectedSubmit << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "protectedSubmitInfo");
    out << "\t\t" << "VkProtectedSubmitInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyProperties2(std::ostream &out, const VkQueueFamilyProperties2* structInfo, Decoded_VkQueueFamilyProperties2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string queue_family_properties_info_var = GenerateStruct_VkQueueFamilyProperties(out,
                                                                                          &structInfo->queueFamilyProperties,
                                                                                          metaInfo->queueFamilyProperties,
                                                                                          consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// queueFamilyProperties
    struct_body << "\t\t\t" << queue_family_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyProperties2");
    out << "\t\t" << "VkQueueFamilyProperties2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassInputAttachmentAspectCreateInfo(std::ostream &out, const VkRenderPassInputAttachmentAspectCreateInfo* structInfo, Decoded_VkRenderPassInputAttachmentAspectCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string paspect_references_array = "NULL";
    if (structInfo->pAspectReferences != NULL) {
        paspect_references_array = "pAspectReferences_" + std::to_string(consumer.GetNextId());
        std::string paspect_references_names;
        for (uint32_t idx = 0; idx < structInfo->aspectReferenceCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pAspectReferences + idx != NULL) {
                variable_name = GenerateStruct_VkInputAttachmentAspectReference(out,
                                                                                structInfo->pAspectReferences + idx,
                                                                                metaInfo->pAspectReferences->GetMetaStructPointer() + idx,
                                                                                consumer);
            }
            paspect_references_names += variable_name + ", ";
        }
        out << "\t\t" << "VkInputAttachmentAspectReference " << paspect_references_array << "[] = {" << paspect_references_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// aspectReferenceCount
    struct_body << "\t\t\t" << structInfo->aspectReferenceCount << "," << std::endl;
// pAspectReferences
    struct_body << "\t\t\t" << paspect_references_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassInputAttachmentAspectCreateInfo");
    out << "\t\t" << "VkRenderPassInputAttachmentAspectCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassMultiviewCreateInfo(std::ostream &out, const VkRenderPassMultiviewCreateInfo* structInfo, Decoded_VkRenderPassMultiviewCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pview_masks_array = "NULL";
    if (structInfo->pViewMasks != NULL) {
        pview_masks_array = "pViewMasks_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pview_masks_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pViewMasks, structInfo->subpassCount) << ";" << std::endl;
    }
    std::string pview_offsets_array = "NULL";
    if (structInfo->pViewOffsets != NULL) {
        pview_offsets_array = "pViewOffsets_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "int32_t " << pview_offsets_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pViewOffsets, structInfo->dependencyCount) << ";" << std::endl;
    }
    std::string pcorrelation_masks_array = "NULL";
    if (structInfo->pCorrelationMasks != NULL) {
        pcorrelation_masks_array = "pCorrelationMasks_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pcorrelation_masks_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCorrelationMasks, structInfo->correlationMaskCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// subpassCount
    struct_body << "\t\t\t" << structInfo->subpassCount << "," << std::endl;
// pViewMasks
    struct_body << "\t\t\t" << pview_masks_array << "," << std::endl;
// dependencyCount
    struct_body << "\t\t\t" << structInfo->dependencyCount << "," << std::endl;
// pViewOffsets
    struct_body << "\t\t\t" << pview_offsets_array << "," << std::endl;
// correlationMaskCount
    struct_body << "\t\t\t" << structInfo->correlationMaskCount << "," << std::endl;
// pCorrelationMasks
    struct_body << "\t\t\t" << pcorrelation_masks_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassMultiviewCreateInfo");
    out << "\t\t" << "VkRenderPassMultiviewCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerYcbcrConversionCreateInfo(std::ostream &out, const VkSamplerYcbcrConversionCreateInfo* structInfo, Decoded_VkSamplerYcbcrConversionCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string components_info_var = GenerateStruct_VkComponentMapping(out,
                                                                        &structInfo->components,
                                                                        metaInfo->components,
                                                                        consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
// ycbcrModel
    struct_body << "\t\t\t" << "VkSamplerYcbcrModelConversion(" << structInfo->ycbcrModel << ")" << "," << std::endl;
// ycbcrRange
    struct_body << "\t\t\t" << "VkSamplerYcbcrRange(" << structInfo->ycbcrRange << ")" << "," << std::endl;
// components
    struct_body << "\t\t\t" << components_info_var << "," << std::endl;
// xChromaOffset
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->xChromaOffset << ")" << "," << std::endl;
// yChromaOffset
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->yChromaOffset << ")" << "," << std::endl;
// chromaFilter
    struct_body << "\t\t\t" << "VkFilter(" << structInfo->chromaFilter << ")" << "," << std::endl;
// forceExplicitReconstruction
    struct_body << "\t\t\t" << structInfo->forceExplicitReconstruction << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerYcbcrConversionCreateInfo");
    out << "\t\t" << "VkSamplerYcbcrConversionCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerYcbcrConversionImageFormatProperties(std::ostream &out, const VkSamplerYcbcrConversionImageFormatProperties* structInfo, Decoded_VkSamplerYcbcrConversionImageFormatProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// combinedImageSamplerDescriptorCount
    struct_body << "\t\t\t" << structInfo->combinedImageSamplerDescriptorCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerYcbcrConversionImageFormatProperties");
    out << "\t\t" << "VkSamplerYcbcrConversionImageFormatProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerYcbcrConversionInfo(std::ostream &out, const VkSamplerYcbcrConversionInfo* structInfo, Decoded_VkSamplerYcbcrConversionInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// conversion
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->conversion) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerYcbcrConversionInfo");
    out << "\t\t" << "VkSamplerYcbcrConversionInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseImageFormatProperties2(std::ostream &out, const VkSparseImageFormatProperties2* structInfo, Decoded_VkSparseImageFormatProperties2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string properties_info_var = GenerateStruct_VkSparseImageFormatProperties(out,
                                                                                   &structInfo->properties,
                                                                                   metaInfo->properties,
                                                                                   consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// properties
    struct_body << "\t\t\t" << properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseImageFormatProperties2");
    out << "\t\t" << "VkSparseImageFormatProperties2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseImageMemoryRequirements2(std::ostream &out, const VkSparseImageMemoryRequirements2* structInfo, Decoded_VkSparseImageMemoryRequirements2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string memory_requirements_info_var = GenerateStruct_VkSparseImageMemoryRequirements(out,
                                                                                              &structInfo->memoryRequirements,
                                                                                              metaInfo->memoryRequirements,
                                                                                              consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memoryRequirements
    struct_body << "\t\t\t" << memory_requirements_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseImageMemoryRequirements2");
    out << "\t\t" << "VkSparseImageMemoryRequirements2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentDescription2(std::ostream &out, const VkAttachmentDescription2* structInfo, Decoded_VkAttachmentDescription2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkAttachmentDescriptionFlags(" << structInfo->flags << ")" << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
// samples
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->samples << ")" << "," << std::endl;
// loadOp
    struct_body << "\t\t\t" << "VkAttachmentLoadOp(" << structInfo->loadOp << ")" << "," << std::endl;
// storeOp
    struct_body << "\t\t\t" << "VkAttachmentStoreOp(" << structInfo->storeOp << ")" << "," << std::endl;
// stencilLoadOp
    struct_body << "\t\t\t" << "VkAttachmentLoadOp(" << structInfo->stencilLoadOp << ")" << "," << std::endl;
// stencilStoreOp
    struct_body << "\t\t\t" << "VkAttachmentStoreOp(" << structInfo->stencilStoreOp << ")" << "," << std::endl;
// initialLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->initialLayout << ")" << "," << std::endl;
// finalLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->finalLayout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentDescription2");
    out << "\t\t" << "VkAttachmentDescription2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentDescriptionStencilLayout(std::ostream &out, const VkAttachmentDescriptionStencilLayout* structInfo, Decoded_VkAttachmentDescriptionStencilLayout* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stencilInitialLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->stencilInitialLayout << ")" << "," << std::endl;
// stencilFinalLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->stencilFinalLayout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentDescriptionStencilLayout");
    out << "\t\t" << "VkAttachmentDescriptionStencilLayout " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentReference2(std::ostream &out, const VkAttachmentReference2* structInfo, Decoded_VkAttachmentReference2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// attachment
    struct_body << "\t\t\t" << structInfo->attachment << "," << std::endl;
// layout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->layout << ")" << "," << std::endl;
// aspectMask
    struct_body << "\t\t\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentReference2");
    out << "\t\t" << "VkAttachmentReference2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentReferenceStencilLayout(std::ostream &out, const VkAttachmentReferenceStencilLayout* structInfo, Decoded_VkAttachmentReferenceStencilLayout* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stencilLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->stencilLayout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentReferenceStencilLayout");
    out << "\t\t" << "VkAttachmentReferenceStencilLayout " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferDeviceAddressInfo(std::ostream &out, const VkBufferDeviceAddressInfo* structInfo, Decoded_VkBufferDeviceAddressInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// buffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferDeviceAddressInfo");
    out << "\t\t" << "VkBufferDeviceAddressInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferOpaqueCaptureAddressCreateInfo(std::ostream &out, const VkBufferOpaqueCaptureAddressCreateInfo* structInfo, Decoded_VkBufferOpaqueCaptureAddressCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// opaqueCaptureAddress
    struct_body << "\t\t\t" << structInfo->opaqueCaptureAddress << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferOpaqueCaptureAddressCreateInfo");
    out << "\t\t" << "VkBufferOpaqueCaptureAddressCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkConformanceVersion(std::ostream &out, const VkConformanceVersion* structInfo, Decoded_VkConformanceVersion* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// major
    struct_body << "\t" << std::to_string(structInfo->major) << "," << std::endl;
// minor
    struct_body << "\t\t\t" << std::to_string(structInfo->minor) << "," << std::endl;
// subminor
    struct_body << "\t\t\t" << std::to_string(structInfo->subminor) << "," << std::endl;
// patch
    struct_body << "\t\t\t" << std::to_string(structInfo->patch) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "conformanceVersion");
    out << "\t\t" << "VkConformanceVersion " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetLayoutBindingFlagsCreateInfo(std::ostream &out, const VkDescriptorSetLayoutBindingFlagsCreateInfo* structInfo, Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pbinding_flags_values;
    std::string pbinding_flags_array = "NULL";
    if (structInfo->pBindingFlags != NULL) {
        for (uint32_t idx = 0; idx < structInfo->bindingCount; idx++) {
            pbinding_flags_values += util::ToString<VkDescriptorBindingFlags>(structInfo->pBindingFlags[idx]) + ", ";
        }
        pbinding_flags_array = "pBindingFlags_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkDescriptorBindingFlags " << pbinding_flags_array << "[] = {" << pbinding_flags_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// bindingCount
    struct_body << "\t\t\t" << structInfo->bindingCount << "," << std::endl;
// pBindingFlags
    struct_body << "\t\t\t" << pbinding_flags_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetLayoutBindingFlagsCreateInfo");
    out << "\t\t" << "VkDescriptorSetLayoutBindingFlagsCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetVariableDescriptorCountAllocateInfo(std::ostream &out, const VkDescriptorSetVariableDescriptorCountAllocateInfo* structInfo, Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdescriptor_counts_array = "NULL";
    if (structInfo->pDescriptorCounts != NULL) {
        pdescriptor_counts_array = "pDescriptorCounts_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pdescriptor_counts_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDescriptorCounts, structInfo->descriptorSetCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// descriptorSetCount
    struct_body << "\t\t\t" << structInfo->descriptorSetCount << "," << std::endl;
// pDescriptorCounts
    struct_body << "\t\t\t" << pdescriptor_counts_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetVariableDescriptorCountAllocateInfo");
    out << "\t\t" << "VkDescriptorSetVariableDescriptorCountAllocateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetVariableDescriptorCountLayoutSupport(std::ostream &out, const VkDescriptorSetVariableDescriptorCountLayoutSupport* structInfo, Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupport* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxVariableDescriptorCount
    struct_body << "\t\t\t" << structInfo->maxVariableDescriptorCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetVariableDescriptorCountLayoutSupport");
    out << "\t\t" << "VkDescriptorSetVariableDescriptorCountLayoutSupport " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceMemoryOpaqueCaptureAddressInfo(std::ostream &out, const VkDeviceMemoryOpaqueCaptureAddressInfo* structInfo, Decoded_VkDeviceMemoryOpaqueCaptureAddressInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceMemoryOpaqueCaptureAddressInfo");
    out << "\t\t" << "VkDeviceMemoryOpaqueCaptureAddressInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFramebufferAttachmentImageInfo(std::ostream &out, const VkFramebufferAttachmentImageInfo* structInfo, Decoded_VkFramebufferAttachmentImageInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pview_formats_values;
    std::string pview_formats_array = "NULL";
    if (structInfo->pViewFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->viewFormatCount; idx++) {
            pview_formats_values += util::ToString<VkFormat>(structInfo->pViewFormats[idx]) + ", ";
        }
        pview_formats_array = "pViewFormats_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkFormat " << pview_formats_array << "[] = {" << pview_formats_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkImageCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// usage
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
// width
    struct_body << "\t\t\t" << structInfo->width << "," << std::endl;
// height
    struct_body << "\t\t\t" << structInfo->height << "," << std::endl;
// layerCount
    struct_body << "\t\t\t" << structInfo->layerCount << "," << std::endl;
// viewFormatCount
    struct_body << "\t\t\t" << structInfo->viewFormatCount << "," << std::endl;
// pViewFormats
    struct_body << "\t\t\t" << pview_formats_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "framebufferAttachmentImageInfo");
    out << "\t\t" << "VkFramebufferAttachmentImageInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFramebufferAttachmentsCreateInfo(std::ostream &out, const VkFramebufferAttachmentsCreateInfo* structInfo, Decoded_VkFramebufferAttachmentsCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pattachment_image_infos_array = "NULL";
    if (structInfo->pAttachmentImageInfos != NULL) {
        pattachment_image_infos_array = "pAttachmentImageInfos_" + std::to_string(consumer.GetNextId());
        std::string pattachment_image_infos_names;
        for (uint32_t idx = 0; idx < structInfo->attachmentImageInfoCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pAttachmentImageInfos + idx != NULL) {
                variable_name = GenerateStruct_VkFramebufferAttachmentImageInfo(out,
                                                                                structInfo->pAttachmentImageInfos + idx,
                                                                                metaInfo->pAttachmentImageInfos->GetMetaStructPointer() + idx,
                                                                                consumer);
            }
            pattachment_image_infos_names += variable_name + ", ";
        }
        out << "\t\t" << "VkFramebufferAttachmentImageInfo " << pattachment_image_infos_array << "[] = {" << pattachment_image_infos_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// attachmentImageInfoCount
    struct_body << "\t\t\t" << structInfo->attachmentImageInfoCount << "," << std::endl;
// pAttachmentImageInfos
    struct_body << "\t\t\t" << pattachment_image_infos_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "framebufferAttachmentsCreateInfo");
    out << "\t\t" << "VkFramebufferAttachmentsCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageFormatListCreateInfo(std::ostream &out, const VkImageFormatListCreateInfo* structInfo, Decoded_VkImageFormatListCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pview_formats_values;
    std::string pview_formats_array = "NULL";
    if (structInfo->pViewFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->viewFormatCount; idx++) {
            pview_formats_values += util::ToString<VkFormat>(structInfo->pViewFormats[idx]) + ", ";
        }
        pview_formats_array = "pViewFormats_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkFormat " << pview_formats_array << "[] = {" << pview_formats_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// viewFormatCount
    struct_body << "\t\t\t" << structInfo->viewFormatCount << "," << std::endl;
// pViewFormats
    struct_body << "\t\t\t" << pview_formats_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageFormatListCreateInfo");
    out << "\t\t" << "VkImageFormatListCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageStencilUsageCreateInfo(std::ostream &out, const VkImageStencilUsageCreateInfo* structInfo, Decoded_VkImageStencilUsageCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stencilUsage
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->stencilUsage << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageStencilUsageCreateInfo");
    out << "\t\t" << "VkImageStencilUsageCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryOpaqueCaptureAddressAllocateInfo(std::ostream &out, const VkMemoryOpaqueCaptureAddressAllocateInfo* structInfo, Decoded_VkMemoryOpaqueCaptureAddressAllocateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// opaqueCaptureAddress
    struct_body << "\t\t\t" << structInfo->opaqueCaptureAddress << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryOpaqueCaptureAddressAllocateInfo");
    out << "\t\t" << "VkMemoryOpaqueCaptureAddressAllocateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevice8BitStorageFeatures(std::ostream &out, const VkPhysicalDevice8BitStorageFeatures* structInfo, Decoded_VkPhysicalDevice8BitStorageFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// storageBuffer8BitAccess
    struct_body << "\t\t\t" << structInfo->storageBuffer8BitAccess << "," << std::endl;
// uniformAndStorageBuffer8BitAccess
    struct_body << "\t\t\t" << structInfo->uniformAndStorageBuffer8BitAccess << "," << std::endl;
// storagePushConstant8
    struct_body << "\t\t\t" << structInfo->storagePushConstant8 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevice8BitStorageFeatures");
    out << "\t\t" << "VkPhysicalDevice8BitStorageFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceBufferDeviceAddressFeatures(std::ostream &out, const VkPhysicalDeviceBufferDeviceAddressFeatures* structInfo, Decoded_VkPhysicalDeviceBufferDeviceAddressFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// bufferDeviceAddress
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddress << "," << std::endl;
// bufferDeviceAddressCaptureReplay
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddressCaptureReplay << "," << std::endl;
// bufferDeviceAddressMultiDevice
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddressMultiDevice << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceBufferDeviceAddressFeatures");
    out << "\t\t" << "VkPhysicalDeviceBufferDeviceAddressFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDepthStencilResolveProperties(std::ostream &out, const VkPhysicalDeviceDepthStencilResolveProperties* structInfo, Decoded_VkPhysicalDeviceDepthStencilResolveProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// supportedDepthResolveModes
    struct_body << "\t\t\t" << "VkResolveModeFlags(" << structInfo->supportedDepthResolveModes << ")" << "," << std::endl;
// supportedStencilResolveModes
    struct_body << "\t\t\t" << "VkResolveModeFlags(" << structInfo->supportedStencilResolveModes << ")" << "," << std::endl;
// independentResolveNone
    struct_body << "\t\t\t" << structInfo->independentResolveNone << "," << std::endl;
// independentResolve
    struct_body << "\t\t\t" << structInfo->independentResolve << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDepthStencilResolveProperties");
    out << "\t\t" << "VkPhysicalDeviceDepthStencilResolveProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDescriptorIndexingFeatures(std::ostream &out, const VkPhysicalDeviceDescriptorIndexingFeatures* structInfo, Decoded_VkPhysicalDeviceDescriptorIndexingFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderInputAttachmentArrayDynamicIndexing
    struct_body << "\t\t\t" << structInfo->shaderInputAttachmentArrayDynamicIndexing << "," << std::endl;
// shaderUniformTexelBufferArrayDynamicIndexing
    struct_body << "\t\t\t" << structInfo->shaderUniformTexelBufferArrayDynamicIndexing << "," << std::endl;
// shaderStorageTexelBufferArrayDynamicIndexing
    struct_body << "\t\t\t" << structInfo->shaderStorageTexelBufferArrayDynamicIndexing << "," << std::endl;
// shaderUniformBufferArrayNonUniformIndexing
    struct_body << "\t\t\t" << structInfo->shaderUniformBufferArrayNonUniformIndexing << "," << std::endl;
// shaderSampledImageArrayNonUniformIndexing
    struct_body << "\t\t\t" << structInfo->shaderSampledImageArrayNonUniformIndexing << "," << std::endl;
// shaderStorageBufferArrayNonUniformIndexing
    struct_body << "\t\t\t" << structInfo->shaderStorageBufferArrayNonUniformIndexing << "," << std::endl;
// shaderStorageImageArrayNonUniformIndexing
    struct_body << "\t\t\t" << structInfo->shaderStorageImageArrayNonUniformIndexing << "," << std::endl;
// shaderInputAttachmentArrayNonUniformIndexing
    struct_body << "\t\t\t" << structInfo->shaderInputAttachmentArrayNonUniformIndexing << "," << std::endl;
// shaderUniformTexelBufferArrayNonUniformIndexing
    struct_body << "\t\t\t" << structInfo->shaderUniformTexelBufferArrayNonUniformIndexing << "," << std::endl;
// shaderStorageTexelBufferArrayNonUniformIndexing
    struct_body << "\t\t\t" << structInfo->shaderStorageTexelBufferArrayNonUniformIndexing << "," << std::endl;
// descriptorBindingUniformBufferUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingUniformBufferUpdateAfterBind << "," << std::endl;
// descriptorBindingSampledImageUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingSampledImageUpdateAfterBind << "," << std::endl;
// descriptorBindingStorageImageUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingStorageImageUpdateAfterBind << "," << std::endl;
// descriptorBindingStorageBufferUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingStorageBufferUpdateAfterBind << "," << std::endl;
// descriptorBindingUniformTexelBufferUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingUniformTexelBufferUpdateAfterBind << "," << std::endl;
// descriptorBindingStorageTexelBufferUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingStorageTexelBufferUpdateAfterBind << "," << std::endl;
// descriptorBindingUpdateUnusedWhilePending
    struct_body << "\t\t\t" << structInfo->descriptorBindingUpdateUnusedWhilePending << "," << std::endl;
// descriptorBindingPartiallyBound
    struct_body << "\t\t\t" << structInfo->descriptorBindingPartiallyBound << "," << std::endl;
// descriptorBindingVariableDescriptorCount
    struct_body << "\t\t\t" << structInfo->descriptorBindingVariableDescriptorCount << "," << std::endl;
// runtimeDescriptorArray
    struct_body << "\t\t\t" << structInfo->runtimeDescriptorArray << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDescriptorIndexingFeatures");
    out << "\t\t" << "VkPhysicalDeviceDescriptorIndexingFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDescriptorIndexingProperties(std::ostream &out, const VkPhysicalDeviceDescriptorIndexingProperties* structInfo, Decoded_VkPhysicalDeviceDescriptorIndexingProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxUpdateAfterBindDescriptorsInAllPools
    struct_body << "\t\t\t" << structInfo->maxUpdateAfterBindDescriptorsInAllPools << "," << std::endl;
// shaderUniformBufferArrayNonUniformIndexingNative
    struct_body << "\t\t\t" << structInfo->shaderUniformBufferArrayNonUniformIndexingNative << "," << std::endl;
// shaderSampledImageArrayNonUniformIndexingNative
    struct_body << "\t\t\t" << structInfo->shaderSampledImageArrayNonUniformIndexingNative << "," << std::endl;
// shaderStorageBufferArrayNonUniformIndexingNative
    struct_body << "\t\t\t" << structInfo->shaderStorageBufferArrayNonUniformIndexingNative << "," << std::endl;
// shaderStorageImageArrayNonUniformIndexingNative
    struct_body << "\t\t\t" << structInfo->shaderStorageImageArrayNonUniformIndexingNative << "," << std::endl;
// shaderInputAttachmentArrayNonUniformIndexingNative
    struct_body << "\t\t\t" << structInfo->shaderInputAttachmentArrayNonUniformIndexingNative << "," << std::endl;
// robustBufferAccessUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->robustBufferAccessUpdateAfterBind << "," << std::endl;
// quadDivergentImplicitLod
    struct_body << "\t\t\t" << structInfo->quadDivergentImplicitLod << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindSamplers
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindSamplers << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindUniformBuffers
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindUniformBuffers << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindStorageBuffers
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindStorageBuffers << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindSampledImages
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindSampledImages << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindStorageImages
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindStorageImages << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindInputAttachments
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindInputAttachments << "," << std::endl;
// maxPerStageUpdateAfterBindResources
    struct_body << "\t\t\t" << structInfo->maxPerStageUpdateAfterBindResources << "," << std::endl;
// maxDescriptorSetUpdateAfterBindSamplers
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindSamplers << "," << std::endl;
// maxDescriptorSetUpdateAfterBindUniformBuffers
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindUniformBuffers << "," << std::endl;
// maxDescriptorSetUpdateAfterBindUniformBuffersDynamic
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic << "," << std::endl;
// maxDescriptorSetUpdateAfterBindStorageBuffers
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageBuffers << "," << std::endl;
// maxDescriptorSetUpdateAfterBindStorageBuffersDynamic
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic << "," << std::endl;
// maxDescriptorSetUpdateAfterBindSampledImages
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindSampledImages << "," << std::endl;
// maxDescriptorSetUpdateAfterBindStorageImages
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageImages << "," << std::endl;
// maxDescriptorSetUpdateAfterBindInputAttachments
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindInputAttachments << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDescriptorIndexingProperties");
    out << "\t\t" << "VkPhysicalDeviceDescriptorIndexingProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDriverProperties(std::ostream &out, const VkPhysicalDeviceDriverProperties* structInfo, Decoded_VkPhysicalDeviceDriverProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string conformance_version_info_var = GenerateStruct_VkConformanceVersion(out,
                                                                                   &structInfo->conformanceVersion,
                                                                                   metaInfo->conformanceVersion,
                                                                                   consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// driverID
    struct_body << "\t\t\t" << "VkDriverId(" << structInfo->driverID << ")" << "," << std::endl;
// driverName
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->driverName) << "," << std::endl;
// driverInfo
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->driverInfo) << "," << std::endl;
// conformanceVersion
    struct_body << "\t\t\t" << conformance_version_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDriverProperties");
    out << "\t\t" << "VkPhysicalDeviceDriverProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFloatControlsProperties(std::ostream &out, const VkPhysicalDeviceFloatControlsProperties* structInfo, Decoded_VkPhysicalDeviceFloatControlsProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// denormBehaviorIndependence
    struct_body << "\t\t\t" << "VkShaderFloatControlsIndependence(" << structInfo->denormBehaviorIndependence << ")" << "," << std::endl;
// roundingModeIndependence
    struct_body << "\t\t\t" << "VkShaderFloatControlsIndependence(" << structInfo->roundingModeIndependence << ")" << "," << std::endl;
// shaderSignedZeroInfNanPreserveFloat16
    struct_body << "\t\t\t" << structInfo->shaderSignedZeroInfNanPreserveFloat16 << "," << std::endl;
// shaderSignedZeroInfNanPreserveFloat32
    struct_body << "\t\t\t" << structInfo->shaderSignedZeroInfNanPreserveFloat32 << "," << std::endl;
// shaderSignedZeroInfNanPreserveFloat64
    struct_body << "\t\t\t" << structInfo->shaderSignedZeroInfNanPreserveFloat64 << "," << std::endl;
// shaderDenormPreserveFloat16
    struct_body << "\t\t\t" << structInfo->shaderDenormPreserveFloat16 << "," << std::endl;
// shaderDenormPreserveFloat32
    struct_body << "\t\t\t" << structInfo->shaderDenormPreserveFloat32 << "," << std::endl;
// shaderDenormPreserveFloat64
    struct_body << "\t\t\t" << structInfo->shaderDenormPreserveFloat64 << "," << std::endl;
// shaderDenormFlushToZeroFloat16
    struct_body << "\t\t\t" << structInfo->shaderDenormFlushToZeroFloat16 << "," << std::endl;
// shaderDenormFlushToZeroFloat32
    struct_body << "\t\t\t" << structInfo->shaderDenormFlushToZeroFloat32 << "," << std::endl;
// shaderDenormFlushToZeroFloat64
    struct_body << "\t\t\t" << structInfo->shaderDenormFlushToZeroFloat64 << "," << std::endl;
// shaderRoundingModeRTEFloat16
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTEFloat16 << "," << std::endl;
// shaderRoundingModeRTEFloat32
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTEFloat32 << "," << std::endl;
// shaderRoundingModeRTEFloat64
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTEFloat64 << "," << std::endl;
// shaderRoundingModeRTZFloat16
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTZFloat16 << "," << std::endl;
// shaderRoundingModeRTZFloat32
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTZFloat32 << "," << std::endl;
// shaderRoundingModeRTZFloat64
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTZFloat64 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFloatControlsProperties");
    out << "\t\t" << "VkPhysicalDeviceFloatControlsProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceHostQueryResetFeatures(std::ostream &out, const VkPhysicalDeviceHostQueryResetFeatures* structInfo, Decoded_VkPhysicalDeviceHostQueryResetFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// hostQueryReset
    struct_body << "\t\t\t" << structInfo->hostQueryReset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceHostQueryResetFeatures");
    out << "\t\t" << "VkPhysicalDeviceHostQueryResetFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImagelessFramebufferFeatures(std::ostream &out, const VkPhysicalDeviceImagelessFramebufferFeatures* structInfo, Decoded_VkPhysicalDeviceImagelessFramebufferFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// imagelessFramebuffer
    struct_body << "\t\t\t" << structInfo->imagelessFramebuffer << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImagelessFramebufferFeatures");
    out << "\t\t" << "VkPhysicalDeviceImagelessFramebufferFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSamplerFilterMinmaxProperties(std::ostream &out, const VkPhysicalDeviceSamplerFilterMinmaxProperties* structInfo, Decoded_VkPhysicalDeviceSamplerFilterMinmaxProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// filterMinmaxSingleComponentFormats
    struct_body << "\t\t\t" << structInfo->filterMinmaxSingleComponentFormats << "," << std::endl;
// filterMinmaxImageComponentMapping
    struct_body << "\t\t\t" << structInfo->filterMinmaxImageComponentMapping << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSamplerFilterMinmaxProperties");
    out << "\t\t" << "VkPhysicalDeviceSamplerFilterMinmaxProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceScalarBlockLayoutFeatures(std::ostream &out, const VkPhysicalDeviceScalarBlockLayoutFeatures* structInfo, Decoded_VkPhysicalDeviceScalarBlockLayoutFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// scalarBlockLayout
    struct_body << "\t\t\t" << structInfo->scalarBlockLayout << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceScalarBlockLayoutFeatures");
    out << "\t\t" << "VkPhysicalDeviceScalarBlockLayoutFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(std::ostream &out, const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* structInfo, Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// separateDepthStencilLayouts
    struct_body << "\t\t\t" << structInfo->separateDepthStencilLayouts << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSeparateDepthStencilLayoutsFeatures");
    out << "\t\t" << "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderAtomicInt64Features(std::ostream &out, const VkPhysicalDeviceShaderAtomicInt64Features* structInfo, Decoded_VkPhysicalDeviceShaderAtomicInt64Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderBufferInt64Atomics
    struct_body << "\t\t\t" << structInfo->shaderBufferInt64Atomics << "," << std::endl;
// shaderSharedInt64Atomics
    struct_body << "\t\t\t" << structInfo->shaderSharedInt64Atomics << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderAtomicInt64Features");
    out << "\t\t" << "VkPhysicalDeviceShaderAtomicInt64Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderFloat16Int8Features(std::ostream &out, const VkPhysicalDeviceShaderFloat16Int8Features* structInfo, Decoded_VkPhysicalDeviceShaderFloat16Int8Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderFloat16
    struct_body << "\t\t\t" << structInfo->shaderFloat16 << "," << std::endl;
// shaderInt8
    struct_body << "\t\t\t" << structInfo->shaderInt8 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderFloat16Int8Features");
    out << "\t\t" << "VkPhysicalDeviceShaderFloat16Int8Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(std::ostream &out, const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* structInfo, Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderSubgroupExtendedTypes
    struct_body << "\t\t\t" << structInfo->shaderSubgroupExtendedTypes << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderSubgroupExtendedTypesFeatures");
    out << "\t\t" << "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTimelineSemaphoreFeatures(std::ostream &out, const VkPhysicalDeviceTimelineSemaphoreFeatures* structInfo, Decoded_VkPhysicalDeviceTimelineSemaphoreFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// timelineSemaphore
    struct_body << "\t\t\t" << structInfo->timelineSemaphore << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTimelineSemaphoreFeatures");
    out << "\t\t" << "VkPhysicalDeviceTimelineSemaphoreFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTimelineSemaphoreProperties(std::ostream &out, const VkPhysicalDeviceTimelineSemaphoreProperties* structInfo, Decoded_VkPhysicalDeviceTimelineSemaphoreProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxTimelineSemaphoreValueDifference
    struct_body << "\t\t\t" << structInfo->maxTimelineSemaphoreValueDifference << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTimelineSemaphoreProperties");
    out << "\t\t" << "VkPhysicalDeviceTimelineSemaphoreProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(std::ostream &out, const VkPhysicalDeviceUniformBufferStandardLayoutFeatures* structInfo, Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// uniformBufferStandardLayout
    struct_body << "\t\t\t" << structInfo->uniformBufferStandardLayout << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceUniformBufferStandardLayoutFeatures");
    out << "\t\t" << "VkPhysicalDeviceUniformBufferStandardLayoutFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan11Features(std::ostream &out, const VkPhysicalDeviceVulkan11Features* structInfo, Decoded_VkPhysicalDeviceVulkan11Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// storageBuffer16BitAccess
    struct_body << "\t\t\t" << structInfo->storageBuffer16BitAccess << "," << std::endl;
// uniformAndStorageBuffer16BitAccess
    struct_body << "\t\t\t" << structInfo->uniformAndStorageBuffer16BitAccess << "," << std::endl;
// storagePushConstant16
    struct_body << "\t\t\t" << structInfo->storagePushConstant16 << "," << std::endl;
// storageInputOutput16
    struct_body << "\t\t\t" << structInfo->storageInputOutput16 << "," << std::endl;
// multiview
    struct_body << "\t\t\t" << structInfo->multiview << "," << std::endl;
// multiviewGeometryShader
    struct_body << "\t\t\t" << structInfo->multiviewGeometryShader << "," << std::endl;
// multiviewTessellationShader
    struct_body << "\t\t\t" << structInfo->multiviewTessellationShader << "," << std::endl;
// variablePointersStorageBuffer
    struct_body << "\t\t\t" << structInfo->variablePointersStorageBuffer << "," << std::endl;
// variablePointers
    struct_body << "\t\t\t" << structInfo->variablePointers << "," << std::endl;
// protectedMemory
    struct_body << "\t\t\t" << structInfo->protectedMemory << "," << std::endl;
// samplerYcbcrConversion
    struct_body << "\t\t\t" << structInfo->samplerYcbcrConversion << "," << std::endl;
// shaderDrawParameters
    struct_body << "\t\t\t" << structInfo->shaderDrawParameters << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkan11Features");
    out << "\t\t" << "VkPhysicalDeviceVulkan11Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan11Properties(std::ostream &out, const VkPhysicalDeviceVulkan11Properties* structInfo, Decoded_VkPhysicalDeviceVulkan11Properties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceUUID
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->deviceUUID[0]), VK_UUID_SIZE) << "," << std::endl;
// driverUUID
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->driverUUID[0]), VK_UUID_SIZE) << "," << std::endl;
// deviceLUID
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->deviceLUID[0]), VK_LUID_SIZE) << "," << std::endl;
// deviceNodeMask
    struct_body << "\t\t\t" << structInfo->deviceNodeMask << "," << std::endl;
// deviceLUIDValid
    struct_body << "\t\t\t" << structInfo->deviceLUIDValid << "," << std::endl;
// subgroupSize
    struct_body << "\t\t\t" << structInfo->subgroupSize << "," << std::endl;
// subgroupSupportedStages
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->subgroupSupportedStages << ")" << "," << std::endl;
// subgroupSupportedOperations
    struct_body << "\t\t\t" << "VkSubgroupFeatureFlags(" << structInfo->subgroupSupportedOperations << ")" << "," << std::endl;
// subgroupQuadOperationsInAllStages
    struct_body << "\t\t\t" << structInfo->subgroupQuadOperationsInAllStages << "," << std::endl;
// pointClippingBehavior
    struct_body << "\t\t\t" << "VkPointClippingBehavior(" << structInfo->pointClippingBehavior << ")" << "," << std::endl;
// maxMultiviewViewCount
    struct_body << "\t\t\t" << structInfo->maxMultiviewViewCount << "," << std::endl;
// maxMultiviewInstanceIndex
    struct_body << "\t\t\t" << structInfo->maxMultiviewInstanceIndex << "," << std::endl;
// protectedNoFault
    struct_body << "\t\t\t" << structInfo->protectedNoFault << "," << std::endl;
// maxPerSetDescriptors
    struct_body << "\t\t\t" << structInfo->maxPerSetDescriptors << "," << std::endl;
// maxMemoryAllocationSize
    struct_body << "\t\t\t" << structInfo->maxMemoryAllocationSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkan11Properties");
    out << "\t\t" << "VkPhysicalDeviceVulkan11Properties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan12Features(std::ostream &out, const VkPhysicalDeviceVulkan12Features* structInfo, Decoded_VkPhysicalDeviceVulkan12Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// samplerMirrorClampToEdge
    struct_body << "\t\t\t" << structInfo->samplerMirrorClampToEdge << "," << std::endl;
// drawIndirectCount
    struct_body << "\t\t\t" << structInfo->drawIndirectCount << "," << std::endl;
// storageBuffer8BitAccess
    struct_body << "\t\t\t" << structInfo->storageBuffer8BitAccess << "," << std::endl;
// uniformAndStorageBuffer8BitAccess
    struct_body << "\t\t\t" << structInfo->uniformAndStorageBuffer8BitAccess << "," << std::endl;
// storagePushConstant8
    struct_body << "\t\t\t" << structInfo->storagePushConstant8 << "," << std::endl;
// shaderBufferInt64Atomics
    struct_body << "\t\t\t" << structInfo->shaderBufferInt64Atomics << "," << std::endl;
// shaderSharedInt64Atomics
    struct_body << "\t\t\t" << structInfo->shaderSharedInt64Atomics << "," << std::endl;
// shaderFloat16
    struct_body << "\t\t\t" << structInfo->shaderFloat16 << "," << std::endl;
// shaderInt8
    struct_body << "\t\t\t" << structInfo->shaderInt8 << "," << std::endl;
// descriptorIndexing
    struct_body << "\t\t\t" << structInfo->descriptorIndexing << "," << std::endl;
// shaderInputAttachmentArrayDynamicIndexing
    struct_body << "\t\t\t" << structInfo->shaderInputAttachmentArrayDynamicIndexing << "," << std::endl;
// shaderUniformTexelBufferArrayDynamicIndexing
    struct_body << "\t\t\t" << structInfo->shaderUniformTexelBufferArrayDynamicIndexing << "," << std::endl;
// shaderStorageTexelBufferArrayDynamicIndexing
    struct_body << "\t\t\t" << structInfo->shaderStorageTexelBufferArrayDynamicIndexing << "," << std::endl;
// shaderUniformBufferArrayNonUniformIndexing
    struct_body << "\t\t\t" << structInfo->shaderUniformBufferArrayNonUniformIndexing << "," << std::endl;
// shaderSampledImageArrayNonUniformIndexing
    struct_body << "\t\t\t" << structInfo->shaderSampledImageArrayNonUniformIndexing << "," << std::endl;
// shaderStorageBufferArrayNonUniformIndexing
    struct_body << "\t\t\t" << structInfo->shaderStorageBufferArrayNonUniformIndexing << "," << std::endl;
// shaderStorageImageArrayNonUniformIndexing
    struct_body << "\t\t\t" << structInfo->shaderStorageImageArrayNonUniformIndexing << "," << std::endl;
// shaderInputAttachmentArrayNonUniformIndexing
    struct_body << "\t\t\t" << structInfo->shaderInputAttachmentArrayNonUniformIndexing << "," << std::endl;
// shaderUniformTexelBufferArrayNonUniformIndexing
    struct_body << "\t\t\t" << structInfo->shaderUniformTexelBufferArrayNonUniformIndexing << "," << std::endl;
// shaderStorageTexelBufferArrayNonUniformIndexing
    struct_body << "\t\t\t" << structInfo->shaderStorageTexelBufferArrayNonUniformIndexing << "," << std::endl;
// descriptorBindingUniformBufferUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingUniformBufferUpdateAfterBind << "," << std::endl;
// descriptorBindingSampledImageUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingSampledImageUpdateAfterBind << "," << std::endl;
// descriptorBindingStorageImageUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingStorageImageUpdateAfterBind << "," << std::endl;
// descriptorBindingStorageBufferUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingStorageBufferUpdateAfterBind << "," << std::endl;
// descriptorBindingUniformTexelBufferUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingUniformTexelBufferUpdateAfterBind << "," << std::endl;
// descriptorBindingStorageTexelBufferUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingStorageTexelBufferUpdateAfterBind << "," << std::endl;
// descriptorBindingUpdateUnusedWhilePending
    struct_body << "\t\t\t" << structInfo->descriptorBindingUpdateUnusedWhilePending << "," << std::endl;
// descriptorBindingPartiallyBound
    struct_body << "\t\t\t" << structInfo->descriptorBindingPartiallyBound << "," << std::endl;
// descriptorBindingVariableDescriptorCount
    struct_body << "\t\t\t" << structInfo->descriptorBindingVariableDescriptorCount << "," << std::endl;
// runtimeDescriptorArray
    struct_body << "\t\t\t" << structInfo->runtimeDescriptorArray << "," << std::endl;
// samplerFilterMinmax
    struct_body << "\t\t\t" << structInfo->samplerFilterMinmax << "," << std::endl;
// scalarBlockLayout
    struct_body << "\t\t\t" << structInfo->scalarBlockLayout << "," << std::endl;
// imagelessFramebuffer
    struct_body << "\t\t\t" << structInfo->imagelessFramebuffer << "," << std::endl;
// uniformBufferStandardLayout
    struct_body << "\t\t\t" << structInfo->uniformBufferStandardLayout << "," << std::endl;
// shaderSubgroupExtendedTypes
    struct_body << "\t\t\t" << structInfo->shaderSubgroupExtendedTypes << "," << std::endl;
// separateDepthStencilLayouts
    struct_body << "\t\t\t" << structInfo->separateDepthStencilLayouts << "," << std::endl;
// hostQueryReset
    struct_body << "\t\t\t" << structInfo->hostQueryReset << "," << std::endl;
// timelineSemaphore
    struct_body << "\t\t\t" << structInfo->timelineSemaphore << "," << std::endl;
// bufferDeviceAddress
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddress << "," << std::endl;
// bufferDeviceAddressCaptureReplay
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddressCaptureReplay << "," << std::endl;
// bufferDeviceAddressMultiDevice
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddressMultiDevice << "," << std::endl;
// vulkanMemoryModel
    struct_body << "\t\t\t" << structInfo->vulkanMemoryModel << "," << std::endl;
// vulkanMemoryModelDeviceScope
    struct_body << "\t\t\t" << structInfo->vulkanMemoryModelDeviceScope << "," << std::endl;
// vulkanMemoryModelAvailabilityVisibilityChains
    struct_body << "\t\t\t" << structInfo->vulkanMemoryModelAvailabilityVisibilityChains << "," << std::endl;
// shaderOutputViewportIndex
    struct_body << "\t\t\t" << structInfo->shaderOutputViewportIndex << "," << std::endl;
// shaderOutputLayer
    struct_body << "\t\t\t" << structInfo->shaderOutputLayer << "," << std::endl;
// subgroupBroadcastDynamicId
    struct_body << "\t\t\t" << structInfo->subgroupBroadcastDynamicId << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkan12Features");
    out << "\t\t" << "VkPhysicalDeviceVulkan12Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan12Properties(std::ostream &out, const VkPhysicalDeviceVulkan12Properties* structInfo, Decoded_VkPhysicalDeviceVulkan12Properties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string conformance_version_info_var = GenerateStruct_VkConformanceVersion(out,
                                                                                   &structInfo->conformanceVersion,
                                                                                   metaInfo->conformanceVersion,
                                                                                   consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// driverID
    struct_body << "\t\t\t" << "VkDriverId(" << structInfo->driverID << ")" << "," << std::endl;
// driverName
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->driverName) << "," << std::endl;
// driverInfo
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->driverInfo) << "," << std::endl;
// conformanceVersion
    struct_body << "\t\t\t" << conformance_version_info_var << "," << std::endl;
// denormBehaviorIndependence
    struct_body << "\t\t\t" << "VkShaderFloatControlsIndependence(" << structInfo->denormBehaviorIndependence << ")" << "," << std::endl;
// roundingModeIndependence
    struct_body << "\t\t\t" << "VkShaderFloatControlsIndependence(" << structInfo->roundingModeIndependence << ")" << "," << std::endl;
// shaderSignedZeroInfNanPreserveFloat16
    struct_body << "\t\t\t" << structInfo->shaderSignedZeroInfNanPreserveFloat16 << "," << std::endl;
// shaderSignedZeroInfNanPreserveFloat32
    struct_body << "\t\t\t" << structInfo->shaderSignedZeroInfNanPreserveFloat32 << "," << std::endl;
// shaderSignedZeroInfNanPreserveFloat64
    struct_body << "\t\t\t" << structInfo->shaderSignedZeroInfNanPreserveFloat64 << "," << std::endl;
// shaderDenormPreserveFloat16
    struct_body << "\t\t\t" << structInfo->shaderDenormPreserveFloat16 << "," << std::endl;
// shaderDenormPreserveFloat32
    struct_body << "\t\t\t" << structInfo->shaderDenormPreserveFloat32 << "," << std::endl;
// shaderDenormPreserveFloat64
    struct_body << "\t\t\t" << structInfo->shaderDenormPreserveFloat64 << "," << std::endl;
// shaderDenormFlushToZeroFloat16
    struct_body << "\t\t\t" << structInfo->shaderDenormFlushToZeroFloat16 << "," << std::endl;
// shaderDenormFlushToZeroFloat32
    struct_body << "\t\t\t" << structInfo->shaderDenormFlushToZeroFloat32 << "," << std::endl;
// shaderDenormFlushToZeroFloat64
    struct_body << "\t\t\t" << structInfo->shaderDenormFlushToZeroFloat64 << "," << std::endl;
// shaderRoundingModeRTEFloat16
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTEFloat16 << "," << std::endl;
// shaderRoundingModeRTEFloat32
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTEFloat32 << "," << std::endl;
// shaderRoundingModeRTEFloat64
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTEFloat64 << "," << std::endl;
// shaderRoundingModeRTZFloat16
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTZFloat16 << "," << std::endl;
// shaderRoundingModeRTZFloat32
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTZFloat32 << "," << std::endl;
// shaderRoundingModeRTZFloat64
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTZFloat64 << "," << std::endl;
// maxUpdateAfterBindDescriptorsInAllPools
    struct_body << "\t\t\t" << structInfo->maxUpdateAfterBindDescriptorsInAllPools << "," << std::endl;
// shaderUniformBufferArrayNonUniformIndexingNative
    struct_body << "\t\t\t" << structInfo->shaderUniformBufferArrayNonUniformIndexingNative << "," << std::endl;
// shaderSampledImageArrayNonUniformIndexingNative
    struct_body << "\t\t\t" << structInfo->shaderSampledImageArrayNonUniformIndexingNative << "," << std::endl;
// shaderStorageBufferArrayNonUniformIndexingNative
    struct_body << "\t\t\t" << structInfo->shaderStorageBufferArrayNonUniformIndexingNative << "," << std::endl;
// shaderStorageImageArrayNonUniformIndexingNative
    struct_body << "\t\t\t" << structInfo->shaderStorageImageArrayNonUniformIndexingNative << "," << std::endl;
// shaderInputAttachmentArrayNonUniformIndexingNative
    struct_body << "\t\t\t" << structInfo->shaderInputAttachmentArrayNonUniformIndexingNative << "," << std::endl;
// robustBufferAccessUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->robustBufferAccessUpdateAfterBind << "," << std::endl;
// quadDivergentImplicitLod
    struct_body << "\t\t\t" << structInfo->quadDivergentImplicitLod << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindSamplers
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindSamplers << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindUniformBuffers
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindUniformBuffers << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindStorageBuffers
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindStorageBuffers << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindSampledImages
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindSampledImages << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindStorageImages
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindStorageImages << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindInputAttachments
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindInputAttachments << "," << std::endl;
// maxPerStageUpdateAfterBindResources
    struct_body << "\t\t\t" << structInfo->maxPerStageUpdateAfterBindResources << "," << std::endl;
// maxDescriptorSetUpdateAfterBindSamplers
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindSamplers << "," << std::endl;
// maxDescriptorSetUpdateAfterBindUniformBuffers
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindUniformBuffers << "," << std::endl;
// maxDescriptorSetUpdateAfterBindUniformBuffersDynamic
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic << "," << std::endl;
// maxDescriptorSetUpdateAfterBindStorageBuffers
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageBuffers << "," << std::endl;
// maxDescriptorSetUpdateAfterBindStorageBuffersDynamic
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic << "," << std::endl;
// maxDescriptorSetUpdateAfterBindSampledImages
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindSampledImages << "," << std::endl;
// maxDescriptorSetUpdateAfterBindStorageImages
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageImages << "," << std::endl;
// maxDescriptorSetUpdateAfterBindInputAttachments
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindInputAttachments << "," << std::endl;
// supportedDepthResolveModes
    struct_body << "\t\t\t" << "VkResolveModeFlags(" << structInfo->supportedDepthResolveModes << ")" << "," << std::endl;
// supportedStencilResolveModes
    struct_body << "\t\t\t" << "VkResolveModeFlags(" << structInfo->supportedStencilResolveModes << ")" << "," << std::endl;
// independentResolveNone
    struct_body << "\t\t\t" << structInfo->independentResolveNone << "," << std::endl;
// independentResolve
    struct_body << "\t\t\t" << structInfo->independentResolve << "," << std::endl;
// filterMinmaxSingleComponentFormats
    struct_body << "\t\t\t" << structInfo->filterMinmaxSingleComponentFormats << "," << std::endl;
// filterMinmaxImageComponentMapping
    struct_body << "\t\t\t" << structInfo->filterMinmaxImageComponentMapping << "," << std::endl;
// maxTimelineSemaphoreValueDifference
    struct_body << "\t\t\t" << structInfo->maxTimelineSemaphoreValueDifference << "UL" << "," << std::endl;
// framebufferIntegerColorSampleCounts
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->framebufferIntegerColorSampleCounts << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkan12Properties");
    out << "\t\t" << "VkPhysicalDeviceVulkan12Properties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkanMemoryModelFeatures(std::ostream &out, const VkPhysicalDeviceVulkanMemoryModelFeatures* structInfo, Decoded_VkPhysicalDeviceVulkanMemoryModelFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// vulkanMemoryModel
    struct_body << "\t\t\t" << structInfo->vulkanMemoryModel << "," << std::endl;
// vulkanMemoryModelDeviceScope
    struct_body << "\t\t\t" << structInfo->vulkanMemoryModelDeviceScope << "," << std::endl;
// vulkanMemoryModelAvailabilityVisibilityChains
    struct_body << "\t\t\t" << structInfo->vulkanMemoryModelAvailabilityVisibilityChains << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkanMemoryModelFeatures");
    out << "\t\t" << "VkPhysicalDeviceVulkanMemoryModelFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassAttachmentBeginInfo(std::ostream &out, const VkRenderPassAttachmentBeginInfo* structInfo, Decoded_VkRenderPassAttachmentBeginInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pattachments_array = "NULL";
    if (metaInfo->pAttachments.GetPointer() != NULL && structInfo->attachmentCount > 0) {
        pattachments_array = "pattachments_array_" + std::to_string(consumer.GetNextId());
        std::string pattachments_values = toStringJoin(metaInfo->pAttachments.GetPointer(),
                                                       metaInfo->pAttachments.GetPointer() + structInfo->attachmentCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->attachmentCount == 1) {
            pattachments_array = "&" + pattachments_values;
        } else if (structInfo->attachmentCount > 1) {
            out << "\t\t" << "VkImageView " << pattachments_array << "[] = {" << pattachments_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// attachmentCount
    struct_body << "\t\t\t" << structInfo->attachmentCount << "," << std::endl;
// pAttachments
    struct_body << "\t\t\t" << pattachments_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassAttachmentBeginInfo");
    out << "\t\t" << "VkRenderPassAttachmentBeginInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassCreateInfo2(std::ostream &out, const VkRenderPassCreateInfo2* structInfo, Decoded_VkRenderPassCreateInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pattachments_array = "NULL";
    if (structInfo->pAttachments != NULL) {
        pattachments_array = "pAttachments_" + std::to_string(consumer.GetNextId());
        std::string pattachments_names;
        for (uint32_t idx = 0; idx < structInfo->attachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentDescription2(out,
                                                                        structInfo->pAttachments + idx,
                                                                        metaInfo->pAttachments->GetMetaStructPointer() + idx,
                                                                        consumer);
            }
            pattachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentDescription2 " << pattachments_array << "[] = {" << pattachments_names << "};" << std::endl;
    }
    std::string psubpasses_array = "NULL";
    if (structInfo->pSubpasses != NULL) {
        psubpasses_array = "pSubpasses_" + std::to_string(consumer.GetNextId());
        std::string psubpasses_names;
        for (uint32_t idx = 0; idx < structInfo->subpassCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pSubpasses + idx != NULL) {
                variable_name = GenerateStruct_VkSubpassDescription2(out,
                                                                     structInfo->pSubpasses + idx,
                                                                     metaInfo->pSubpasses->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            psubpasses_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSubpassDescription2 " << psubpasses_array << "[] = {" << psubpasses_names << "};" << std::endl;
    }
    std::string pdependencies_array = "NULL";
    if (structInfo->pDependencies != NULL) {
        pdependencies_array = "pDependencies_" + std::to_string(consumer.GetNextId());
        std::string pdependencies_names;
        for (uint32_t idx = 0; idx < structInfo->dependencyCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pDependencies + idx != NULL) {
                variable_name = GenerateStruct_VkSubpassDependency2(out,
                                                                    structInfo->pDependencies + idx,
                                                                    metaInfo->pDependencies->GetMetaStructPointer() + idx,
                                                                    consumer);
            }
            pdependencies_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSubpassDependency2 " << pdependencies_array << "[] = {" << pdependencies_names << "};" << std::endl;
    }
    std::string pcorrelated_view_masks_array = "NULL";
    if (structInfo->pCorrelatedViewMasks != NULL) {
        pcorrelated_view_masks_array = "pCorrelatedViewMasks_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pcorrelated_view_masks_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCorrelatedViewMasks, structInfo->correlatedViewMaskCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkRenderPassCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// attachmentCount
    struct_body << "\t\t\t" << structInfo->attachmentCount << "," << std::endl;
// pAttachments
    struct_body << "\t\t\t" << pattachments_array << "," << std::endl;
// subpassCount
    struct_body << "\t\t\t" << structInfo->subpassCount << "," << std::endl;
// pSubpasses
    struct_body << "\t\t\t" << psubpasses_array << "," << std::endl;
// dependencyCount
    struct_body << "\t\t\t" << structInfo->dependencyCount << "," << std::endl;
// pDependencies
    struct_body << "\t\t\t" << pdependencies_array << "," << std::endl;
// correlatedViewMaskCount
    struct_body << "\t\t\t" << structInfo->correlatedViewMaskCount << "," << std::endl;
// pCorrelatedViewMasks
    struct_body << "\t\t\t" << pcorrelated_view_masks_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassCreateInfo2");
    out << "\t\t" << "VkRenderPassCreateInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerReductionModeCreateInfo(std::ostream &out, const VkSamplerReductionModeCreateInfo* structInfo, Decoded_VkSamplerReductionModeCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// reductionMode
    struct_body << "\t\t\t" << "VkSamplerReductionMode(" << structInfo->reductionMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerReductionModeCreateInfo");
    out << "\t\t" << "VkSamplerReductionModeCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreSignalInfo(std::ostream &out, const VkSemaphoreSignalInfo* structInfo, Decoded_VkSemaphoreSignalInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// semaphore
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
// value
    struct_body << "\t\t\t" << structInfo->value << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreSignalInfo");
    out << "\t\t" << "VkSemaphoreSignalInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreTypeCreateInfo(std::ostream &out, const VkSemaphoreTypeCreateInfo* structInfo, Decoded_VkSemaphoreTypeCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// semaphoreType
    struct_body << "\t\t\t" << "VkSemaphoreType(" << structInfo->semaphoreType << ")" << "," << std::endl;
// initialValue
    struct_body << "\t\t\t" << structInfo->initialValue << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreTypeCreateInfo");
    out << "\t\t" << "VkSemaphoreTypeCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreWaitInfo(std::ostream &out, const VkSemaphoreWaitInfo* structInfo, Decoded_VkSemaphoreWaitInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string psemaphores_array = "NULL";
    if (metaInfo->pSemaphores.GetPointer() != NULL && structInfo->semaphoreCount > 0) {
        psemaphores_array = "psemaphores_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_SEMAPHORE));
        std::string psemaphores_values = toStringJoin(metaInfo->pSemaphores.GetPointer(),
                                                      metaInfo->pSemaphores.GetPointer() + structInfo->semaphoreCount,
                                                      [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                      ", ");
        if (structInfo->semaphoreCount == 1) {
            psemaphores_array = "&" + psemaphores_values;
        } else if (structInfo->semaphoreCount > 1) {
            out << "\t\t" << "VkSemaphore " << psemaphores_array << "[] = {" << psemaphores_values << "};" << std::endl;
        }
    }
    std::string pvalues_array = "pvalues_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->semaphoreCount > 0) {
        std::string pvalues_values = toStringJoin(structInfo->pValues,
                                                  structInfo->pValues + structInfo->semaphoreCount,
                                                  [](uint64_t current) { return std::to_string(current); },
                                                  ", ");
        if (structInfo->semaphoreCount == 1) {
            pvalues_array = "&" + pvalues_values;
        } else if (structInfo->semaphoreCount > 1) {
            out << "\t\t" << "uint64_t " << pvalues_array << "[] = {" << pvalues_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkSemaphoreWaitFlags(" << structInfo->flags << ")" << "," << std::endl;
// semaphoreCount
    struct_body << "\t\t\t" << structInfo->semaphoreCount << "," << std::endl;
// pSemaphores
    struct_body << "\t\t\t" << psemaphores_array << "," << std::endl;
// pValues
    struct_body << "\t\t\t" << "{ *" << pvalues_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreWaitInfo");
    out << "\t\t" << "VkSemaphoreWaitInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassBeginInfo(std::ostream &out, const VkSubpassBeginInfo* structInfo, Decoded_VkSubpassBeginInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// contents
    struct_body << "\t\t\t" << "VkSubpassContents(" << structInfo->contents << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassBeginInfo");
    out << "\t\t" << "VkSubpassBeginInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassDependency2(std::ostream &out, const VkSubpassDependency2* structInfo, Decoded_VkSubpassDependency2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcSubpass
    struct_body << "\t\t\t" << structInfo->srcSubpass << "," << std::endl;
// dstSubpass
    struct_body << "\t\t\t" << structInfo->dstSubpass << "," << std::endl;
// srcStageMask
    struct_body << "\t\t\t" << "VkPipelineStageFlags(" << structInfo->srcStageMask << ")" << "," << std::endl;
// dstStageMask
    struct_body << "\t\t\t" << "VkPipelineStageFlags(" << structInfo->dstStageMask << ")" << "," << std::endl;
// srcAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
// dstAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << "," << std::endl;
// dependencyFlags
    struct_body << "\t\t\t" << "VkDependencyFlags(" << structInfo->dependencyFlags << ")" << "," << std::endl;
// viewOffset
    struct_body << "\t\t\t" << structInfo->viewOffset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassDependency2");
    out << "\t\t" << "VkSubpassDependency2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassDescription2(std::ostream &out, const VkSubpassDescription2* structInfo, Decoded_VkSubpassDescription2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pinput_attachments_array = "NULL";
    if (structInfo->pInputAttachments != NULL) {
        pinput_attachments_array = "pInputAttachments_" + std::to_string(consumer.GetNextId());
        std::string pinput_attachments_names;
        for (uint32_t idx = 0; idx < structInfo->inputAttachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pInputAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentReference2(out,
                                                                      structInfo->pInputAttachments + idx,
                                                                      metaInfo->pInputAttachments->GetMetaStructPointer() + idx,
                                                                      consumer);
            }
            pinput_attachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentReference2 " << pinput_attachments_array << "[] = {" << pinput_attachments_names << "};" << std::endl;
    }
    std::string pcolor_attachments_array = "NULL";
    if (structInfo->pColorAttachments != NULL) {
        pcolor_attachments_array = "pColorAttachments_" + std::to_string(consumer.GetNextId());
        std::string pcolor_attachments_names;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pColorAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentReference2(out,
                                                                      structInfo->pColorAttachments + idx,
                                                                      metaInfo->pColorAttachments->GetMetaStructPointer() + idx,
                                                                      consumer);
            }
            pcolor_attachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentReference2 " << pcolor_attachments_array << "[] = {" << pcolor_attachments_names << "};" << std::endl;
    }
    std::string presolve_attachments_array = "NULL";
    if (structInfo->pResolveAttachments != NULL) {
        presolve_attachments_array = "pResolveAttachments_" + std::to_string(consumer.GetNextId());
        std::string presolve_attachments_names;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pResolveAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentReference2(out,
                                                                      structInfo->pResolveAttachments + idx,
                                                                      metaInfo->pResolveAttachments->GetMetaStructPointer() + idx,
                                                                      consumer);
            }
            presolve_attachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentReference2 " << presolve_attachments_array << "[] = {" << presolve_attachments_names << "};" << std::endl;
    }
    std::string pdepth_stencil_attachment_struct = "NULL";
    if (structInfo->pDepthStencilAttachment != NULL) {
        pdepth_stencil_attachment_struct = GenerateStruct_VkAttachmentReference2(out,
                                                                                 structInfo->pDepthStencilAttachment,
                                                                                 metaInfo->pDepthStencilAttachment->GetMetaStructPointer(),
                                                                                 consumer);
        pdepth_stencil_attachment_struct.insert(0, "&");
    }
    std::string ppreserve_attachments_array = "NULL";
    if (structInfo->pPreserveAttachments != NULL) {
        ppreserve_attachments_array = "pPreserveAttachments_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << ppreserve_attachments_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pPreserveAttachments, structInfo->preserveAttachmentCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkSubpassDescriptionFlags(" << structInfo->flags << ")" << "," << std::endl;
// pipelineBindPoint
    struct_body << "\t\t\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
// viewMask
    struct_body << "\t\t\t" << structInfo->viewMask << "," << std::endl;
// inputAttachmentCount
    struct_body << "\t\t\t" << structInfo->inputAttachmentCount << "," << std::endl;
// pInputAttachments
    struct_body << "\t\t\t" << pinput_attachments_array << "," << std::endl;
// colorAttachmentCount
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
// pColorAttachments
    struct_body << "\t\t\t" << pcolor_attachments_array << "," << std::endl;
// pResolveAttachments
    struct_body << "\t\t\t" << presolve_attachments_array << "," << std::endl;
// pDepthStencilAttachment
    struct_body << "\t\t\t" << pdepth_stencil_attachment_struct << "," << std::endl;
// preserveAttachmentCount
    struct_body << "\t\t\t" << structInfo->preserveAttachmentCount << "," << std::endl;
// pPreserveAttachments
    struct_body << "\t\t\t" << ppreserve_attachments_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassDescription2");
    out << "\t\t" << "VkSubpassDescription2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassDescriptionDepthStencilResolve(std::ostream &out, const VkSubpassDescriptionDepthStencilResolve* structInfo, Decoded_VkSubpassDescriptionDepthStencilResolve* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdepth_stencil_resolve_attachment_struct = "NULL";
    if (structInfo->pDepthStencilResolveAttachment != NULL) {
        pdepth_stencil_resolve_attachment_struct = GenerateStruct_VkAttachmentReference2(out,
                                                                                         structInfo->pDepthStencilResolveAttachment,
                                                                                         metaInfo->pDepthStencilResolveAttachment->GetMetaStructPointer(),
                                                                                         consumer);
        pdepth_stencil_resolve_attachment_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// depthResolveMode
    struct_body << "\t\t\t" << "VkResolveModeFlagBits(" << structInfo->depthResolveMode << ")" << "," << std::endl;
// stencilResolveMode
    struct_body << "\t\t\t" << "VkResolveModeFlagBits(" << structInfo->stencilResolveMode << ")" << "," << std::endl;
// pDepthStencilResolveAttachment
    struct_body << "\t\t\t" << pdepth_stencil_resolve_attachment_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassDescriptionDepthStencilResolve");
    out << "\t\t" << "VkSubpassDescriptionDepthStencilResolve " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassEndInfo(std::ostream &out, const VkSubpassEndInfo* structInfo, Decoded_VkSubpassEndInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassEndInfo");
    out << "\t\t" << "VkSubpassEndInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTimelineSemaphoreSubmitInfo(std::ostream &out, const VkTimelineSemaphoreSubmitInfo* structInfo, Decoded_VkTimelineSemaphoreSubmitInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pwait_semaphore_values_array = "pwait_semaphore_values_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->waitSemaphoreValueCount > 0) {
        std::string pwait_semaphore_values_values = toStringJoin(structInfo->pWaitSemaphoreValues,
                                                                 structInfo->pWaitSemaphoreValues + structInfo->waitSemaphoreValueCount,
                                                                 [](uint64_t current) { return std::to_string(current); },
                                                                 ", ");
        if (structInfo->waitSemaphoreValueCount == 1) {
            pwait_semaphore_values_array = "&" + pwait_semaphore_values_values;
        } else if (structInfo->waitSemaphoreValueCount > 1) {
            out << "\t\t" << "uint64_t " << pwait_semaphore_values_array << "[] = {" << pwait_semaphore_values_values << "};" << std::endl;
        }
    }
    std::string psignal_semaphore_values_array = "psignal_semaphore_values_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->signalSemaphoreValueCount > 0) {
        std::string psignal_semaphore_values_values = toStringJoin(structInfo->pSignalSemaphoreValues,
                                                                   structInfo->pSignalSemaphoreValues + structInfo->signalSemaphoreValueCount,
                                                                   [](uint64_t current) { return std::to_string(current); },
                                                                   ", ");
        if (structInfo->signalSemaphoreValueCount == 1) {
            psignal_semaphore_values_array = "&" + psignal_semaphore_values_values;
        } else if (structInfo->signalSemaphoreValueCount > 1) {
            out << "\t\t" << "uint64_t " << psignal_semaphore_values_array << "[] = {" << psignal_semaphore_values_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// waitSemaphoreValueCount
    struct_body << "\t\t\t" << structInfo->waitSemaphoreValueCount << "," << std::endl;
// pWaitSemaphoreValues
    struct_body << "\t\t\t" << "{ *" << pwait_semaphore_values_array << " }" << "," << std::endl;
// signalSemaphoreValueCount
    struct_body << "\t\t\t" << structInfo->signalSemaphoreValueCount << "," << std::endl;
// pSignalSemaphoreValues
    struct_body << "\t\t\t" << "{ *" << psignal_semaphore_values_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "timelineSemaphoreSubmitInfo");
    out << "\t\t" << "VkTimelineSemaphoreSubmitInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBlitImageInfo2(std::ostream &out, const VkBlitImageInfo2* structInfo, Decoded_VkBlitImageInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkImageBlit2(out,
                                                            structInfo->pRegions + idx,
                                                            metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                            consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkImageBlit2 " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcImage
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcImage) << "," << std::endl;
// srcImageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
// dstImage
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstImage) << "," << std::endl;
// dstImageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
// regionCount
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
// pRegions
    struct_body << "\t\t\t" << pregions_array << "," << std::endl;
// filter
    struct_body << "\t\t\t" << "VkFilter(" << structInfo->filter << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "blitImageInfo2");
    out << "\t\t" << "VkBlitImageInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferCopy2(std::ostream &out, const VkBufferCopy2* structInfo, Decoded_VkBufferCopy2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcOffset
    struct_body << "\t\t\t" << structInfo->srcOffset << "UL" << "," << std::endl;
// dstOffset
    struct_body << "\t\t\t" << structInfo->dstOffset << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferCopy2");
    out << "\t\t" << "VkBufferCopy2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferImageCopy2(std::ostream &out, const VkBufferImageCopy2* structInfo, Decoded_VkBufferImageCopy2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string image_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                     &structInfo->imageSubresource,
                                                                                     metaInfo->imageSubresource,
                                                                                     consumer);
    std::string image_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->imageOffset,
                                                                  metaInfo->imageOffset,
                                                                  consumer);
    std::string image_extent_info_var = GenerateStruct_VkExtent3D(out,
                                                                  &structInfo->imageExtent,
                                                                  metaInfo->imageExtent,
                                                                  consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// bufferOffset
    struct_body << "\t\t\t" << structInfo->bufferOffset << "UL" << "," << std::endl;
// bufferRowLength
    struct_body << "\t\t\t" << structInfo->bufferRowLength << "," << std::endl;
// bufferImageHeight
    struct_body << "\t\t\t" << structInfo->bufferImageHeight << "," << std::endl;
// imageSubresource
    struct_body << "\t\t\t" << image_subresource_info_var << "," << std::endl;
// imageOffset
    struct_body << "\t\t\t" << image_offset_info_var << "," << std::endl;
// imageExtent
    struct_body << "\t\t\t" << image_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferImageCopy2");
    out << "\t\t" << "VkBufferImageCopy2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferMemoryBarrier2(std::ostream &out, const VkBufferMemoryBarrier2* structInfo, Decoded_VkBufferMemoryBarrier2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcStageMask
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->srcStageMask << ")" << "," << std::endl;
// srcAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags2(" << structInfo->srcAccessMask << ")" << "," << std::endl;
// dstStageMask
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->dstStageMask << ")" << "," << std::endl;
// dstAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags2(" << structInfo->dstAccessMask << ")" << "," << std::endl;
// srcQueueFamilyIndex
    struct_body << "\t\t\t" << structInfo->srcQueueFamilyIndex << "," << std::endl;
// dstQueueFamilyIndex
    struct_body << "\t\t\t" << structInfo->dstQueueFamilyIndex << "," << std::endl;
// buffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferMemoryBarrier2");
    out << "\t\t" << "VkBufferMemoryBarrier2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferInheritanceRenderingInfo(std::ostream &out, const VkCommandBufferInheritanceRenderingInfo* structInfo, Decoded_VkCommandBufferInheritanceRenderingInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcolor_attachment_formats_values;
    std::string pcolor_attachment_formats_array = "NULL";
    if (structInfo->pColorAttachmentFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            pcolor_attachment_formats_values += util::ToString<VkFormat>(structInfo->pColorAttachmentFormats[idx]) + ", ";
        }
        pcolor_attachment_formats_array = "pColorAttachmentFormats_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkFormat " << pcolor_attachment_formats_array << "[] = {" << pcolor_attachment_formats_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkRenderingFlags(" << structInfo->flags << ")" << "," << std::endl;
// viewMask
    struct_body << "\t\t\t" << structInfo->viewMask << "," << std::endl;
// colorAttachmentCount
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
// pColorAttachmentFormats
    struct_body << "\t\t\t" << pcolor_attachment_formats_array << "," << std::endl;
// depthAttachmentFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->depthAttachmentFormat << ")" << "," << std::endl;
// stencilAttachmentFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->stencilAttachmentFormat << ")" << "," << std::endl;
// rasterizationSamples
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->rasterizationSamples << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferInheritanceRenderingInfo");
    out << "\t\t" << "VkCommandBufferInheritanceRenderingInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferSubmitInfo(std::ostream &out, const VkCommandBufferSubmitInfo* structInfo, Decoded_VkCommandBufferSubmitInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// commandBuffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->commandBuffer) << "," << std::endl;
// deviceMask
    struct_body << "\t\t\t" << structInfo->deviceMask << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferSubmitInfo");
    out << "\t\t" << "VkCommandBufferSubmitInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyBufferInfo2(std::ostream &out, const VkCopyBufferInfo2* structInfo, Decoded_VkCopyBufferInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkBufferCopy2(out,
                                                             structInfo->pRegions + idx,
                                                             metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                             consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkBufferCopy2 " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcBuffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcBuffer) << "," << std::endl;
// dstBuffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstBuffer) << "," << std::endl;
// regionCount
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
// pRegions
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyBufferInfo2");
    out << "\t\t" << "VkCopyBufferInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyBufferToImageInfo2(std::ostream &out, const VkCopyBufferToImageInfo2* structInfo, Decoded_VkCopyBufferToImageInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkBufferImageCopy2(out,
                                                                  structInfo->pRegions + idx,
                                                                  metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkBufferImageCopy2 " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcBuffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcBuffer) << "," << std::endl;
// dstImage
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstImage) << "," << std::endl;
// dstImageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
// regionCount
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
// pRegions
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyBufferToImageInfo2");
    out << "\t\t" << "VkCopyBufferToImageInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyImageInfo2(std::ostream &out, const VkCopyImageInfo2* structInfo, Decoded_VkCopyImageInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkImageCopy2(out,
                                                            structInfo->pRegions + idx,
                                                            metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                            consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkImageCopy2 " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcImage
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcImage) << "," << std::endl;
// srcImageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
// dstImage
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstImage) << "," << std::endl;
// dstImageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
// regionCount
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
// pRegions
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyImageInfo2");
    out << "\t\t" << "VkCopyImageInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyImageToBufferInfo2(std::ostream &out, const VkCopyImageToBufferInfo2* structInfo, Decoded_VkCopyImageToBufferInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkBufferImageCopy2(out,
                                                                  structInfo->pRegions + idx,
                                                                  metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkBufferImageCopy2 " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcImage
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcImage) << "," << std::endl;
// srcImageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
// dstBuffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstBuffer) << "," << std::endl;
// regionCount
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
// pRegions
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyImageToBufferInfo2");
    out << "\t\t" << "VkCopyImageToBufferInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDependencyInfo(std::ostream &out, const VkDependencyInfo* structInfo, Decoded_VkDependencyInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pmemory_barriers_array = "NULL";
    if (structInfo->pMemoryBarriers != NULL) {
        pmemory_barriers_array = "pMemoryBarriers_" + std::to_string(consumer.GetNextId());
        std::string pmemory_barriers_names;
        for (uint32_t idx = 0; idx < structInfo->memoryBarrierCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pMemoryBarriers + idx != NULL) {
                variable_name = GenerateStruct_VkMemoryBarrier2(out,
                                                                structInfo->pMemoryBarriers + idx,
                                                                metaInfo->pMemoryBarriers->GetMetaStructPointer() + idx,
                                                                consumer);
            }
            pmemory_barriers_names += variable_name + ", ";
        }
        out << "\t\t" << "VkMemoryBarrier2 " << pmemory_barriers_array << "[] = {" << pmemory_barriers_names << "};" << std::endl;
    }
    std::string pbuffer_memory_barriers_array = "NULL";
    if (structInfo->pBufferMemoryBarriers != NULL) {
        pbuffer_memory_barriers_array = "pBufferMemoryBarriers_" + std::to_string(consumer.GetNextId());
        std::string pbuffer_memory_barriers_names;
        for (uint32_t idx = 0; idx < structInfo->bufferMemoryBarrierCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pBufferMemoryBarriers + idx != NULL) {
                variable_name = GenerateStruct_VkBufferMemoryBarrier2(out,
                                                                      structInfo->pBufferMemoryBarriers + idx,
                                                                      metaInfo->pBufferMemoryBarriers->GetMetaStructPointer() + idx,
                                                                      consumer);
            }
            pbuffer_memory_barriers_names += variable_name + ", ";
        }
        out << "\t\t" << "VkBufferMemoryBarrier2 " << pbuffer_memory_barriers_array << "[] = {" << pbuffer_memory_barriers_names << "};" << std::endl;
    }
    std::string pimage_memory_barriers_array = "NULL";
    if (structInfo->pImageMemoryBarriers != NULL) {
        pimage_memory_barriers_array = "pImageMemoryBarriers_" + std::to_string(consumer.GetNextId());
        std::string pimage_memory_barriers_names;
        for (uint32_t idx = 0; idx < structInfo->imageMemoryBarrierCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pImageMemoryBarriers + idx != NULL) {
                variable_name = GenerateStruct_VkImageMemoryBarrier2(out,
                                                                     structInfo->pImageMemoryBarriers + idx,
                                                                     metaInfo->pImageMemoryBarriers->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            pimage_memory_barriers_names += variable_name + ", ";
        }
        out << "\t\t" << "VkImageMemoryBarrier2 " << pimage_memory_barriers_array << "[] = {" << pimage_memory_barriers_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// dependencyFlags
    struct_body << "\t\t\t" << "VkDependencyFlags(" << structInfo->dependencyFlags << ")" << "," << std::endl;
// memoryBarrierCount
    struct_body << "\t\t\t" << structInfo->memoryBarrierCount << "," << std::endl;
// pMemoryBarriers
    struct_body << "\t\t\t" << pmemory_barriers_array << "," << std::endl;
// bufferMemoryBarrierCount
    struct_body << "\t\t\t" << structInfo->bufferMemoryBarrierCount << "," << std::endl;
// pBufferMemoryBarriers
    struct_body << "\t\t\t" << pbuffer_memory_barriers_array << "," << std::endl;
// imageMemoryBarrierCount
    struct_body << "\t\t\t" << structInfo->imageMemoryBarrierCount << "," << std::endl;
// pImageMemoryBarriers
    struct_body << "\t\t\t" << pimage_memory_barriers_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dependencyInfo");
    out << "\t\t" << "VkDependencyInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorPoolInlineUniformBlockCreateInfo(std::ostream &out, const VkDescriptorPoolInlineUniformBlockCreateInfo* structInfo, Decoded_VkDescriptorPoolInlineUniformBlockCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxInlineUniformBlockBindings
    struct_body << "\t\t\t" << structInfo->maxInlineUniformBlockBindings << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorPoolInlineUniformBlockCreateInfo");
    out << "\t\t" << "VkDescriptorPoolInlineUniformBlockCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceBufferMemoryRequirements(std::ostream &out, const VkDeviceBufferMemoryRequirements* structInfo, Decoded_VkDeviceBufferMemoryRequirements* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcreate_info_struct = "NULL";
    if (structInfo->pCreateInfo != NULL) {
        pcreate_info_struct = GenerateStruct_VkBufferCreateInfo(out,
                                                                structInfo->pCreateInfo,
                                                                metaInfo->pCreateInfo->GetMetaStructPointer(),
                                                                consumer);
        pcreate_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pCreateInfo
    struct_body << "\t\t\t" << pcreate_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceBufferMemoryRequirements");
    out << "\t\t" << "VkDeviceBufferMemoryRequirements " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceImageMemoryRequirements(std::ostream &out, const VkDeviceImageMemoryRequirements* structInfo, Decoded_VkDeviceImageMemoryRequirements* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcreate_info_struct = "NULL";
    if (structInfo->pCreateInfo != NULL) {
        pcreate_info_struct = GenerateStruct_VkImageCreateInfo(out,
                                                               structInfo->pCreateInfo,
                                                               metaInfo->pCreateInfo->GetMetaStructPointer(),
                                                               consumer);
        pcreate_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pCreateInfo
    struct_body << "\t\t\t" << pcreate_info_struct << "," << std::endl;
// planeAspect
    struct_body << "\t\t\t" << "VkImageAspectFlagBits(" << structInfo->planeAspect << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceImageMemoryRequirements");
    out << "\t\t" << "VkDeviceImageMemoryRequirements " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDevicePrivateDataCreateInfo(std::ostream &out, const VkDevicePrivateDataCreateInfo* structInfo, Decoded_VkDevicePrivateDataCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// privateDataSlotRequestCount
    struct_body << "\t\t\t" << structInfo->privateDataSlotRequestCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "devicePrivateDataCreateInfo");
    out << "\t\t" << "VkDevicePrivateDataCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFormatProperties3(std::ostream &out, const VkFormatProperties3* structInfo, Decoded_VkFormatProperties3* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// linearTilingFeatures
    struct_body << "\t\t\t" << "VkFormatFeatureFlags2(" << structInfo->linearTilingFeatures << ")" << "," << std::endl;
// optimalTilingFeatures
    struct_body << "\t\t\t" << "VkFormatFeatureFlags2(" << structInfo->optimalTilingFeatures << ")" << "," << std::endl;
// bufferFeatures
    struct_body << "\t\t\t" << "VkFormatFeatureFlags2(" << structInfo->bufferFeatures << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "formatProperties3");
    out << "\t\t" << "VkFormatProperties3 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageBlit2(std::ostream &out, const VkImageBlit2* structInfo, Decoded_VkImageBlit2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string src_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->srcSubresource,
                                                                                   metaInfo->srcSubresource,
                                                                                   consumer);
    std::string dst_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->dstSubresource,
                                                                                   metaInfo->dstSubresource,
                                                                                   consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcSubresource
    struct_body << "\t\t\t" << src_subresource_info_var << "," << std::endl;
// srcOffsets
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkOffset3D*>(&structInfo->srcOffsets[0]), 2) << "," << std::endl;
// dstSubresource
    struct_body << "\t\t\t" << dst_subresource_info_var << "," << std::endl;
// dstOffsets
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkOffset3D*>(&structInfo->dstOffsets[0]), 2) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageBlit2");
    out << "\t\t" << "VkImageBlit2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageCopy2(std::ostream &out, const VkImageCopy2* structInfo, Decoded_VkImageCopy2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string src_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->srcSubresource,
                                                                                   metaInfo->srcSubresource,
                                                                                   consumer);
    std::string src_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->srcOffset,
                                                                metaInfo->srcOffset,
                                                                consumer);
    std::string dst_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->dstSubresource,
                                                                                   metaInfo->dstSubresource,
                                                                                   consumer);
    std::string dst_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->dstOffset,
                                                                metaInfo->dstOffset,
                                                                consumer);
    std::string extent_info_var = GenerateStruct_VkExtent3D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcSubresource
    struct_body << "\t\t\t" << src_subresource_info_var << "," << std::endl;
// srcOffset
    struct_body << "\t\t\t" << src_offset_info_var << "," << std::endl;
// dstSubresource
    struct_body << "\t\t\t" << dst_subresource_info_var << "," << std::endl;
// dstOffset
    struct_body << "\t\t\t" << dst_offset_info_var << "," << std::endl;
// extent
    struct_body << "\t\t\t" << extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageCopy2");
    out << "\t\t" << "VkImageCopy2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageMemoryBarrier2(std::ostream &out, const VkImageMemoryBarrier2* structInfo, Decoded_VkImageMemoryBarrier2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string subresource_range_info_var = GenerateStruct_VkImageSubresourceRange(out,
                                                                                    &structInfo->subresourceRange,
                                                                                    metaInfo->subresourceRange,
                                                                                    consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcStageMask
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->srcStageMask << ")" << "," << std::endl;
// srcAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags2(" << structInfo->srcAccessMask << ")" << "," << std::endl;
// dstStageMask
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->dstStageMask << ")" << "," << std::endl;
// dstAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags2(" << structInfo->dstAccessMask << ")" << "," << std::endl;
// oldLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->oldLayout << ")" << "," << std::endl;
// newLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->newLayout << ")" << "," << std::endl;
// srcQueueFamilyIndex
    struct_body << "\t\t\t" << structInfo->srcQueueFamilyIndex << "," << std::endl;
// dstQueueFamilyIndex
    struct_body << "\t\t\t" << structInfo->dstQueueFamilyIndex << "," << std::endl;
// image
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
// subresourceRange
    struct_body << "\t\t\t" << subresource_range_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageMemoryBarrier2");
    out << "\t\t" << "VkImageMemoryBarrier2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageResolve2(std::ostream &out, const VkImageResolve2* structInfo, Decoded_VkImageResolve2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string src_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->srcSubresource,
                                                                                   metaInfo->srcSubresource,
                                                                                   consumer);
    std::string src_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->srcOffset,
                                                                metaInfo->srcOffset,
                                                                consumer);
    std::string dst_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->dstSubresource,
                                                                                   metaInfo->dstSubresource,
                                                                                   consumer);
    std::string dst_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->dstOffset,
                                                                metaInfo->dstOffset,
                                                                consumer);
    std::string extent_info_var = GenerateStruct_VkExtent3D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcSubresource
    struct_body << "\t\t\t" << src_subresource_info_var << "," << std::endl;
// srcOffset
    struct_body << "\t\t\t" << src_offset_info_var << "," << std::endl;
// dstSubresource
    struct_body << "\t\t\t" << dst_subresource_info_var << "," << std::endl;
// dstOffset
    struct_body << "\t\t\t" << dst_offset_info_var << "," << std::endl;
// extent
    struct_body << "\t\t\t" << extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageResolve2");
    out << "\t\t" << "VkImageResolve2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryBarrier2(std::ostream &out, const VkMemoryBarrier2* structInfo, Decoded_VkMemoryBarrier2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcStageMask
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->srcStageMask << ")" << "," << std::endl;
// srcAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags2(" << structInfo->srcAccessMask << ")" << "," << std::endl;
// dstStageMask
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->dstStageMask << ")" << "," << std::endl;
// dstAccessMask
    struct_body << "\t\t\t" << "VkAccessFlags2(" << structInfo->dstAccessMask << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryBarrier2");
    out << "\t\t" << "VkMemoryBarrier2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDynamicRenderingFeatures(std::ostream &out, const VkPhysicalDeviceDynamicRenderingFeatures* structInfo, Decoded_VkPhysicalDeviceDynamicRenderingFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// dynamicRendering
    struct_body << "\t\t\t" << structInfo->dynamicRendering << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDynamicRenderingFeatures");
    out << "\t\t" << "VkPhysicalDeviceDynamicRenderingFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageRobustnessFeatures(std::ostream &out, const VkPhysicalDeviceImageRobustnessFeatures* structInfo, Decoded_VkPhysicalDeviceImageRobustnessFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// robustImageAccess
    struct_body << "\t\t\t" << structInfo->robustImageAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageRobustnessFeatures");
    out << "\t\t" << "VkPhysicalDeviceImageRobustnessFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceInlineUniformBlockFeatures(std::ostream &out, const VkPhysicalDeviceInlineUniformBlockFeatures* structInfo, Decoded_VkPhysicalDeviceInlineUniformBlockFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// inlineUniformBlock
    struct_body << "\t\t\t" << structInfo->inlineUniformBlock << "," << std::endl;
// descriptorBindingInlineUniformBlockUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingInlineUniformBlockUpdateAfterBind << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceInlineUniformBlockFeatures");
    out << "\t\t" << "VkPhysicalDeviceInlineUniformBlockFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceInlineUniformBlockProperties(std::ostream &out, const VkPhysicalDeviceInlineUniformBlockProperties* structInfo, Decoded_VkPhysicalDeviceInlineUniformBlockProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxInlineUniformBlockSize
    struct_body << "\t\t\t" << structInfo->maxInlineUniformBlockSize << "," << std::endl;
// maxPerStageDescriptorInlineUniformBlocks
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorInlineUniformBlocks << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks << "," << std::endl;
// maxDescriptorSetInlineUniformBlocks
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetInlineUniformBlocks << "," << std::endl;
// maxDescriptorSetUpdateAfterBindInlineUniformBlocks
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindInlineUniformBlocks << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceInlineUniformBlockProperties");
    out << "\t\t" << "VkPhysicalDeviceInlineUniformBlockProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance4Features(std::ostream &out, const VkPhysicalDeviceMaintenance4Features* structInfo, Decoded_VkPhysicalDeviceMaintenance4Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maintenance4
    struct_body << "\t\t\t" << structInfo->maintenance4 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance4Features");
    out << "\t\t" << "VkPhysicalDeviceMaintenance4Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance4Properties(std::ostream &out, const VkPhysicalDeviceMaintenance4Properties* structInfo, Decoded_VkPhysicalDeviceMaintenance4Properties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxBufferSize
    struct_body << "\t\t\t" << structInfo->maxBufferSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance4Properties");
    out << "\t\t" << "VkPhysicalDeviceMaintenance4Properties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineCreationCacheControlFeatures(std::ostream &out, const VkPhysicalDevicePipelineCreationCacheControlFeatures* structInfo, Decoded_VkPhysicalDevicePipelineCreationCacheControlFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pipelineCreationCacheControl
    struct_body << "\t\t\t" << structInfo->pipelineCreationCacheControl << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineCreationCacheControlFeatures");
    out << "\t\t" << "VkPhysicalDevicePipelineCreationCacheControlFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePrivateDataFeatures(std::ostream &out, const VkPhysicalDevicePrivateDataFeatures* structInfo, Decoded_VkPhysicalDevicePrivateDataFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// privateData
    struct_body << "\t\t\t" << structInfo->privateData << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePrivateDataFeatures");
    out << "\t\t" << "VkPhysicalDevicePrivateDataFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(std::ostream &out, const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* structInfo, Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderDemoteToHelperInvocation
    struct_body << "\t\t\t" << structInfo->shaderDemoteToHelperInvocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderDemoteToHelperInvocationFeatures");
    out << "\t\t" << "VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderIntegerDotProductFeatures(std::ostream &out, const VkPhysicalDeviceShaderIntegerDotProductFeatures* structInfo, Decoded_VkPhysicalDeviceShaderIntegerDotProductFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderIntegerDotProduct
    struct_body << "\t\t\t" << structInfo->shaderIntegerDotProduct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderIntegerDotProductFeatures");
    out << "\t\t" << "VkPhysicalDeviceShaderIntegerDotProductFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderIntegerDotProductProperties(std::ostream &out, const VkPhysicalDeviceShaderIntegerDotProductProperties* structInfo, Decoded_VkPhysicalDeviceShaderIntegerDotProductProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// integerDotProduct8BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct8BitUnsignedAccelerated << "," << std::endl;
// integerDotProduct8BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct8BitSignedAccelerated << "," << std::endl;
// integerDotProduct8BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct8BitMixedSignednessAccelerated << "," << std::endl;
// integerDotProduct4x8BitPackedUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct4x8BitPackedUnsignedAccelerated << "," << std::endl;
// integerDotProduct4x8BitPackedSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct4x8BitPackedSignedAccelerated << "," << std::endl;
// integerDotProduct4x8BitPackedMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct4x8BitPackedMixedSignednessAccelerated << "," << std::endl;
// integerDotProduct16BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct16BitUnsignedAccelerated << "," << std::endl;
// integerDotProduct16BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct16BitSignedAccelerated << "," << std::endl;
// integerDotProduct16BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct16BitMixedSignednessAccelerated << "," << std::endl;
// integerDotProduct32BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct32BitUnsignedAccelerated << "," << std::endl;
// integerDotProduct32BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct32BitSignedAccelerated << "," << std::endl;
// integerDotProduct32BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct32BitMixedSignednessAccelerated << "," << std::endl;
// integerDotProduct64BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct64BitUnsignedAccelerated << "," << std::endl;
// integerDotProduct64BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct64BitSignedAccelerated << "," << std::endl;
// integerDotProduct64BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct64BitMixedSignednessAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating8BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating8BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating8BitSignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating16BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating16BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating16BitSignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating32BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating32BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating32BitSignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating64BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating64BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating64BitSignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderIntegerDotProductProperties");
    out << "\t\t" << "VkPhysicalDeviceShaderIntegerDotProductProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderTerminateInvocationFeatures(std::ostream &out, const VkPhysicalDeviceShaderTerminateInvocationFeatures* structInfo, Decoded_VkPhysicalDeviceShaderTerminateInvocationFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderTerminateInvocation
    struct_body << "\t\t\t" << structInfo->shaderTerminateInvocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderTerminateInvocationFeatures");
    out << "\t\t" << "VkPhysicalDeviceShaderTerminateInvocationFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSubgroupSizeControlFeatures(std::ostream &out, const VkPhysicalDeviceSubgroupSizeControlFeatures* structInfo, Decoded_VkPhysicalDeviceSubgroupSizeControlFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// subgroupSizeControl
    struct_body << "\t\t\t" << structInfo->subgroupSizeControl << "," << std::endl;
// computeFullSubgroups
    struct_body << "\t\t\t" << structInfo->computeFullSubgroups << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSubgroupSizeControlFeatures");
    out << "\t\t" << "VkPhysicalDeviceSubgroupSizeControlFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSubgroupSizeControlProperties(std::ostream &out, const VkPhysicalDeviceSubgroupSizeControlProperties* structInfo, Decoded_VkPhysicalDeviceSubgroupSizeControlProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// minSubgroupSize
    struct_body << "\t\t\t" << structInfo->minSubgroupSize << "," << std::endl;
// maxSubgroupSize
    struct_body << "\t\t\t" << structInfo->maxSubgroupSize << "," << std::endl;
// maxComputeWorkgroupSubgroups
    struct_body << "\t\t\t" << structInfo->maxComputeWorkgroupSubgroups << "," << std::endl;
// requiredSubgroupSizeStages
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->requiredSubgroupSizeStages << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSubgroupSizeControlProperties");
    out << "\t\t" << "VkPhysicalDeviceSubgroupSizeControlProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSynchronization2Features(std::ostream &out, const VkPhysicalDeviceSynchronization2Features* structInfo, Decoded_VkPhysicalDeviceSynchronization2Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// synchronization2
    struct_body << "\t\t\t" << structInfo->synchronization2 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSynchronization2Features");
    out << "\t\t" << "VkPhysicalDeviceSynchronization2Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTexelBufferAlignmentProperties(std::ostream &out, const VkPhysicalDeviceTexelBufferAlignmentProperties* structInfo, Decoded_VkPhysicalDeviceTexelBufferAlignmentProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// storageTexelBufferOffsetAlignmentBytes
    struct_body << "\t\t\t" << structInfo->storageTexelBufferOffsetAlignmentBytes << "UL" << "," << std::endl;
// storageTexelBufferOffsetSingleTexelAlignment
    struct_body << "\t\t\t" << structInfo->storageTexelBufferOffsetSingleTexelAlignment << "," << std::endl;
// uniformTexelBufferOffsetAlignmentBytes
    struct_body << "\t\t\t" << structInfo->uniformTexelBufferOffsetAlignmentBytes << "UL" << "," << std::endl;
// uniformTexelBufferOffsetSingleTexelAlignment
    struct_body << "\t\t\t" << structInfo->uniformTexelBufferOffsetSingleTexelAlignment << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTexelBufferAlignmentProperties");
    out << "\t\t" << "VkPhysicalDeviceTexelBufferAlignmentProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(std::ostream &out, const VkPhysicalDeviceTextureCompressionASTCHDRFeatures* structInfo, Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// textureCompressionASTC_HDR
    struct_body << "\t\t\t" << structInfo->textureCompressionASTC_HDR << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTextureCompressionASTCHDRFeatures");
    out << "\t\t" << "VkPhysicalDeviceTextureCompressionASTCHDRFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceToolProperties(std::ostream &out, const VkPhysicalDeviceToolProperties* structInfo, Decoded_VkPhysicalDeviceToolProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// name
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->name) << "," << std::endl;
// version
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->version) << "," << std::endl;
// purposes
    struct_body << "\t\t\t" << "VkToolPurposeFlags(" << structInfo->purposes << ")" << "," << std::endl;
// description
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << "," << std::endl;
// layer
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->layer) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceToolProperties");
    out << "\t\t" << "VkPhysicalDeviceToolProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan13Features(std::ostream &out, const VkPhysicalDeviceVulkan13Features* structInfo, Decoded_VkPhysicalDeviceVulkan13Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// robustImageAccess
    struct_body << "\t\t\t" << structInfo->robustImageAccess << "," << std::endl;
// inlineUniformBlock
    struct_body << "\t\t\t" << structInfo->inlineUniformBlock << "," << std::endl;
// descriptorBindingInlineUniformBlockUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingInlineUniformBlockUpdateAfterBind << "," << std::endl;
// pipelineCreationCacheControl
    struct_body << "\t\t\t" << structInfo->pipelineCreationCacheControl << "," << std::endl;
// privateData
    struct_body << "\t\t\t" << structInfo->privateData << "," << std::endl;
// shaderDemoteToHelperInvocation
    struct_body << "\t\t\t" << structInfo->shaderDemoteToHelperInvocation << "," << std::endl;
// shaderTerminateInvocation
    struct_body << "\t\t\t" << structInfo->shaderTerminateInvocation << "," << std::endl;
// subgroupSizeControl
    struct_body << "\t\t\t" << structInfo->subgroupSizeControl << "," << std::endl;
// computeFullSubgroups
    struct_body << "\t\t\t" << structInfo->computeFullSubgroups << "," << std::endl;
// synchronization2
    struct_body << "\t\t\t" << structInfo->synchronization2 << "," << std::endl;
// textureCompressionASTC_HDR
    struct_body << "\t\t\t" << structInfo->textureCompressionASTC_HDR << "," << std::endl;
// shaderZeroInitializeWorkgroupMemory
    struct_body << "\t\t\t" << structInfo->shaderZeroInitializeWorkgroupMemory << "," << std::endl;
// dynamicRendering
    struct_body << "\t\t\t" << structInfo->dynamicRendering << "," << std::endl;
// shaderIntegerDotProduct
    struct_body << "\t\t\t" << structInfo->shaderIntegerDotProduct << "," << std::endl;
// maintenance4
    struct_body << "\t\t\t" << structInfo->maintenance4 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkan13Features");
    out << "\t\t" << "VkPhysicalDeviceVulkan13Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan13Properties(std::ostream &out, const VkPhysicalDeviceVulkan13Properties* structInfo, Decoded_VkPhysicalDeviceVulkan13Properties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// minSubgroupSize
    struct_body << "\t\t\t" << structInfo->minSubgroupSize << "," << std::endl;
// maxSubgroupSize
    struct_body << "\t\t\t" << structInfo->maxSubgroupSize << "," << std::endl;
// maxComputeWorkgroupSubgroups
    struct_body << "\t\t\t" << structInfo->maxComputeWorkgroupSubgroups << "," << std::endl;
// requiredSubgroupSizeStages
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->requiredSubgroupSizeStages << ")" << "," << std::endl;
// maxInlineUniformBlockSize
    struct_body << "\t\t\t" << structInfo->maxInlineUniformBlockSize << "," << std::endl;
// maxPerStageDescriptorInlineUniformBlocks
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorInlineUniformBlocks << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks << "," << std::endl;
// maxDescriptorSetInlineUniformBlocks
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetInlineUniformBlocks << "," << std::endl;
// maxDescriptorSetUpdateAfterBindInlineUniformBlocks
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindInlineUniformBlocks << "," << std::endl;
// maxInlineUniformTotalSize
    struct_body << "\t\t\t" << structInfo->maxInlineUniformTotalSize << "," << std::endl;
// integerDotProduct8BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct8BitUnsignedAccelerated << "," << std::endl;
// integerDotProduct8BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct8BitSignedAccelerated << "," << std::endl;
// integerDotProduct8BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct8BitMixedSignednessAccelerated << "," << std::endl;
// integerDotProduct4x8BitPackedUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct4x8BitPackedUnsignedAccelerated << "," << std::endl;
// integerDotProduct4x8BitPackedSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct4x8BitPackedSignedAccelerated << "," << std::endl;
// integerDotProduct4x8BitPackedMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct4x8BitPackedMixedSignednessAccelerated << "," << std::endl;
// integerDotProduct16BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct16BitUnsignedAccelerated << "," << std::endl;
// integerDotProduct16BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct16BitSignedAccelerated << "," << std::endl;
// integerDotProduct16BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct16BitMixedSignednessAccelerated << "," << std::endl;
// integerDotProduct32BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct32BitUnsignedAccelerated << "," << std::endl;
// integerDotProduct32BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct32BitSignedAccelerated << "," << std::endl;
// integerDotProduct32BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct32BitMixedSignednessAccelerated << "," << std::endl;
// integerDotProduct64BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct64BitUnsignedAccelerated << "," << std::endl;
// integerDotProduct64BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct64BitSignedAccelerated << "," << std::endl;
// integerDotProduct64BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProduct64BitMixedSignednessAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating8BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating8BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating8BitSignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating16BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating16BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating16BitSignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating32BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating32BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating32BitSignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating64BitUnsignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating64BitSignedAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating64BitSignedAccelerated << "," << std::endl;
// integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated << "," << std::endl;
// storageTexelBufferOffsetAlignmentBytes
    struct_body << "\t\t\t" << structInfo->storageTexelBufferOffsetAlignmentBytes << "UL" << "," << std::endl;
// storageTexelBufferOffsetSingleTexelAlignment
    struct_body << "\t\t\t" << structInfo->storageTexelBufferOffsetSingleTexelAlignment << "," << std::endl;
// uniformTexelBufferOffsetAlignmentBytes
    struct_body << "\t\t\t" << structInfo->uniformTexelBufferOffsetAlignmentBytes << "UL" << "," << std::endl;
// uniformTexelBufferOffsetSingleTexelAlignment
    struct_body << "\t\t\t" << structInfo->uniformTexelBufferOffsetSingleTexelAlignment << "," << std::endl;
// maxBufferSize
    struct_body << "\t\t\t" << structInfo->maxBufferSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkan13Properties");
    out << "\t\t" << "VkPhysicalDeviceVulkan13Properties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(std::ostream &out, const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* structInfo, Decoded_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderZeroInitializeWorkgroupMemory
    struct_body << "\t\t\t" << structInfo->shaderZeroInitializeWorkgroupMemory << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceZeroInitializeWorkgroupMemoryFeatures");
    out << "\t\t" << "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCreationFeedback(std::ostream &out, const VkPipelineCreationFeedback* structInfo, Decoded_VkPipelineCreationFeedback* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// flags
    struct_body << "\t" << "VkPipelineCreationFeedbackFlags(" << structInfo->flags << ")" << "," << std::endl;
// duration
    struct_body << "\t\t\t" << structInfo->duration << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCreationFeedback");
    out << "\t\t" << "VkPipelineCreationFeedback " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCreationFeedbackCreateInfo(std::ostream &out, const VkPipelineCreationFeedbackCreateInfo* structInfo, Decoded_VkPipelineCreationFeedbackCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppipeline_stage_creation_feedbacks_array = "NULL";
    if (structInfo->pPipelineStageCreationFeedbacks != NULL) {
        ppipeline_stage_creation_feedbacks_array = "pPipelineStageCreationFeedbacks_" + std::to_string(consumer.GetNextId());
        std::string ppipeline_stage_creation_feedbacks_names;
        for (uint32_t idx = 0; idx < structInfo->pipelineStageCreationFeedbackCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPipelineStageCreationFeedbacks + idx != NULL) {
                variable_name = GenerateStruct_VkPipelineCreationFeedback(out,
                                                                          structInfo->pPipelineStageCreationFeedbacks + idx,
                                                                          metaInfo->pPipelineStageCreationFeedbacks->GetMetaStructPointer() + idx,
                                                                          consumer);
            }
            ppipeline_stage_creation_feedbacks_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPipelineCreationFeedback " << ppipeline_stage_creation_feedbacks_array << "[] = {" << ppipeline_stage_creation_feedbacks_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pPipelineCreationFeedback
    out << "\t\t" << "// TODO: Support pPipelineCreationFeedback (output?) argument." << std::endl;
// pipelineStageCreationFeedbackCount
    struct_body << "\t\t\t" << structInfo->pipelineStageCreationFeedbackCount << "," << std::endl;
// pPipelineStageCreationFeedbacks
    struct_body << "\t\t\t" << ppipeline_stage_creation_feedbacks_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCreationFeedbackCreateInfo");
    out << "\t\t" << "VkPipelineCreationFeedbackCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRenderingCreateInfo(std::ostream &out, const VkPipelineRenderingCreateInfo* structInfo, Decoded_VkPipelineRenderingCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcolor_attachment_formats_values;
    std::string pcolor_attachment_formats_array = "NULL";
    if (structInfo->pColorAttachmentFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            pcolor_attachment_formats_values += util::ToString<VkFormat>(structInfo->pColorAttachmentFormats[idx]) + ", ";
        }
        pcolor_attachment_formats_array = "pColorAttachmentFormats_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkFormat " << pcolor_attachment_formats_array << "[] = {" << pcolor_attachment_formats_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// viewMask
    struct_body << "\t\t\t" << structInfo->viewMask << "," << std::endl;
// colorAttachmentCount
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
// pColorAttachmentFormats
    struct_body << "\t\t\t" << pcolor_attachment_formats_array << "," << std::endl;
// depthAttachmentFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->depthAttachmentFormat << ")" << "," << std::endl;
// stencilAttachmentFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->stencilAttachmentFormat << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRenderingCreateInfo");
    out << "\t\t" << "VkPipelineRenderingCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(std::ostream &out, const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* structInfo, Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// requiredSubgroupSize
    struct_body << "\t\t\t" << structInfo->requiredSubgroupSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineShaderStageRequiredSubgroupSizeCreateInfo");
    out << "\t\t" << "VkPipelineShaderStageRequiredSubgroupSizeCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPrivateDataSlotCreateInfo(std::ostream &out, const VkPrivateDataSlotCreateInfo* structInfo, Decoded_VkPrivateDataSlotCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPrivateDataSlotCreateFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "privateDataSlotCreateInfo");
    out << "\t\t" << "VkPrivateDataSlotCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderingAttachmentInfo(std::ostream &out, const VkRenderingAttachmentInfo* structInfo, Decoded_VkRenderingAttachmentInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// imageView
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->imageView) << "," << std::endl;
// imageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->imageLayout << ")" << "," << std::endl;
// resolveMode
    struct_body << "\t\t\t" << "VkResolveModeFlagBits(" << structInfo->resolveMode << ")" << "," << std::endl;
// resolveImageView
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->resolveImageView) << "," << std::endl;
// resolveImageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->resolveImageLayout << ")" << "," << std::endl;
// loadOp
    struct_body << "\t\t\t" << "VkAttachmentLoadOp(" << structInfo->loadOp << ")" << "," << std::endl;
// storeOp
    struct_body << "\t\t\t" << "VkAttachmentStoreOp(" << structInfo->storeOp << ")" << "," << std::endl;
// clearValue
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(structInfo->clearValue) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderingAttachmentInfo");
    out << "\t\t" << "VkRenderingAttachmentInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderingInfo(std::ostream &out, const VkRenderingInfo* structInfo, Decoded_VkRenderingInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string render_area_info_var = GenerateStruct_VkRect2D(out,
                                                               &structInfo->renderArea,
                                                               metaInfo->renderArea,
                                                               consumer);
    std::string pcolor_attachments_array = "NULL";
    if (structInfo->pColorAttachments != NULL) {
        pcolor_attachments_array = "pColorAttachments_" + std::to_string(consumer.GetNextId());
        std::string pcolor_attachments_names;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pColorAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkRenderingAttachmentInfo(out,
                                                                         structInfo->pColorAttachments + idx,
                                                                         metaInfo->pColorAttachments->GetMetaStructPointer() + idx,
                                                                         consumer);
            }
            pcolor_attachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkRenderingAttachmentInfo " << pcolor_attachments_array << "[] = {" << pcolor_attachments_names << "};" << std::endl;
    }
    std::string pdepth_attachment_struct = "NULL";
    if (structInfo->pDepthAttachment != NULL) {
        pdepth_attachment_struct = GenerateStruct_VkRenderingAttachmentInfo(out,
                                                                            structInfo->pDepthAttachment,
                                                                            metaInfo->pDepthAttachment->GetMetaStructPointer(),
                                                                            consumer);
        pdepth_attachment_struct.insert(0, "&");
    }
    std::string pstencil_attachment_struct = "NULL";
    if (structInfo->pStencilAttachment != NULL) {
        pstencil_attachment_struct = GenerateStruct_VkRenderingAttachmentInfo(out,
                                                                              structInfo->pStencilAttachment,
                                                                              metaInfo->pStencilAttachment->GetMetaStructPointer(),
                                                                              consumer);
        pstencil_attachment_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkRenderingFlags(" << structInfo->flags << ")" << "," << std::endl;
// renderArea
    struct_body << "\t\t\t" << render_area_info_var << "," << std::endl;
// layerCount
    struct_body << "\t\t\t" << structInfo->layerCount << "," << std::endl;
// viewMask
    struct_body << "\t\t\t" << structInfo->viewMask << "," << std::endl;
// colorAttachmentCount
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
// pColorAttachments
    struct_body << "\t\t\t" << pcolor_attachments_array << "," << std::endl;
// pDepthAttachment
    struct_body << "\t\t\t" << pdepth_attachment_struct << "," << std::endl;
// pStencilAttachment
    struct_body << "\t\t\t" << pstencil_attachment_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderingInfo");
    out << "\t\t" << "VkRenderingInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkResolveImageInfo2(std::ostream &out, const VkResolveImageInfo2* structInfo, Decoded_VkResolveImageInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkImageResolve2(out,
                                                               structInfo->pRegions + idx,
                                                               metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                               consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkImageResolve2 " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcImage
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcImage) << "," << std::endl;
// srcImageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
// dstImage
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstImage) << "," << std::endl;
// dstImageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
// regionCount
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
// pRegions
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "resolveImageInfo2");
    out << "\t\t" << "VkResolveImageInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreSubmitInfo(std::ostream &out, const VkSemaphoreSubmitInfo* structInfo, Decoded_VkSemaphoreSubmitInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// semaphore
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
// value
    struct_body << "\t\t\t" << structInfo->value << "UL" << "," << std::endl;
// stageMask
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->stageMask << ")" << "," << std::endl;
// deviceIndex
    struct_body << "\t\t\t" << structInfo->deviceIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreSubmitInfo");
    out << "\t\t" << "VkSemaphoreSubmitInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWriteDescriptorSetInlineUniformBlock(std::ostream &out, const VkWriteDescriptorSetInlineUniformBlock* structInfo, Decoded_VkWriteDescriptorSetInlineUniformBlock* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdata_array = "NULL";
    if (structInfo->pData != NULL) {
        std::string pdata_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->dataSize; ++idx0) {
            pdata_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pData)[idx0]) + ", ";
        }
        pdata_array = "pData_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pdata_array << "[] = {" << pdata_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// dataSize
    struct_body << "\t\t\t" << structInfo->dataSize << "," << std::endl;
// pData
    struct_body << "\t\t\t" << pdata_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "writeDescriptorSetInlineUniformBlock");
    out << "\t\t" << "VkWriteDescriptorSetInlineUniformBlock " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceCapabilitiesKHR(std::ostream &out, const VkSurfaceCapabilitiesKHR* structInfo, Decoded_VkSurfaceCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string current_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->currentExtent,
                                                                    metaInfo->currentExtent,
                                                                    consumer);
    std::string min_image_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->minImageExtent,
                                                                      metaInfo->minImageExtent,
                                                                      consumer);
    std::string max_image_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->maxImageExtent,
                                                                      metaInfo->maxImageExtent,
                                                                      consumer);
// minImageCount
    struct_body << "\t" << structInfo->minImageCount << "," << std::endl;
// maxImageCount
    struct_body << "\t\t\t" << structInfo->maxImageCount << "," << std::endl;
// currentExtent
    struct_body << "\t\t\t" << current_extent_info_var << "," << std::endl;
// minImageExtent
    struct_body << "\t\t\t" << min_image_extent_info_var << "," << std::endl;
// maxImageExtent
    struct_body << "\t\t\t" << max_image_extent_info_var << "," << std::endl;
// maxImageArrayLayers
    struct_body << "\t\t\t" << structInfo->maxImageArrayLayers << "," << std::endl;
// supportedTransforms
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagsKHR(" << structInfo->supportedTransforms << ")" << "," << std::endl;
// currentTransform
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->currentTransform << ")" << "," << std::endl;
// supportedCompositeAlpha
    struct_body << "\t\t\t" << "VkCompositeAlphaFlagsKHR(" << structInfo->supportedCompositeAlpha << ")" << "," << std::endl;
// supportedUsageFlags
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->supportedUsageFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceCapabilitiesKHR");
    out << "\t\t" << "VkSurfaceCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceFormatKHR(std::ostream &out, const VkSurfaceFormatKHR* structInfo, Decoded_VkSurfaceFormatKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// format
    struct_body << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
// colorSpace
    struct_body << "\t\t\t" << "VkColorSpaceKHR(" << structInfo->colorSpace << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceFormatKHR");
    out << "\t\t" << "VkSurfaceFormatKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAcquireNextImageInfoKHR(std::ostream &out, const VkAcquireNextImageInfoKHR* structInfo, Decoded_VkAcquireNextImageInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// swapchain
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->swapchain) << "," << std::endl;
// timeout
    struct_body << "\t\t\t" << structInfo->timeout << "UL" << "," << std::endl;
// semaphore
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
// fence
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->fence) << "," << std::endl;
// deviceMask
    struct_body << "\t\t\t" << structInfo->deviceMask << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "acquireNextImageInfoKHR");
    out << "\t\t" << "VkAcquireNextImageInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindImageMemorySwapchainInfoKHR(std::ostream &out, const VkBindImageMemorySwapchainInfoKHR* structInfo, Decoded_VkBindImageMemorySwapchainInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// swapchain
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->swapchain) << "," << std::endl;
// imageIndex
    struct_body << "\t\t\t" << structInfo->imageIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindImageMemorySwapchainInfoKHR");
    out << "\t\t" << "VkBindImageMemorySwapchainInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupPresentCapabilitiesKHR(std::ostream &out, const VkDeviceGroupPresentCapabilitiesKHR* structInfo, Decoded_VkDeviceGroupPresentCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// presentMask
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->presentMask[0]), VK_MAX_DEVICE_GROUP_SIZE) << "," << std::endl;
// modes
    struct_body << "\t\t\t" << "VkDeviceGroupPresentModeFlagsKHR(" << structInfo->modes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupPresentCapabilitiesKHR");
    out << "\t\t" << "VkDeviceGroupPresentCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupPresentInfoKHR(std::ostream &out, const VkDeviceGroupPresentInfoKHR* structInfo, Decoded_VkDeviceGroupPresentInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdevice_masks_array = "NULL";
    if (structInfo->pDeviceMasks != NULL) {
        pdevice_masks_array = "pDeviceMasks_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pdevice_masks_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceMasks, structInfo->swapchainCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// swapchainCount
    struct_body << "\t\t\t" << structInfo->swapchainCount << "," << std::endl;
// pDeviceMasks
    struct_body << "\t\t\t" << pdevice_masks_array << "," << std::endl;
// mode
    struct_body << "\t\t\t" << "VkDeviceGroupPresentModeFlagBitsKHR(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupPresentInfoKHR");
    out << "\t\t" << "VkDeviceGroupPresentInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupSwapchainCreateInfoKHR(std::ostream &out, const VkDeviceGroupSwapchainCreateInfoKHR* structInfo, Decoded_VkDeviceGroupSwapchainCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// modes
    struct_body << "\t\t\t" << "VkDeviceGroupPresentModeFlagsKHR(" << structInfo->modes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupSwapchainCreateInfoKHR");
    out << "\t\t" << "VkDeviceGroupSwapchainCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageSwapchainCreateInfoKHR(std::ostream &out, const VkImageSwapchainCreateInfoKHR* structInfo, Decoded_VkImageSwapchainCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// swapchain
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->swapchain) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageSwapchainCreateInfoKHR");
    out << "\t\t" << "VkImageSwapchainCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayModeCreateInfoKHR(std::ostream &out, const VkDisplayModeCreateInfoKHR* structInfo, Decoded_VkDisplayModeCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string parameters_info_var = GenerateStruct_VkDisplayModeParametersKHR(out,
                                                                                &structInfo->parameters,
                                                                                metaInfo->parameters,
                                                                                consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDisplayModeCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// parameters
    struct_body << "\t\t\t" << parameters_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayModeCreateInfoKHR");
    out << "\t\t" << "VkDisplayModeCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayModeParametersKHR(std::ostream &out, const VkDisplayModeParametersKHR* structInfo, Decoded_VkDisplayModeParametersKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string visible_region_info_var = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->visibleRegion,
                                                                    metaInfo->visibleRegion,
                                                                    consumer);
// visibleRegion
    struct_body << "\t" << visible_region_info_var << "," << std::endl;
// refreshRate
    struct_body << "\t\t\t" << structInfo->refreshRate << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayModeParametersKHR");
    out << "\t\t" << "VkDisplayModeParametersKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayModePropertiesKHR(std::ostream &out, const VkDisplayModePropertiesKHR* structInfo, Decoded_VkDisplayModePropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string parameters_info_var = GenerateStruct_VkDisplayModeParametersKHR(out,
                                                                                &structInfo->parameters,
                                                                                metaInfo->parameters,
                                                                                consumer);
// displayMode
    struct_body << "\t" << consumer.GetHandle(metaInfo->displayMode) << "," << std::endl;
// parameters
    struct_body << "\t\t\t" << parameters_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayModePropertiesKHR");
    out << "\t\t" << "VkDisplayModePropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPlaneCapabilitiesKHR(std::ostream &out, const VkDisplayPlaneCapabilitiesKHR* structInfo, Decoded_VkDisplayPlaneCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string min_src_position_info_var = GenerateStruct_VkOffset2D(out,
                                                                      &structInfo->minSrcPosition,
                                                                      metaInfo->minSrcPosition,
                                                                      consumer);
    std::string max_src_position_info_var = GenerateStruct_VkOffset2D(out,
                                                                      &structInfo->maxSrcPosition,
                                                                      metaInfo->maxSrcPosition,
                                                                      consumer);
    std::string min_src_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->minSrcExtent,
                                                                    metaInfo->minSrcExtent,
                                                                    consumer);
    std::string max_src_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->maxSrcExtent,
                                                                    metaInfo->maxSrcExtent,
                                                                    consumer);
    std::string min_dst_position_info_var = GenerateStruct_VkOffset2D(out,
                                                                      &structInfo->minDstPosition,
                                                                      metaInfo->minDstPosition,
                                                                      consumer);
    std::string max_dst_position_info_var = GenerateStruct_VkOffset2D(out,
                                                                      &structInfo->maxDstPosition,
                                                                      metaInfo->maxDstPosition,
                                                                      consumer);
    std::string min_dst_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->minDstExtent,
                                                                    metaInfo->minDstExtent,
                                                                    consumer);
    std::string max_dst_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->maxDstExtent,
                                                                    metaInfo->maxDstExtent,
                                                                    consumer);
// supportedAlpha
    struct_body << "\t" << "VkDisplayPlaneAlphaFlagsKHR(" << structInfo->supportedAlpha << ")" << "," << std::endl;
// minSrcPosition
    struct_body << "\t\t\t" << min_src_position_info_var << "," << std::endl;
// maxSrcPosition
    struct_body << "\t\t\t" << max_src_position_info_var << "," << std::endl;
// minSrcExtent
    struct_body << "\t\t\t" << min_src_extent_info_var << "," << std::endl;
// maxSrcExtent
    struct_body << "\t\t\t" << max_src_extent_info_var << "," << std::endl;
// minDstPosition
    struct_body << "\t\t\t" << min_dst_position_info_var << "," << std::endl;
// maxDstPosition
    struct_body << "\t\t\t" << max_dst_position_info_var << "," << std::endl;
// minDstExtent
    struct_body << "\t\t\t" << min_dst_extent_info_var << "," << std::endl;
// maxDstExtent
    struct_body << "\t\t\t" << max_dst_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPlaneCapabilitiesKHR");
    out << "\t\t" << "VkDisplayPlaneCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPlanePropertiesKHR(std::ostream &out, const VkDisplayPlanePropertiesKHR* structInfo, Decoded_VkDisplayPlanePropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// currentDisplay
    struct_body << "\t" << consumer.GetHandle(metaInfo->currentDisplay) << "," << std::endl;
// currentStackIndex
    struct_body << "\t\t\t" << structInfo->currentStackIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPlanePropertiesKHR");
    out << "\t\t" << "VkDisplayPlanePropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPropertiesKHR(std::ostream &out, const VkDisplayPropertiesKHR* structInfo, Decoded_VkDisplayPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string physical_dimensions_info_var = GenerateStruct_VkExtent2D(out,
                                                                         &structInfo->physicalDimensions,
                                                                         metaInfo->physicalDimensions,
                                                                         consumer);
    std::string physical_resolution_info_var = GenerateStruct_VkExtent2D(out,
                                                                         &structInfo->physicalResolution,
                                                                         metaInfo->physicalResolution,
                                                                         consumer);
// display
    struct_body << "\t" << consumer.GetHandle(metaInfo->display) << "," << std::endl;
// displayName
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->displayName) << "," << std::endl;
// physicalDimensions
    struct_body << "\t\t\t" << physical_dimensions_info_var << "," << std::endl;
// physicalResolution
    struct_body << "\t\t\t" << physical_resolution_info_var << "," << std::endl;
// supportedTransforms
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagsKHR(" << structInfo->supportedTransforms << ")" << "," << std::endl;
// planeReorderPossible
    struct_body << "\t\t\t" << structInfo->planeReorderPossible << "," << std::endl;
// persistentContent
    struct_body << "\t\t\t" << structInfo->persistentContent << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPropertiesKHR");
    out << "\t\t" << "VkDisplayPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplaySurfaceCreateInfoKHR(std::ostream &out, const VkDisplaySurfaceCreateInfoKHR* structInfo, Decoded_VkDisplaySurfaceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string image_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                  &structInfo->imageExtent,
                                                                  metaInfo->imageExtent,
                                                                  consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDisplaySurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// displayMode
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->displayMode) << "," << std::endl;
// planeIndex
    struct_body << "\t\t\t" << structInfo->planeIndex << "," << std::endl;
// planeStackIndex
    struct_body << "\t\t\t" << structInfo->planeStackIndex << "," << std::endl;
// transform
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->transform << ")" << "," << std::endl;
// globalAlpha
    struct_body << "\t\t\t" << structInfo->globalAlpha << "," << std::endl;
// alphaMode
    struct_body << "\t\t\t" << "VkDisplayPlaneAlphaFlagBitsKHR(" << structInfo->alphaMode << ")" << "," << std::endl;
// imageExtent
    struct_body << "\t\t\t" << image_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displaySurfaceCreateInfoKHR");
    out << "\t\t" << "VkDisplaySurfaceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPresentInfoKHR(std::ostream &out, const VkDisplayPresentInfoKHR* structInfo, Decoded_VkDisplayPresentInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string src_rect_info_var = GenerateStruct_VkRect2D(out,
                                                            &structInfo->srcRect,
                                                            metaInfo->srcRect,
                                                            consumer);
    std::string dst_rect_info_var = GenerateStruct_VkRect2D(out,
                                                            &structInfo->dstRect,
                                                            metaInfo->dstRect,
                                                            consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcRect
    struct_body << "\t\t\t" << src_rect_info_var << "," << std::endl;
// dstRect
    struct_body << "\t\t\t" << dst_rect_info_var << "," << std::endl;
// persistent
    struct_body << "\t\t\t" << structInfo->persistent << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPresentInfoKHR");
    out << "\t\t" << "VkDisplayPresentInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkXlibSurfaceCreateInfoKHR(std::ostream &out, const VkXlibSurfaceCreateInfoKHR* structInfo, Decoded_VkXlibSurfaceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkXlibSurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// dpy
    struct_body << "\t\t\t" << structInfo->dpy << "," << std::endl;
// window
    struct_body << "\t\t\t" << structInfo->window << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "xlibSurfaceCreateInfoKHR");
    out << "\t\t" << "VkXlibSurfaceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    out << "\t\t" << "OverrideVkXlibSurfaceCreateInfoKHR(&" << variable_name << ", " << "appdata" << ");" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkXcbSurfaceCreateInfoKHR(std::ostream &out, const VkXcbSurfaceCreateInfoKHR* structInfo, Decoded_VkXcbSurfaceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkXcbSurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// connection
    struct_body << "\t\t\t" << structInfo->connection << "," << std::endl;
// window
    struct_body << "\t\t\t" << structInfo->window << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "xcbSurfaceCreateInfoKHR");
    out << "\t\t" << "VkXcbSurfaceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    out << "\t\t" << "OverrideVkXcbSurfaceCreateInfoKHR(&" << variable_name << ", " << "appdata" << ");" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWaylandSurfaceCreateInfoKHR(std::ostream &out, const VkWaylandSurfaceCreateInfoKHR* structInfo, Decoded_VkWaylandSurfaceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkWaylandSurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// display
    struct_body << "\t\t\t" << structInfo->display << "," << std::endl;
// surface
    struct_body << "\t\t\t" << structInfo->surface << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "waylandSurfaceCreateInfoKHR");
    out << "\t\t" << "VkWaylandSurfaceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    out << "\t\t" << "OverrideVkWaylandSurfaceCreateInfoKHR(&" << variable_name << ", " << "appdata" << ");" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAndroidSurfaceCreateInfoKHR(std::ostream &out, const VkAndroidSurfaceCreateInfoKHR* structInfo, Decoded_VkAndroidSurfaceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkAndroidSurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// window
    struct_body << "\t\t\t" << structInfo->window << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "androidSurfaceCreateInfoKHR");
    out << "\t\t" << "VkAndroidSurfaceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    out << "\t\t" << "OverrideVkAndroidSurfaceCreateInfoKHR(&" << variable_name << ", " << "appdata" << ");" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWin32SurfaceCreateInfoKHR(std::ostream &out, const VkWin32SurfaceCreateInfoKHR* structInfo, Decoded_VkWin32SurfaceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkWin32SurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// hinstance
    struct_body << "\t\t\t" << structInfo->hinstance << "," << std::endl;
// hwnd
    struct_body << "\t\t\t" << structInfo->hwnd << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "win32SurfaceCreateInfoKHR");
    out << "\t\t" << "VkWin32SurfaceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    out << "\t\t" << "OverrideVkWin32SurfaceCreateInfoKHR(&" << variable_name << ", " << "appdata" << ");" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindVideoSessionMemoryInfoKHR(std::ostream &out, const VkBindVideoSessionMemoryInfoKHR* structInfo, Decoded_VkBindVideoSessionMemoryInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memoryBindIndex
    struct_body << "\t\t\t" << structInfo->memoryBindIndex << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
// memoryOffset
    struct_body << "\t\t\t" << structInfo->memoryOffset << "UL" << "," << std::endl;
// memorySize
    struct_body << "\t\t\t" << structInfo->memorySize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindVideoSessionMemoryInfoKHR");
    out << "\t\t" << "VkBindVideoSessionMemoryInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVideoFormatInfoKHR(std::ostream &out, const VkPhysicalDeviceVideoFormatInfoKHR* structInfo, Decoded_VkPhysicalDeviceVideoFormatInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// imageUsage
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->imageUsage << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVideoFormatInfoKHR");
    out << "\t\t" << "VkPhysicalDeviceVideoFormatInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyQueryResultStatusPropertiesKHR(std::ostream &out, const VkQueueFamilyQueryResultStatusPropertiesKHR* structInfo, Decoded_VkQueueFamilyQueryResultStatusPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// queryResultStatusSupport
    struct_body << "\t\t\t" << structInfo->queryResultStatusSupport << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyQueryResultStatusPropertiesKHR");
    out << "\t\t" << "VkQueueFamilyQueryResultStatusPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyVideoPropertiesKHR(std::ostream &out, const VkQueueFamilyVideoPropertiesKHR* structInfo, Decoded_VkQueueFamilyVideoPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// videoCodecOperations
    struct_body << "\t\t\t" << "VkVideoCodecOperationFlagsKHR(" << structInfo->videoCodecOperations << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyVideoPropertiesKHR");
    out << "\t\t" << "VkQueueFamilyVideoPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoBeginCodingInfoKHR(std::ostream &out, const VkVideoBeginCodingInfoKHR* structInfo, Decoded_VkVideoBeginCodingInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string preference_slots_array = "NULL";
    if (structInfo->pReferenceSlots != NULL) {
        preference_slots_array = "pReferenceSlots_" + std::to_string(consumer.GetNextId());
        std::string preference_slots_names;
        for (uint32_t idx = 0; idx < structInfo->referenceSlotCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pReferenceSlots + idx != NULL) {
                variable_name = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                                           structInfo->pReferenceSlots + idx,
                                                                           metaInfo->pReferenceSlots->GetMetaStructPointer() + idx,
                                                                           consumer);
            }
            preference_slots_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVideoReferenceSlotInfoKHR " << preference_slots_array << "[] = {" << preference_slots_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoBeginCodingFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// videoSession
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->videoSession) << "," << std::endl;
// videoSessionParameters
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->videoSessionParameters) << "," << std::endl;
// referenceSlotCount
    struct_body << "\t\t\t" << structInfo->referenceSlotCount << "," << std::endl;
// pReferenceSlots
    struct_body << "\t\t\t" << preference_slots_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoBeginCodingInfoKHR");
    out << "\t\t" << "VkVideoBeginCodingInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoCapabilitiesKHR(std::ostream &out, const VkVideoCapabilitiesKHR* structInfo, Decoded_VkVideoCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string picture_access_granularity_info_var = GenerateStruct_VkExtent2D(out,
                                                                                &structInfo->pictureAccessGranularity,
                                                                                metaInfo->pictureAccessGranularity,
                                                                                consumer);
    std::string min_coded_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->minCodedExtent,
                                                                      metaInfo->minCodedExtent,
                                                                      consumer);
    std::string max_coded_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->maxCodedExtent,
                                                                      metaInfo->maxCodedExtent,
                                                                      consumer);
    std::string std_header_version_info_var = GenerateStruct_VkExtensionProperties(out,
                                                                                   &structInfo->stdHeaderVersion,
                                                                                   metaInfo->stdHeaderVersion,
                                                                                   consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoCapabilityFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// minBitstreamBufferOffsetAlignment
    struct_body << "\t\t\t" << structInfo->minBitstreamBufferOffsetAlignment << "UL" << "," << std::endl;
// minBitstreamBufferSizeAlignment
    struct_body << "\t\t\t" << structInfo->minBitstreamBufferSizeAlignment << "UL" << "," << std::endl;
// pictureAccessGranularity
    struct_body << "\t\t\t" << picture_access_granularity_info_var << "," << std::endl;
// minCodedExtent
    struct_body << "\t\t\t" << min_coded_extent_info_var << "," << std::endl;
// maxCodedExtent
    struct_body << "\t\t\t" << max_coded_extent_info_var << "," << std::endl;
// maxDpbSlots
    struct_body << "\t\t\t" << structInfo->maxDpbSlots << "," << std::endl;
// maxActiveReferencePictures
    struct_body << "\t\t\t" << structInfo->maxActiveReferencePictures << "," << std::endl;
// stdHeaderVersion
    struct_body << "\t\t\t" << std_header_version_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoCapabilitiesKHR");
    out << "\t\t" << "VkVideoCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoCodingControlInfoKHR(std::ostream &out, const VkVideoCodingControlInfoKHR* structInfo, Decoded_VkVideoCodingControlInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoCodingControlFlagsKHR(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoCodingControlInfoKHR");
    out << "\t\t" << "VkVideoCodingControlInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEndCodingInfoKHR(std::ostream &out, const VkVideoEndCodingInfoKHR* structInfo, Decoded_VkVideoEndCodingInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoEndCodingFlagsKHR(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEndCodingInfoKHR");
    out << "\t\t" << "VkVideoEndCodingInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoFormatPropertiesKHR(std::ostream &out, const VkVideoFormatPropertiesKHR* structInfo, Decoded_VkVideoFormatPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string component_mapping_info_var = GenerateStruct_VkComponentMapping(out,
                                                                               &structInfo->componentMapping,
                                                                               metaInfo->componentMapping,
                                                                               consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
// componentMapping
    struct_body << "\t\t\t" << component_mapping_info_var << "," << std::endl;
// imageCreateFlags
    struct_body << "\t\t\t" << "VkImageCreateFlags(" << structInfo->imageCreateFlags << ")" << "," << std::endl;
// imageType
    struct_body << "\t\t\t" << "VkImageType(" << structInfo->imageType << ")" << "," << std::endl;
// imageTiling
    struct_body << "\t\t\t" << "VkImageTiling(" << structInfo->imageTiling << ")" << "," << std::endl;
// imageUsageFlags
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->imageUsageFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoFormatPropertiesKHR");
    out << "\t\t" << "VkVideoFormatPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoPictureResourceInfoKHR(std::ostream &out, const VkVideoPictureResourceInfoKHR* structInfo, Decoded_VkVideoPictureResourceInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string coded_offset_info_var = GenerateStruct_VkOffset2D(out,
                                                                  &structInfo->codedOffset,
                                                                  metaInfo->codedOffset,
                                                                  consumer);
    std::string coded_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                  &structInfo->codedExtent,
                                                                  metaInfo->codedExtent,
                                                                  consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// codedOffset
    struct_body << "\t\t\t" << coded_offset_info_var << "," << std::endl;
// codedExtent
    struct_body << "\t\t\t" << coded_extent_info_var << "," << std::endl;
// baseArrayLayer
    struct_body << "\t\t\t" << structInfo->baseArrayLayer << "," << std::endl;
// imageViewBinding
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->imageViewBinding) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoPictureResourceInfoKHR");
    out << "\t\t" << "VkVideoPictureResourceInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoProfileInfoKHR(std::ostream &out, const VkVideoProfileInfoKHR* structInfo, Decoded_VkVideoProfileInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// videoCodecOperation
    struct_body << "\t\t\t" << "VkVideoCodecOperationFlagBitsKHR(" << structInfo->videoCodecOperation << ")" << "," << std::endl;
// chromaSubsampling
    struct_body << "\t\t\t" << "VkVideoChromaSubsamplingFlagsKHR(" << structInfo->chromaSubsampling << ")" << "," << std::endl;
// lumaBitDepth
    struct_body << "\t\t\t" << "VkVideoComponentBitDepthFlagsKHR(" << structInfo->lumaBitDepth << ")" << "," << std::endl;
// chromaBitDepth
    struct_body << "\t\t\t" << "VkVideoComponentBitDepthFlagsKHR(" << structInfo->chromaBitDepth << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoProfileInfoKHR");
    out << "\t\t" << "VkVideoProfileInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoProfileListInfoKHR(std::ostream &out, const VkVideoProfileListInfoKHR* structInfo, Decoded_VkVideoProfileListInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pprofiles_array = "NULL";
    if (structInfo->pProfiles != NULL) {
        pprofiles_array = "pProfiles_" + std::to_string(consumer.GetNextId());
        std::string pprofiles_names;
        for (uint32_t idx = 0; idx < structInfo->profileCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pProfiles + idx != NULL) {
                variable_name = GenerateStruct_VkVideoProfileInfoKHR(out,
                                                                     structInfo->pProfiles + idx,
                                                                     metaInfo->pProfiles->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            pprofiles_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVideoProfileInfoKHR " << pprofiles_array << "[] = {" << pprofiles_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// profileCount
    struct_body << "\t\t\t" << structInfo->profileCount << "," << std::endl;
// pProfiles
    struct_body << "\t\t\t" << pprofiles_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoProfileListInfoKHR");
    out << "\t\t" << "VkVideoProfileListInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoReferenceSlotInfoKHR(std::ostream &out, const VkVideoReferenceSlotInfoKHR* structInfo, Decoded_VkVideoReferenceSlotInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppicture_resource_struct = "NULL";
    if (structInfo->pPictureResource != NULL) {
        ppicture_resource_struct = GenerateStruct_VkVideoPictureResourceInfoKHR(out,
                                                                                structInfo->pPictureResource,
                                                                                metaInfo->pPictureResource->GetMetaStructPointer(),
                                                                                consumer);
        ppicture_resource_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// slotIndex
    struct_body << "\t\t\t" << structInfo->slotIndex << "," << std::endl;
// pPictureResource
    struct_body << "\t\t\t" << ppicture_resource_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoReferenceSlotInfoKHR");
    out << "\t\t" << "VkVideoReferenceSlotInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoSessionCreateInfoKHR(std::ostream &out, const VkVideoSessionCreateInfoKHR* structInfo, Decoded_VkVideoSessionCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pvideo_profile_struct = "NULL";
    if (structInfo->pVideoProfile != NULL) {
        pvideo_profile_struct = GenerateStruct_VkVideoProfileInfoKHR(out,
                                                                     structInfo->pVideoProfile,
                                                                     metaInfo->pVideoProfile->GetMetaStructPointer(),
                                                                     consumer);
        pvideo_profile_struct.insert(0, "&");
    }
    std::string max_coded_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->maxCodedExtent,
                                                                      metaInfo->maxCodedExtent,
                                                                      consumer);
    std::string pstd_header_version_struct = "NULL";
    if (structInfo->pStdHeaderVersion != NULL) {
        pstd_header_version_struct = GenerateStruct_VkExtensionProperties(out,
                                                                          structInfo->pStdHeaderVersion,
                                                                          metaInfo->pStdHeaderVersion->GetMetaStructPointer(),
                                                                          consumer);
        pstd_header_version_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// queueFamilyIndex
    struct_body << "\t\t\t" << structInfo->queueFamilyIndex << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoSessionCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// pVideoProfile
    struct_body << "\t\t\t" << pvideo_profile_struct << "," << std::endl;
// pictureFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->pictureFormat << ")" << "," << std::endl;
// maxCodedExtent
    struct_body << "\t\t\t" << max_coded_extent_info_var << "," << std::endl;
// referencePictureFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->referencePictureFormat << ")" << "," << std::endl;
// maxDpbSlots
    struct_body << "\t\t\t" << structInfo->maxDpbSlots << "," << std::endl;
// maxActiveReferencePictures
    struct_body << "\t\t\t" << structInfo->maxActiveReferencePictures << "," << std::endl;
// pStdHeaderVersion
    struct_body << "\t\t\t" << pstd_header_version_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoSessionCreateInfoKHR");
    out << "\t\t" << "VkVideoSessionCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoSessionMemoryRequirementsKHR(std::ostream &out, const VkVideoSessionMemoryRequirementsKHR* structInfo, Decoded_VkVideoSessionMemoryRequirementsKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string memory_requirements_info_var = GenerateStruct_VkMemoryRequirements(out,
                                                                                   &structInfo->memoryRequirements,
                                                                                   metaInfo->memoryRequirements,
                                                                                   consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memoryBindIndex
    struct_body << "\t\t\t" << structInfo->memoryBindIndex << "," << std::endl;
// memoryRequirements
    struct_body << "\t\t\t" << memory_requirements_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoSessionMemoryRequirementsKHR");
    out << "\t\t" << "VkVideoSessionMemoryRequirementsKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoSessionParametersCreateInfoKHR(std::ostream &out, const VkVideoSessionParametersCreateInfoKHR* structInfo, Decoded_VkVideoSessionParametersCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoSessionParametersCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// videoSessionParametersTemplate
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->videoSessionParametersTemplate) << "," << std::endl;
// videoSession
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->videoSession) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoSessionParametersCreateInfoKHR");
    out << "\t\t" << "VkVideoSessionParametersCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoSessionParametersUpdateInfoKHR(std::ostream &out, const VkVideoSessionParametersUpdateInfoKHR* structInfo, Decoded_VkVideoSessionParametersUpdateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// updateSequenceCount
    struct_body << "\t\t\t" << structInfo->updateSequenceCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoSessionParametersUpdateInfoKHR");
    out << "\t\t" << "VkVideoSessionParametersUpdateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeCapabilitiesKHR(std::ostream &out, const VkVideoDecodeCapabilitiesKHR* structInfo, Decoded_VkVideoDecodeCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoDecodeCapabilityFlagsKHR(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeCapabilitiesKHR");
    out << "\t\t" << "VkVideoDecodeCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeInfoKHR(std::ostream &out, const VkVideoDecodeInfoKHR* structInfo, Decoded_VkVideoDecodeInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string dst_picture_resource_info_var = GenerateStruct_VkVideoPictureResourceInfoKHR(out,
                                                                                             &structInfo->dstPictureResource,
                                                                                             metaInfo->dstPictureResource,
                                                                                             consumer);
    std::string psetup_reference_slot_struct = "NULL";
    if (structInfo->pSetupReferenceSlot != NULL) {
        psetup_reference_slot_struct = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                                                  structInfo->pSetupReferenceSlot,
                                                                                  metaInfo->pSetupReferenceSlot->GetMetaStructPointer(),
                                                                                  consumer);
        psetup_reference_slot_struct.insert(0, "&");
    }
    std::string preference_slots_array = "NULL";
    if (structInfo->pReferenceSlots != NULL) {
        preference_slots_array = "pReferenceSlots_" + std::to_string(consumer.GetNextId());
        std::string preference_slots_names;
        for (uint32_t idx = 0; idx < structInfo->referenceSlotCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pReferenceSlots + idx != NULL) {
                variable_name = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                                           structInfo->pReferenceSlots + idx,
                                                                           metaInfo->pReferenceSlots->GetMetaStructPointer() + idx,
                                                                           consumer);
            }
            preference_slots_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVideoReferenceSlotInfoKHR " << preference_slots_array << "[] = {" << preference_slots_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoDecodeFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// srcBuffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcBuffer) << "," << std::endl;
// srcBufferOffset
    struct_body << "\t\t\t" << structInfo->srcBufferOffset << "UL" << "," << std::endl;
// srcBufferRange
    struct_body << "\t\t\t" << structInfo->srcBufferRange << "UL" << "," << std::endl;
// dstPictureResource
    struct_body << "\t\t\t" << dst_picture_resource_info_var << "," << std::endl;
// pSetupReferenceSlot
    struct_body << "\t\t\t" << psetup_reference_slot_struct << "," << std::endl;
// referenceSlotCount
    struct_body << "\t\t\t" << structInfo->referenceSlotCount << "," << std::endl;
// pReferenceSlots
    struct_body << "\t\t\t" << preference_slots_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeInfoKHR");
    out << "\t\t" << "VkVideoDecodeInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeUsageInfoKHR(std::ostream &out, const VkVideoDecodeUsageInfoKHR* structInfo, Decoded_VkVideoDecodeUsageInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// videoUsageHints
    struct_body << "\t\t\t" << "VkVideoDecodeUsageFlagsKHR(" << structInfo->videoUsageHints << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeUsageInfoKHR");
    out << "\t\t" << "VkVideoDecodeUsageInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH264CapabilitiesKHR(std::ostream &out, const VkVideoDecodeH264CapabilitiesKHR* structInfo, Decoded_VkVideoDecodeH264CapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string field_offset_granularity_info_var = GenerateStruct_VkOffset2D(out,
                                                                              &structInfo->fieldOffsetGranularity,
                                                                              metaInfo->fieldOffsetGranularity,
                                                                              consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxLevelIdc
    struct_body << "\t\t\t" << "StdVideoH264LevelIdc(" << structInfo->maxLevelIdc << ")" << "," << std::endl;
// fieldOffsetGranularity
    struct_body << "\t\t\t" << field_offset_granularity_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH264CapabilitiesKHR");
    out << "\t\t" << "VkVideoDecodeH264CapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH264DpbSlotInfoKHR(std::ostream &out, const VkVideoDecodeH264DpbSlotInfoKHR* structInfo, Decoded_VkVideoDecodeH264DpbSlotInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_reference_info_struct = "NULL";
    if (structInfo->pStdReferenceInfo != NULL) {
        pstd_reference_info_struct = GenerateStruct_StdVideoDecodeH264ReferenceInfo(out,
                                                                                    structInfo->pStdReferenceInfo,
                                                                                    metaInfo->pStdReferenceInfo->GetMetaStructPointer(),
                                                                                    consumer);
        pstd_reference_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pStdReferenceInfo
    struct_body << "\t\t\t" << pstd_reference_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH264DpbSlotInfoKHR");
    out << "\t\t" << "VkVideoDecodeH264DpbSlotInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH264PictureInfoKHR(std::ostream &out, const VkVideoDecodeH264PictureInfoKHR* structInfo, Decoded_VkVideoDecodeH264PictureInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_picture_info_struct = "NULL";
    if (structInfo->pStdPictureInfo != NULL) {
        pstd_picture_info_struct = GenerateStruct_StdVideoDecodeH264PictureInfo(out,
                                                                                structInfo->pStdPictureInfo,
                                                                                metaInfo->pStdPictureInfo->GetMetaStructPointer(),
                                                                                consumer);
        pstd_picture_info_struct.insert(0, "&");
    }
    std::string pslice_offsets_array = "NULL";
    if (structInfo->pSliceOffsets != NULL) {
        pslice_offsets_array = "pSliceOffsets_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pslice_offsets_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pSliceOffsets, structInfo->sliceCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pStdPictureInfo
    struct_body << "\t\t\t" << pstd_picture_info_struct << "," << std::endl;
// sliceCount
    struct_body << "\t\t\t" << structInfo->sliceCount << "," << std::endl;
// pSliceOffsets
    struct_body << "\t\t\t" << pslice_offsets_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH264PictureInfoKHR");
    out << "\t\t" << "VkVideoDecodeH264PictureInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH264ProfileInfoKHR(std::ostream &out, const VkVideoDecodeH264ProfileInfoKHR* structInfo, Decoded_VkVideoDecodeH264ProfileInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stdProfileIdc
    struct_body << "\t\t\t" << "StdVideoH264ProfileIdc(" << structInfo->stdProfileIdc << ")" << "," << std::endl;
// pictureLayout
    struct_body << "\t\t\t" << "VkVideoDecodeH264PictureLayoutFlagBitsKHR(" << structInfo->pictureLayout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH264ProfileInfoKHR");
    out << "\t\t" << "VkVideoDecodeH264ProfileInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH264SessionParametersAddInfoKHR(std::ostream &out, const VkVideoDecodeH264SessionParametersAddInfoKHR* structInfo, Decoded_VkVideoDecodeH264SessionParametersAddInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_s_pss_array = "NULL";
    if (structInfo->pStdSPSs != NULL) {
        pstd_s_pss_array = "pStdSPSs_" + std::to_string(consumer.GetNextId());
        std::string pstd_s_pss_names;
        for (uint32_t idx = 0; idx < structInfo->stdSPSCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdSPSs + idx != NULL) {
                variable_name = GenerateStruct_StdVideoH264SequenceParameterSet(out,
                                                                                structInfo->pStdSPSs + idx,
                                                                                metaInfo->pStdSPSs->GetMetaStructPointer() + idx,
                                                                                consumer);
            }
            pstd_s_pss_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoH264SequenceParameterSet " << pstd_s_pss_array << "[] = {" << pstd_s_pss_names << "};" << std::endl;
    }
    std::string pstd_pp_ss_array = "NULL";
    if (structInfo->pStdPPSs != NULL) {
        pstd_pp_ss_array = "pStdPPSs_" + std::to_string(consumer.GetNextId());
        std::string pstd_pp_ss_names;
        for (uint32_t idx = 0; idx < structInfo->stdPPSCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdPPSs + idx != NULL) {
                variable_name = GenerateStruct_StdVideoH264PictureParameterSet(out,
                                                                               structInfo->pStdPPSs + idx,
                                                                               metaInfo->pStdPPSs->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pstd_pp_ss_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoH264PictureParameterSet " << pstd_pp_ss_array << "[] = {" << pstd_pp_ss_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stdSPSCount
    struct_body << "\t\t\t" << structInfo->stdSPSCount << "," << std::endl;
// pStdSPSs
    struct_body << "\t\t\t" << pstd_s_pss_array << "," << std::endl;
// stdPPSCount
    struct_body << "\t\t\t" << structInfo->stdPPSCount << "," << std::endl;
// pStdPPSs
    struct_body << "\t\t\t" << pstd_pp_ss_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH264SessionParametersAddInfoKHR");
    out << "\t\t" << "VkVideoDecodeH264SessionParametersAddInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH264SessionParametersCreateInfoKHR(std::ostream &out, const VkVideoDecodeH264SessionParametersCreateInfoKHR* structInfo, Decoded_VkVideoDecodeH264SessionParametersCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pparameters_add_info_struct = "NULL";
    if (structInfo->pParametersAddInfo != NULL) {
        pparameters_add_info_struct = GenerateStruct_VkVideoDecodeH264SessionParametersAddInfoKHR(out,
                                                                                                  structInfo->pParametersAddInfo,
                                                                                                  metaInfo->pParametersAddInfo->GetMetaStructPointer(),
                                                                                                  consumer);
        pparameters_add_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxStdSPSCount
    struct_body << "\t\t\t" << structInfo->maxStdSPSCount << "," << std::endl;
// maxStdPPSCount
    struct_body << "\t\t\t" << structInfo->maxStdPPSCount << "," << std::endl;
// pParametersAddInfo
    struct_body << "\t\t\t" << pparameters_add_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH264SessionParametersCreateInfoKHR");
    out << "\t\t" << "VkVideoDecodeH264SessionParametersCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentSampleCountInfoAMD(std::ostream &out, const VkAttachmentSampleCountInfoAMD* structInfo, Decoded_VkAttachmentSampleCountInfoAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcolor_attachment_samples_values;
    std::string pcolor_attachment_samples_array = "NULL";
    if (structInfo->pColorAttachmentSamples != NULL) {
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            pcolor_attachment_samples_values += util::ToString<VkSampleCountFlagBits>(structInfo->pColorAttachmentSamples[idx]) + ", ";
        }
        pcolor_attachment_samples_array = "pColorAttachmentSamples_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkSampleCountFlagBits " << pcolor_attachment_samples_array << "[] = {" << pcolor_attachment_samples_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// colorAttachmentCount
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
// pColorAttachmentSamples
    struct_body << "\t\t\t" << pcolor_attachment_samples_array << "," << std::endl;
// depthStencilAttachmentSamples
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->depthStencilAttachmentSamples << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentSampleCountInfoAMD");
    out << "\t\t" << "VkAttachmentSampleCountInfoAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMultiviewPerViewAttributesInfoNVX(std::ostream &out, const VkMultiviewPerViewAttributesInfoNVX* structInfo, Decoded_VkMultiviewPerViewAttributesInfoNVX* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// perViewAttributes
    struct_body << "\t\t\t" << structInfo->perViewAttributes << "," << std::endl;
// perViewAttributesPositionXOnly
    struct_body << "\t\t\t" << structInfo->perViewAttributesPositionXOnly << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "multiviewPerViewAttributesInfoNVX");
    out << "\t\t" << "VkMultiviewPerViewAttributesInfoNVX " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderingFragmentDensityMapAttachmentInfoEXT(std::ostream &out, const VkRenderingFragmentDensityMapAttachmentInfoEXT* structInfo, Decoded_VkRenderingFragmentDensityMapAttachmentInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// imageView
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->imageView) << "," << std::endl;
// imageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->imageLayout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderingFragmentDensityMapAttachmentInfoEXT");
    out << "\t\t" << "VkRenderingFragmentDensityMapAttachmentInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderingFragmentShadingRateAttachmentInfoKHR(std::ostream &out, const VkRenderingFragmentShadingRateAttachmentInfoKHR* structInfo, Decoded_VkRenderingFragmentShadingRateAttachmentInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string shading_rate_attachment_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                        &structInfo->shadingRateAttachmentTexelSize,
                                                                                        metaInfo->shadingRateAttachmentTexelSize,
                                                                                        consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// imageView
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->imageView) << "," << std::endl;
// imageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->imageLayout << ")" << "," << std::endl;
// shadingRateAttachmentTexelSize
    struct_body << "\t\t\t" << shading_rate_attachment_texel_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderingFragmentShadingRateAttachmentInfoKHR");
    out << "\t\t" << "VkRenderingFragmentShadingRateAttachmentInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportMemoryWin32HandleInfoKHR(std::ostream &out, const VkExportMemoryWin32HandleInfoKHR* structInfo, Decoded_VkExportMemoryWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pAttributes
    struct_body << "\t\t\t" << structInfo->pAttributes << "," << std::endl;
// dwAccess
    struct_body << "\t\t\t" << structInfo->dwAccess << "," << std::endl;
// name
    struct_body << "\t\t\t" << structInfo->name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportMemoryWin32HandleInfoKHR");
    out << "\t\t" << "VkExportMemoryWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportMemoryWin32HandleInfoKHR(std::ostream &out, const VkImportMemoryWin32HandleInfoKHR* structInfo, Decoded_VkImportMemoryWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
// handle
    struct_body << "\t\t\t" << structInfo->handle << "," << std::endl;
// name
    struct_body << "\t\t\t" << structInfo->name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importMemoryWin32HandleInfoKHR");
    out << "\t\t" << "VkImportMemoryWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryGetWin32HandleInfoKHR(std::ostream &out, const VkMemoryGetWin32HandleInfoKHR* structInfo, Decoded_VkMemoryGetWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryGetWin32HandleInfoKHR");
    out << "\t\t" << "VkMemoryGetWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryWin32HandlePropertiesKHR(std::ostream &out, const VkMemoryWin32HandlePropertiesKHR* structInfo, Decoded_VkMemoryWin32HandlePropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memoryTypeBits
    struct_body << "\t\t\t" << structInfo->memoryTypeBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryWin32HandlePropertiesKHR");
    out << "\t\t" << "VkMemoryWin32HandlePropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportMemoryFdInfoKHR(std::ostream &out, const VkImportMemoryFdInfoKHR* structInfo, Decoded_VkImportMemoryFdInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
// fd
    struct_body << "\t\t\t" << structInfo->fd << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importMemoryFdInfoKHR");
    out << "\t\t" << "VkImportMemoryFdInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryFdPropertiesKHR(std::ostream &out, const VkMemoryFdPropertiesKHR* structInfo, Decoded_VkMemoryFdPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memoryTypeBits
    struct_body << "\t\t\t" << structInfo->memoryTypeBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryFdPropertiesKHR");
    out << "\t\t" << "VkMemoryFdPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryGetFdInfoKHR(std::ostream &out, const VkMemoryGetFdInfoKHR* structInfo, Decoded_VkMemoryGetFdInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryGetFdInfoKHR");
    out << "\t\t" << "VkMemoryGetFdInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWin32KeyedMutexAcquireReleaseInfoKHR(std::ostream &out, const VkWin32KeyedMutexAcquireReleaseInfoKHR* structInfo, Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pacquire_syncs_array = "NULL";
    if (metaInfo->pAcquireSyncs.GetPointer() != NULL && structInfo->acquireCount > 0) {
        pacquire_syncs_array = "pacquire_syncs_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DEVICE_MEMORY));
        std::string pacquire_syncs_values = toStringJoin(metaInfo->pAcquireSyncs.GetPointer(),
                                                         metaInfo->pAcquireSyncs.GetPointer() + structInfo->acquireCount,
                                                         [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                         ", ");
        if (structInfo->acquireCount == 1) {
            pacquire_syncs_array = "&" + pacquire_syncs_values;
        } else if (structInfo->acquireCount > 1) {
            out << "\t\t" << "VkDeviceMemory " << pacquire_syncs_array << "[] = {" << pacquire_syncs_values << "};" << std::endl;
        }
    }
    std::string pacquire_keys_array = "pacquire_keys_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->acquireCount > 0) {
        std::string pacquire_keys_values = toStringJoin(structInfo->pAcquireKeys,
                                                        structInfo->pAcquireKeys + structInfo->acquireCount,
                                                        [](uint64_t current) { return std::to_string(current); },
                                                        ", ");
        if (structInfo->acquireCount == 1) {
            pacquire_keys_array = "&" + pacquire_keys_values;
        } else if (structInfo->acquireCount > 1) {
            out << "\t\t" << "uint64_t " << pacquire_keys_array << "[] = {" << pacquire_keys_values << "};" << std::endl;
        }
    }
    std::string pacquire_timeouts_array = "NULL";
    if (structInfo->pAcquireTimeouts != NULL) {
        pacquire_timeouts_array = "pAcquireTimeouts_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pacquire_timeouts_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pAcquireTimeouts, structInfo->acquireCount) << ";" << std::endl;
    }
    std::string prelease_syncs_array = "NULL";
    if (metaInfo->pReleaseSyncs.GetPointer() != NULL && structInfo->releaseCount > 0) {
        prelease_syncs_array = "prelease_syncs_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DEVICE_MEMORY));
        std::string prelease_syncs_values = toStringJoin(metaInfo->pReleaseSyncs.GetPointer(),
                                                         metaInfo->pReleaseSyncs.GetPointer() + structInfo->releaseCount,
                                                         [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                         ", ");
        if (structInfo->releaseCount == 1) {
            prelease_syncs_array = "&" + prelease_syncs_values;
        } else if (structInfo->releaseCount > 1) {
            out << "\t\t" << "VkDeviceMemory " << prelease_syncs_array << "[] = {" << prelease_syncs_values << "};" << std::endl;
        }
    }
    std::string prelease_keys_array = "prelease_keys_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->releaseCount > 0) {
        std::string prelease_keys_values = toStringJoin(structInfo->pReleaseKeys,
                                                        structInfo->pReleaseKeys + structInfo->releaseCount,
                                                        [](uint64_t current) { return std::to_string(current); },
                                                        ", ");
        if (structInfo->releaseCount == 1) {
            prelease_keys_array = "&" + prelease_keys_values;
        } else if (structInfo->releaseCount > 1) {
            out << "\t\t" << "uint64_t " << prelease_keys_array << "[] = {" << prelease_keys_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// acquireCount
    struct_body << "\t\t\t" << structInfo->acquireCount << "," << std::endl;
// pAcquireSyncs
    struct_body << "\t\t\t" << pacquire_syncs_array << "," << std::endl;
// pAcquireKeys
    struct_body << "\t\t\t" << "{ *" << pacquire_keys_array << " }" << "," << std::endl;
// pAcquireTimeouts
    struct_body << "\t\t\t" << pacquire_timeouts_array << "," << std::endl;
// releaseCount
    struct_body << "\t\t\t" << structInfo->releaseCount << "," << std::endl;
// pReleaseSyncs
    struct_body << "\t\t\t" << prelease_syncs_array << "," << std::endl;
// pReleaseKeys
    struct_body << "\t\t\t" << "{ *" << prelease_keys_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "win32KeyedMutexAcquireReleaseInfoKHR");
    out << "\t\t" << "VkWin32KeyedMutexAcquireReleaseInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkD3D12FenceSubmitInfoKHR(std::ostream &out, const VkD3D12FenceSubmitInfoKHR* structInfo, Decoded_VkD3D12FenceSubmitInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pwait_semaphore_values_array = "pwait_semaphore_values_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->waitSemaphoreValuesCount > 0) {
        std::string pwait_semaphore_values_values = toStringJoin(structInfo->pWaitSemaphoreValues,
                                                                 structInfo->pWaitSemaphoreValues + structInfo->waitSemaphoreValuesCount,
                                                                 [](uint64_t current) { return std::to_string(current); },
                                                                 ", ");
        if (structInfo->waitSemaphoreValuesCount == 1) {
            pwait_semaphore_values_array = "&" + pwait_semaphore_values_values;
        } else if (structInfo->waitSemaphoreValuesCount > 1) {
            out << "\t\t" << "uint64_t " << pwait_semaphore_values_array << "[] = {" << pwait_semaphore_values_values << "};" << std::endl;
        }
    }
    std::string psignal_semaphore_values_array = "psignal_semaphore_values_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->signalSemaphoreValuesCount > 0) {
        std::string psignal_semaphore_values_values = toStringJoin(structInfo->pSignalSemaphoreValues,
                                                                   structInfo->pSignalSemaphoreValues + structInfo->signalSemaphoreValuesCount,
                                                                   [](uint64_t current) { return std::to_string(current); },
                                                                   ", ");
        if (structInfo->signalSemaphoreValuesCount == 1) {
            psignal_semaphore_values_array = "&" + psignal_semaphore_values_values;
        } else if (structInfo->signalSemaphoreValuesCount > 1) {
            out << "\t\t" << "uint64_t " << psignal_semaphore_values_array << "[] = {" << psignal_semaphore_values_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// waitSemaphoreValuesCount
    struct_body << "\t\t\t" << structInfo->waitSemaphoreValuesCount << "," << std::endl;
// pWaitSemaphoreValues
    struct_body << "\t\t\t" << "{ *" << pwait_semaphore_values_array << " }" << "," << std::endl;
// signalSemaphoreValuesCount
    struct_body << "\t\t\t" << structInfo->signalSemaphoreValuesCount << "," << std::endl;
// pSignalSemaphoreValues
    struct_body << "\t\t\t" << "{ *" << psignal_semaphore_values_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "d3D12FenceSubmitInfoKHR");
    out << "\t\t" << "VkD3D12FenceSubmitInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportSemaphoreWin32HandleInfoKHR(std::ostream &out, const VkExportSemaphoreWin32HandleInfoKHR* structInfo, Decoded_VkExportSemaphoreWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pAttributes
    struct_body << "\t\t\t" << structInfo->pAttributes << "," << std::endl;
// dwAccess
    struct_body << "\t\t\t" << structInfo->dwAccess << "," << std::endl;
// name
    struct_body << "\t\t\t" << structInfo->name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportSemaphoreWin32HandleInfoKHR");
    out << "\t\t" << "VkExportSemaphoreWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportSemaphoreWin32HandleInfoKHR(std::ostream &out, const VkImportSemaphoreWin32HandleInfoKHR* structInfo, Decoded_VkImportSemaphoreWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// semaphore
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkSemaphoreImportFlags(" << structInfo->flags << ")" << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
// handle
    struct_body << "\t\t\t" << structInfo->handle << "," << std::endl;
// name
    struct_body << "\t\t\t" << structInfo->name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importSemaphoreWin32HandleInfoKHR");
    out << "\t\t" << "VkImportSemaphoreWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreGetWin32HandleInfoKHR(std::ostream &out, const VkSemaphoreGetWin32HandleInfoKHR* structInfo, Decoded_VkSemaphoreGetWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// semaphore
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreGetWin32HandleInfoKHR");
    out << "\t\t" << "VkSemaphoreGetWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportSemaphoreFdInfoKHR(std::ostream &out, const VkImportSemaphoreFdInfoKHR* structInfo, Decoded_VkImportSemaphoreFdInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// semaphore
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkSemaphoreImportFlags(" << structInfo->flags << ")" << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
// fd
    struct_body << "\t\t\t" << structInfo->fd << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importSemaphoreFdInfoKHR");
    out << "\t\t" << "VkImportSemaphoreFdInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreGetFdInfoKHR(std::ostream &out, const VkSemaphoreGetFdInfoKHR* structInfo, Decoded_VkSemaphoreGetFdInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// semaphore
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreGetFdInfoKHR");
    out << "\t\t" << "VkSemaphoreGetFdInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePushDescriptorPropertiesKHR(std::ostream &out, const VkPhysicalDevicePushDescriptorPropertiesKHR* structInfo, Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxPushDescriptors
    struct_body << "\t\t\t" << structInfo->maxPushDescriptors << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePushDescriptorPropertiesKHR");
    out << "\t\t" << "VkPhysicalDevicePushDescriptorPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentRegionKHR(std::ostream &out, const VkPresentRegionKHR* structInfo, Decoded_VkPresentRegionKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string prectangles_array = "NULL";
    if (structInfo->pRectangles != NULL) {
        prectangles_array = "pRectangles_" + std::to_string(consumer.GetNextId());
        std::string prectangles_names;
        for (uint32_t idx = 0; idx < structInfo->rectangleCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRectangles + idx != NULL) {
                variable_name = GenerateStruct_VkRectLayerKHR(out,
                                                              structInfo->pRectangles + idx,
                                                              metaInfo->pRectangles->GetMetaStructPointer() + idx,
                                                              consumer);
            }
            prectangles_names += variable_name + ", ";
        }
        out << "\t\t" << "VkRectLayerKHR " << prectangles_array << "[] = {" << prectangles_names << "};" << std::endl;
    }
// rectangleCount
    struct_body << "\t" << structInfo->rectangleCount << "," << std::endl;
// pRectangles
    struct_body << "\t\t\t" << prectangles_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentRegionKHR");
    out << "\t\t" << "VkPresentRegionKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentRegionsKHR(std::ostream &out, const VkPresentRegionsKHR* structInfo, Decoded_VkPresentRegionsKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->swapchainCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkPresentRegionKHR(out,
                                                                  structInfo->pRegions + idx,
                                                                  metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPresentRegionKHR " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// swapchainCount
    struct_body << "\t\t\t" << structInfo->swapchainCount << "," << std::endl;
// pRegions
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentRegionsKHR");
    out << "\t\t" << "VkPresentRegionsKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRectLayerKHR(std::ostream &out, const VkRectLayerKHR* structInfo, Decoded_VkRectLayerKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string offset_info_var = GenerateStruct_VkOffset2D(out,
                                                            &structInfo->offset,
                                                            metaInfo->offset,
                                                            consumer);
    std::string extent_info_var = GenerateStruct_VkExtent2D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
// offset
    struct_body << "\t" << offset_info_var << "," << std::endl;
// extent
    struct_body << "\t\t\t" << extent_info_var << "," << std::endl;
// layer
    struct_body << "\t\t\t" << structInfo->layer << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "rectLayerKHR");
    out << "\t\t" << "VkRectLayerKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSharedPresentSurfaceCapabilitiesKHR(std::ostream &out, const VkSharedPresentSurfaceCapabilitiesKHR* structInfo, Decoded_VkSharedPresentSurfaceCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// sharedPresentSupportedUsageFlags
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->sharedPresentSupportedUsageFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sharedPresentSurfaceCapabilitiesKHR");
    out << "\t\t" << "VkSharedPresentSurfaceCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportFenceWin32HandleInfoKHR(std::ostream &out, const VkExportFenceWin32HandleInfoKHR* structInfo, Decoded_VkExportFenceWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pAttributes
    struct_body << "\t\t\t" << structInfo->pAttributes << "," << std::endl;
// dwAccess
    struct_body << "\t\t\t" << structInfo->dwAccess << "," << std::endl;
// name
    struct_body << "\t\t\t" << structInfo->name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportFenceWin32HandleInfoKHR");
    out << "\t\t" << "VkExportFenceWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFenceGetWin32HandleInfoKHR(std::ostream &out, const VkFenceGetWin32HandleInfoKHR* structInfo, Decoded_VkFenceGetWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fence
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->fence) << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "fenceGetWin32HandleInfoKHR");
    out << "\t\t" << "VkFenceGetWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportFenceWin32HandleInfoKHR(std::ostream &out, const VkImportFenceWin32HandleInfoKHR* structInfo, Decoded_VkImportFenceWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fence
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->fence) << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkFenceImportFlags(" << structInfo->flags << ")" << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
// handle
    struct_body << "\t\t\t" << structInfo->handle << "," << std::endl;
// name
    struct_body << "\t\t\t" << structInfo->name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importFenceWin32HandleInfoKHR");
    out << "\t\t" << "VkImportFenceWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFenceGetFdInfoKHR(std::ostream &out, const VkFenceGetFdInfoKHR* structInfo, Decoded_VkFenceGetFdInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fence
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->fence) << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "fenceGetFdInfoKHR");
    out << "\t\t" << "VkFenceGetFdInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportFenceFdInfoKHR(std::ostream &out, const VkImportFenceFdInfoKHR* structInfo, Decoded_VkImportFenceFdInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fence
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->fence) << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkFenceImportFlags(" << structInfo->flags << ")" << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
// fd
    struct_body << "\t\t\t" << structInfo->fd << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importFenceFdInfoKHR");
    out << "\t\t" << "VkImportFenceFdInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAcquireProfilingLockInfoKHR(std::ostream &out, const VkAcquireProfilingLockInfoKHR* structInfo, Decoded_VkAcquireProfilingLockInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkAcquireProfilingLockFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// timeout
    struct_body << "\t\t\t" << structInfo->timeout << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "acquireProfilingLockInfoKHR");
    out << "\t\t" << "VkAcquireProfilingLockInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceCounterDescriptionKHR(std::ostream &out, const VkPerformanceCounterDescriptionKHR* structInfo, Decoded_VkPerformanceCounterDescriptionKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPerformanceCounterDescriptionFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// name
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->name) << "," << std::endl;
// category
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->category) << "," << std::endl;
// description
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceCounterDescriptionKHR");
    out << "\t\t" << "VkPerformanceCounterDescriptionKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceCounterKHR(std::ostream &out, const VkPerformanceCounterKHR* structInfo, Decoded_VkPerformanceCounterKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// unit
    struct_body << "\t\t\t" << "VkPerformanceCounterUnitKHR(" << structInfo->unit << ")" << "," << std::endl;
// scope
    struct_body << "\t\t\t" << "VkPerformanceCounterScopeKHR(" << structInfo->scope << ")" << "," << std::endl;
// storage
    struct_body << "\t\t\t" << "VkPerformanceCounterStorageKHR(" << structInfo->storage << ")" << "," << std::endl;
// uuid
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->uuid[0]), VK_UUID_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceCounterKHR");
    out << "\t\t" << "VkPerformanceCounterKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceQuerySubmitInfoKHR(std::ostream &out, const VkPerformanceQuerySubmitInfoKHR* structInfo, Decoded_VkPerformanceQuerySubmitInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// counterPassIndex
    struct_body << "\t\t\t" << structInfo->counterPassIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceQuerySubmitInfoKHR");
    out << "\t\t" << "VkPerformanceQuerySubmitInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePerformanceQueryFeaturesKHR(std::ostream &out, const VkPhysicalDevicePerformanceQueryFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePerformanceQueryFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// performanceCounterQueryPools
    struct_body << "\t\t\t" << structInfo->performanceCounterQueryPools << "," << std::endl;
// performanceCounterMultipleQueryPools
    struct_body << "\t\t\t" << structInfo->performanceCounterMultipleQueryPools << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePerformanceQueryFeaturesKHR");
    out << "\t\t" << "VkPhysicalDevicePerformanceQueryFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePerformanceQueryPropertiesKHR(std::ostream &out, const VkPhysicalDevicePerformanceQueryPropertiesKHR* structInfo, Decoded_VkPhysicalDevicePerformanceQueryPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// allowCommandBufferQueryCopies
    struct_body << "\t\t\t" << structInfo->allowCommandBufferQueryCopies << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePerformanceQueryPropertiesKHR");
    out << "\t\t" << "VkPhysicalDevicePerformanceQueryPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueryPoolPerformanceCreateInfoKHR(std::ostream &out, const VkQueryPoolPerformanceCreateInfoKHR* structInfo, Decoded_VkQueryPoolPerformanceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcounter_indices_array = "NULL";
    if (structInfo->pCounterIndices != NULL) {
        pcounter_indices_array = "pCounterIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pcounter_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCounterIndices, structInfo->counterIndexCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// queueFamilyIndex
    struct_body << "\t\t\t" << structInfo->queueFamilyIndex << "," << std::endl;
// counterIndexCount
    struct_body << "\t\t\t" << structInfo->counterIndexCount << "," << std::endl;
// pCounterIndices
    struct_body << "\t\t\t" << pcounter_indices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queryPoolPerformanceCreateInfoKHR");
    out << "\t\t" << "VkQueryPoolPerformanceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSurfaceInfo2KHR(std::ostream &out, const VkPhysicalDeviceSurfaceInfo2KHR* structInfo, Decoded_VkPhysicalDeviceSurfaceInfo2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// surface
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->surface) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSurfaceInfo2KHR");
    out << "\t\t" << "VkPhysicalDeviceSurfaceInfo2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceCapabilities2KHR(std::ostream &out, const VkSurfaceCapabilities2KHR* structInfo, Decoded_VkSurfaceCapabilities2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string surface_capabilities_info_var = GenerateStruct_VkSurfaceCapabilitiesKHR(out,
                                                                                        &structInfo->surfaceCapabilities,
                                                                                        metaInfo->surfaceCapabilities,
                                                                                        consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// surfaceCapabilities
    struct_body << "\t\t\t" << surface_capabilities_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceCapabilities2KHR");
    out << "\t\t" << "VkSurfaceCapabilities2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceFormat2KHR(std::ostream &out, const VkSurfaceFormat2KHR* structInfo, Decoded_VkSurfaceFormat2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string surface_format_info_var = GenerateStruct_VkSurfaceFormatKHR(out,
                                                                            &structInfo->surfaceFormat,
                                                                            metaInfo->surfaceFormat,
                                                                            consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// surfaceFormat
    struct_body << "\t\t\t" << surface_format_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceFormat2KHR");
    out << "\t\t" << "VkSurfaceFormat2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayModeProperties2KHR(std::ostream &out, const VkDisplayModeProperties2KHR* structInfo, Decoded_VkDisplayModeProperties2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string display_mode_properties_info_var = GenerateStruct_VkDisplayModePropertiesKHR(out,
                                                                                             &structInfo->displayModeProperties,
                                                                                             metaInfo->displayModeProperties,
                                                                                             consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// displayModeProperties
    struct_body << "\t\t\t" << display_mode_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayModeProperties2KHR");
    out << "\t\t" << "VkDisplayModeProperties2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPlaneCapabilities2KHR(std::ostream &out, const VkDisplayPlaneCapabilities2KHR* structInfo, Decoded_VkDisplayPlaneCapabilities2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string capabilities_info_var = GenerateStruct_VkDisplayPlaneCapabilitiesKHR(out,
                                                                                     &structInfo->capabilities,
                                                                                     metaInfo->capabilities,
                                                                                     consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// capabilities
    struct_body << "\t\t\t" << capabilities_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPlaneCapabilities2KHR");
    out << "\t\t" << "VkDisplayPlaneCapabilities2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPlaneInfo2KHR(std::ostream &out, const VkDisplayPlaneInfo2KHR* structInfo, Decoded_VkDisplayPlaneInfo2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// mode
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->mode) << "," << std::endl;
// planeIndex
    struct_body << "\t\t\t" << structInfo->planeIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPlaneInfo2KHR");
    out << "\t\t" << "VkDisplayPlaneInfo2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPlaneProperties2KHR(std::ostream &out, const VkDisplayPlaneProperties2KHR* structInfo, Decoded_VkDisplayPlaneProperties2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string display_plane_properties_info_var = GenerateStruct_VkDisplayPlanePropertiesKHR(out,
                                                                                               &structInfo->displayPlaneProperties,
                                                                                               metaInfo->displayPlaneProperties,
                                                                                               consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// displayPlaneProperties
    struct_body << "\t\t\t" << display_plane_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPlaneProperties2KHR");
    out << "\t\t" << "VkDisplayPlaneProperties2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayProperties2KHR(std::ostream &out, const VkDisplayProperties2KHR* structInfo, Decoded_VkDisplayProperties2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string display_properties_info_var = GenerateStruct_VkDisplayPropertiesKHR(out,
                                                                                    &structInfo->displayProperties,
                                                                                    metaInfo->displayProperties,
                                                                                    consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// displayProperties
    struct_body << "\t\t\t" << display_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayProperties2KHR");
    out << "\t\t" << "VkDisplayProperties2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePortabilitySubsetFeaturesKHR(std::ostream &out, const VkPhysicalDevicePortabilitySubsetFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePortabilitySubsetFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// constantAlphaColorBlendFactors
    struct_body << "\t\t\t" << structInfo->constantAlphaColorBlendFactors << "," << std::endl;
// events
    struct_body << "\t\t\t" << structInfo->events << "," << std::endl;
// imageViewFormatReinterpretation
    struct_body << "\t\t\t" << structInfo->imageViewFormatReinterpretation << "," << std::endl;
// imageViewFormatSwizzle
    struct_body << "\t\t\t" << structInfo->imageViewFormatSwizzle << "," << std::endl;
// imageView2DOn3DImage
    struct_body << "\t\t\t" << structInfo->imageView2DOn3DImage << "," << std::endl;
// multisampleArrayImage
    struct_body << "\t\t\t" << structInfo->multisampleArrayImage << "," << std::endl;
// mutableComparisonSamplers
    struct_body << "\t\t\t" << structInfo->mutableComparisonSamplers << "," << std::endl;
// pointPolygons
    struct_body << "\t\t\t" << structInfo->pointPolygons << "," << std::endl;
// samplerMipLodBias
    struct_body << "\t\t\t" << structInfo->samplerMipLodBias << "," << std::endl;
// separateStencilMaskRef
    struct_body << "\t\t\t" << structInfo->separateStencilMaskRef << "," << std::endl;
// shaderSampleRateInterpolationFunctions
    struct_body << "\t\t\t" << structInfo->shaderSampleRateInterpolationFunctions << "," << std::endl;
// tessellationIsolines
    struct_body << "\t\t\t" << structInfo->tessellationIsolines << "," << std::endl;
// tessellationPointMode
    struct_body << "\t\t\t" << structInfo->tessellationPointMode << "," << std::endl;
// triangleFans
    struct_body << "\t\t\t" << structInfo->triangleFans << "," << std::endl;
// vertexAttributeAccessBeyondStride
    struct_body << "\t\t\t" << structInfo->vertexAttributeAccessBeyondStride << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePortabilitySubsetFeaturesKHR");
    out << "\t\t" << "VkPhysicalDevicePortabilitySubsetFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePortabilitySubsetPropertiesKHR(std::ostream &out, const VkPhysicalDevicePortabilitySubsetPropertiesKHR* structInfo, Decoded_VkPhysicalDevicePortabilitySubsetPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// minVertexInputBindingStrideAlignment
    struct_body << "\t\t\t" << structInfo->minVertexInputBindingStrideAlignment << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePortabilitySubsetPropertiesKHR");
    out << "\t\t" << "VkPhysicalDevicePortabilitySubsetPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderClockFeaturesKHR(std::ostream &out, const VkPhysicalDeviceShaderClockFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceShaderClockFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderSubgroupClock
    struct_body << "\t\t\t" << structInfo->shaderSubgroupClock << "," << std::endl;
// shaderDeviceClock
    struct_body << "\t\t\t" << structInfo->shaderDeviceClock << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderClockFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceShaderClockFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH265CapabilitiesKHR(std::ostream &out, const VkVideoDecodeH265CapabilitiesKHR* structInfo, Decoded_VkVideoDecodeH265CapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxLevelIdc
    struct_body << "\t\t\t" << "StdVideoH265LevelIdc(" << structInfo->maxLevelIdc << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH265CapabilitiesKHR");
    out << "\t\t" << "VkVideoDecodeH265CapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH265DpbSlotInfoKHR(std::ostream &out, const VkVideoDecodeH265DpbSlotInfoKHR* structInfo, Decoded_VkVideoDecodeH265DpbSlotInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_reference_info_struct = "NULL";
    if (structInfo->pStdReferenceInfo != NULL) {
        pstd_reference_info_struct = GenerateStruct_StdVideoDecodeH265ReferenceInfo(out,
                                                                                    structInfo->pStdReferenceInfo,
                                                                                    metaInfo->pStdReferenceInfo->GetMetaStructPointer(),
                                                                                    consumer);
        pstd_reference_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pStdReferenceInfo
    struct_body << "\t\t\t" << pstd_reference_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH265DpbSlotInfoKHR");
    out << "\t\t" << "VkVideoDecodeH265DpbSlotInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH265PictureInfoKHR(std::ostream &out, const VkVideoDecodeH265PictureInfoKHR* structInfo, Decoded_VkVideoDecodeH265PictureInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_picture_info_struct = "NULL";
    if (structInfo->pStdPictureInfo != NULL) {
        pstd_picture_info_struct = GenerateStruct_StdVideoDecodeH265PictureInfo(out,
                                                                                structInfo->pStdPictureInfo,
                                                                                metaInfo->pStdPictureInfo->GetMetaStructPointer(),
                                                                                consumer);
        pstd_picture_info_struct.insert(0, "&");
    }
    std::string pslice_segment_offsets_array = "NULL";
    if (structInfo->pSliceSegmentOffsets != NULL) {
        pslice_segment_offsets_array = "pSliceSegmentOffsets_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pslice_segment_offsets_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pSliceSegmentOffsets, structInfo->sliceSegmentCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pStdPictureInfo
    struct_body << "\t\t\t" << pstd_picture_info_struct << "," << std::endl;
// sliceSegmentCount
    struct_body << "\t\t\t" << structInfo->sliceSegmentCount << "," << std::endl;
// pSliceSegmentOffsets
    struct_body << "\t\t\t" << pslice_segment_offsets_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH265PictureInfoKHR");
    out << "\t\t" << "VkVideoDecodeH265PictureInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH265ProfileInfoKHR(std::ostream &out, const VkVideoDecodeH265ProfileInfoKHR* structInfo, Decoded_VkVideoDecodeH265ProfileInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stdProfileIdc
    struct_body << "\t\t\t" << "StdVideoH265ProfileIdc(" << structInfo->stdProfileIdc << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH265ProfileInfoKHR");
    out << "\t\t" << "VkVideoDecodeH265ProfileInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH265SessionParametersAddInfoKHR(std::ostream &out, const VkVideoDecodeH265SessionParametersAddInfoKHR* structInfo, Decoded_VkVideoDecodeH265SessionParametersAddInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_v_pss_array = "NULL";
    if (structInfo->pStdVPSs != NULL) {
        pstd_v_pss_array = "pStdVPSs_" + std::to_string(consumer.GetNextId());
        std::string pstd_v_pss_names;
        for (uint32_t idx = 0; idx < structInfo->stdVPSCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdVPSs + idx != NULL) {
                variable_name = GenerateStruct_StdVideoH265VideoParameterSet(out,
                                                                             structInfo->pStdVPSs + idx,
                                                                             metaInfo->pStdVPSs->GetMetaStructPointer() + idx,
                                                                             consumer);
            }
            pstd_v_pss_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoH265VideoParameterSet " << pstd_v_pss_array << "[] = {" << pstd_v_pss_names << "};" << std::endl;
    }
    std::string pstd_s_pss_array = "NULL";
    if (structInfo->pStdSPSs != NULL) {
        pstd_s_pss_array = "pStdSPSs_" + std::to_string(consumer.GetNextId());
        std::string pstd_s_pss_names;
        for (uint32_t idx = 0; idx < structInfo->stdSPSCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdSPSs + idx != NULL) {
                variable_name = GenerateStruct_StdVideoH265SequenceParameterSet(out,
                                                                                structInfo->pStdSPSs + idx,
                                                                                metaInfo->pStdSPSs->GetMetaStructPointer() + idx,
                                                                                consumer);
            }
            pstd_s_pss_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoH265SequenceParameterSet " << pstd_s_pss_array << "[] = {" << pstd_s_pss_names << "};" << std::endl;
    }
    std::string pstd_pp_ss_array = "NULL";
    if (structInfo->pStdPPSs != NULL) {
        pstd_pp_ss_array = "pStdPPSs_" + std::to_string(consumer.GetNextId());
        std::string pstd_pp_ss_names;
        for (uint32_t idx = 0; idx < structInfo->stdPPSCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdPPSs + idx != NULL) {
                variable_name = GenerateStruct_StdVideoH265PictureParameterSet(out,
                                                                               structInfo->pStdPPSs + idx,
                                                                               metaInfo->pStdPPSs->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pstd_pp_ss_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoH265PictureParameterSet " << pstd_pp_ss_array << "[] = {" << pstd_pp_ss_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stdVPSCount
    struct_body << "\t\t\t" << structInfo->stdVPSCount << "," << std::endl;
// pStdVPSs
    struct_body << "\t\t\t" << pstd_v_pss_array << "," << std::endl;
// stdSPSCount
    struct_body << "\t\t\t" << structInfo->stdSPSCount << "," << std::endl;
// pStdSPSs
    struct_body << "\t\t\t" << pstd_s_pss_array << "," << std::endl;
// stdPPSCount
    struct_body << "\t\t\t" << structInfo->stdPPSCount << "," << std::endl;
// pStdPPSs
    struct_body << "\t\t\t" << pstd_pp_ss_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH265SessionParametersAddInfoKHR");
    out << "\t\t" << "VkVideoDecodeH265SessionParametersAddInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH265SessionParametersCreateInfoKHR(std::ostream &out, const VkVideoDecodeH265SessionParametersCreateInfoKHR* structInfo, Decoded_VkVideoDecodeH265SessionParametersCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pparameters_add_info_struct = "NULL";
    if (structInfo->pParametersAddInfo != NULL) {
        pparameters_add_info_struct = GenerateStruct_VkVideoDecodeH265SessionParametersAddInfoKHR(out,
                                                                                                  structInfo->pParametersAddInfo,
                                                                                                  metaInfo->pParametersAddInfo->GetMetaStructPointer(),
                                                                                                  consumer);
        pparameters_add_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxStdVPSCount
    struct_body << "\t\t\t" << structInfo->maxStdVPSCount << "," << std::endl;
// maxStdSPSCount
    struct_body << "\t\t\t" << structInfo->maxStdSPSCount << "," << std::endl;
// maxStdPPSCount
    struct_body << "\t\t\t" << structInfo->maxStdPPSCount << "," << std::endl;
// pParametersAddInfo
    struct_body << "\t\t\t" << pparameters_add_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH265SessionParametersCreateInfoKHR");
    out << "\t\t" << "VkVideoDecodeH265SessionParametersCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceQueueGlobalPriorityCreateInfoKHR(std::ostream &out, const VkDeviceQueueGlobalPriorityCreateInfoKHR* structInfo, Decoded_VkDeviceQueueGlobalPriorityCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// globalPriority
    struct_body << "\t\t\t" << "VkQueueGlobalPriorityKHR(" << structInfo->globalPriority << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceQueueGlobalPriorityCreateInfoKHR");
    out << "\t\t" << "VkDeviceQueueGlobalPriorityCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(std::ostream &out, const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// globalPriorityQuery
    struct_body << "\t\t\t" << structInfo->globalPriorityQuery << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceGlobalPriorityQueryFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyGlobalPriorityPropertiesKHR(std::ostream &out, const VkQueueFamilyGlobalPriorityPropertiesKHR* structInfo, Decoded_VkQueueFamilyGlobalPriorityPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// priorityCount
    struct_body << "\t\t\t" << structInfo->priorityCount << "," << std::endl;
// priorities
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkQueueGlobalPriorityKHR*>(&structInfo->priorities[0]), VK_MAX_GLOBAL_PRIORITY_SIZE_KHR) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyGlobalPriorityPropertiesKHR");
    out << "\t\t" << "VkQueueFamilyGlobalPriorityPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFragmentShadingRateAttachmentInfoKHR(std::ostream &out, const VkFragmentShadingRateAttachmentInfoKHR* structInfo, Decoded_VkFragmentShadingRateAttachmentInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pfragment_shading_rate_attachment_struct = "NULL";
    if (structInfo->pFragmentShadingRateAttachment != NULL) {
        pfragment_shading_rate_attachment_struct = GenerateStruct_VkAttachmentReference2(out,
                                                                                         structInfo->pFragmentShadingRateAttachment,
                                                                                         metaInfo->pFragmentShadingRateAttachment->GetMetaStructPointer(),
                                                                                         consumer);
        pfragment_shading_rate_attachment_struct.insert(0, "&");
    }
    std::string shading_rate_attachment_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                        &structInfo->shadingRateAttachmentTexelSize,
                                                                                        metaInfo->shadingRateAttachmentTexelSize,
                                                                                        consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pFragmentShadingRateAttachment
    struct_body << "\t\t\t" << pfragment_shading_rate_attachment_struct << "," << std::endl;
// shadingRateAttachmentTexelSize
    struct_body << "\t\t\t" << shading_rate_attachment_texel_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "fragmentShadingRateAttachmentInfoKHR");
    out << "\t\t" << "VkFragmentShadingRateAttachmentInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(std::ostream &out, const VkPhysicalDeviceFragmentShadingRateFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRateFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pipelineFragmentShadingRate
    struct_body << "\t\t\t" << structInfo->pipelineFragmentShadingRate << "," << std::endl;
// primitiveFragmentShadingRate
    struct_body << "\t\t\t" << structInfo->primitiveFragmentShadingRate << "," << std::endl;
// attachmentFragmentShadingRate
    struct_body << "\t\t\t" << structInfo->attachmentFragmentShadingRate << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShadingRateFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceFragmentShadingRateFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRateKHR(std::ostream &out, const VkPhysicalDeviceFragmentShadingRateKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRateKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string fragment_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                   &structInfo->fragmentSize,
                                                                   metaInfo->fragmentSize,
                                                                   consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// sampleCounts
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->sampleCounts << ")" << "," << std::endl;
// fragmentSize
    struct_body << "\t\t\t" << fragment_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShadingRateKHR");
    out << "\t\t" << "VkPhysicalDeviceFragmentShadingRateKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(std::ostream &out, const VkPhysicalDeviceFragmentShadingRatePropertiesKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRatePropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string min_fragment_shading_rate_attachment_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                                     &structInfo->minFragmentShadingRateAttachmentTexelSize,
                                                                                                     metaInfo->minFragmentShadingRateAttachmentTexelSize,
                                                                                                     consumer);
    std::string max_fragment_shading_rate_attachment_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                                     &structInfo->maxFragmentShadingRateAttachmentTexelSize,
                                                                                                     metaInfo->maxFragmentShadingRateAttachmentTexelSize,
                                                                                                     consumer);
    std::string max_fragment_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                       &structInfo->maxFragmentSize,
                                                                       metaInfo->maxFragmentSize,
                                                                       consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// minFragmentShadingRateAttachmentTexelSize
    struct_body << "\t\t\t" << min_fragment_shading_rate_attachment_texel_size_info_var << "," << std::endl;
// maxFragmentShadingRateAttachmentTexelSize
    struct_body << "\t\t\t" << max_fragment_shading_rate_attachment_texel_size_info_var << "," << std::endl;
// maxFragmentShadingRateAttachmentTexelSizeAspectRatio
    struct_body << "\t\t\t" << structInfo->maxFragmentShadingRateAttachmentTexelSizeAspectRatio << "," << std::endl;
// primitiveFragmentShadingRateWithMultipleViewports
    struct_body << "\t\t\t" << structInfo->primitiveFragmentShadingRateWithMultipleViewports << "," << std::endl;
// layeredShadingRateAttachments
    struct_body << "\t\t\t" << structInfo->layeredShadingRateAttachments << "," << std::endl;
// fragmentShadingRateNonTrivialCombinerOps
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateNonTrivialCombinerOps << "," << std::endl;
// maxFragmentSize
    struct_body << "\t\t\t" << max_fragment_size_info_var << "," << std::endl;
// maxFragmentSizeAspectRatio
    struct_body << "\t\t\t" << structInfo->maxFragmentSizeAspectRatio << "," << std::endl;
// maxFragmentShadingRateCoverageSamples
    struct_body << "\t\t\t" << structInfo->maxFragmentShadingRateCoverageSamples << "," << std::endl;
// maxFragmentShadingRateRasterizationSamples
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->maxFragmentShadingRateRasterizationSamples << ")" << "," << std::endl;
// fragmentShadingRateWithShaderDepthStencilWrites
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateWithShaderDepthStencilWrites << "," << std::endl;
// fragmentShadingRateWithSampleMask
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateWithSampleMask << "," << std::endl;
// fragmentShadingRateWithShaderSampleMask
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateWithShaderSampleMask << "," << std::endl;
// fragmentShadingRateWithConservativeRasterization
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateWithConservativeRasterization << "," << std::endl;
// fragmentShadingRateWithFragmentShaderInterlock
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateWithFragmentShaderInterlock << "," << std::endl;
// fragmentShadingRateWithCustomSampleLocations
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateWithCustomSampleLocations << "," << std::endl;
// fragmentShadingRateStrictMultiplyCombiner
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateStrictMultiplyCombiner << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShadingRatePropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceFragmentShadingRatePropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineFragmentShadingRateStateCreateInfoKHR(std::ostream &out, const VkPipelineFragmentShadingRateStateCreateInfoKHR* structInfo, Decoded_VkPipelineFragmentShadingRateStateCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string fragment_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                   &structInfo->fragmentSize,
                                                                   metaInfo->fragmentSize,
                                                                   consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fragmentSize
    struct_body << "\t\t\t" << fragment_size_info_var << "," << std::endl;
// combinerOps
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkFragmentShadingRateCombinerOpKHR*>(&structInfo->combinerOps[0]), 2) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineFragmentShadingRateStateCreateInfoKHR");
    out << "\t\t" << "VkPipelineFragmentShadingRateStateCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceProtectedCapabilitiesKHR(std::ostream &out, const VkSurfaceProtectedCapabilitiesKHR* structInfo, Decoded_VkSurfaceProtectedCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// supportsProtected
    struct_body << "\t\t\t" << structInfo->supportsProtected << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceProtectedCapabilitiesKHR");
    out << "\t\t" << "VkSurfaceProtectedCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePresentWaitFeaturesKHR(std::ostream &out, const VkPhysicalDevicePresentWaitFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePresentWaitFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// presentWait
    struct_body << "\t\t\t" << structInfo->presentWait << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePresentWaitFeaturesKHR");
    out << "\t\t" << "VkPhysicalDevicePresentWaitFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(std::ostream &out, const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pipelineExecutableInfo
    struct_body << "\t\t\t" << structInfo->pipelineExecutableInfo << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineExecutablePropertiesFeaturesKHR");
    out << "\t\t" << "VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineExecutableInfoKHR(std::ostream &out, const VkPipelineExecutableInfoKHR* structInfo, Decoded_VkPipelineExecutableInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pipeline
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipeline) << "," << std::endl;
// executableIndex
    struct_body << "\t\t\t" << structInfo->executableIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineExecutableInfoKHR");
    out << "\t\t" << "VkPipelineExecutableInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineExecutableInternalRepresentationKHR(std::ostream &out, const VkPipelineExecutableInternalRepresentationKHR* structInfo, Decoded_VkPipelineExecutableInternalRepresentationKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// name
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->name) << "," << std::endl;
// description
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << "," << std::endl;
// isText
    struct_body << "\t\t\t" << structInfo->isText << "," << std::endl;
// dataSize
    struct_body << "\t\t\t" << structInfo->dataSize << "," << std::endl;
// pData
    out << "\t\t" << "// TODO: Support pData (output with array length value?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineExecutableInternalRepresentationKHR");
    out << "\t\t" << "VkPipelineExecutableInternalRepresentationKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineExecutablePropertiesKHR(std::ostream &out, const VkPipelineExecutablePropertiesKHR* structInfo, Decoded_VkPipelineExecutablePropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stages
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->stages << ")" << "," << std::endl;
// name
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->name) << "," << std::endl;
// description
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << "," << std::endl;
// subgroupSize
    struct_body << "\t\t\t" << structInfo->subgroupSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineExecutablePropertiesKHR");
    out << "\t\t" << "VkPipelineExecutablePropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineExecutableStatisticKHR(std::ostream &out, const VkPipelineExecutableStatisticKHR* structInfo, Decoded_VkPipelineExecutableStatisticKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// name
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->name) << "," << std::endl;
// description
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkPipelineExecutableStatisticFormatKHR(" << structInfo->format << ")" << "," << std::endl;
// value
    struct_body << "\t\t\t" << structInfo->value.b32 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineExecutableStatisticKHR");
    out << "\t\t" << "VkPipelineExecutableStatisticKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineInfoKHR(std::ostream &out, const VkPipelineInfoKHR* structInfo, Decoded_VkPipelineInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pipeline
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipeline) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineInfoKHR");
    out << "\t\t" << "VkPipelineInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryMapInfoKHR(std::ostream &out, const VkMemoryMapInfoKHR* structInfo, Decoded_VkMemoryMapInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkMemoryMapFlags(" << structInfo->flags << ")" << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryMapInfoKHR");
    out << "\t\t" << "VkMemoryMapInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryUnmapInfoKHR(std::ostream &out, const VkMemoryUnmapInfoKHR* structInfo, Decoded_VkMemoryUnmapInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkMemoryUnmapFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryUnmapInfoKHR");
    out << "\t\t" << "VkMemoryUnmapInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineLibraryCreateInfoKHR(std::ostream &out, const VkPipelineLibraryCreateInfoKHR* structInfo, Decoded_VkPipelineLibraryCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string plibraries_array = "NULL";
    if (metaInfo->pLibraries.GetPointer() != NULL && structInfo->libraryCount > 0) {
        plibraries_array = "plibraries_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_PIPELINE));
        std::string plibraries_values = toStringJoin(metaInfo->pLibraries.GetPointer(),
                                                     metaInfo->pLibraries.GetPointer() + structInfo->libraryCount,
                                                     [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                     ", ");
        if (structInfo->libraryCount == 1) {
            plibraries_array = "&" + plibraries_values;
        } else if (structInfo->libraryCount > 1) {
            out << "\t\t" << "VkPipeline " << plibraries_array << "[] = {" << plibraries_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// libraryCount
    struct_body << "\t\t\t" << structInfo->libraryCount << "," << std::endl;
// pLibraries
    struct_body << "\t\t\t" << plibraries_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineLibraryCreateInfoKHR");
    out << "\t\t" << "VkPipelineLibraryCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePresentIdFeaturesKHR(std::ostream &out, const VkPhysicalDevicePresentIdFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePresentIdFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// presentId
    struct_body << "\t\t\t" << structInfo->presentId << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePresentIdFeaturesKHR");
    out << "\t\t" << "VkPhysicalDevicePresentIdFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentIdKHR(std::ostream &out, const VkPresentIdKHR* structInfo, Decoded_VkPresentIdKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppresent_ids_array = "ppresent_ids_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->swapchainCount > 0) {
        std::string ppresent_ids_values = toStringJoin(structInfo->pPresentIds,
                                                       structInfo->pPresentIds + structInfo->swapchainCount,
                                                       [](uint64_t current) { return std::to_string(current); },
                                                       ", ");
        if (structInfo->swapchainCount == 1) {
            ppresent_ids_array = "&" + ppresent_ids_values;
        } else if (structInfo->swapchainCount > 1) {
            out << "\t\t" << "uint64_t " << ppresent_ids_array << "[] = {" << ppresent_ids_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// swapchainCount
    struct_body << "\t\t\t" << structInfo->swapchainCount << "," << std::endl;
// pPresentIds
    struct_body << "\t\t\t" << "{ *" << ppresent_ids_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentIdKHR");
    out << "\t\t" << "VkPresentIdKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR(std::ostream &out, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* structInfo, Decoded_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pvideo_profile_struct = "NULL";
    if (structInfo->pVideoProfile != NULL) {
        pvideo_profile_struct = GenerateStruct_VkVideoProfileInfoKHR(out,
                                                                     structInfo->pVideoProfile,
                                                                     metaInfo->pVideoProfile->GetMetaStructPointer(),
                                                                     consumer);
        pvideo_profile_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pVideoProfile
    struct_body << "\t\t\t" << pvideo_profile_struct << "," << std::endl;
// qualityLevel
    struct_body << "\t\t\t" << structInfo->qualityLevel << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVideoEncodeQualityLevelInfoKHR");
    out << "\t\t" << "VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(std::ostream &out, const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* structInfo, Decoded_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// encodeFeedbackFlags
    struct_body << "\t\t\t" << "VkVideoEncodeFeedbackFlagsKHR(" << structInfo->encodeFeedbackFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queryPoolVideoEncodeFeedbackCreateInfoKHR");
    out << "\t\t" << "VkQueryPoolVideoEncodeFeedbackCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeCapabilitiesKHR(std::ostream &out, const VkVideoEncodeCapabilitiesKHR* structInfo, Decoded_VkVideoEncodeCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string encode_input_picture_granularity_info_var = GenerateStruct_VkExtent2D(out,
                                                                                      &structInfo->encodeInputPictureGranularity,
                                                                                      metaInfo->encodeInputPictureGranularity,
                                                                                      consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoEncodeCapabilityFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// rateControlModes
    struct_body << "\t\t\t" << "VkVideoEncodeRateControlModeFlagsKHR(" << structInfo->rateControlModes << ")" << "," << std::endl;
// maxRateControlLayers
    struct_body << "\t\t\t" << structInfo->maxRateControlLayers << "," << std::endl;
// maxBitrate
    struct_body << "\t\t\t" << structInfo->maxBitrate << "UL" << "," << std::endl;
// maxQualityLevels
    struct_body << "\t\t\t" << structInfo->maxQualityLevels << "," << std::endl;
// encodeInputPictureGranularity
    struct_body << "\t\t\t" << encode_input_picture_granularity_info_var << "," << std::endl;
// supportedEncodeFeedbackFlags
    struct_body << "\t\t\t" << "VkVideoEncodeFeedbackFlagsKHR(" << structInfo->supportedEncodeFeedbackFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeCapabilitiesKHR");
    out << "\t\t" << "VkVideoEncodeCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeInfoKHR(std::ostream &out, const VkVideoEncodeInfoKHR* structInfo, Decoded_VkVideoEncodeInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string src_picture_resource_info_var = GenerateStruct_VkVideoPictureResourceInfoKHR(out,
                                                                                             &structInfo->srcPictureResource,
                                                                                             metaInfo->srcPictureResource,
                                                                                             consumer);
    std::string psetup_reference_slot_struct = "NULL";
    if (structInfo->pSetupReferenceSlot != NULL) {
        psetup_reference_slot_struct = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                                                  structInfo->pSetupReferenceSlot,
                                                                                  metaInfo->pSetupReferenceSlot->GetMetaStructPointer(),
                                                                                  consumer);
        psetup_reference_slot_struct.insert(0, "&");
    }
    std::string preference_slots_array = "NULL";
    if (structInfo->pReferenceSlots != NULL) {
        preference_slots_array = "pReferenceSlots_" + std::to_string(consumer.GetNextId());
        std::string preference_slots_names;
        for (uint32_t idx = 0; idx < structInfo->referenceSlotCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pReferenceSlots + idx != NULL) {
                variable_name = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                                           structInfo->pReferenceSlots + idx,
                                                                           metaInfo->pReferenceSlots->GetMetaStructPointer() + idx,
                                                                           consumer);
            }
            preference_slots_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVideoReferenceSlotInfoKHR " << preference_slots_array << "[] = {" << preference_slots_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoEncodeFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// dstBuffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstBuffer) << "," << std::endl;
// dstBufferOffset
    struct_body << "\t\t\t" << structInfo->dstBufferOffset << "UL" << "," << std::endl;
// dstBufferRange
    struct_body << "\t\t\t" << structInfo->dstBufferRange << "UL" << "," << std::endl;
// srcPictureResource
    struct_body << "\t\t\t" << src_picture_resource_info_var << "," << std::endl;
// pSetupReferenceSlot
    struct_body << "\t\t\t" << psetup_reference_slot_struct << "," << std::endl;
// referenceSlotCount
    struct_body << "\t\t\t" << structInfo->referenceSlotCount << "," << std::endl;
// pReferenceSlots
    struct_body << "\t\t\t" << preference_slots_array << "," << std::endl;
// precedingExternallyEncodedBytes
    struct_body << "\t\t\t" << structInfo->precedingExternallyEncodedBytes << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeInfoKHR");
    out << "\t\t" << "VkVideoEncodeInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeQualityLevelInfoKHR(std::ostream &out, const VkVideoEncodeQualityLevelInfoKHR* structInfo, Decoded_VkVideoEncodeQualityLevelInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// qualityLevel
    struct_body << "\t\t\t" << structInfo->qualityLevel << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeQualityLevelInfoKHR");
    out << "\t\t" << "VkVideoEncodeQualityLevelInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeQualityLevelPropertiesKHR(std::ostream &out, const VkVideoEncodeQualityLevelPropertiesKHR* structInfo, Decoded_VkVideoEncodeQualityLevelPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// preferredRateControlMode
    struct_body << "\t\t\t" << "VkVideoEncodeRateControlModeFlagBitsKHR(" << structInfo->preferredRateControlMode << ")" << "," << std::endl;
// preferredRateControlLayerCount
    struct_body << "\t\t\t" << structInfo->preferredRateControlLayerCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeQualityLevelPropertiesKHR");
    out << "\t\t" << "VkVideoEncodeQualityLevelPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeRateControlInfoKHR(std::ostream &out, const VkVideoEncodeRateControlInfoKHR* structInfo, Decoded_VkVideoEncodeRateControlInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string players_array = "NULL";
    if (structInfo->pLayers != NULL) {
        players_array = "pLayers_" + std::to_string(consumer.GetNextId());
        std::string players_names;
        for (uint32_t idx = 0; idx < structInfo->layerCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pLayers + idx != NULL) {
                variable_name = GenerateStruct_VkVideoEncodeRateControlLayerInfoKHR(out,
                                                                                    structInfo->pLayers + idx,
                                                                                    metaInfo->pLayers->GetMetaStructPointer() + idx,
                                                                                    consumer);
            }
            players_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVideoEncodeRateControlLayerInfoKHR " << players_array << "[] = {" << players_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoEncodeRateControlFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// rateControlMode
    struct_body << "\t\t\t" << "VkVideoEncodeRateControlModeFlagBitsKHR(" << structInfo->rateControlMode << ")" << "," << std::endl;
// layerCount
    struct_body << "\t\t\t" << structInfo->layerCount << "," << std::endl;
// pLayers
    struct_body << "\t\t\t" << players_array << "," << std::endl;
// virtualBufferSizeInMs
    struct_body << "\t\t\t" << structInfo->virtualBufferSizeInMs << "," << std::endl;
// initialVirtualBufferSizeInMs
    struct_body << "\t\t\t" << structInfo->initialVirtualBufferSizeInMs << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeRateControlInfoKHR");
    out << "\t\t" << "VkVideoEncodeRateControlInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeRateControlLayerInfoKHR(std::ostream &out, const VkVideoEncodeRateControlLayerInfoKHR* structInfo, Decoded_VkVideoEncodeRateControlLayerInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// averageBitrate
    struct_body << "\t\t\t" << structInfo->averageBitrate << "UL" << "," << std::endl;
// maxBitrate
    struct_body << "\t\t\t" << structInfo->maxBitrate << "UL" << "," << std::endl;
// frameRateNumerator
    struct_body << "\t\t\t" << structInfo->frameRateNumerator << "," << std::endl;
// frameRateDenominator
    struct_body << "\t\t\t" << structInfo->frameRateDenominator << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeRateControlLayerInfoKHR");
    out << "\t\t" << "VkVideoEncodeRateControlLayerInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeSessionParametersFeedbackInfoKHR(std::ostream &out, const VkVideoEncodeSessionParametersFeedbackInfoKHR* structInfo, Decoded_VkVideoEncodeSessionParametersFeedbackInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// hasOverrides
    struct_body << "\t\t\t" << structInfo->hasOverrides << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeSessionParametersFeedbackInfoKHR");
    out << "\t\t" << "VkVideoEncodeSessionParametersFeedbackInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeSessionParametersGetInfoKHR(std::ostream &out, const VkVideoEncodeSessionParametersGetInfoKHR* structInfo, Decoded_VkVideoEncodeSessionParametersGetInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// videoSessionParameters
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->videoSessionParameters) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeSessionParametersGetInfoKHR");
    out << "\t\t" << "VkVideoEncodeSessionParametersGetInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeUsageInfoKHR(std::ostream &out, const VkVideoEncodeUsageInfoKHR* structInfo, Decoded_VkVideoEncodeUsageInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// videoUsageHints
    struct_body << "\t\t\t" << "VkVideoEncodeUsageFlagsKHR(" << structInfo->videoUsageHints << ")" << "," << std::endl;
// videoContentHints
    struct_body << "\t\t\t" << "VkVideoEncodeContentFlagsKHR(" << structInfo->videoContentHints << ")" << "," << std::endl;
// tuningMode
    struct_body << "\t\t\t" << "VkVideoEncodeTuningModeKHR(" << structInfo->tuningMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeUsageInfoKHR");
    out << "\t\t" << "VkVideoEncodeUsageInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCheckpointData2NV(std::ostream &out, const VkCheckpointData2NV* structInfo, Decoded_VkCheckpointData2NV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stage
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->stage << ")" << "," << std::endl;
// pCheckpointMarker
    out << "\t\t" << "// TODO: Support pCheckpointMarker (output?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "checkpointData2NV");
    out << "\t\t" << "VkCheckpointData2NV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyCheckpointProperties2NV(std::ostream &out, const VkQueueFamilyCheckpointProperties2NV* structInfo, Decoded_VkQueueFamilyCheckpointProperties2NV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// checkpointExecutionStageMask
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->checkpointExecutionStageMask << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyCheckpointProperties2NV");
    out << "\t\t" << "VkQueueFamilyCheckpointProperties2NV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(std::ostream &out, const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fragmentShaderBarycentric
    struct_body << "\t\t\t" << structInfo->fragmentShaderBarycentric << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShaderBarycentricFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(std::ostream &out, const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// triStripVertexOrderIndependentOfProvokingVertex
    struct_body << "\t\t\t" << structInfo->triStripVertexOrderIndependentOfProvokingVertex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShaderBarycentricPropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(std::ostream &out, const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderSubgroupUniformControlFlow
    struct_body << "\t\t\t" << structInfo->shaderSubgroupUniformControlFlow << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(std::ostream &out, const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// workgroupMemoryExplicitLayout
    struct_body << "\t\t\t" << structInfo->workgroupMemoryExplicitLayout << "," << std::endl;
// workgroupMemoryExplicitLayoutScalarBlockLayout
    struct_body << "\t\t\t" << structInfo->workgroupMemoryExplicitLayoutScalarBlockLayout << "," << std::endl;
// workgroupMemoryExplicitLayout8BitAccess
    struct_body << "\t\t\t" << structInfo->workgroupMemoryExplicitLayout8BitAccess << "," << std::endl;
// workgroupMemoryExplicitLayout16BitAccess
    struct_body << "\t\t\t" << structInfo->workgroupMemoryExplicitLayout16BitAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(std::ostream &out, const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// rayTracingMaintenance1
    struct_body << "\t\t\t" << structInfo->rayTracingMaintenance1 << "," << std::endl;
// rayTracingPipelineTraceRaysIndirect2
    struct_body << "\t\t\t" << structInfo->rayTracingPipelineTraceRaysIndirect2 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingMaintenance1FeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTraceRaysIndirectCommand2KHR(std::ostream &out, const VkTraceRaysIndirectCommand2KHR* structInfo, Decoded_VkTraceRaysIndirectCommand2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// raygenShaderRecordAddress
    struct_body << "\t" << structInfo->raygenShaderRecordAddress << "UL" << "," << std::endl;
// raygenShaderRecordSize
    struct_body << "\t\t\t" << structInfo->raygenShaderRecordSize << "UL" << "," << std::endl;
// missShaderBindingTableAddress
    struct_body << "\t\t\t" << structInfo->missShaderBindingTableAddress << "UL" << "," << std::endl;
// missShaderBindingTableSize
    struct_body << "\t\t\t" << structInfo->missShaderBindingTableSize << "UL" << "," << std::endl;
// missShaderBindingTableStride
    struct_body << "\t\t\t" << structInfo->missShaderBindingTableStride << "UL" << "," << std::endl;
// hitShaderBindingTableAddress
    struct_body << "\t\t\t" << structInfo->hitShaderBindingTableAddress << "UL" << "," << std::endl;
// hitShaderBindingTableSize
    struct_body << "\t\t\t" << structInfo->hitShaderBindingTableSize << "UL" << "," << std::endl;
// hitShaderBindingTableStride
    struct_body << "\t\t\t" << structInfo->hitShaderBindingTableStride << "UL" << "," << std::endl;
// callableShaderBindingTableAddress
    struct_body << "\t\t\t" << structInfo->callableShaderBindingTableAddress << "UL" << "," << std::endl;
// callableShaderBindingTableSize
    struct_body << "\t\t\t" << structInfo->callableShaderBindingTableSize << "UL" << "," << std::endl;
// callableShaderBindingTableStride
    struct_body << "\t\t\t" << structInfo->callableShaderBindingTableStride << "UL" << "," << std::endl;
// width
    struct_body << "\t\t\t" << structInfo->width << "," << std::endl;
// height
    struct_body << "\t\t\t" << structInfo->height << "," << std::endl;
// depth
    struct_body << "\t\t\t" << structInfo->depth << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "traceRaysIndirectCommand2KHR");
    out << "\t\t" << "VkTraceRaysIndirectCommand2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferUsageFlags2CreateInfoKHR(std::ostream &out, const VkBufferUsageFlags2CreateInfoKHR* structInfo, Decoded_VkBufferUsageFlags2CreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// usage
    struct_body << "\t\t\t" << "VkBufferUsageFlags2KHR(" << structInfo->usage << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferUsageFlags2CreateInfoKHR");
    out << "\t\t" << "VkBufferUsageFlags2CreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceImageSubresourceInfoKHR(std::ostream &out, const VkDeviceImageSubresourceInfoKHR* structInfo, Decoded_VkDeviceImageSubresourceInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcreate_info_struct = "NULL";
    if (structInfo->pCreateInfo != NULL) {
        pcreate_info_struct = GenerateStruct_VkImageCreateInfo(out,
                                                               structInfo->pCreateInfo,
                                                               metaInfo->pCreateInfo->GetMetaStructPointer(),
                                                               consumer);
        pcreate_info_struct.insert(0, "&");
    }
    std::string psubresource_struct = "NULL";
    if (structInfo->pSubresource != NULL) {
        psubresource_struct = GenerateStruct_VkImageSubresource2KHR(out,
                                                                    structInfo->pSubresource,
                                                                    metaInfo->pSubresource->GetMetaStructPointer(),
                                                                    consumer);
        psubresource_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pCreateInfo
    struct_body << "\t\t\t" << pcreate_info_struct << "," << std::endl;
// pSubresource
    struct_body << "\t\t\t" << psubresource_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceImageSubresourceInfoKHR");
    out << "\t\t" << "VkDeviceImageSubresourceInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageSubresource2KHR(std::ostream &out, const VkImageSubresource2KHR* structInfo, Decoded_VkImageSubresource2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string image_subresource_info_var = GenerateStruct_VkImageSubresource(out,
                                                                               &structInfo->imageSubresource,
                                                                               metaInfo->imageSubresource,
                                                                               consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// imageSubresource
    struct_body << "\t\t\t" << image_subresource_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageSubresource2KHR");
    out << "\t\t" << "VkImageSubresource2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance5FeaturesKHR(std::ostream &out, const VkPhysicalDeviceMaintenance5FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceMaintenance5FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maintenance5
    struct_body << "\t\t\t" << structInfo->maintenance5 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance5FeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceMaintenance5FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance5PropertiesKHR(std::ostream &out, const VkPhysicalDeviceMaintenance5PropertiesKHR* structInfo, Decoded_VkPhysicalDeviceMaintenance5PropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// earlyFragmentMultisampleCoverageAfterSampleCounting
    struct_body << "\t\t\t" << structInfo->earlyFragmentMultisampleCoverageAfterSampleCounting << "," << std::endl;
// earlyFragmentSampleMaskTestBeforeSampleCounting
    struct_body << "\t\t\t" << structInfo->earlyFragmentSampleMaskTestBeforeSampleCounting << "," << std::endl;
// depthStencilSwizzleOneSupport
    struct_body << "\t\t\t" << structInfo->depthStencilSwizzleOneSupport << "," << std::endl;
// polygonModePointSize
    struct_body << "\t\t\t" << structInfo->polygonModePointSize << "," << std::endl;
// nonStrictSinglePixelWideLinesUseParallelogram
    struct_body << "\t\t\t" << structInfo->nonStrictSinglePixelWideLinesUseParallelogram << "," << std::endl;
// nonStrictWideLinesUseParallelogram
    struct_body << "\t\t\t" << structInfo->nonStrictWideLinesUseParallelogram << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance5PropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceMaintenance5PropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCreateFlags2CreateInfoKHR(std::ostream &out, const VkPipelineCreateFlags2CreateInfoKHR* structInfo, Decoded_VkPipelineCreateFlags2CreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineCreateFlags2KHR(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCreateFlags2CreateInfoKHR");
    out << "\t\t" << "VkPipelineCreateFlags2CreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderingAreaInfoKHR(std::ostream &out, const VkRenderingAreaInfoKHR* structInfo, Decoded_VkRenderingAreaInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcolor_attachment_formats_values;
    std::string pcolor_attachment_formats_array = "NULL";
    if (structInfo->pColorAttachmentFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            pcolor_attachment_formats_values += util::ToString<VkFormat>(structInfo->pColorAttachmentFormats[idx]) + ", ";
        }
        pcolor_attachment_formats_array = "pColorAttachmentFormats_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkFormat " << pcolor_attachment_formats_array << "[] = {" << pcolor_attachment_formats_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// viewMask
    struct_body << "\t\t\t" << structInfo->viewMask << "," << std::endl;
// colorAttachmentCount
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
// pColorAttachmentFormats
    struct_body << "\t\t\t" << pcolor_attachment_formats_array << "," << std::endl;
// depthAttachmentFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->depthAttachmentFormat << ")" << "," << std::endl;
// stencilAttachmentFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->stencilAttachmentFormat << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderingAreaInfoKHR");
    out << "\t\t" << "VkRenderingAreaInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubresourceLayout2KHR(std::ostream &out, const VkSubresourceLayout2KHR* structInfo, Decoded_VkSubresourceLayout2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string subresource_layout_info_var = GenerateStruct_VkSubresourceLayout(out,
                                                                                 &structInfo->subresourceLayout,
                                                                                 metaInfo->subresourceLayout,
                                                                                 consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// subresourceLayout
    struct_body << "\t\t\t" << subresource_layout_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subresourceLayout2KHR");
    out << "\t\t" << "VkSubresourceLayout2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(std::ostream &out, const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// rayTracingPositionFetch
    struct_body << "\t\t\t" << structInfo->rayTracingPositionFetch << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingPositionFetchFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCooperativeMatrixPropertiesKHR(std::ostream &out, const VkCooperativeMatrixPropertiesKHR* structInfo, Decoded_VkCooperativeMatrixPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// MSize
    struct_body << "\t\t\t" << structInfo->MSize << "," << std::endl;
// NSize
    struct_body << "\t\t\t" << structInfo->NSize << "," << std::endl;
// KSize
    struct_body << "\t\t\t" << structInfo->KSize << "," << std::endl;
// AType
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->AType << ")" << "," << std::endl;
// BType
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->BType << ")" << "," << std::endl;
// CType
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->CType << ")" << "," << std::endl;
// ResultType
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->ResultType << ")" << "," << std::endl;
// saturatingAccumulation
    struct_body << "\t\t\t" << structInfo->saturatingAccumulation << "," << std::endl;
// scope
    struct_body << "\t\t\t" << "VkScopeKHR(" << structInfo->scope << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "cooperativeMatrixPropertiesKHR");
    out << "\t\t" << "VkCooperativeMatrixPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(std::ostream &out, const VkPhysicalDeviceCooperativeMatrixFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// cooperativeMatrix
    struct_body << "\t\t\t" << structInfo->cooperativeMatrix << "," << std::endl;
// cooperativeMatrixRobustBufferAccess
    struct_body << "\t\t\t" << structInfo->cooperativeMatrixRobustBufferAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCooperativeMatrixFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceCooperativeMatrixFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(std::ostream &out, const VkPhysicalDeviceCooperativeMatrixPropertiesKHR* structInfo, Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// cooperativeMatrixSupportedStages
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->cooperativeMatrixSupportedStages << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCooperativeMatrixPropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceCooperativeMatrixPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR(std::ostream &out, const VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// vertexAttributeInstanceRateDivisor
    struct_body << "\t\t\t" << structInfo->vertexAttributeInstanceRateDivisor << "," << std::endl;
// vertexAttributeInstanceRateZeroDivisor
    struct_body << "\t\t\t" << structInfo->vertexAttributeInstanceRateZeroDivisor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVertexAttributeDivisorFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR(std::ostream &out, const VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR* structInfo, Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxVertexAttribDivisor
    struct_body << "\t\t\t" << structInfo->maxVertexAttribDivisor << "," << std::endl;
// supportsNonZeroFirstInstance
    struct_body << "\t\t\t" << structInfo->supportsNonZeroFirstInstance << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVertexAttributeDivisorPropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceVertexAttributeDivisorPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineVertexInputDivisorStateCreateInfoKHR(std::ostream &out, const VkPipelineVertexInputDivisorStateCreateInfoKHR* structInfo, Decoded_VkPipelineVertexInputDivisorStateCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pvertex_binding_divisors_array = "NULL";
    if (structInfo->pVertexBindingDivisors != NULL) {
        pvertex_binding_divisors_array = "pVertexBindingDivisors_" + std::to_string(consumer.GetNextId());
        std::string pvertex_binding_divisors_names;
        for (uint32_t idx = 0; idx < structInfo->vertexBindingDivisorCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pVertexBindingDivisors + idx != NULL) {
                variable_name = GenerateStruct_VkVertexInputBindingDivisorDescriptionKHR(out,
                                                                                         structInfo->pVertexBindingDivisors + idx,
                                                                                         metaInfo->pVertexBindingDivisors->GetMetaStructPointer() + idx,
                                                                                         consumer);
            }
            pvertex_binding_divisors_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVertexInputBindingDivisorDescriptionKHR " << pvertex_binding_divisors_array << "[] = {" << pvertex_binding_divisors_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// vertexBindingDivisorCount
    struct_body << "\t\t\t" << structInfo->vertexBindingDivisorCount << "," << std::endl;
// pVertexBindingDivisors
    struct_body << "\t\t\t" << pvertex_binding_divisors_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineVertexInputDivisorStateCreateInfoKHR");
    out << "\t\t" << "VkPipelineVertexInputDivisorStateCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVertexInputBindingDivisorDescriptionKHR(std::ostream &out, const VkVertexInputBindingDivisorDescriptionKHR* structInfo, Decoded_VkVertexInputBindingDivisorDescriptionKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// binding
    struct_body << "\t" << structInfo->binding << "," << std::endl;
// divisor
    struct_body << "\t\t\t" << structInfo->divisor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "vertexInputBindingDivisorDescriptionKHR");
    out << "\t\t" << "VkVertexInputBindingDivisorDescriptionKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCalibratedTimestampInfoKHR(std::ostream &out, const VkCalibratedTimestampInfoKHR* structInfo, Decoded_VkCalibratedTimestampInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// timeDomain
    struct_body << "\t\t\t" << "VkTimeDomainKHR(" << structInfo->timeDomain << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "calibratedTimestampInfoKHR");
    out << "\t\t" << "VkCalibratedTimestampInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugReportCallbackCreateInfoEXT(std::ostream &out, const VkDebugReportCallbackCreateInfoEXT* structInfo, Decoded_VkDebugReportCallbackCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDebugReportFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// pfnCallback
    struct_body << "\t\t\t" << structInfo->pfnCallback << "," << std::endl;
// pUserData
    out << "\t\t" << "// TODO: Support pUserData (output?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "debugReportCallbackCreateInfoEXT");
    out << "\t\t" << "VkDebugReportCallbackCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRasterizationStateRasterizationOrderAMD(std::ostream &out, const VkPipelineRasterizationStateRasterizationOrderAMD* structInfo, Decoded_VkPipelineRasterizationStateRasterizationOrderAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// rasterizationOrder
    struct_body << "\t\t\t" << "VkRasterizationOrderAMD(" << structInfo->rasterizationOrder << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRasterizationStateRasterizationOrderAMD");
    out << "\t\t" << "VkPipelineRasterizationStateRasterizationOrderAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugMarkerMarkerInfoEXT(std::ostream &out, const VkDebugMarkerMarkerInfoEXT* structInfo, Decoded_VkDebugMarkerMarkerInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pMarkerName
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pMarkerName) << "," << std::endl;
// color
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->color[0]), 4) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "debugMarkerMarkerInfoEXT");
    out << "\t\t" << "VkDebugMarkerMarkerInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugMarkerObjectNameInfoEXT(std::ostream &out, const VkDebugMarkerObjectNameInfoEXT* structInfo, Decoded_VkDebugMarkerObjectNameInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// objectType
    struct_body << "\t\t\t" << "VkDebugReportObjectTypeEXT(" << structInfo->objectType << ")" << "," << std::endl;
// object
    struct_body << "\t\t\t" << structInfo->object << "UL" << "," << std::endl;
// pObjectName
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pObjectName) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "debugMarkerObjectNameInfoEXT");
    out << "\t\t" << "VkDebugMarkerObjectNameInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugMarkerObjectTagInfoEXT(std::ostream &out, const VkDebugMarkerObjectTagInfoEXT* structInfo, Decoded_VkDebugMarkerObjectTagInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ptag_array = "NULL";
    if (structInfo->pTag != NULL) {
        std::string ptag_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->tagSize; ++idx0) {
            ptag_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pTag)[idx0]) + ", ";
        }
        ptag_array = "pTag_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << ptag_array << "[] = {" << ptag_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// objectType
    struct_body << "\t\t\t" << "VkDebugReportObjectTypeEXT(" << structInfo->objectType << ")" << "," << std::endl;
// object
    struct_body << "\t\t\t" << structInfo->object << "UL" << "," << std::endl;
// tagName
    struct_body << "\t\t\t" << structInfo->tagName << "UL" << "," << std::endl;
// tagSize
    struct_body << "\t\t\t" << structInfo->tagSize << "," << std::endl;
// pTag
    struct_body << "\t\t\t" << ptag_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "debugMarkerObjectTagInfoEXT");
    out << "\t\t" << "VkDebugMarkerObjectTagInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDedicatedAllocationBufferCreateInfoNV(std::ostream &out, const VkDedicatedAllocationBufferCreateInfoNV* structInfo, Decoded_VkDedicatedAllocationBufferCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// dedicatedAllocation
    struct_body << "\t\t\t" << structInfo->dedicatedAllocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dedicatedAllocationBufferCreateInfoNV");
    out << "\t\t" << "VkDedicatedAllocationBufferCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDedicatedAllocationImageCreateInfoNV(std::ostream &out, const VkDedicatedAllocationImageCreateInfoNV* structInfo, Decoded_VkDedicatedAllocationImageCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// dedicatedAllocation
    struct_body << "\t\t\t" << structInfo->dedicatedAllocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dedicatedAllocationImageCreateInfoNV");
    out << "\t\t" << "VkDedicatedAllocationImageCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDedicatedAllocationMemoryAllocateInfoNV(std::ostream &out, const VkDedicatedAllocationMemoryAllocateInfoNV* structInfo, Decoded_VkDedicatedAllocationMemoryAllocateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// image
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
// buffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dedicatedAllocationMemoryAllocateInfoNV");
    out << "\t\t" << "VkDedicatedAllocationMemoryAllocateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTransformFeedbackFeaturesEXT(std::ostream &out, const VkPhysicalDeviceTransformFeedbackFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// transformFeedback
    struct_body << "\t\t\t" << structInfo->transformFeedback << "," << std::endl;
// geometryStreams
    struct_body << "\t\t\t" << structInfo->geometryStreams << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTransformFeedbackFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceTransformFeedbackFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTransformFeedbackPropertiesEXT(std::ostream &out, const VkPhysicalDeviceTransformFeedbackPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxTransformFeedbackStreams
    struct_body << "\t\t\t" << structInfo->maxTransformFeedbackStreams << "," << std::endl;
// maxTransformFeedbackBuffers
    struct_body << "\t\t\t" << structInfo->maxTransformFeedbackBuffers << "," << std::endl;
// maxTransformFeedbackBufferSize
    struct_body << "\t\t\t" << structInfo->maxTransformFeedbackBufferSize << "UL" << "," << std::endl;
// maxTransformFeedbackStreamDataSize
    struct_body << "\t\t\t" << structInfo->maxTransformFeedbackStreamDataSize << "," << std::endl;
// maxTransformFeedbackBufferDataSize
    struct_body << "\t\t\t" << structInfo->maxTransformFeedbackBufferDataSize << "," << std::endl;
// maxTransformFeedbackBufferDataStride
    struct_body << "\t\t\t" << structInfo->maxTransformFeedbackBufferDataStride << "," << std::endl;
// transformFeedbackQueries
    struct_body << "\t\t\t" << structInfo->transformFeedbackQueries << "," << std::endl;
// transformFeedbackStreamsLinesTriangles
    struct_body << "\t\t\t" << structInfo->transformFeedbackStreamsLinesTriangles << "," << std::endl;
// transformFeedbackRasterizationStreamSelect
    struct_body << "\t\t\t" << structInfo->transformFeedbackRasterizationStreamSelect << "," << std::endl;
// transformFeedbackDraw
    struct_body << "\t\t\t" << structInfo->transformFeedbackDraw << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTransformFeedbackPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceTransformFeedbackPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRasterizationStateStreamCreateInfoEXT(std::ostream &out, const VkPipelineRasterizationStateStreamCreateInfoEXT* structInfo, Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineRasterizationStateStreamCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// rasterizationStream
    struct_body << "\t\t\t" << structInfo->rasterizationStream << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRasterizationStateStreamCreateInfoEXT");
    out << "\t\t" << "VkPipelineRasterizationStateStreamCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewAddressPropertiesNVX(std::ostream &out, const VkImageViewAddressPropertiesNVX* structInfo, Decoded_VkImageViewAddressPropertiesNVX* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceAddress
    struct_body << "\t\t\t" << structInfo->deviceAddress << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewAddressPropertiesNVX");
    out << "\t\t" << "VkImageViewAddressPropertiesNVX " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewHandleInfoNVX(std::ostream &out, const VkImageViewHandleInfoNVX* structInfo, Decoded_VkImageViewHandleInfoNVX* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// imageView
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->imageView) << "," << std::endl;
// descriptorType
    struct_body << "\t\t\t" << "VkDescriptorType(" << structInfo->descriptorType << ")" << "," << std::endl;
// sampler
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->sampler) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewHandleInfoNVX");
    out << "\t\t" << "VkImageViewHandleInfoNVX " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264CapabilitiesEXT(std::ostream &out, const VkVideoEncodeH264CapabilitiesEXT* structInfo, Decoded_VkVideoEncodeH264CapabilitiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoEncodeH264CapabilityFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// maxLevelIdc
    struct_body << "\t\t\t" << "StdVideoH264LevelIdc(" << structInfo->maxLevelIdc << ")" << "," << std::endl;
// maxSliceCount
    struct_body << "\t\t\t" << structInfo->maxSliceCount << "," << std::endl;
// maxPPictureL0ReferenceCount
    struct_body << "\t\t\t" << structInfo->maxPPictureL0ReferenceCount << "," << std::endl;
// maxBPictureL0ReferenceCount
    struct_body << "\t\t\t" << structInfo->maxBPictureL0ReferenceCount << "," << std::endl;
// maxL1ReferenceCount
    struct_body << "\t\t\t" << structInfo->maxL1ReferenceCount << "," << std::endl;
// maxTemporalLayerCount
    struct_body << "\t\t\t" << structInfo->maxTemporalLayerCount << "," << std::endl;
// expectDyadicTemporalLayerPattern
    struct_body << "\t\t\t" << structInfo->expectDyadicTemporalLayerPattern << "," << std::endl;
// minQp
    struct_body << "\t\t\t" << structInfo->minQp << "," << std::endl;
// maxQp
    struct_body << "\t\t\t" << structInfo->maxQp << "," << std::endl;
// prefersGopRemainingFrames
    struct_body << "\t\t\t" << structInfo->prefersGopRemainingFrames << "," << std::endl;
// requiresGopRemainingFrames
    struct_body << "\t\t\t" << structInfo->requiresGopRemainingFrames << "," << std::endl;
// stdSyntaxFlags
    struct_body << "\t\t\t" << "VkVideoEncodeH264StdFlagsEXT(" << structInfo->stdSyntaxFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264CapabilitiesEXT");
    out << "\t\t" << "VkVideoEncodeH264CapabilitiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264DpbSlotInfoEXT(std::ostream &out, const VkVideoEncodeH264DpbSlotInfoEXT* structInfo, Decoded_VkVideoEncodeH264DpbSlotInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_reference_info_struct = "NULL";
    if (structInfo->pStdReferenceInfo != NULL) {
        pstd_reference_info_struct = GenerateStruct_StdVideoEncodeH264ReferenceInfo(out,
                                                                                    structInfo->pStdReferenceInfo,
                                                                                    metaInfo->pStdReferenceInfo->GetMetaStructPointer(),
                                                                                    consumer);
        pstd_reference_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pStdReferenceInfo
    struct_body << "\t\t\t" << pstd_reference_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264DpbSlotInfoEXT");
    out << "\t\t" << "VkVideoEncodeH264DpbSlotInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264FrameSizeEXT(std::ostream &out, const VkVideoEncodeH264FrameSizeEXT* structInfo, Decoded_VkVideoEncodeH264FrameSizeEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// frameISize
    struct_body << "\t" << structInfo->frameISize << "," << std::endl;
// framePSize
    struct_body << "\t\t\t" << structInfo->framePSize << "," << std::endl;
// frameBSize
    struct_body << "\t\t\t" << structInfo->frameBSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264FrameSizeEXT");
    out << "\t\t" << "VkVideoEncodeH264FrameSizeEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264GopRemainingFrameInfoEXT(std::ostream &out, const VkVideoEncodeH264GopRemainingFrameInfoEXT* structInfo, Decoded_VkVideoEncodeH264GopRemainingFrameInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// useGopRemainingFrames
    struct_body << "\t\t\t" << structInfo->useGopRemainingFrames << "," << std::endl;
// gopRemainingI
    struct_body << "\t\t\t" << structInfo->gopRemainingI << "," << std::endl;
// gopRemainingP
    struct_body << "\t\t\t" << structInfo->gopRemainingP << "," << std::endl;
// gopRemainingB
    struct_body << "\t\t\t" << structInfo->gopRemainingB << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264GopRemainingFrameInfoEXT");
    out << "\t\t" << "VkVideoEncodeH264GopRemainingFrameInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264NaluSliceInfoEXT(std::ostream &out, const VkVideoEncodeH264NaluSliceInfoEXT* structInfo, Decoded_VkVideoEncodeH264NaluSliceInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_slice_header_struct = "NULL";
    if (structInfo->pStdSliceHeader != NULL) {
        pstd_slice_header_struct = GenerateStruct_StdVideoEncodeH264SliceHeader(out,
                                                                                structInfo->pStdSliceHeader,
                                                                                metaInfo->pStdSliceHeader->GetMetaStructPointer(),
                                                                                consumer);
        pstd_slice_header_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// constantQp
    struct_body << "\t\t\t" << structInfo->constantQp << "," << std::endl;
// pStdSliceHeader
    struct_body << "\t\t\t" << pstd_slice_header_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264NaluSliceInfoEXT");
    out << "\t\t" << "VkVideoEncodeH264NaluSliceInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264PictureInfoEXT(std::ostream &out, const VkVideoEncodeH264PictureInfoEXT* structInfo, Decoded_VkVideoEncodeH264PictureInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pnalu_slice_entries_array = "NULL";
    if (structInfo->pNaluSliceEntries != NULL) {
        pnalu_slice_entries_array = "pNaluSliceEntries_" + std::to_string(consumer.GetNextId());
        std::string pnalu_slice_entries_names;
        for (uint32_t idx = 0; idx < structInfo->naluSliceEntryCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pNaluSliceEntries + idx != NULL) {
                variable_name = GenerateStruct_VkVideoEncodeH264NaluSliceInfoEXT(out,
                                                                                 structInfo->pNaluSliceEntries + idx,
                                                                                 metaInfo->pNaluSliceEntries->GetMetaStructPointer() + idx,
                                                                                 consumer);
            }
            pnalu_slice_entries_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVideoEncodeH264NaluSliceInfoEXT " << pnalu_slice_entries_array << "[] = {" << pnalu_slice_entries_names << "};" << std::endl;
    }
    std::string pstd_picture_info_struct = "NULL";
    if (structInfo->pStdPictureInfo != NULL) {
        pstd_picture_info_struct = GenerateStruct_StdVideoEncodeH264PictureInfo(out,
                                                                                structInfo->pStdPictureInfo,
                                                                                metaInfo->pStdPictureInfo->GetMetaStructPointer(),
                                                                                consumer);
        pstd_picture_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// naluSliceEntryCount
    struct_body << "\t\t\t" << structInfo->naluSliceEntryCount << "," << std::endl;
// pNaluSliceEntries
    struct_body << "\t\t\t" << pnalu_slice_entries_array << "," << std::endl;
// pStdPictureInfo
    struct_body << "\t\t\t" << pstd_picture_info_struct << "," << std::endl;
// generatePrefixNalu
    struct_body << "\t\t\t" << structInfo->generatePrefixNalu << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264PictureInfoEXT");
    out << "\t\t" << "VkVideoEncodeH264PictureInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264ProfileInfoEXT(std::ostream &out, const VkVideoEncodeH264ProfileInfoEXT* structInfo, Decoded_VkVideoEncodeH264ProfileInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stdProfileIdc
    struct_body << "\t\t\t" << "StdVideoH264ProfileIdc(" << structInfo->stdProfileIdc << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264ProfileInfoEXT");
    out << "\t\t" << "VkVideoEncodeH264ProfileInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264QpEXT(std::ostream &out, const VkVideoEncodeH264QpEXT* structInfo, Decoded_VkVideoEncodeH264QpEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// qpI
    struct_body << "\t" << structInfo->qpI << "," << std::endl;
// qpP
    struct_body << "\t\t\t" << structInfo->qpP << "," << std::endl;
// qpB
    struct_body << "\t\t\t" << structInfo->qpB << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264QpEXT");
    out << "\t\t" << "VkVideoEncodeH264QpEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264QualityLevelPropertiesEXT(std::ostream &out, const VkVideoEncodeH264QualityLevelPropertiesEXT* structInfo, Decoded_VkVideoEncodeH264QualityLevelPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string preferred_constant_qp_info_var = GenerateStruct_VkVideoEncodeH264QpEXT(out,
                                                                                       &structInfo->preferredConstantQp,
                                                                                       metaInfo->preferredConstantQp,
                                                                                       consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// preferredRateControlFlags
    struct_body << "\t\t\t" << "VkVideoEncodeH264RateControlFlagsEXT(" << structInfo->preferredRateControlFlags << ")" << "," << std::endl;
// preferredGopFrameCount
    struct_body << "\t\t\t" << structInfo->preferredGopFrameCount << "," << std::endl;
// preferredIdrPeriod
    struct_body << "\t\t\t" << structInfo->preferredIdrPeriod << "," << std::endl;
// preferredConsecutiveBFrameCount
    struct_body << "\t\t\t" << structInfo->preferredConsecutiveBFrameCount << "," << std::endl;
// preferredTemporalLayerCount
    struct_body << "\t\t\t" << structInfo->preferredTemporalLayerCount << "," << std::endl;
// preferredConstantQp
    struct_body << "\t\t\t" << preferred_constant_qp_info_var << "," << std::endl;
// preferredMaxL0ReferenceCount
    struct_body << "\t\t\t" << structInfo->preferredMaxL0ReferenceCount << "," << std::endl;
// preferredMaxL1ReferenceCount
    struct_body << "\t\t\t" << structInfo->preferredMaxL1ReferenceCount << "," << std::endl;
// preferredStdEntropyCodingModeFlag
    struct_body << "\t\t\t" << structInfo->preferredStdEntropyCodingModeFlag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264QualityLevelPropertiesEXT");
    out << "\t\t" << "VkVideoEncodeH264QualityLevelPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264RateControlInfoEXT(std::ostream &out, const VkVideoEncodeH264RateControlInfoEXT* structInfo, Decoded_VkVideoEncodeH264RateControlInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoEncodeH264RateControlFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// gopFrameCount
    struct_body << "\t\t\t" << structInfo->gopFrameCount << "," << std::endl;
// idrPeriod
    struct_body << "\t\t\t" << structInfo->idrPeriod << "," << std::endl;
// consecutiveBFrameCount
    struct_body << "\t\t\t" << structInfo->consecutiveBFrameCount << "," << std::endl;
// temporalLayerCount
    struct_body << "\t\t\t" << structInfo->temporalLayerCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264RateControlInfoEXT");
    out << "\t\t" << "VkVideoEncodeH264RateControlInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264RateControlLayerInfoEXT(std::ostream &out, const VkVideoEncodeH264RateControlLayerInfoEXT* structInfo, Decoded_VkVideoEncodeH264RateControlLayerInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string min_qp_info_var = GenerateStruct_VkVideoEncodeH264QpEXT(out,
                                                                        &structInfo->minQp,
                                                                        metaInfo->minQp,
                                                                        consumer);
    std::string max_qp_info_var = GenerateStruct_VkVideoEncodeH264QpEXT(out,
                                                                        &structInfo->maxQp,
                                                                        metaInfo->maxQp,
                                                                        consumer);
    std::string max_frame_size_info_var = GenerateStruct_VkVideoEncodeH264FrameSizeEXT(out,
                                                                                       &structInfo->maxFrameSize,
                                                                                       metaInfo->maxFrameSize,
                                                                                       consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// useMinQp
    struct_body << "\t\t\t" << structInfo->useMinQp << "," << std::endl;
// minQp
    struct_body << "\t\t\t" << min_qp_info_var << "," << std::endl;
// useMaxQp
    struct_body << "\t\t\t" << structInfo->useMaxQp << "," << std::endl;
// maxQp
    struct_body << "\t\t\t" << max_qp_info_var << "," << std::endl;
// useMaxFrameSize
    struct_body << "\t\t\t" << structInfo->useMaxFrameSize << "," << std::endl;
// maxFrameSize
    struct_body << "\t\t\t" << max_frame_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264RateControlLayerInfoEXT");
    out << "\t\t" << "VkVideoEncodeH264RateControlLayerInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264SessionCreateInfoEXT(std::ostream &out, const VkVideoEncodeH264SessionCreateInfoEXT* structInfo, Decoded_VkVideoEncodeH264SessionCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// useMaxLevelIdc
    struct_body << "\t\t\t" << structInfo->useMaxLevelIdc << "," << std::endl;
// maxLevelIdc
    struct_body << "\t\t\t" << "StdVideoH264LevelIdc(" << structInfo->maxLevelIdc << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264SessionCreateInfoEXT");
    out << "\t\t" << "VkVideoEncodeH264SessionCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264SessionParametersAddInfoEXT(std::ostream &out, const VkVideoEncodeH264SessionParametersAddInfoEXT* structInfo, Decoded_VkVideoEncodeH264SessionParametersAddInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_s_pss_array = "NULL";
    if (structInfo->pStdSPSs != NULL) {
        pstd_s_pss_array = "pStdSPSs_" + std::to_string(consumer.GetNextId());
        std::string pstd_s_pss_names;
        for (uint32_t idx = 0; idx < structInfo->stdSPSCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdSPSs + idx != NULL) {
                variable_name = GenerateStruct_StdVideoH264SequenceParameterSet(out,
                                                                                structInfo->pStdSPSs + idx,
                                                                                metaInfo->pStdSPSs->GetMetaStructPointer() + idx,
                                                                                consumer);
            }
            pstd_s_pss_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoH264SequenceParameterSet " << pstd_s_pss_array << "[] = {" << pstd_s_pss_names << "};" << std::endl;
    }
    std::string pstd_pp_ss_array = "NULL";
    if (structInfo->pStdPPSs != NULL) {
        pstd_pp_ss_array = "pStdPPSs_" + std::to_string(consumer.GetNextId());
        std::string pstd_pp_ss_names;
        for (uint32_t idx = 0; idx < structInfo->stdPPSCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdPPSs + idx != NULL) {
                variable_name = GenerateStruct_StdVideoH264PictureParameterSet(out,
                                                                               structInfo->pStdPPSs + idx,
                                                                               metaInfo->pStdPPSs->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pstd_pp_ss_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoH264PictureParameterSet " << pstd_pp_ss_array << "[] = {" << pstd_pp_ss_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stdSPSCount
    struct_body << "\t\t\t" << structInfo->stdSPSCount << "," << std::endl;
// pStdSPSs
    struct_body << "\t\t\t" << pstd_s_pss_array << "," << std::endl;
// stdPPSCount
    struct_body << "\t\t\t" << structInfo->stdPPSCount << "," << std::endl;
// pStdPPSs
    struct_body << "\t\t\t" << pstd_pp_ss_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264SessionParametersAddInfoEXT");
    out << "\t\t" << "VkVideoEncodeH264SessionParametersAddInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264SessionParametersCreateInfoEXT(std::ostream &out, const VkVideoEncodeH264SessionParametersCreateInfoEXT* structInfo, Decoded_VkVideoEncodeH264SessionParametersCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pparameters_add_info_struct = "NULL";
    if (structInfo->pParametersAddInfo != NULL) {
        pparameters_add_info_struct = GenerateStruct_VkVideoEncodeH264SessionParametersAddInfoEXT(out,
                                                                                                  structInfo->pParametersAddInfo,
                                                                                                  metaInfo->pParametersAddInfo->GetMetaStructPointer(),
                                                                                                  consumer);
        pparameters_add_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxStdSPSCount
    struct_body << "\t\t\t" << structInfo->maxStdSPSCount << "," << std::endl;
// maxStdPPSCount
    struct_body << "\t\t\t" << structInfo->maxStdPPSCount << "," << std::endl;
// pParametersAddInfo
    struct_body << "\t\t\t" << pparameters_add_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264SessionParametersCreateInfoEXT");
    out << "\t\t" << "VkVideoEncodeH264SessionParametersCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264SessionParametersFeedbackInfoEXT(std::ostream &out, const VkVideoEncodeH264SessionParametersFeedbackInfoEXT* structInfo, Decoded_VkVideoEncodeH264SessionParametersFeedbackInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// hasStdSPSOverrides
    struct_body << "\t\t\t" << structInfo->hasStdSPSOverrides << "," << std::endl;
// hasStdPPSOverrides
    struct_body << "\t\t\t" << structInfo->hasStdPPSOverrides << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264SessionParametersFeedbackInfoEXT");
    out << "\t\t" << "VkVideoEncodeH264SessionParametersFeedbackInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264SessionParametersGetInfoEXT(std::ostream &out, const VkVideoEncodeH264SessionParametersGetInfoEXT* structInfo, Decoded_VkVideoEncodeH264SessionParametersGetInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// writeStdSPS
    struct_body << "\t\t\t" << structInfo->writeStdSPS << "," << std::endl;
// writeStdPPS
    struct_body << "\t\t\t" << structInfo->writeStdPPS << "," << std::endl;
// stdSPSId
    struct_body << "\t\t\t" << structInfo->stdSPSId << "," << std::endl;
// stdPPSId
    struct_body << "\t\t\t" << structInfo->stdPPSId << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264SessionParametersGetInfoEXT");
    out << "\t\t" << "VkVideoEncodeH264SessionParametersGetInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265CapabilitiesEXT(std::ostream &out, const VkVideoEncodeH265CapabilitiesEXT* structInfo, Decoded_VkVideoEncodeH265CapabilitiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string max_tiles_info_var = GenerateStruct_VkExtent2D(out,
                                                               &structInfo->maxTiles,
                                                               metaInfo->maxTiles,
                                                               consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoEncodeH265CapabilityFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// maxLevelIdc
    struct_body << "\t\t\t" << "StdVideoH265LevelIdc(" << structInfo->maxLevelIdc << ")" << "," << std::endl;
// maxSliceSegmentCount
    struct_body << "\t\t\t" << structInfo->maxSliceSegmentCount << "," << std::endl;
// maxTiles
    struct_body << "\t\t\t" << max_tiles_info_var << "," << std::endl;
// ctbSizes
    struct_body << "\t\t\t" << "VkVideoEncodeH265CtbSizeFlagsEXT(" << structInfo->ctbSizes << ")" << "," << std::endl;
// transformBlockSizes
    struct_body << "\t\t\t" << "VkVideoEncodeH265TransformBlockSizeFlagsEXT(" << structInfo->transformBlockSizes << ")" << "," << std::endl;
// maxPPictureL0ReferenceCount
    struct_body << "\t\t\t" << structInfo->maxPPictureL0ReferenceCount << "," << std::endl;
// maxBPictureL0ReferenceCount
    struct_body << "\t\t\t" << structInfo->maxBPictureL0ReferenceCount << "," << std::endl;
// maxL1ReferenceCount
    struct_body << "\t\t\t" << structInfo->maxL1ReferenceCount << "," << std::endl;
// maxSubLayerCount
    struct_body << "\t\t\t" << structInfo->maxSubLayerCount << "," << std::endl;
// expectDyadicTemporalSubLayerPattern
    struct_body << "\t\t\t" << structInfo->expectDyadicTemporalSubLayerPattern << "," << std::endl;
// minQp
    struct_body << "\t\t\t" << structInfo->minQp << "," << std::endl;
// maxQp
    struct_body << "\t\t\t" << structInfo->maxQp << "," << std::endl;
// prefersGopRemainingFrames
    struct_body << "\t\t\t" << structInfo->prefersGopRemainingFrames << "," << std::endl;
// requiresGopRemainingFrames
    struct_body << "\t\t\t" << structInfo->requiresGopRemainingFrames << "," << std::endl;
// stdSyntaxFlags
    struct_body << "\t\t\t" << "VkVideoEncodeH265StdFlagsEXT(" << structInfo->stdSyntaxFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265CapabilitiesEXT");
    out << "\t\t" << "VkVideoEncodeH265CapabilitiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265DpbSlotInfoEXT(std::ostream &out, const VkVideoEncodeH265DpbSlotInfoEXT* structInfo, Decoded_VkVideoEncodeH265DpbSlotInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_reference_info_struct = "NULL";
    if (structInfo->pStdReferenceInfo != NULL) {
        pstd_reference_info_struct = GenerateStruct_StdVideoEncodeH265ReferenceInfo(out,
                                                                                    structInfo->pStdReferenceInfo,
                                                                                    metaInfo->pStdReferenceInfo->GetMetaStructPointer(),
                                                                                    consumer);
        pstd_reference_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pStdReferenceInfo
    struct_body << "\t\t\t" << pstd_reference_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265DpbSlotInfoEXT");
    out << "\t\t" << "VkVideoEncodeH265DpbSlotInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265FrameSizeEXT(std::ostream &out, const VkVideoEncodeH265FrameSizeEXT* structInfo, Decoded_VkVideoEncodeH265FrameSizeEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// frameISize
    struct_body << "\t" << structInfo->frameISize << "," << std::endl;
// framePSize
    struct_body << "\t\t\t" << structInfo->framePSize << "," << std::endl;
// frameBSize
    struct_body << "\t\t\t" << structInfo->frameBSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265FrameSizeEXT");
    out << "\t\t" << "VkVideoEncodeH265FrameSizeEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265GopRemainingFrameInfoEXT(std::ostream &out, const VkVideoEncodeH265GopRemainingFrameInfoEXT* structInfo, Decoded_VkVideoEncodeH265GopRemainingFrameInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// useGopRemainingFrames
    struct_body << "\t\t\t" << structInfo->useGopRemainingFrames << "," << std::endl;
// gopRemainingI
    struct_body << "\t\t\t" << structInfo->gopRemainingI << "," << std::endl;
// gopRemainingP
    struct_body << "\t\t\t" << structInfo->gopRemainingP << "," << std::endl;
// gopRemainingB
    struct_body << "\t\t\t" << structInfo->gopRemainingB << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265GopRemainingFrameInfoEXT");
    out << "\t\t" << "VkVideoEncodeH265GopRemainingFrameInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265NaluSliceSegmentInfoEXT(std::ostream &out, const VkVideoEncodeH265NaluSliceSegmentInfoEXT* structInfo, Decoded_VkVideoEncodeH265NaluSliceSegmentInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_slice_segment_header_struct = "NULL";
    if (structInfo->pStdSliceSegmentHeader != NULL) {
        pstd_slice_segment_header_struct = GenerateStruct_StdVideoEncodeH265SliceSegmentHeader(out,
                                                                                               structInfo->pStdSliceSegmentHeader,
                                                                                               metaInfo->pStdSliceSegmentHeader->GetMetaStructPointer(),
                                                                                               consumer);
        pstd_slice_segment_header_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// constantQp
    struct_body << "\t\t\t" << structInfo->constantQp << "," << std::endl;
// pStdSliceSegmentHeader
    struct_body << "\t\t\t" << pstd_slice_segment_header_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265NaluSliceSegmentInfoEXT");
    out << "\t\t" << "VkVideoEncodeH265NaluSliceSegmentInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265PictureInfoEXT(std::ostream &out, const VkVideoEncodeH265PictureInfoEXT* structInfo, Decoded_VkVideoEncodeH265PictureInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pnalu_slice_segment_entries_array = "NULL";
    if (structInfo->pNaluSliceSegmentEntries != NULL) {
        pnalu_slice_segment_entries_array = "pNaluSliceSegmentEntries_" + std::to_string(consumer.GetNextId());
        std::string pnalu_slice_segment_entries_names;
        for (uint32_t idx = 0; idx < structInfo->naluSliceSegmentEntryCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pNaluSliceSegmentEntries + idx != NULL) {
                variable_name = GenerateStruct_VkVideoEncodeH265NaluSliceSegmentInfoEXT(out,
                                                                                        structInfo->pNaluSliceSegmentEntries + idx,
                                                                                        metaInfo->pNaluSliceSegmentEntries->GetMetaStructPointer() + idx,
                                                                                        consumer);
            }
            pnalu_slice_segment_entries_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVideoEncodeH265NaluSliceSegmentInfoEXT " << pnalu_slice_segment_entries_array << "[] = {" << pnalu_slice_segment_entries_names << "};" << std::endl;
    }
    std::string pstd_picture_info_struct = "NULL";
    if (structInfo->pStdPictureInfo != NULL) {
        pstd_picture_info_struct = GenerateStruct_StdVideoEncodeH265PictureInfo(out,
                                                                                structInfo->pStdPictureInfo,
                                                                                metaInfo->pStdPictureInfo->GetMetaStructPointer(),
                                                                                consumer);
        pstd_picture_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// naluSliceSegmentEntryCount
    struct_body << "\t\t\t" << structInfo->naluSliceSegmentEntryCount << "," << std::endl;
// pNaluSliceSegmentEntries
    struct_body << "\t\t\t" << pnalu_slice_segment_entries_array << "," << std::endl;
// pStdPictureInfo
    struct_body << "\t\t\t" << pstd_picture_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265PictureInfoEXT");
    out << "\t\t" << "VkVideoEncodeH265PictureInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265ProfileInfoEXT(std::ostream &out, const VkVideoEncodeH265ProfileInfoEXT* structInfo, Decoded_VkVideoEncodeH265ProfileInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stdProfileIdc
    struct_body << "\t\t\t" << "StdVideoH265ProfileIdc(" << structInfo->stdProfileIdc << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265ProfileInfoEXT");
    out << "\t\t" << "VkVideoEncodeH265ProfileInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265QpEXT(std::ostream &out, const VkVideoEncodeH265QpEXT* structInfo, Decoded_VkVideoEncodeH265QpEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// qpI
    struct_body << "\t" << structInfo->qpI << "," << std::endl;
// qpP
    struct_body << "\t\t\t" << structInfo->qpP << "," << std::endl;
// qpB
    struct_body << "\t\t\t" << structInfo->qpB << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265QpEXT");
    out << "\t\t" << "VkVideoEncodeH265QpEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265QualityLevelPropertiesEXT(std::ostream &out, const VkVideoEncodeH265QualityLevelPropertiesEXT* structInfo, Decoded_VkVideoEncodeH265QualityLevelPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string preferred_constant_qp_info_var = GenerateStruct_VkVideoEncodeH265QpEXT(out,
                                                                                       &structInfo->preferredConstantQp,
                                                                                       metaInfo->preferredConstantQp,
                                                                                       consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// preferredRateControlFlags
    struct_body << "\t\t\t" << "VkVideoEncodeH265RateControlFlagsEXT(" << structInfo->preferredRateControlFlags << ")" << "," << std::endl;
// preferredGopFrameCount
    struct_body << "\t\t\t" << structInfo->preferredGopFrameCount << "," << std::endl;
// preferredIdrPeriod
    struct_body << "\t\t\t" << structInfo->preferredIdrPeriod << "," << std::endl;
// preferredConsecutiveBFrameCount
    struct_body << "\t\t\t" << structInfo->preferredConsecutiveBFrameCount << "," << std::endl;
// preferredSubLayerCount
    struct_body << "\t\t\t" << structInfo->preferredSubLayerCount << "," << std::endl;
// preferredConstantQp
    struct_body << "\t\t\t" << preferred_constant_qp_info_var << "," << std::endl;
// preferredMaxL0ReferenceCount
    struct_body << "\t\t\t" << structInfo->preferredMaxL0ReferenceCount << "," << std::endl;
// preferredMaxL1ReferenceCount
    struct_body << "\t\t\t" << structInfo->preferredMaxL1ReferenceCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265QualityLevelPropertiesEXT");
    out << "\t\t" << "VkVideoEncodeH265QualityLevelPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265RateControlInfoEXT(std::ostream &out, const VkVideoEncodeH265RateControlInfoEXT* structInfo, Decoded_VkVideoEncodeH265RateControlInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkVideoEncodeH265RateControlFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// gopFrameCount
    struct_body << "\t\t\t" << structInfo->gopFrameCount << "," << std::endl;
// idrPeriod
    struct_body << "\t\t\t" << structInfo->idrPeriod << "," << std::endl;
// consecutiveBFrameCount
    struct_body << "\t\t\t" << structInfo->consecutiveBFrameCount << "," << std::endl;
// subLayerCount
    struct_body << "\t\t\t" << structInfo->subLayerCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265RateControlInfoEXT");
    out << "\t\t" << "VkVideoEncodeH265RateControlInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265RateControlLayerInfoEXT(std::ostream &out, const VkVideoEncodeH265RateControlLayerInfoEXT* structInfo, Decoded_VkVideoEncodeH265RateControlLayerInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string min_qp_info_var = GenerateStruct_VkVideoEncodeH265QpEXT(out,
                                                                        &structInfo->minQp,
                                                                        metaInfo->minQp,
                                                                        consumer);
    std::string max_qp_info_var = GenerateStruct_VkVideoEncodeH265QpEXT(out,
                                                                        &structInfo->maxQp,
                                                                        metaInfo->maxQp,
                                                                        consumer);
    std::string max_frame_size_info_var = GenerateStruct_VkVideoEncodeH265FrameSizeEXT(out,
                                                                                       &structInfo->maxFrameSize,
                                                                                       metaInfo->maxFrameSize,
                                                                                       consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// useMinQp
    struct_body << "\t\t\t" << structInfo->useMinQp << "," << std::endl;
// minQp
    struct_body << "\t\t\t" << min_qp_info_var << "," << std::endl;
// useMaxQp
    struct_body << "\t\t\t" << structInfo->useMaxQp << "," << std::endl;
// maxQp
    struct_body << "\t\t\t" << max_qp_info_var << "," << std::endl;
// useMaxFrameSize
    struct_body << "\t\t\t" << structInfo->useMaxFrameSize << "," << std::endl;
// maxFrameSize
    struct_body << "\t\t\t" << max_frame_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265RateControlLayerInfoEXT");
    out << "\t\t" << "VkVideoEncodeH265RateControlLayerInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265SessionCreateInfoEXT(std::ostream &out, const VkVideoEncodeH265SessionCreateInfoEXT* structInfo, Decoded_VkVideoEncodeH265SessionCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// useMaxLevelIdc
    struct_body << "\t\t\t" << structInfo->useMaxLevelIdc << "," << std::endl;
// maxLevelIdc
    struct_body << "\t\t\t" << "StdVideoH265LevelIdc(" << structInfo->maxLevelIdc << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265SessionCreateInfoEXT");
    out << "\t\t" << "VkVideoEncodeH265SessionCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265SessionParametersAddInfoEXT(std::ostream &out, const VkVideoEncodeH265SessionParametersAddInfoEXT* structInfo, Decoded_VkVideoEncodeH265SessionParametersAddInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_v_pss_array = "NULL";
    if (structInfo->pStdVPSs != NULL) {
        pstd_v_pss_array = "pStdVPSs_" + std::to_string(consumer.GetNextId());
        std::string pstd_v_pss_names;
        for (uint32_t idx = 0; idx < structInfo->stdVPSCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdVPSs + idx != NULL) {
                variable_name = GenerateStruct_StdVideoH265VideoParameterSet(out,
                                                                             structInfo->pStdVPSs + idx,
                                                                             metaInfo->pStdVPSs->GetMetaStructPointer() + idx,
                                                                             consumer);
            }
            pstd_v_pss_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoH265VideoParameterSet " << pstd_v_pss_array << "[] = {" << pstd_v_pss_names << "};" << std::endl;
    }
    std::string pstd_s_pss_array = "NULL";
    if (structInfo->pStdSPSs != NULL) {
        pstd_s_pss_array = "pStdSPSs_" + std::to_string(consumer.GetNextId());
        std::string pstd_s_pss_names;
        for (uint32_t idx = 0; idx < structInfo->stdSPSCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdSPSs + idx != NULL) {
                variable_name = GenerateStruct_StdVideoH265SequenceParameterSet(out,
                                                                                structInfo->pStdSPSs + idx,
                                                                                metaInfo->pStdSPSs->GetMetaStructPointer() + idx,
                                                                                consumer);
            }
            pstd_s_pss_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoH265SequenceParameterSet " << pstd_s_pss_array << "[] = {" << pstd_s_pss_names << "};" << std::endl;
    }
    std::string pstd_pp_ss_array = "NULL";
    if (structInfo->pStdPPSs != NULL) {
        pstd_pp_ss_array = "pStdPPSs_" + std::to_string(consumer.GetNextId());
        std::string pstd_pp_ss_names;
        for (uint32_t idx = 0; idx < structInfo->stdPPSCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdPPSs + idx != NULL) {
                variable_name = GenerateStruct_StdVideoH265PictureParameterSet(out,
                                                                               structInfo->pStdPPSs + idx,
                                                                               metaInfo->pStdPPSs->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pstd_pp_ss_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoH265PictureParameterSet " << pstd_pp_ss_array << "[] = {" << pstd_pp_ss_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stdVPSCount
    struct_body << "\t\t\t" << structInfo->stdVPSCount << "," << std::endl;
// pStdVPSs
    struct_body << "\t\t\t" << pstd_v_pss_array << "," << std::endl;
// stdSPSCount
    struct_body << "\t\t\t" << structInfo->stdSPSCount << "," << std::endl;
// pStdSPSs
    struct_body << "\t\t\t" << pstd_s_pss_array << "," << std::endl;
// stdPPSCount
    struct_body << "\t\t\t" << structInfo->stdPPSCount << "," << std::endl;
// pStdPPSs
    struct_body << "\t\t\t" << pstd_pp_ss_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265SessionParametersAddInfoEXT");
    out << "\t\t" << "VkVideoEncodeH265SessionParametersAddInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265SessionParametersCreateInfoEXT(std::ostream &out, const VkVideoEncodeH265SessionParametersCreateInfoEXT* structInfo, Decoded_VkVideoEncodeH265SessionParametersCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pparameters_add_info_struct = "NULL";
    if (structInfo->pParametersAddInfo != NULL) {
        pparameters_add_info_struct = GenerateStruct_VkVideoEncodeH265SessionParametersAddInfoEXT(out,
                                                                                                  structInfo->pParametersAddInfo,
                                                                                                  metaInfo->pParametersAddInfo->GetMetaStructPointer(),
                                                                                                  consumer);
        pparameters_add_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxStdVPSCount
    struct_body << "\t\t\t" << structInfo->maxStdVPSCount << "," << std::endl;
// maxStdSPSCount
    struct_body << "\t\t\t" << structInfo->maxStdSPSCount << "," << std::endl;
// maxStdPPSCount
    struct_body << "\t\t\t" << structInfo->maxStdPPSCount << "," << std::endl;
// pParametersAddInfo
    struct_body << "\t\t\t" << pparameters_add_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265SessionParametersCreateInfoEXT");
    out << "\t\t" << "VkVideoEncodeH265SessionParametersCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265SessionParametersFeedbackInfoEXT(std::ostream &out, const VkVideoEncodeH265SessionParametersFeedbackInfoEXT* structInfo, Decoded_VkVideoEncodeH265SessionParametersFeedbackInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// hasStdVPSOverrides
    struct_body << "\t\t\t" << structInfo->hasStdVPSOverrides << "," << std::endl;
// hasStdSPSOverrides
    struct_body << "\t\t\t" << structInfo->hasStdSPSOverrides << "," << std::endl;
// hasStdPPSOverrides
    struct_body << "\t\t\t" << structInfo->hasStdPPSOverrides << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265SessionParametersFeedbackInfoEXT");
    out << "\t\t" << "VkVideoEncodeH265SessionParametersFeedbackInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265SessionParametersGetInfoEXT(std::ostream &out, const VkVideoEncodeH265SessionParametersGetInfoEXT* structInfo, Decoded_VkVideoEncodeH265SessionParametersGetInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// writeStdVPS
    struct_body << "\t\t\t" << structInfo->writeStdVPS << "," << std::endl;
// writeStdSPS
    struct_body << "\t\t\t" << structInfo->writeStdSPS << "," << std::endl;
// writeStdPPS
    struct_body << "\t\t\t" << structInfo->writeStdPPS << "," << std::endl;
// stdVPSId
    struct_body << "\t\t\t" << structInfo->stdVPSId << "," << std::endl;
// stdSPSId
    struct_body << "\t\t\t" << structInfo->stdSPSId << "," << std::endl;
// stdPPSId
    struct_body << "\t\t\t" << structInfo->stdPPSId << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265SessionParametersGetInfoEXT");
    out << "\t\t" << "VkVideoEncodeH265SessionParametersGetInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTextureLODGatherFormatPropertiesAMD(std::ostream &out, const VkTextureLODGatherFormatPropertiesAMD* structInfo, Decoded_VkTextureLODGatherFormatPropertiesAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// supportsTextureGatherLODBiasAMD
    struct_body << "\t\t\t" << structInfo->supportsTextureGatherLODBiasAMD << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "textureLODGatherFormatPropertiesAMD");
    out << "\t\t" << "VkTextureLODGatherFormatPropertiesAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkShaderResourceUsageAMD(std::ostream &out, const VkShaderResourceUsageAMD* structInfo, Decoded_VkShaderResourceUsageAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// numUsedVgprs
    struct_body << "\t" << structInfo->numUsedVgprs << "," << std::endl;
// numUsedSgprs
    struct_body << "\t\t\t" << structInfo->numUsedSgprs << "," << std::endl;
// ldsSizePerLocalWorkGroup
    struct_body << "\t\t\t" << structInfo->ldsSizePerLocalWorkGroup << "," << std::endl;
// ldsUsageSizeInBytes
    struct_body << "\t\t\t" << structInfo->ldsUsageSizeInBytes << "," << std::endl;
// scratchMemUsageInBytes
    struct_body << "\t\t\t" << structInfo->scratchMemUsageInBytes << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "shaderResourceUsageAMD");
    out << "\t\t" << "VkShaderResourceUsageAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkShaderStatisticsInfoAMD(std::ostream &out, const VkShaderStatisticsInfoAMD* structInfo, Decoded_VkShaderStatisticsInfoAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string resource_usage_info_var = GenerateStruct_VkShaderResourceUsageAMD(out,
                                                                                  &structInfo->resourceUsage,
                                                                                  metaInfo->resourceUsage,
                                                                                  consumer);
// shaderStageMask
    struct_body << "\t" << "VkShaderStageFlags(" << structInfo->shaderStageMask << ")" << "," << std::endl;
// resourceUsage
    struct_body << "\t\t\t" << resource_usage_info_var << "," << std::endl;
// numPhysicalVgprs
    struct_body << "\t\t\t" << structInfo->numPhysicalVgprs << "," << std::endl;
// numPhysicalSgprs
    struct_body << "\t\t\t" << structInfo->numPhysicalSgprs << "," << std::endl;
// numAvailableVgprs
    struct_body << "\t\t\t" << structInfo->numAvailableVgprs << "," << std::endl;
// numAvailableSgprs
    struct_body << "\t\t\t" << structInfo->numAvailableSgprs << "," << std::endl;
// computeWorkGroupSize
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->computeWorkGroupSize[0]), 3) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "shaderStatisticsInfoAMD");
    out << "\t\t" << "VkShaderStatisticsInfoAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkStreamDescriptorSurfaceCreateInfoGGP(std::ostream &out, const VkStreamDescriptorSurfaceCreateInfoGGP* structInfo, Decoded_VkStreamDescriptorSurfaceCreateInfoGGP* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkStreamDescriptorSurfaceCreateFlagsGGP(" << structInfo->flags << ")" << "," << std::endl;
// streamDescriptor
    struct_body << "\t\t\t" << structInfo->streamDescriptor << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "streamDescriptorSurfaceCreateInfoGGP");
    out << "\t\t" << "VkStreamDescriptorSurfaceCreateInfoGGP " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCornerSampledImageFeaturesNV(std::ostream &out, const VkPhysicalDeviceCornerSampledImageFeaturesNV* structInfo, Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// cornerSampledImage
    struct_body << "\t\t\t" << structInfo->cornerSampledImage << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCornerSampledImageFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceCornerSampledImageFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalImageFormatPropertiesNV(std::ostream &out, const VkExternalImageFormatPropertiesNV* structInfo, Decoded_VkExternalImageFormatPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string image_format_properties_info_var = GenerateStruct_VkImageFormatProperties(out,
                                                                                          &structInfo->imageFormatProperties,
                                                                                          metaInfo->imageFormatProperties,
                                                                                          consumer);
// imageFormatProperties
    struct_body << "\t" << image_format_properties_info_var << "," << std::endl;
// externalMemoryFeatures
    struct_body << "\t\t\t" << "VkExternalMemoryFeatureFlagsNV(" << structInfo->externalMemoryFeatures << ")" << "," << std::endl;
// exportFromImportedHandleTypes
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->exportFromImportedHandleTypes << ")" << "," << std::endl;
// compatibleHandleTypes
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->compatibleHandleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalImageFormatPropertiesNV");
    out << "\t\t" << "VkExternalImageFormatPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportMemoryAllocateInfoNV(std::ostream &out, const VkExportMemoryAllocateInfoNV* structInfo, Decoded_VkExportMemoryAllocateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// handleTypes
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->handleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportMemoryAllocateInfoNV");
    out << "\t\t" << "VkExportMemoryAllocateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalMemoryImageCreateInfoNV(std::ostream &out, const VkExternalMemoryImageCreateInfoNV* structInfo, Decoded_VkExternalMemoryImageCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// handleTypes
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->handleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalMemoryImageCreateInfoNV");
    out << "\t\t" << "VkExternalMemoryImageCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportMemoryWin32HandleInfoNV(std::ostream &out, const VkExportMemoryWin32HandleInfoNV* structInfo, Decoded_VkExportMemoryWin32HandleInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pAttributes
    struct_body << "\t\t\t" << structInfo->pAttributes << "," << std::endl;
// dwAccess
    struct_body << "\t\t\t" << structInfo->dwAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportMemoryWin32HandleInfoNV");
    out << "\t\t" << "VkExportMemoryWin32HandleInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportMemoryWin32HandleInfoNV(std::ostream &out, const VkImportMemoryWin32HandleInfoNV* structInfo, Decoded_VkImportMemoryWin32HandleInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->handleType << ")" << "," << std::endl;
// handle
    struct_body << "\t\t\t" << structInfo->handle << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importMemoryWin32HandleInfoNV");
    out << "\t\t" << "VkImportMemoryWin32HandleInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWin32KeyedMutexAcquireReleaseInfoNV(std::ostream &out, const VkWin32KeyedMutexAcquireReleaseInfoNV* structInfo, Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pacquire_syncs_array = "NULL";
    if (metaInfo->pAcquireSyncs.GetPointer() != NULL && structInfo->acquireCount > 0) {
        pacquire_syncs_array = "pacquire_syncs_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DEVICE_MEMORY));
        std::string pacquire_syncs_values = toStringJoin(metaInfo->pAcquireSyncs.GetPointer(),
                                                         metaInfo->pAcquireSyncs.GetPointer() + structInfo->acquireCount,
                                                         [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                         ", ");
        if (structInfo->acquireCount == 1) {
            pacquire_syncs_array = "&" + pacquire_syncs_values;
        } else if (structInfo->acquireCount > 1) {
            out << "\t\t" << "VkDeviceMemory " << pacquire_syncs_array << "[] = {" << pacquire_syncs_values << "};" << std::endl;
        }
    }
    std::string pacquire_keys_array = "pacquire_keys_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->acquireCount > 0) {
        std::string pacquire_keys_values = toStringJoin(structInfo->pAcquireKeys,
                                                        structInfo->pAcquireKeys + structInfo->acquireCount,
                                                        [](uint64_t current) { return std::to_string(current); },
                                                        ", ");
        if (structInfo->acquireCount == 1) {
            pacquire_keys_array = "&" + pacquire_keys_values;
        } else if (structInfo->acquireCount > 1) {
            out << "\t\t" << "uint64_t " << pacquire_keys_array << "[] = {" << pacquire_keys_values << "};" << std::endl;
        }
    }
    std::string pacquire_timeout_milliseconds_array = "NULL";
    if (structInfo->pAcquireTimeoutMilliseconds != NULL) {
        pacquire_timeout_milliseconds_array = "pAcquireTimeoutMilliseconds_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pacquire_timeout_milliseconds_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pAcquireTimeoutMilliseconds, structInfo->acquireCount) << ";" << std::endl;
    }
    std::string prelease_syncs_array = "NULL";
    if (metaInfo->pReleaseSyncs.GetPointer() != NULL && structInfo->releaseCount > 0) {
        prelease_syncs_array = "prelease_syncs_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DEVICE_MEMORY));
        std::string prelease_syncs_values = toStringJoin(metaInfo->pReleaseSyncs.GetPointer(),
                                                         metaInfo->pReleaseSyncs.GetPointer() + structInfo->releaseCount,
                                                         [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                         ", ");
        if (structInfo->releaseCount == 1) {
            prelease_syncs_array = "&" + prelease_syncs_values;
        } else if (structInfo->releaseCount > 1) {
            out << "\t\t" << "VkDeviceMemory " << prelease_syncs_array << "[] = {" << prelease_syncs_values << "};" << std::endl;
        }
    }
    std::string prelease_keys_array = "prelease_keys_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->releaseCount > 0) {
        std::string prelease_keys_values = toStringJoin(structInfo->pReleaseKeys,
                                                        structInfo->pReleaseKeys + structInfo->releaseCount,
                                                        [](uint64_t current) { return std::to_string(current); },
                                                        ", ");
        if (structInfo->releaseCount == 1) {
            prelease_keys_array = "&" + prelease_keys_values;
        } else if (structInfo->releaseCount > 1) {
            out << "\t\t" << "uint64_t " << prelease_keys_array << "[] = {" << prelease_keys_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// acquireCount
    struct_body << "\t\t\t" << structInfo->acquireCount << "," << std::endl;
// pAcquireSyncs
    struct_body << "\t\t\t" << pacquire_syncs_array << "," << std::endl;
// pAcquireKeys
    struct_body << "\t\t\t" << "{ *" << pacquire_keys_array << " }" << "," << std::endl;
// pAcquireTimeoutMilliseconds
    struct_body << "\t\t\t" << pacquire_timeout_milliseconds_array << "," << std::endl;
// releaseCount
    struct_body << "\t\t\t" << structInfo->releaseCount << "," << std::endl;
// pReleaseSyncs
    struct_body << "\t\t\t" << prelease_syncs_array << "," << std::endl;
// pReleaseKeys
    struct_body << "\t\t\t" << "{ *" << prelease_keys_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "win32KeyedMutexAcquireReleaseInfoNV");
    out << "\t\t" << "VkWin32KeyedMutexAcquireReleaseInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkValidationFlagsEXT(std::ostream &out, const VkValidationFlagsEXT* structInfo, Decoded_VkValidationFlagsEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdisabled_validation_checks_values;
    std::string pdisabled_validation_checks_array = "NULL";
    if (structInfo->pDisabledValidationChecks != NULL) {
        for (uint32_t idx = 0; idx < structInfo->disabledValidationCheckCount; idx++) {
            pdisabled_validation_checks_values += util::ToString<VkValidationCheckEXT>(structInfo->pDisabledValidationChecks[idx]) + ", ";
        }
        pdisabled_validation_checks_array = "pDisabledValidationChecks_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkValidationCheckEXT " << pdisabled_validation_checks_array << "[] = {" << pdisabled_validation_checks_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// disabledValidationCheckCount
    struct_body << "\t\t\t" << structInfo->disabledValidationCheckCount << "," << std::endl;
// pDisabledValidationChecks
    struct_body << "\t\t\t" << pdisabled_validation_checks_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "validationFlagsEXT");
    out << "\t\t" << "VkValidationFlagsEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkViSurfaceCreateInfoNN(std::ostream &out, const VkViSurfaceCreateInfoNN* structInfo, Decoded_VkViSurfaceCreateInfoNN* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkViSurfaceCreateFlagsNN(" << structInfo->flags << ")" << "," << std::endl;
// window
    out << "\t\t" << "// TODO: Support window (output?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "viSurfaceCreateInfoNN");
    out << "\t\t" << "VkViSurfaceCreateInfoNN " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewASTCDecodeModeEXT(std::ostream &out, const VkImageViewASTCDecodeModeEXT* structInfo, Decoded_VkImageViewASTCDecodeModeEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// decodeMode
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->decodeMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewASTCDecodeModeEXT");
    out << "\t\t" << "VkImageViewASTCDecodeModeEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceASTCDecodeFeaturesEXT(std::ostream &out, const VkPhysicalDeviceASTCDecodeFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// decodeModeSharedExponent
    struct_body << "\t\t\t" << structInfo->decodeModeSharedExponent << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceASTCDecodeFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceASTCDecodeFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineRobustnessFeaturesEXT(std::ostream &out, const VkPhysicalDevicePipelineRobustnessFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePipelineRobustnessFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pipelineRobustness
    struct_body << "\t\t\t" << structInfo->pipelineRobustness << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineRobustnessFeaturesEXT");
    out << "\t\t" << "VkPhysicalDevicePipelineRobustnessFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineRobustnessPropertiesEXT(std::ostream &out, const VkPhysicalDevicePipelineRobustnessPropertiesEXT* structInfo, Decoded_VkPhysicalDevicePipelineRobustnessPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// defaultRobustnessStorageBuffers
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehaviorEXT(" << structInfo->defaultRobustnessStorageBuffers << ")" << "," << std::endl;
// defaultRobustnessUniformBuffers
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehaviorEXT(" << structInfo->defaultRobustnessUniformBuffers << ")" << "," << std::endl;
// defaultRobustnessVertexInputs
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehaviorEXT(" << structInfo->defaultRobustnessVertexInputs << ")" << "," << std::endl;
// defaultRobustnessImages
    struct_body << "\t\t\t" << "VkPipelineRobustnessImageBehaviorEXT(" << structInfo->defaultRobustnessImages << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineRobustnessPropertiesEXT");
    out << "\t\t" << "VkPhysicalDevicePipelineRobustnessPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRobustnessCreateInfoEXT(std::ostream &out, const VkPipelineRobustnessCreateInfoEXT* structInfo, Decoded_VkPipelineRobustnessCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// storageBuffers
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehaviorEXT(" << structInfo->storageBuffers << ")" << "," << std::endl;
// uniformBuffers
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehaviorEXT(" << structInfo->uniformBuffers << ")" << "," << std::endl;
// vertexInputs
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehaviorEXT(" << structInfo->vertexInputs << ")" << "," << std::endl;
// images
    struct_body << "\t\t\t" << "VkPipelineRobustnessImageBehaviorEXT(" << structInfo->images << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRobustnessCreateInfoEXT");
    out << "\t\t" << "VkPipelineRobustnessCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferInheritanceConditionalRenderingInfoEXT(std::ostream &out, const VkCommandBufferInheritanceConditionalRenderingInfoEXT* structInfo, Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// conditionalRenderingEnable
    struct_body << "\t\t\t" << structInfo->conditionalRenderingEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferInheritanceConditionalRenderingInfoEXT");
    out << "\t\t" << "VkCommandBufferInheritanceConditionalRenderingInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkConditionalRenderingBeginInfoEXT(std::ostream &out, const VkConditionalRenderingBeginInfoEXT* structInfo, Decoded_VkConditionalRenderingBeginInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// buffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkConditionalRenderingFlagsEXT(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "conditionalRenderingBeginInfoEXT");
    out << "\t\t" << "VkConditionalRenderingBeginInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceConditionalRenderingFeaturesEXT(std::ostream &out, const VkPhysicalDeviceConditionalRenderingFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// conditionalRendering
    struct_body << "\t\t\t" << structInfo->conditionalRendering << "," << std::endl;
// inheritedConditionalRendering
    struct_body << "\t\t\t" << structInfo->inheritedConditionalRendering << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceConditionalRenderingFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceConditionalRenderingFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportWScalingStateCreateInfoNV(std::ostream &out, const VkPipelineViewportWScalingStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportWScalingStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pviewport_w_scalings_array = "NULL";
    if (structInfo->pViewportWScalings != NULL) {
        pviewport_w_scalings_array = "pViewportWScalings_" + std::to_string(consumer.GetNextId());
        std::string pviewport_w_scalings_names;
        for (uint32_t idx = 0; idx < structInfo->viewportCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pViewportWScalings + idx != NULL) {
                variable_name = GenerateStruct_VkViewportWScalingNV(out,
                                                                    structInfo->pViewportWScalings + idx,
                                                                    metaInfo->pViewportWScalings->GetMetaStructPointer() + idx,
                                                                    consumer);
            }
            pviewport_w_scalings_names += variable_name + ", ";
        }
        out << "\t\t" << "VkViewportWScalingNV " << pviewport_w_scalings_array << "[] = {" << pviewport_w_scalings_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// viewportWScalingEnable
    struct_body << "\t\t\t" << structInfo->viewportWScalingEnable << "," << std::endl;
// viewportCount
    struct_body << "\t\t\t" << structInfo->viewportCount << "," << std::endl;
// pViewportWScalings
    struct_body << "\t\t\t" << pviewport_w_scalings_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportWScalingStateCreateInfoNV");
    out << "\t\t" << "VkPipelineViewportWScalingStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkViewportWScalingNV(std::ostream &out, const VkViewportWScalingNV* structInfo, Decoded_VkViewportWScalingNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// xcoeff
    struct_body << "\t" << structInfo->xcoeff << "," << std::endl;
// ycoeff
    struct_body << "\t\t\t" << structInfo->ycoeff << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "viewportWScalingNV");
    out << "\t\t" << "VkViewportWScalingNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceCapabilities2EXT(std::ostream &out, const VkSurfaceCapabilities2EXT* structInfo, Decoded_VkSurfaceCapabilities2EXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string current_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->currentExtent,
                                                                    metaInfo->currentExtent,
                                                                    consumer);
    std::string min_image_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->minImageExtent,
                                                                      metaInfo->minImageExtent,
                                                                      consumer);
    std::string max_image_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->maxImageExtent,
                                                                      metaInfo->maxImageExtent,
                                                                      consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// minImageCount
    struct_body << "\t\t\t" << structInfo->minImageCount << "," << std::endl;
// maxImageCount
    struct_body << "\t\t\t" << structInfo->maxImageCount << "," << std::endl;
// currentExtent
    struct_body << "\t\t\t" << current_extent_info_var << "," << std::endl;
// minImageExtent
    struct_body << "\t\t\t" << min_image_extent_info_var << "," << std::endl;
// maxImageExtent
    struct_body << "\t\t\t" << max_image_extent_info_var << "," << std::endl;
// maxImageArrayLayers
    struct_body << "\t\t\t" << structInfo->maxImageArrayLayers << "," << std::endl;
// supportedTransforms
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagsKHR(" << structInfo->supportedTransforms << ")" << "," << std::endl;
// currentTransform
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->currentTransform << ")" << "," << std::endl;
// supportedCompositeAlpha
    struct_body << "\t\t\t" << "VkCompositeAlphaFlagsKHR(" << structInfo->supportedCompositeAlpha << ")" << "," << std::endl;
// supportedUsageFlags
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->supportedUsageFlags << ")" << "," << std::endl;
// supportedSurfaceCounters
    struct_body << "\t\t\t" << "VkSurfaceCounterFlagsEXT(" << structInfo->supportedSurfaceCounters << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceCapabilities2EXT");
    out << "\t\t" << "VkSurfaceCapabilities2EXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceEventInfoEXT(std::ostream &out, const VkDeviceEventInfoEXT* structInfo, Decoded_VkDeviceEventInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceEvent
    struct_body << "\t\t\t" << "VkDeviceEventTypeEXT(" << structInfo->deviceEvent << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceEventInfoEXT");
    out << "\t\t" << "VkDeviceEventInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayEventInfoEXT(std::ostream &out, const VkDisplayEventInfoEXT* structInfo, Decoded_VkDisplayEventInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// displayEvent
    struct_body << "\t\t\t" << "VkDisplayEventTypeEXT(" << structInfo->displayEvent << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayEventInfoEXT");
    out << "\t\t" << "VkDisplayEventInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPowerInfoEXT(std::ostream &out, const VkDisplayPowerInfoEXT* structInfo, Decoded_VkDisplayPowerInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// powerState
    struct_body << "\t\t\t" << "VkDisplayPowerStateEXT(" << structInfo->powerState << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPowerInfoEXT");
    out << "\t\t" << "VkDisplayPowerInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainCounterCreateInfoEXT(std::ostream &out, const VkSwapchainCounterCreateInfoEXT* structInfo, Decoded_VkSwapchainCounterCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// surfaceCounters
    struct_body << "\t\t\t" << "VkSurfaceCounterFlagsEXT(" << structInfo->surfaceCounters << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainCounterCreateInfoEXT");
    out << "\t\t" << "VkSwapchainCounterCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPastPresentationTimingGOOGLE(std::ostream &out, const VkPastPresentationTimingGOOGLE* structInfo, Decoded_VkPastPresentationTimingGOOGLE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// presentID
    struct_body << "\t" << structInfo->presentID << "," << std::endl;
// desiredPresentTime
    struct_body << "\t\t\t" << structInfo->desiredPresentTime << "UL" << "," << std::endl;
// actualPresentTime
    struct_body << "\t\t\t" << structInfo->actualPresentTime << "UL" << "," << std::endl;
// earliestPresentTime
    struct_body << "\t\t\t" << structInfo->earliestPresentTime << "UL" << "," << std::endl;
// presentMargin
    struct_body << "\t\t\t" << structInfo->presentMargin << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pastPresentationTimingGOOGLE");
    out << "\t\t" << "VkPastPresentationTimingGOOGLE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentTimeGOOGLE(std::ostream &out, const VkPresentTimeGOOGLE* structInfo, Decoded_VkPresentTimeGOOGLE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// presentID
    struct_body << "\t" << structInfo->presentID << "," << std::endl;
// desiredPresentTime
    struct_body << "\t\t\t" << structInfo->desiredPresentTime << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentTimeGOOGLE");
    out << "\t\t" << "VkPresentTimeGOOGLE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentTimesInfoGOOGLE(std::ostream &out, const VkPresentTimesInfoGOOGLE* structInfo, Decoded_VkPresentTimesInfoGOOGLE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ptimes_array = "NULL";
    if (structInfo->pTimes != NULL) {
        ptimes_array = "pTimes_" + std::to_string(consumer.GetNextId());
        std::string ptimes_names;
        for (uint32_t idx = 0; idx < structInfo->swapchainCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pTimes + idx != NULL) {
                variable_name = GenerateStruct_VkPresentTimeGOOGLE(out,
                                                                   structInfo->pTimes + idx,
                                                                   metaInfo->pTimes->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            ptimes_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPresentTimeGOOGLE " << ptimes_array << "[] = {" << ptimes_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// swapchainCount
    struct_body << "\t\t\t" << structInfo->swapchainCount << "," << std::endl;
// pTimes
    struct_body << "\t\t\t" << ptimes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentTimesInfoGOOGLE");
    out << "\t\t" << "VkPresentTimesInfoGOOGLE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRefreshCycleDurationGOOGLE(std::ostream &out, const VkRefreshCycleDurationGOOGLE* structInfo, Decoded_VkRefreshCycleDurationGOOGLE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// refreshDuration
    struct_body << "\t" << structInfo->refreshDuration << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "refreshCycleDurationGOOGLE");
    out << "\t\t" << "VkRefreshCycleDurationGOOGLE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(std::ostream &out, const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* structInfo, Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// perViewPositionAllComponents
    struct_body << "\t\t\t" << structInfo->perViewPositionAllComponents << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultiviewPerViewAttributesPropertiesNVX");
    out << "\t\t" << "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportSwizzleStateCreateInfoNV(std::ostream &out, const VkPipelineViewportSwizzleStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportSwizzleStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pviewport_swizzles_array = "NULL";
    if (structInfo->pViewportSwizzles != NULL) {
        pviewport_swizzles_array = "pViewportSwizzles_" + std::to_string(consumer.GetNextId());
        std::string pviewport_swizzles_names;
        for (uint32_t idx = 0; idx < structInfo->viewportCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pViewportSwizzles + idx != NULL) {
                variable_name = GenerateStruct_VkViewportSwizzleNV(out,
                                                                   structInfo->pViewportSwizzles + idx,
                                                                   metaInfo->pViewportSwizzles->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            pviewport_swizzles_names += variable_name + ", ";
        }
        out << "\t\t" << "VkViewportSwizzleNV " << pviewport_swizzles_array << "[] = {" << pviewport_swizzles_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineViewportSwizzleStateCreateFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
// viewportCount
    struct_body << "\t\t\t" << structInfo->viewportCount << "," << std::endl;
// pViewportSwizzles
    struct_body << "\t\t\t" << pviewport_swizzles_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportSwizzleStateCreateInfoNV");
    out << "\t\t" << "VkPipelineViewportSwizzleStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkViewportSwizzleNV(std::ostream &out, const VkViewportSwizzleNV* structInfo, Decoded_VkViewportSwizzleNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// x
    struct_body << "\t" << "VkViewportCoordinateSwizzleNV(" << structInfo->x << ")" << "," << std::endl;
// y
    struct_body << "\t\t\t" << "VkViewportCoordinateSwizzleNV(" << structInfo->y << ")" << "," << std::endl;
// z
    struct_body << "\t\t\t" << "VkViewportCoordinateSwizzleNV(" << structInfo->z << ")" << "," << std::endl;
// w
    struct_body << "\t\t\t" << "VkViewportCoordinateSwizzleNV(" << structInfo->w << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "viewportSwizzleNV");
    out << "\t\t" << "VkViewportSwizzleNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDiscardRectanglePropertiesEXT(std::ostream &out, const VkPhysicalDeviceDiscardRectanglePropertiesEXT* structInfo, Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxDiscardRectangles
    struct_body << "\t\t\t" << structInfo->maxDiscardRectangles << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDiscardRectanglePropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceDiscardRectanglePropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineDiscardRectangleStateCreateInfoEXT(std::ostream &out, const VkPipelineDiscardRectangleStateCreateInfoEXT* structInfo, Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdiscard_rectangles_array = "NULL";
    if (structInfo->pDiscardRectangles != NULL) {
        pdiscard_rectangles_array = "pDiscardRectangles_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkRect2D " << pdiscard_rectangles_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDiscardRectangles, structInfo->discardRectangleCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineDiscardRectangleStateCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// discardRectangleMode
    struct_body << "\t\t\t" << "VkDiscardRectangleModeEXT(" << structInfo->discardRectangleMode << ")" << "," << std::endl;
// discardRectangleCount
    struct_body << "\t\t\t" << structInfo->discardRectangleCount << "," << std::endl;
// pDiscardRectangles
    struct_body << "\t\t\t" << pdiscard_rectangles_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineDiscardRectangleStateCreateInfoEXT");
    out << "\t\t" << "VkPipelineDiscardRectangleStateCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(std::ostream &out, const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// primitiveOverestimationSize
    struct_body << "\t\t\t" << structInfo->primitiveOverestimationSize << "," << std::endl;
// maxExtraPrimitiveOverestimationSize
    struct_body << "\t\t\t" << structInfo->maxExtraPrimitiveOverestimationSize << "," << std::endl;
// extraPrimitiveOverestimationSizeGranularity
    struct_body << "\t\t\t" << structInfo->extraPrimitiveOverestimationSizeGranularity << "," << std::endl;
// primitiveUnderestimation
    struct_body << "\t\t\t" << structInfo->primitiveUnderestimation << "," << std::endl;
// conservativePointAndLineRasterization
    struct_body << "\t\t\t" << structInfo->conservativePointAndLineRasterization << "," << std::endl;
// degenerateTrianglesRasterized
    struct_body << "\t\t\t" << structInfo->degenerateTrianglesRasterized << "," << std::endl;
// degenerateLinesRasterized
    struct_body << "\t\t\t" << structInfo->degenerateLinesRasterized << "," << std::endl;
// fullyCoveredFragmentShaderInputVariable
    struct_body << "\t\t\t" << structInfo->fullyCoveredFragmentShaderInputVariable << "," << std::endl;
// conservativeRasterizationPostDepthCoverage
    struct_body << "\t\t\t" << structInfo->conservativeRasterizationPostDepthCoverage << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceConservativeRasterizationPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceConservativeRasterizationPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRasterizationConservativeStateCreateInfoEXT(std::ostream &out, const VkPipelineRasterizationConservativeStateCreateInfoEXT* structInfo, Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineRasterizationConservativeStateCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// conservativeRasterizationMode
    struct_body << "\t\t\t" << "VkConservativeRasterizationModeEXT(" << structInfo->conservativeRasterizationMode << ")" << "," << std::endl;
// extraPrimitiveOverestimationSize
    struct_body << "\t\t\t" << structInfo->extraPrimitiveOverestimationSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRasterizationConservativeStateCreateInfoEXT");
    out << "\t\t" << "VkPipelineRasterizationConservativeStateCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDepthClipEnableFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDepthClipEnableFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// depthClipEnable
    struct_body << "\t\t\t" << structInfo->depthClipEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDepthClipEnableFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceDepthClipEnableFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRasterizationDepthClipStateCreateInfoEXT(std::ostream &out, const VkPipelineRasterizationDepthClipStateCreateInfoEXT* structInfo, Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineRasterizationDepthClipStateCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// depthClipEnable
    struct_body << "\t\t\t" << structInfo->depthClipEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRasterizationDepthClipStateCreateInfoEXT");
    out << "\t\t" << "VkPipelineRasterizationDepthClipStateCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkHdrMetadataEXT(std::ostream &out, const VkHdrMetadataEXT* structInfo, Decoded_VkHdrMetadataEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string display_primary_red_info_var = GenerateStruct_VkXYColorEXT(out,
                                                                           &structInfo->displayPrimaryRed,
                                                                           metaInfo->displayPrimaryRed,
                                                                           consumer);
    std::string display_primary_green_info_var = GenerateStruct_VkXYColorEXT(out,
                                                                             &structInfo->displayPrimaryGreen,
                                                                             metaInfo->displayPrimaryGreen,
                                                                             consumer);
    std::string display_primary_blue_info_var = GenerateStruct_VkXYColorEXT(out,
                                                                            &structInfo->displayPrimaryBlue,
                                                                            metaInfo->displayPrimaryBlue,
                                                                            consumer);
    std::string white_point_info_var = GenerateStruct_VkXYColorEXT(out,
                                                                   &structInfo->whitePoint,
                                                                   metaInfo->whitePoint,
                                                                   consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// displayPrimaryRed
    struct_body << "\t\t\t" << display_primary_red_info_var << "," << std::endl;
// displayPrimaryGreen
    struct_body << "\t\t\t" << display_primary_green_info_var << "," << std::endl;
// displayPrimaryBlue
    struct_body << "\t\t\t" << display_primary_blue_info_var << "," << std::endl;
// whitePoint
    struct_body << "\t\t\t" << white_point_info_var << "," << std::endl;
// maxLuminance
    struct_body << "\t\t\t" << structInfo->maxLuminance << "," << std::endl;
// minLuminance
    struct_body << "\t\t\t" << structInfo->minLuminance << "," << std::endl;
// maxContentLightLevel
    struct_body << "\t\t\t" << structInfo->maxContentLightLevel << "," << std::endl;
// maxFrameAverageLightLevel
    struct_body << "\t\t\t" << structInfo->maxFrameAverageLightLevel << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "hdrMetadataEXT");
    out << "\t\t" << "VkHdrMetadataEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkXYColorEXT(std::ostream &out, const VkXYColorEXT* structInfo, Decoded_VkXYColorEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// x
    struct_body << "\t" << structInfo->x << "," << std::endl;
// y
    struct_body << "\t\t\t" << structInfo->y << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "xYColorEXT");
    out << "\t\t" << "VkXYColorEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(std::ostream &out, const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* structInfo, Decoded_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// relaxedLineRasterization
    struct_body << "\t\t\t" << structInfo->relaxedLineRasterization << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRelaxedLineRasterizationFeaturesIMG");
    out << "\t\t" << "VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIOSSurfaceCreateInfoMVK(std::ostream &out, const VkIOSSurfaceCreateInfoMVK* structInfo, Decoded_VkIOSSurfaceCreateInfoMVK* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkIOSSurfaceCreateFlagsMVK(" << structInfo->flags << ")" << "," << std::endl;
// pView
    struct_body << "\t\t\t" << structInfo->pView << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "iOSSurfaceCreateInfoMVK");
    out << "\t\t" << "VkIOSSurfaceCreateInfoMVK " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMacOSSurfaceCreateInfoMVK(std::ostream &out, const VkMacOSSurfaceCreateInfoMVK* structInfo, Decoded_VkMacOSSurfaceCreateInfoMVK* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkMacOSSurfaceCreateFlagsMVK(" << structInfo->flags << ")" << "," << std::endl;
// pView
    struct_body << "\t\t\t" << structInfo->pView << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "macOSSurfaceCreateInfoMVK");
    out << "\t\t" << "VkMacOSSurfaceCreateInfoMVK " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugUtilsLabelEXT(std::ostream &out, const VkDebugUtilsLabelEXT* structInfo, Decoded_VkDebugUtilsLabelEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pLabelName
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pLabelName) << "," << std::endl;
// color
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->color[0]), 4) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "debugUtilsLabelEXT");
    out << "\t\t" << "VkDebugUtilsLabelEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugUtilsMessengerCallbackDataEXT(std::ostream &out, const VkDebugUtilsMessengerCallbackDataEXT* structInfo, Decoded_VkDebugUtilsMessengerCallbackDataEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pqueue_labels_array = "NULL";
    if (structInfo->pQueueLabels != NULL) {
        pqueue_labels_array = "pQueueLabels_" + std::to_string(consumer.GetNextId());
        std::string pqueue_labels_names;
        for (uint32_t idx = 0; idx < structInfo->queueLabelCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pQueueLabels + idx != NULL) {
                variable_name = GenerateStruct_VkDebugUtilsLabelEXT(out,
                                                                    structInfo->pQueueLabels + idx,
                                                                    metaInfo->pQueueLabels->GetMetaStructPointer() + idx,
                                                                    consumer);
            }
            pqueue_labels_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDebugUtilsLabelEXT " << pqueue_labels_array << "[] = {" << pqueue_labels_names << "};" << std::endl;
    }
    std::string pcmd_buf_labels_array = "NULL";
    if (structInfo->pCmdBufLabels != NULL) {
        pcmd_buf_labels_array = "pCmdBufLabels_" + std::to_string(consumer.GetNextId());
        std::string pcmd_buf_labels_names;
        for (uint32_t idx = 0; idx < structInfo->cmdBufLabelCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pCmdBufLabels + idx != NULL) {
                variable_name = GenerateStruct_VkDebugUtilsLabelEXT(out,
                                                                    structInfo->pCmdBufLabels + idx,
                                                                    metaInfo->pCmdBufLabels->GetMetaStructPointer() + idx,
                                                                    consumer);
            }
            pcmd_buf_labels_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDebugUtilsLabelEXT " << pcmd_buf_labels_array << "[] = {" << pcmd_buf_labels_names << "};" << std::endl;
    }
    std::string pobjects_array = "NULL";
    if (structInfo->pObjects != NULL) {
        pobjects_array = "pObjects_" + std::to_string(consumer.GetNextId());
        std::string pobjects_names;
        for (uint32_t idx = 0; idx < structInfo->objectCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pObjects + idx != NULL) {
                variable_name = GenerateStruct_VkDebugUtilsObjectNameInfoEXT(out,
                                                                             structInfo->pObjects + idx,
                                                                             metaInfo->pObjects->GetMetaStructPointer() + idx,
                                                                             consumer);
            }
            pobjects_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDebugUtilsObjectNameInfoEXT " << pobjects_array << "[] = {" << pobjects_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDebugUtilsMessengerCallbackDataFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// pMessageIdName
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pMessageIdName) << "," << std::endl;
// messageIdNumber
    struct_body << "\t\t\t" << structInfo->messageIdNumber << "," << std::endl;
// pMessage
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pMessage) << "," << std::endl;
// queueLabelCount
    struct_body << "\t\t\t" << structInfo->queueLabelCount << "," << std::endl;
// pQueueLabels
    struct_body << "\t\t\t" << pqueue_labels_array << "," << std::endl;
// cmdBufLabelCount
    struct_body << "\t\t\t" << structInfo->cmdBufLabelCount << "," << std::endl;
// pCmdBufLabels
    struct_body << "\t\t\t" << pcmd_buf_labels_array << "," << std::endl;
// objectCount
    struct_body << "\t\t\t" << structInfo->objectCount << "," << std::endl;
// pObjects
    struct_body << "\t\t\t" << pobjects_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "debugUtilsMessengerCallbackDataEXT");
    out << "\t\t" << "VkDebugUtilsMessengerCallbackDataEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugUtilsObjectNameInfoEXT(std::ostream &out, const VkDebugUtilsObjectNameInfoEXT* structInfo, Decoded_VkDebugUtilsObjectNameInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// objectType
    struct_body << "\t\t\t" << "VkObjectType(" << structInfo->objectType << ")" << "," << std::endl;
// objectHandle
    struct_body << "\t\t\t" << structInfo->objectHandle << "UL" << "," << std::endl;
// pObjectName
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pObjectName) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "debugUtilsObjectNameInfoEXT");
    out << "\t\t" << "VkDebugUtilsObjectNameInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugUtilsObjectTagInfoEXT(std::ostream &out, const VkDebugUtilsObjectTagInfoEXT* structInfo, Decoded_VkDebugUtilsObjectTagInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ptag_array = "NULL";
    if (structInfo->pTag != NULL) {
        std::string ptag_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->tagSize; ++idx0) {
            ptag_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pTag)[idx0]) + ", ";
        }
        ptag_array = "pTag_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << ptag_array << "[] = {" << ptag_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// objectType
    struct_body << "\t\t\t" << "VkObjectType(" << structInfo->objectType << ")" << "," << std::endl;
// objectHandle
    struct_body << "\t\t\t" << structInfo->objectHandle << "UL" << "," << std::endl;
// tagName
    struct_body << "\t\t\t" << structInfo->tagName << "UL" << "," << std::endl;
// tagSize
    struct_body << "\t\t\t" << structInfo->tagSize << "," << std::endl;
// pTag
    struct_body << "\t\t\t" << ptag_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "debugUtilsObjectTagInfoEXT");
    out << "\t\t" << "VkDebugUtilsObjectTagInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAndroidHardwareBufferFormatProperties2ANDROID(std::ostream &out, const VkAndroidHardwareBufferFormatProperties2ANDROID* structInfo, Decoded_VkAndroidHardwareBufferFormatProperties2ANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string sampler_ycbcr_conversion_components_info_var = GenerateStruct_VkComponentMapping(out,
                                                                                                 &structInfo->samplerYcbcrConversionComponents,
                                                                                                 metaInfo->samplerYcbcrConversionComponents,
                                                                                                 consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
// externalFormat
    struct_body << "\t\t\t" << structInfo->externalFormat << "UL" << "," << std::endl;
// formatFeatures
    struct_body << "\t\t\t" << "VkFormatFeatureFlags2(" << structInfo->formatFeatures << ")" << "," << std::endl;
// samplerYcbcrConversionComponents
    struct_body << "\t\t\t" << sampler_ycbcr_conversion_components_info_var << "," << std::endl;
// suggestedYcbcrModel
    struct_body << "\t\t\t" << "VkSamplerYcbcrModelConversion(" << structInfo->suggestedYcbcrModel << ")" << "," << std::endl;
// suggestedYcbcrRange
    struct_body << "\t\t\t" << "VkSamplerYcbcrRange(" << structInfo->suggestedYcbcrRange << ")" << "," << std::endl;
// suggestedXChromaOffset
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->suggestedXChromaOffset << ")" << "," << std::endl;
// suggestedYChromaOffset
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->suggestedYChromaOffset << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "androidHardwareBufferFormatProperties2ANDROID");
    out << "\t\t" << "VkAndroidHardwareBufferFormatProperties2ANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAndroidHardwareBufferFormatPropertiesANDROID(std::ostream &out, const VkAndroidHardwareBufferFormatPropertiesANDROID* structInfo, Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string sampler_ycbcr_conversion_components_info_var = GenerateStruct_VkComponentMapping(out,
                                                                                                 &structInfo->samplerYcbcrConversionComponents,
                                                                                                 metaInfo->samplerYcbcrConversionComponents,
                                                                                                 consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
// externalFormat
    struct_body << "\t\t\t" << structInfo->externalFormat << "UL" << "," << std::endl;
// formatFeatures
    struct_body << "\t\t\t" << "VkFormatFeatureFlags(" << structInfo->formatFeatures << ")" << "," << std::endl;
// samplerYcbcrConversionComponents
    struct_body << "\t\t\t" << sampler_ycbcr_conversion_components_info_var << "," << std::endl;
// suggestedYcbcrModel
    struct_body << "\t\t\t" << "VkSamplerYcbcrModelConversion(" << structInfo->suggestedYcbcrModel << ")" << "," << std::endl;
// suggestedYcbcrRange
    struct_body << "\t\t\t" << "VkSamplerYcbcrRange(" << structInfo->suggestedYcbcrRange << ")" << "," << std::endl;
// suggestedXChromaOffset
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->suggestedXChromaOffset << ")" << "," << std::endl;
// suggestedYChromaOffset
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->suggestedYChromaOffset << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "androidHardwareBufferFormatPropertiesANDROID");
    out << "\t\t" << "VkAndroidHardwareBufferFormatPropertiesANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAndroidHardwareBufferPropertiesANDROID(std::ostream &out, const VkAndroidHardwareBufferPropertiesANDROID* structInfo, Decoded_VkAndroidHardwareBufferPropertiesANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// allocationSize
    struct_body << "\t\t\t" << structInfo->allocationSize << "UL" << "," << std::endl;
// memoryTypeBits
    struct_body << "\t\t\t" << structInfo->memoryTypeBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "androidHardwareBufferPropertiesANDROID");
    out << "\t\t" << "VkAndroidHardwareBufferPropertiesANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAndroidHardwareBufferUsageANDROID(std::ostream &out, const VkAndroidHardwareBufferUsageANDROID* structInfo, Decoded_VkAndroidHardwareBufferUsageANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// androidHardwareBufferUsage
    struct_body << "\t\t\t" << structInfo->androidHardwareBufferUsage << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "androidHardwareBufferUsageANDROID");
    out << "\t\t" << "VkAndroidHardwareBufferUsageANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalFormatANDROID(std::ostream &out, const VkExternalFormatANDROID* structInfo, Decoded_VkExternalFormatANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// externalFormat
    struct_body << "\t\t\t" << structInfo->externalFormat << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalFormatANDROID");
    out << "\t\t" << "VkExternalFormatANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryGetAndroidHardwareBufferInfoANDROID(std::ostream &out, const VkMemoryGetAndroidHardwareBufferInfoANDROID* structInfo, Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryGetAndroidHardwareBufferInfoANDROID");
    out << "\t\t" << "VkMemoryGetAndroidHardwareBufferInfoANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentSampleLocationsEXT(std::ostream &out, const VkAttachmentSampleLocationsEXT* structInfo, Decoded_VkAttachmentSampleLocationsEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string sample_locations_info_info_var = GenerateStruct_VkSampleLocationsInfoEXT(out,
                                                                                         &structInfo->sampleLocationsInfo,
                                                                                         metaInfo->sampleLocationsInfo,
                                                                                         consumer);
// attachmentIndex
    struct_body << "\t" << structInfo->attachmentIndex << "," << std::endl;
// sampleLocationsInfo
    struct_body << "\t\t\t" << sample_locations_info_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentSampleLocationsEXT");
    out << "\t\t" << "VkAttachmentSampleLocationsEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMultisamplePropertiesEXT(std::ostream &out, const VkMultisamplePropertiesEXT* structInfo, Decoded_VkMultisamplePropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string max_sample_location_grid_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                   &structInfo->maxSampleLocationGridSize,
                                                                                   metaInfo->maxSampleLocationGridSize,
                                                                                   consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxSampleLocationGridSize
    struct_body << "\t\t\t" << max_sample_location_grid_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "multisamplePropertiesEXT");
    out << "\t\t" << "VkMultisamplePropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSampleLocationsPropertiesEXT(std::ostream &out, const VkPhysicalDeviceSampleLocationsPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string max_sample_location_grid_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                   &structInfo->maxSampleLocationGridSize,
                                                                                   metaInfo->maxSampleLocationGridSize,
                                                                                   consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// sampleLocationSampleCounts
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->sampleLocationSampleCounts << ")" << "," << std::endl;
// maxSampleLocationGridSize
    struct_body << "\t\t\t" << max_sample_location_grid_size_info_var << "," << std::endl;
// sampleLocationCoordinateRange
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->sampleLocationCoordinateRange[0]), 2) << "," << std::endl;
// sampleLocationSubPixelBits
    struct_body << "\t\t\t" << structInfo->sampleLocationSubPixelBits << "," << std::endl;
// variableSampleLocations
    struct_body << "\t\t\t" << structInfo->variableSampleLocations << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSampleLocationsPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceSampleLocationsPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineSampleLocationsStateCreateInfoEXT(std::ostream &out, const VkPipelineSampleLocationsStateCreateInfoEXT* structInfo, Decoded_VkPipelineSampleLocationsStateCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string sample_locations_info_info_var = GenerateStruct_VkSampleLocationsInfoEXT(out,
                                                                                         &structInfo->sampleLocationsInfo,
                                                                                         metaInfo->sampleLocationsInfo,
                                                                                         consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// sampleLocationsEnable
    struct_body << "\t\t\t" << structInfo->sampleLocationsEnable << "," << std::endl;
// sampleLocationsInfo
    struct_body << "\t\t\t" << sample_locations_info_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineSampleLocationsStateCreateInfoEXT");
    out << "\t\t" << "VkPipelineSampleLocationsStateCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassSampleLocationsBeginInfoEXT(std::ostream &out, const VkRenderPassSampleLocationsBeginInfoEXT* structInfo, Decoded_VkRenderPassSampleLocationsBeginInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pattachment_initial_sample_locations_array = "NULL";
    if (structInfo->pAttachmentInitialSampleLocations != NULL) {
        pattachment_initial_sample_locations_array = "pAttachmentInitialSampleLocations_" + std::to_string(consumer.GetNextId());
        std::string pattachment_initial_sample_locations_names;
        for (uint32_t idx = 0; idx < structInfo->attachmentInitialSampleLocationsCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pAttachmentInitialSampleLocations + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentSampleLocationsEXT(out,
                                                                              structInfo->pAttachmentInitialSampleLocations + idx,
                                                                              metaInfo->pAttachmentInitialSampleLocations->GetMetaStructPointer() + idx,
                                                                              consumer);
            }
            pattachment_initial_sample_locations_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentSampleLocationsEXT " << pattachment_initial_sample_locations_array << "[] = {" << pattachment_initial_sample_locations_names << "};" << std::endl;
    }
    std::string ppost_subpass_sample_locations_array = "NULL";
    if (structInfo->pPostSubpassSampleLocations != NULL) {
        ppost_subpass_sample_locations_array = "pPostSubpassSampleLocations_" + std::to_string(consumer.GetNextId());
        std::string ppost_subpass_sample_locations_names;
        for (uint32_t idx = 0; idx < structInfo->postSubpassSampleLocationsCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPostSubpassSampleLocations + idx != NULL) {
                variable_name = GenerateStruct_VkSubpassSampleLocationsEXT(out,
                                                                           structInfo->pPostSubpassSampleLocations + idx,
                                                                           metaInfo->pPostSubpassSampleLocations->GetMetaStructPointer() + idx,
                                                                           consumer);
            }
            ppost_subpass_sample_locations_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSubpassSampleLocationsEXT " << ppost_subpass_sample_locations_array << "[] = {" << ppost_subpass_sample_locations_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// attachmentInitialSampleLocationsCount
    struct_body << "\t\t\t" << structInfo->attachmentInitialSampleLocationsCount << "," << std::endl;
// pAttachmentInitialSampleLocations
    struct_body << "\t\t\t" << pattachment_initial_sample_locations_array << "," << std::endl;
// postSubpassSampleLocationsCount
    struct_body << "\t\t\t" << structInfo->postSubpassSampleLocationsCount << "," << std::endl;
// pPostSubpassSampleLocations
    struct_body << "\t\t\t" << ppost_subpass_sample_locations_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassSampleLocationsBeginInfoEXT");
    out << "\t\t" << "VkRenderPassSampleLocationsBeginInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSampleLocationEXT(std::ostream &out, const VkSampleLocationEXT* structInfo, Decoded_VkSampleLocationEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// x
    struct_body << "\t" << structInfo->x << "," << std::endl;
// y
    struct_body << "\t\t\t" << structInfo->y << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sampleLocationEXT");
    out << "\t\t" << "VkSampleLocationEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSampleLocationsInfoEXT(std::ostream &out, const VkSampleLocationsInfoEXT* structInfo, Decoded_VkSampleLocationsInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string sample_location_grid_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                               &structInfo->sampleLocationGridSize,
                                                                               metaInfo->sampleLocationGridSize,
                                                                               consumer);
    std::string psample_locations_array = "NULL";
    if (structInfo->pSampleLocations != NULL) {
        psample_locations_array = "pSampleLocations_" + std::to_string(consumer.GetNextId());
        std::string psample_locations_names;
        for (uint32_t idx = 0; idx < structInfo->sampleLocationsCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pSampleLocations + idx != NULL) {
                variable_name = GenerateStruct_VkSampleLocationEXT(out,
                                                                   structInfo->pSampleLocations + idx,
                                                                   metaInfo->pSampleLocations->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            psample_locations_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSampleLocationEXT " << psample_locations_array << "[] = {" << psample_locations_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// sampleLocationsPerPixel
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->sampleLocationsPerPixel << ")" << "," << std::endl;
// sampleLocationGridSize
    struct_body << "\t\t\t" << sample_location_grid_size_info_var << "," << std::endl;
// sampleLocationsCount
    struct_body << "\t\t\t" << structInfo->sampleLocationsCount << "," << std::endl;
// pSampleLocations
    struct_body << "\t\t\t" << psample_locations_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sampleLocationsInfoEXT");
    out << "\t\t" << "VkSampleLocationsInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassSampleLocationsEXT(std::ostream &out, const VkSubpassSampleLocationsEXT* structInfo, Decoded_VkSubpassSampleLocationsEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string sample_locations_info_info_var = GenerateStruct_VkSampleLocationsInfoEXT(out,
                                                                                         &structInfo->sampleLocationsInfo,
                                                                                         metaInfo->sampleLocationsInfo,
                                                                                         consumer);
// subpassIndex
    struct_body << "\t" << structInfo->subpassIndex << "," << std::endl;
// sampleLocationsInfo
    struct_body << "\t\t\t" << sample_locations_info_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassSampleLocationsEXT");
    out << "\t\t" << "VkSubpassSampleLocationsEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(std::ostream &out, const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// advancedBlendCoherentOperations
    struct_body << "\t\t\t" << structInfo->advancedBlendCoherentOperations << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceBlendOperationAdvancedFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(std::ostream &out, const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// advancedBlendMaxColorAttachments
    struct_body << "\t\t\t" << structInfo->advancedBlendMaxColorAttachments << "," << std::endl;
// advancedBlendIndependentBlend
    struct_body << "\t\t\t" << structInfo->advancedBlendIndependentBlend << "," << std::endl;
// advancedBlendNonPremultipliedSrcColor
    struct_body << "\t\t\t" << structInfo->advancedBlendNonPremultipliedSrcColor << "," << std::endl;
// advancedBlendNonPremultipliedDstColor
    struct_body << "\t\t\t" << structInfo->advancedBlendNonPremultipliedDstColor << "," << std::endl;
// advancedBlendCorrelatedOverlap
    struct_body << "\t\t\t" << structInfo->advancedBlendCorrelatedOverlap << "," << std::endl;
// advancedBlendAllOperations
    struct_body << "\t\t\t" << structInfo->advancedBlendAllOperations << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceBlendOperationAdvancedPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineColorBlendAdvancedStateCreateInfoEXT(std::ostream &out, const VkPipelineColorBlendAdvancedStateCreateInfoEXT* structInfo, Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// srcPremultiplied
    struct_body << "\t\t\t" << structInfo->srcPremultiplied << "," << std::endl;
// dstPremultiplied
    struct_body << "\t\t\t" << structInfo->dstPremultiplied << "," << std::endl;
// blendOverlap
    struct_body << "\t\t\t" << "VkBlendOverlapEXT(" << structInfo->blendOverlap << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineColorBlendAdvancedStateCreateInfoEXT");
    out << "\t\t" << "VkPipelineColorBlendAdvancedStateCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCoverageToColorStateCreateInfoNV(std::ostream &out, const VkPipelineCoverageToColorStateCreateInfoNV* structInfo, Decoded_VkPipelineCoverageToColorStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineCoverageToColorStateCreateFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
// coverageToColorEnable
    struct_body << "\t\t\t" << structInfo->coverageToColorEnable << "," << std::endl;
// coverageToColorLocation
    struct_body << "\t\t\t" << structInfo->coverageToColorLocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCoverageToColorStateCreateInfoNV");
    out << "\t\t" << "VkPipelineCoverageToColorStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCoverageModulationStateCreateInfoNV(std::ostream &out, const VkPipelineCoverageModulationStateCreateInfoNV* structInfo, Decoded_VkPipelineCoverageModulationStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcoverage_modulation_table_array = "NULL";
    if (structInfo->pCoverageModulationTable != NULL) {
        pcoverage_modulation_table_array = "pCoverageModulationTable_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "float " << pcoverage_modulation_table_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCoverageModulationTable, structInfo->coverageModulationTableCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineCoverageModulationStateCreateFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
// coverageModulationMode
    struct_body << "\t\t\t" << "VkCoverageModulationModeNV(" << structInfo->coverageModulationMode << ")" << "," << std::endl;
// coverageModulationTableEnable
    struct_body << "\t\t\t" << structInfo->coverageModulationTableEnable << "," << std::endl;
// coverageModulationTableCount
    struct_body << "\t\t\t" << structInfo->coverageModulationTableCount << "," << std::endl;
// pCoverageModulationTable
    struct_body << "\t\t\t" << pcoverage_modulation_table_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCoverageModulationStateCreateInfoNV");
    out << "\t\t" << "VkPipelineCoverageModulationStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(std::ostream &out, const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* structInfo, Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderSMBuiltins
    struct_body << "\t\t\t" << structInfo->shaderSMBuiltins << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderSMBuiltinsFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceShaderSMBuiltinsFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(std::ostream &out, const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* structInfo, Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderSMCount
    struct_body << "\t\t\t" << structInfo->shaderSMCount << "," << std::endl;
// shaderWarpsPerSM
    struct_body << "\t\t\t" << structInfo->shaderWarpsPerSM << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderSMBuiltinsPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceShaderSMBuiltinsPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrmFormatModifierProperties2EXT(std::ostream &out, const VkDrmFormatModifierProperties2EXT* structInfo, Decoded_VkDrmFormatModifierProperties2EXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// drmFormatModifier
    struct_body << "\t" << structInfo->drmFormatModifier << "UL" << "," << std::endl;
// drmFormatModifierPlaneCount
    struct_body << "\t\t\t" << structInfo->drmFormatModifierPlaneCount << "," << std::endl;
// drmFormatModifierTilingFeatures
    struct_body << "\t\t\t" << "VkFormatFeatureFlags2(" << structInfo->drmFormatModifierTilingFeatures << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drmFormatModifierProperties2EXT");
    out << "\t\t" << "VkDrmFormatModifierProperties2EXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrmFormatModifierPropertiesEXT(std::ostream &out, const VkDrmFormatModifierPropertiesEXT* structInfo, Decoded_VkDrmFormatModifierPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// drmFormatModifier
    struct_body << "\t" << structInfo->drmFormatModifier << "UL" << "," << std::endl;
// drmFormatModifierPlaneCount
    struct_body << "\t\t\t" << structInfo->drmFormatModifierPlaneCount << "," << std::endl;
// drmFormatModifierTilingFeatures
    struct_body << "\t\t\t" << "VkFormatFeatureFlags(" << structInfo->drmFormatModifierTilingFeatures << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drmFormatModifierPropertiesEXT");
    out << "\t\t" << "VkDrmFormatModifierPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrmFormatModifierPropertiesList2EXT(std::ostream &out, const VkDrmFormatModifierPropertiesList2EXT* structInfo, Decoded_VkDrmFormatModifierPropertiesList2EXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdrm_format_modifier_properties_array = "NULL";
    if (structInfo->pDrmFormatModifierProperties != NULL) {
        pdrm_format_modifier_properties_array = "pDrmFormatModifierProperties_" + std::to_string(consumer.GetNextId());
        std::string pdrm_format_modifier_properties_names;
        for (uint32_t idx = 0; idx < structInfo->drmFormatModifierCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pDrmFormatModifierProperties + idx != NULL) {
                variable_name = GenerateStruct_VkDrmFormatModifierProperties2EXT(out,
                                                                                 structInfo->pDrmFormatModifierProperties + idx,
                                                                                 metaInfo->pDrmFormatModifierProperties->GetMetaStructPointer() + idx,
                                                                                 consumer);
            }
            pdrm_format_modifier_properties_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDrmFormatModifierProperties2EXT " << pdrm_format_modifier_properties_array << "[] = {" << pdrm_format_modifier_properties_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// drmFormatModifierCount
    struct_body << "\t\t\t" << structInfo->drmFormatModifierCount << "," << std::endl;
// pDrmFormatModifierProperties
    struct_body << "\t\t\t" << pdrm_format_modifier_properties_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drmFormatModifierPropertiesList2EXT");
    out << "\t\t" << "VkDrmFormatModifierPropertiesList2EXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrmFormatModifierPropertiesListEXT(std::ostream &out, const VkDrmFormatModifierPropertiesListEXT* structInfo, Decoded_VkDrmFormatModifierPropertiesListEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdrm_format_modifier_properties_array = "NULL";
    if (structInfo->pDrmFormatModifierProperties != NULL) {
        pdrm_format_modifier_properties_array = "pDrmFormatModifierProperties_" + std::to_string(consumer.GetNextId());
        std::string pdrm_format_modifier_properties_names;
        for (uint32_t idx = 0; idx < structInfo->drmFormatModifierCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pDrmFormatModifierProperties + idx != NULL) {
                variable_name = GenerateStruct_VkDrmFormatModifierPropertiesEXT(out,
                                                                                structInfo->pDrmFormatModifierProperties + idx,
                                                                                metaInfo->pDrmFormatModifierProperties->GetMetaStructPointer() + idx,
                                                                                consumer);
            }
            pdrm_format_modifier_properties_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDrmFormatModifierPropertiesEXT " << pdrm_format_modifier_properties_array << "[] = {" << pdrm_format_modifier_properties_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// drmFormatModifierCount
    struct_body << "\t\t\t" << structInfo->drmFormatModifierCount << "," << std::endl;
// pDrmFormatModifierProperties
    struct_body << "\t\t\t" << pdrm_format_modifier_properties_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drmFormatModifierPropertiesListEXT");
    out << "\t\t" << "VkDrmFormatModifierPropertiesListEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageDrmFormatModifierExplicitCreateInfoEXT(std::ostream &out, const VkImageDrmFormatModifierExplicitCreateInfoEXT* structInfo, Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pplane_layouts_array = "NULL";
    if (structInfo->pPlaneLayouts != NULL) {
        pplane_layouts_array = "pPlaneLayouts_" + std::to_string(consumer.GetNextId());
        std::string pplane_layouts_names;
        for (uint32_t idx = 0; idx < structInfo->drmFormatModifierPlaneCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPlaneLayouts + idx != NULL) {
                variable_name = GenerateStruct_VkSubresourceLayout(out,
                                                                   structInfo->pPlaneLayouts + idx,
                                                                   metaInfo->pPlaneLayouts->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            pplane_layouts_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSubresourceLayout " << pplane_layouts_array << "[] = {" << pplane_layouts_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// drmFormatModifier
    struct_body << "\t\t\t" << structInfo->drmFormatModifier << "UL" << "," << std::endl;
// drmFormatModifierPlaneCount
    struct_body << "\t\t\t" << structInfo->drmFormatModifierPlaneCount << "," << std::endl;
// pPlaneLayouts
    struct_body << "\t\t\t" << pplane_layouts_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageDrmFormatModifierExplicitCreateInfoEXT");
    out << "\t\t" << "VkImageDrmFormatModifierExplicitCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageDrmFormatModifierListCreateInfoEXT(std::ostream &out, const VkImageDrmFormatModifierListCreateInfoEXT* structInfo, Decoded_VkImageDrmFormatModifierListCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdrm_format_modifiers_array = "pdrm_format_modifiers_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->drmFormatModifierCount > 0) {
        std::string pdrm_format_modifiers_values = toStringJoin(structInfo->pDrmFormatModifiers,
                                                                structInfo->pDrmFormatModifiers + structInfo->drmFormatModifierCount,
                                                                [](uint64_t current) { return std::to_string(current); },
                                                                ", ");
        if (structInfo->drmFormatModifierCount == 1) {
            pdrm_format_modifiers_array = "&" + pdrm_format_modifiers_values;
        } else if (structInfo->drmFormatModifierCount > 1) {
            out << "\t\t" << "uint64_t " << pdrm_format_modifiers_array << "[] = {" << pdrm_format_modifiers_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// drmFormatModifierCount
    struct_body << "\t\t\t" << structInfo->drmFormatModifierCount << "," << std::endl;
// pDrmFormatModifiers
    struct_body << "\t\t\t" << "{ *" << pdrm_format_modifiers_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageDrmFormatModifierListCreateInfoEXT");
    out << "\t\t" << "VkImageDrmFormatModifierListCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageDrmFormatModifierPropertiesEXT(std::ostream &out, const VkImageDrmFormatModifierPropertiesEXT* structInfo, Decoded_VkImageDrmFormatModifierPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// drmFormatModifier
    struct_body << "\t\t\t" << structInfo->drmFormatModifier << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageDrmFormatModifierPropertiesEXT");
    out << "\t\t" << "VkImageDrmFormatModifierPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(std::ostream &out, const VkPhysicalDeviceImageDrmFormatModifierInfoEXT* structInfo, Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pqueue_family_indices_array = "NULL";
    if (structInfo->pQueueFamilyIndices != NULL) {
        pqueue_family_indices_array = "pQueueFamilyIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pqueue_family_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pQueueFamilyIndices, structInfo->queueFamilyIndexCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// drmFormatModifier
    struct_body << "\t\t\t" << structInfo->drmFormatModifier << "UL" << "," << std::endl;
// sharingMode
    struct_body << "\t\t\t" << "VkSharingMode(" << structInfo->sharingMode << ")" << "," << std::endl;
// queueFamilyIndexCount
    struct_body << "\t\t\t" << structInfo->queueFamilyIndexCount << "," << std::endl;
// pQueueFamilyIndices
    struct_body << "\t\t\t" << pqueue_family_indices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageDrmFormatModifierInfoEXT");
    out << "\t\t" << "VkPhysicalDeviceImageDrmFormatModifierInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkShaderModuleValidationCacheCreateInfoEXT(std::ostream &out, const VkShaderModuleValidationCacheCreateInfoEXT* structInfo, Decoded_VkShaderModuleValidationCacheCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// validationCache
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->validationCache) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "shaderModuleValidationCacheCreateInfoEXT");
    out << "\t\t" << "VkShaderModuleValidationCacheCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkValidationCacheCreateInfoEXT(std::ostream &out, const VkValidationCacheCreateInfoEXT* structInfo, Decoded_VkValidationCacheCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pinitial_data_array = "NULL";
    if (structInfo->pInitialData != NULL) {
        std::string pinitial_data_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->initialDataSize; ++idx0) {
            pinitial_data_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pInitialData)[idx0]) + ", ";
        }
        pinitial_data_array = "pInitialData_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pinitial_data_array << "[] = {" << pinitial_data_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkValidationCacheCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// initialDataSize
    struct_body << "\t\t\t" << structInfo->initialDataSize << "," << std::endl;
// pInitialData
    struct_body << "\t\t\t" << pinitial_data_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "validationCacheCreateInfoEXT");
    out << "\t\t" << "VkValidationCacheCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCoarseSampleLocationNV(std::ostream &out, const VkCoarseSampleLocationNV* structInfo, Decoded_VkCoarseSampleLocationNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// pixelX
    struct_body << "\t" << structInfo->pixelX << "," << std::endl;
// pixelY
    struct_body << "\t\t\t" << structInfo->pixelY << "," << std::endl;
// sample
    struct_body << "\t\t\t" << structInfo->sample << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "coarseSampleLocationNV");
    out << "\t\t" << "VkCoarseSampleLocationNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCoarseSampleOrderCustomNV(std::ostream &out, const VkCoarseSampleOrderCustomNV* structInfo, Decoded_VkCoarseSampleOrderCustomNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string psample_locations_array = "NULL";
    if (structInfo->pSampleLocations != NULL) {
        psample_locations_array = "pSampleLocations_" + std::to_string(consumer.GetNextId());
        std::string psample_locations_names;
        for (uint32_t idx = 0; idx < structInfo->sampleLocationCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pSampleLocations + idx != NULL) {
                variable_name = GenerateStruct_VkCoarseSampleLocationNV(out,
                                                                        structInfo->pSampleLocations + idx,
                                                                        metaInfo->pSampleLocations->GetMetaStructPointer() + idx,
                                                                        consumer);
            }
            psample_locations_names += variable_name + ", ";
        }
        out << "\t\t" << "VkCoarseSampleLocationNV " << psample_locations_array << "[] = {" << psample_locations_names << "};" << std::endl;
    }
// shadingRate
    struct_body << "\t" << "VkShadingRatePaletteEntryNV(" << structInfo->shadingRate << ")" << "," << std::endl;
// sampleCount
    struct_body << "\t\t\t" << structInfo->sampleCount << "," << std::endl;
// sampleLocationCount
    struct_body << "\t\t\t" << structInfo->sampleLocationCount << "," << std::endl;
// pSampleLocations
    struct_body << "\t\t\t" << psample_locations_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "coarseSampleOrderCustomNV");
    out << "\t\t" << "VkCoarseSampleOrderCustomNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShadingRateImageFeaturesNV(std::ostream &out, const VkPhysicalDeviceShadingRateImageFeaturesNV* structInfo, Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shadingRateImage
    struct_body << "\t\t\t" << structInfo->shadingRateImage << "," << std::endl;
// shadingRateCoarseSampleOrder
    struct_body << "\t\t\t" << structInfo->shadingRateCoarseSampleOrder << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShadingRateImageFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceShadingRateImageFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShadingRateImagePropertiesNV(std::ostream &out, const VkPhysicalDeviceShadingRateImagePropertiesNV* structInfo, Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string shading_rate_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                             &structInfo->shadingRateTexelSize,
                                                                             metaInfo->shadingRateTexelSize,
                                                                             consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shadingRateTexelSize
    struct_body << "\t\t\t" << shading_rate_texel_size_info_var << "," << std::endl;
// shadingRatePaletteSize
    struct_body << "\t\t\t" << structInfo->shadingRatePaletteSize << "," << std::endl;
// shadingRateMaxCoarseSamples
    struct_body << "\t\t\t" << structInfo->shadingRateMaxCoarseSamples << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShadingRateImagePropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceShadingRateImagePropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(std::ostream &out, const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcustom_sample_orders_array = "NULL";
    if (structInfo->pCustomSampleOrders != NULL) {
        pcustom_sample_orders_array = "pCustomSampleOrders_" + std::to_string(consumer.GetNextId());
        std::string pcustom_sample_orders_names;
        for (uint32_t idx = 0; idx < structInfo->customSampleOrderCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pCustomSampleOrders + idx != NULL) {
                variable_name = GenerateStruct_VkCoarseSampleOrderCustomNV(out,
                                                                           structInfo->pCustomSampleOrders + idx,
                                                                           metaInfo->pCustomSampleOrders->GetMetaStructPointer() + idx,
                                                                           consumer);
            }
            pcustom_sample_orders_names += variable_name + ", ";
        }
        out << "\t\t" << "VkCoarseSampleOrderCustomNV " << pcustom_sample_orders_array << "[] = {" << pcustom_sample_orders_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// sampleOrderType
    struct_body << "\t\t\t" << "VkCoarseSampleOrderTypeNV(" << structInfo->sampleOrderType << ")" << "," << std::endl;
// customSampleOrderCount
    struct_body << "\t\t\t" << structInfo->customSampleOrderCount << "," << std::endl;
// pCustomSampleOrders
    struct_body << "\t\t\t" << pcustom_sample_orders_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportCoarseSampleOrderStateCreateInfoNV");
    out << "\t\t" << "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportShadingRateImageStateCreateInfoNV(std::ostream &out, const VkPipelineViewportShadingRateImageStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pshading_rate_palettes_array = "NULL";
    if (structInfo->pShadingRatePalettes != NULL) {
        pshading_rate_palettes_array = "pShadingRatePalettes_" + std::to_string(consumer.GetNextId());
        std::string pshading_rate_palettes_names;
        for (uint32_t idx = 0; idx < structInfo->viewportCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pShadingRatePalettes + idx != NULL) {
                variable_name = GenerateStruct_VkShadingRatePaletteNV(out,
                                                                      structInfo->pShadingRatePalettes + idx,
                                                                      metaInfo->pShadingRatePalettes->GetMetaStructPointer() + idx,
                                                                      consumer);
            }
            pshading_rate_palettes_names += variable_name + ", ";
        }
        out << "\t\t" << "VkShadingRatePaletteNV " << pshading_rate_palettes_array << "[] = {" << pshading_rate_palettes_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shadingRateImageEnable
    struct_body << "\t\t\t" << structInfo->shadingRateImageEnable << "," << std::endl;
// viewportCount
    struct_body << "\t\t\t" << structInfo->viewportCount << "," << std::endl;
// pShadingRatePalettes
    struct_body << "\t\t\t" << pshading_rate_palettes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportShadingRateImageStateCreateInfoNV");
    out << "\t\t" << "VkPipelineViewportShadingRateImageStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkShadingRatePaletteNV(std::ostream &out, const VkShadingRatePaletteNV* structInfo, Decoded_VkShadingRatePaletteNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pshading_rate_palette_entries_values;
    std::string pshading_rate_palette_entries_array = "NULL";
    if (structInfo->pShadingRatePaletteEntries != NULL) {
        for (uint32_t idx = 0; idx < structInfo->shadingRatePaletteEntryCount; idx++) {
            pshading_rate_palette_entries_values += util::ToString<VkShadingRatePaletteEntryNV>(structInfo->pShadingRatePaletteEntries[idx]) + ", ";
        }
        pshading_rate_palette_entries_array = "pShadingRatePaletteEntries_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkShadingRatePaletteEntryNV " << pshading_rate_palette_entries_array << "[] = {" << pshading_rate_palette_entries_values << "};" << std::endl;
    }
// shadingRatePaletteEntryCount
    struct_body << "\t" << structInfo->shadingRatePaletteEntryCount << "," << std::endl;
// pShadingRatePaletteEntries
    struct_body << "\t\t\t" << pshading_rate_palette_entries_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "shadingRatePaletteNV");
    out << "\t\t" << "VkShadingRatePaletteNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAabbPositionsKHR(std::ostream &out, const VkAabbPositionsKHR* structInfo, Decoded_VkAabbPositionsKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// minX
    struct_body << "\t" << structInfo->minX << "," << std::endl;
// minY
    struct_body << "\t\t\t" << structInfo->minY << "," << std::endl;
// minZ
    struct_body << "\t\t\t" << structInfo->minZ << "," << std::endl;
// maxX
    struct_body << "\t\t\t" << structInfo->maxX << "," << std::endl;
// maxY
    struct_body << "\t\t\t" << structInfo->maxY << "," << std::endl;
// maxZ
    struct_body << "\t\t\t" << structInfo->maxZ << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "aabbPositionsKHR");
    out << "\t\t" << "VkAabbPositionsKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureCreateInfoNV(std::ostream &out, const VkAccelerationStructureCreateInfoNV* structInfo, Decoded_VkAccelerationStructureCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string info_info_var = GenerateStruct_VkAccelerationStructureInfoNV(out,
                                                                             &structInfo->info,
                                                                             metaInfo->info,
                                                                             consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// compactedSize
    struct_body << "\t\t\t" << structInfo->compactedSize << "UL" << "," << std::endl;
// info
    struct_body << "\t\t\t" << info_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureCreateInfoNV");
    out << "\t\t" << "VkAccelerationStructureCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureInfoNV(std::ostream &out, const VkAccelerationStructureInfoNV* structInfo, Decoded_VkAccelerationStructureInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pgeometries_array = "NULL";
    if (structInfo->pGeometries != NULL) {
        pgeometries_array = "pGeometries_" + std::to_string(consumer.GetNextId());
        std::string pgeometries_names;
        for (uint32_t idx = 0; idx < structInfo->geometryCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pGeometries + idx != NULL) {
                variable_name = GenerateStruct_VkGeometryNV(out,
                                                            structInfo->pGeometries + idx,
                                                            metaInfo->pGeometries->GetMetaStructPointer() + idx,
                                                            consumer);
            }
            pgeometries_names += variable_name + ", ";
        }
        out << "\t\t" << "VkGeometryNV " << pgeometries_array << "[] = {" << pgeometries_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// type
    struct_body << "\t\t\t" << "VkAccelerationStructureTypeNV(" << structInfo->type << ")" << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkBuildAccelerationStructureFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
// instanceCount
    struct_body << "\t\t\t" << structInfo->instanceCount << "," << std::endl;
// geometryCount
    struct_body << "\t\t\t" << structInfo->geometryCount << "," << std::endl;
// pGeometries
    struct_body << "\t\t\t" << pgeometries_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureInfoNV");
    out << "\t\t" << "VkAccelerationStructureInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureInstanceKHR(std::ostream &out, const VkAccelerationStructureInstanceKHR* structInfo, Decoded_VkAccelerationStructureInstanceKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string transform_info_var = GenerateStruct_VkTransformMatrixKHR(out,
                                                                         &structInfo->transform,
                                                                         metaInfo->transform,
                                                                         consumer);
// transform
    struct_body << "\t" << transform_info_var << "," << std::endl;
// instanceCustomIndex
    struct_body << "\t\t\t" << structInfo->instanceCustomIndex << "," << std::endl;
// mask
    struct_body << "\t\t\t" << structInfo->mask << "," << std::endl;
// instanceShaderBindingTableRecordOffset
    struct_body << "\t\t\t" << structInfo->instanceShaderBindingTableRecordOffset << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkGeometryInstanceFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// accelerationStructureReference
    struct_body << "\t\t\t" << structInfo->accelerationStructureReference << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureInstanceKHR");
    out << "\t\t" << "VkAccelerationStructureInstanceKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureMemoryRequirementsInfoNV(std::ostream &out, const VkAccelerationStructureMemoryRequirementsInfoNV* structInfo, Decoded_VkAccelerationStructureMemoryRequirementsInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// type
    struct_body << "\t\t\t" << "VkAccelerationStructureMemoryRequirementsTypeNV(" << structInfo->type << ")" << "," << std::endl;
// accelerationStructure
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->accelerationStructure) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureMemoryRequirementsInfoNV");
    out << "\t\t" << "VkAccelerationStructureMemoryRequirementsInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindAccelerationStructureMemoryInfoNV(std::ostream &out, const VkBindAccelerationStructureMemoryInfoNV* structInfo, Decoded_VkBindAccelerationStructureMemoryInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdevice_indices_array = "NULL";
    if (structInfo->pDeviceIndices != NULL) {
        pdevice_indices_array = "pDeviceIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pdevice_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceIndices, structInfo->deviceIndexCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// accelerationStructure
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->accelerationStructure) << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
// memoryOffset
    struct_body << "\t\t\t" << structInfo->memoryOffset << "UL" << "," << std::endl;
// deviceIndexCount
    struct_body << "\t\t\t" << structInfo->deviceIndexCount << "," << std::endl;
// pDeviceIndices
    struct_body << "\t\t\t" << pdevice_indices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindAccelerationStructureMemoryInfoNV");
    out << "\t\t" << "VkBindAccelerationStructureMemoryInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeometryAABBNV(std::ostream &out, const VkGeometryAABBNV* structInfo, Decoded_VkGeometryAABBNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// aabbData
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->aabbData) << "," << std::endl;
// numAABBs
    struct_body << "\t\t\t" << structInfo->numAABBs << "," << std::endl;
// stride
    struct_body << "\t\t\t" << structInfo->stride << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "geometryAABBNV");
    out << "\t\t" << "VkGeometryAABBNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeometryDataNV(std::ostream &out, const VkGeometryDataNV* structInfo, Decoded_VkGeometryDataNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string triangles_info_var = GenerateStruct_VkGeometryTrianglesNV(out,
                                                                          &structInfo->triangles,
                                                                          metaInfo->triangles,
                                                                          consumer);
    std::string aabbs_info_var = GenerateStruct_VkGeometryAABBNV(out,
                                                                 &structInfo->aabbs,
                                                                 metaInfo->aabbs,
                                                                 consumer);
// triangles
    struct_body << "\t" << triangles_info_var << "," << std::endl;
// aabbs
    struct_body << "\t\t\t" << aabbs_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "geometryDataNV");
    out << "\t\t" << "VkGeometryDataNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeometryNV(std::ostream &out, const VkGeometryNV* structInfo, Decoded_VkGeometryNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string geometry_info_var = GenerateStruct_VkGeometryDataNV(out,
                                                                    &structInfo->geometry,
                                                                    metaInfo->geometry,
                                                                    consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// geometryType
    struct_body << "\t\t\t" << "VkGeometryTypeKHR(" << structInfo->geometryType << ")" << "," << std::endl;
// geometry
    struct_body << "\t\t\t" << geometry_info_var << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkGeometryFlagsKHR(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "geometryNV");
    out << "\t\t" << "VkGeometryNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeometryTrianglesNV(std::ostream &out, const VkGeometryTrianglesNV* structInfo, Decoded_VkGeometryTrianglesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// vertexData
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->vertexData) << "," << std::endl;
// vertexOffset
    struct_body << "\t\t\t" << structInfo->vertexOffset << "UL" << "," << std::endl;
// vertexCount
    struct_body << "\t\t\t" << structInfo->vertexCount << "," << std::endl;
// vertexStride
    struct_body << "\t\t\t" << structInfo->vertexStride << "UL" << "," << std::endl;
// vertexFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->vertexFormat << ")" << "," << std::endl;
// indexData
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->indexData) << "," << std::endl;
// indexOffset
    struct_body << "\t\t\t" << structInfo->indexOffset << "UL" << "," << std::endl;
// indexCount
    struct_body << "\t\t\t" << structInfo->indexCount << "," << std::endl;
// indexType
    struct_body << "\t\t\t" << "VkIndexType(" << structInfo->indexType << ")" << "," << std::endl;
// transformData
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->transformData) << "," << std::endl;
// transformOffset
    struct_body << "\t\t\t" << structInfo->transformOffset << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "geometryTrianglesNV");
    out << "\t\t" << "VkGeometryTrianglesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingPropertiesNV(std::ostream &out, const VkPhysicalDeviceRayTracingPropertiesNV* structInfo, Decoded_VkPhysicalDeviceRayTracingPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderGroupHandleSize
    struct_body << "\t\t\t" << structInfo->shaderGroupHandleSize << "," << std::endl;
// maxRecursionDepth
    struct_body << "\t\t\t" << structInfo->maxRecursionDepth << "," << std::endl;
// maxShaderGroupStride
    struct_body << "\t\t\t" << structInfo->maxShaderGroupStride << "," << std::endl;
// shaderGroupBaseAlignment
    struct_body << "\t\t\t" << structInfo->shaderGroupBaseAlignment << "," << std::endl;
// maxGeometryCount
    struct_body << "\t\t\t" << structInfo->maxGeometryCount << "UL" << "," << std::endl;
// maxInstanceCount
    struct_body << "\t\t\t" << structInfo->maxInstanceCount << "UL" << "," << std::endl;
// maxTriangleCount
    struct_body << "\t\t\t" << structInfo->maxTriangleCount << "UL" << "," << std::endl;
// maxDescriptorSetAccelerationStructures
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetAccelerationStructures << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceRayTracingPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRayTracingPipelineCreateInfoNV(std::ostream &out, const VkRayTracingPipelineCreateInfoNV* structInfo, Decoded_VkRayTracingPipelineCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstages_array = "NULL";
    if (structInfo->pStages != NULL) {
        pstages_array = "pStages_" + std::to_string(consumer.GetNextId());
        std::string pstages_names;
        for (uint32_t idx = 0; idx < structInfo->stageCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStages + idx != NULL) {
                variable_name = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                                               structInfo->pStages + idx,
                                                                               metaInfo->pStages->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pstages_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPipelineShaderStageCreateInfo " << pstages_array << "[] = {" << pstages_names << "};" << std::endl;
    }
    std::string pgroups_array = "NULL";
    if (structInfo->pGroups != NULL) {
        pgroups_array = "pGroups_" + std::to_string(consumer.GetNextId());
        std::string pgroups_names;
        for (uint32_t idx = 0; idx < structInfo->groupCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pGroups + idx != NULL) {
                variable_name = GenerateStruct_VkRayTracingShaderGroupCreateInfoNV(out,
                                                                                   structInfo->pGroups + idx,
                                                                                   metaInfo->pGroups->GetMetaStructPointer() + idx,
                                                                                   consumer);
            }
            pgroups_names += variable_name + ", ";
        }
        out << "\t\t" << "VkRayTracingShaderGroupCreateInfoNV " << pgroups_array << "[] = {" << pgroups_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// stageCount
    struct_body << "\t\t\t" << structInfo->stageCount << "," << std::endl;
// pStages
    struct_body << "\t\t\t" << pstages_array << "," << std::endl;
// groupCount
    struct_body << "\t\t\t" << structInfo->groupCount << "," << std::endl;
// pGroups
    struct_body << "\t\t\t" << pgroups_array << "," << std::endl;
// maxRecursionDepth
    struct_body << "\t\t\t" << structInfo->maxRecursionDepth << "," << std::endl;
// layout
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->layout) << "," << std::endl;
// basePipelineHandle
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->basePipelineHandle) << "," << std::endl;
// basePipelineIndex
    struct_body << "\t\t\t" << structInfo->basePipelineIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "rayTracingPipelineCreateInfoNV");
    out << "\t\t" << "VkRayTracingPipelineCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRayTracingShaderGroupCreateInfoNV(std::ostream &out, const VkRayTracingShaderGroupCreateInfoNV* structInfo, Decoded_VkRayTracingShaderGroupCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// type
    struct_body << "\t\t\t" << "VkRayTracingShaderGroupTypeKHR(" << structInfo->type << ")" << "," << std::endl;
// generalShader
    struct_body << "\t\t\t" << structInfo->generalShader << "," << std::endl;
// closestHitShader
    struct_body << "\t\t\t" << structInfo->closestHitShader << "," << std::endl;
// anyHitShader
    struct_body << "\t\t\t" << structInfo->anyHitShader << "," << std::endl;
// intersectionShader
    struct_body << "\t\t\t" << structInfo->intersectionShader << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "rayTracingShaderGroupCreateInfoNV");
    out << "\t\t" << "VkRayTracingShaderGroupCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTransformMatrixKHR(std::ostream &out, const VkTransformMatrixKHR* structInfo, Decoded_VkTransformMatrixKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// matrix
    struct_body << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->matrix[0][0]), 3) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "transformMatrixKHR");
    out << "\t\t" << "VkTransformMatrixKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWriteDescriptorSetAccelerationStructureNV(std::ostream &out, const VkWriteDescriptorSetAccelerationStructureNV* structInfo, Decoded_VkWriteDescriptorSetAccelerationStructureNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pacceleration_structures_array = "NULL";
    if (metaInfo->pAccelerationStructures.GetPointer() != NULL && structInfo->accelerationStructureCount > 0) {
        pacceleration_structures_array = "pacceleration_structures_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV));
        std::string pacceleration_structures_values = toStringJoin(metaInfo->pAccelerationStructures.GetPointer(),
                                                                   metaInfo->pAccelerationStructures.GetPointer() + structInfo->accelerationStructureCount,
                                                                   [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                                   ", ");
        if (structInfo->accelerationStructureCount == 1) {
            pacceleration_structures_array = "&" + pacceleration_structures_values;
        } else if (structInfo->accelerationStructureCount > 1) {
            out << "\t\t" << "VkAccelerationStructureNV " << pacceleration_structures_array << "[] = {" << pacceleration_structures_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// accelerationStructureCount
    struct_body << "\t\t\t" << structInfo->accelerationStructureCount << "," << std::endl;
// pAccelerationStructures
    struct_body << "\t\t\t" << pacceleration_structures_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "writeDescriptorSetAccelerationStructureNV");
    out << "\t\t" << "VkWriteDescriptorSetAccelerationStructureNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(std::ostream &out, const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* structInfo, Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// representativeFragmentTest
    struct_body << "\t\t\t" << structInfo->representativeFragmentTest << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRepresentativeFragmentTestFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(std::ostream &out, const VkPipelineRepresentativeFragmentTestStateCreateInfoNV* structInfo, Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// representativeFragmentTestEnable
    struct_body << "\t\t\t" << structInfo->representativeFragmentTestEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRepresentativeFragmentTestStateCreateInfoNV");
    out << "\t\t" << "VkPipelineRepresentativeFragmentTestStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFilterCubicImageViewImageFormatPropertiesEXT(std::ostream &out, const VkFilterCubicImageViewImageFormatPropertiesEXT* structInfo, Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// filterCubic
    struct_body << "\t\t\t" << structInfo->filterCubic << "," << std::endl;
// filterCubicMinmax
    struct_body << "\t\t\t" << structInfo->filterCubicMinmax << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "filterCubicImageViewImageFormatPropertiesEXT");
    out << "\t\t" << "VkFilterCubicImageViewImageFormatPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageViewImageFormatInfoEXT(std::ostream &out, const VkPhysicalDeviceImageViewImageFormatInfoEXT* structInfo, Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// imageViewType
    struct_body << "\t\t\t" << "VkImageViewType(" << structInfo->imageViewType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageViewImageFormatInfoEXT");
    out << "\t\t" << "VkPhysicalDeviceImageViewImageFormatInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryHostPointerPropertiesEXT(std::ostream &out, const VkMemoryHostPointerPropertiesEXT* structInfo, Decoded_VkMemoryHostPointerPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memoryTypeBits
    struct_body << "\t\t\t" << structInfo->memoryTypeBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryHostPointerPropertiesEXT");
    out << "\t\t" << "VkMemoryHostPointerPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(std::ostream &out, const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// minImportedHostPointerAlignment
    struct_body << "\t\t\t" << structInfo->minImportedHostPointerAlignment << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalMemoryHostPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceExternalMemoryHostPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCompilerControlCreateInfoAMD(std::ostream &out, const VkPipelineCompilerControlCreateInfoAMD* structInfo, Decoded_VkPipelineCompilerControlCreateInfoAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// compilerControlFlags
    struct_body << "\t\t\t" << "VkPipelineCompilerControlFlagsAMD(" << structInfo->compilerControlFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCompilerControlCreateInfoAMD");
    out << "\t\t" << "VkPipelineCompilerControlCreateInfoAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCorePropertiesAMD(std::ostream &out, const VkPhysicalDeviceShaderCorePropertiesAMD* structInfo, Decoded_VkPhysicalDeviceShaderCorePropertiesAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderEngineCount
    struct_body << "\t\t\t" << structInfo->shaderEngineCount << "," << std::endl;
// shaderArraysPerEngineCount
    struct_body << "\t\t\t" << structInfo->shaderArraysPerEngineCount << "," << std::endl;
// computeUnitsPerShaderArray
    struct_body << "\t\t\t" << structInfo->computeUnitsPerShaderArray << "," << std::endl;
// simdPerComputeUnit
    struct_body << "\t\t\t" << structInfo->simdPerComputeUnit << "," << std::endl;
// wavefrontsPerSimd
    struct_body << "\t\t\t" << structInfo->wavefrontsPerSimd << "," << std::endl;
// wavefrontSize
    struct_body << "\t\t\t" << structInfo->wavefrontSize << "," << std::endl;
// sgprsPerSimd
    struct_body << "\t\t\t" << structInfo->sgprsPerSimd << "," << std::endl;
// minSgprAllocation
    struct_body << "\t\t\t" << structInfo->minSgprAllocation << "," << std::endl;
// maxSgprAllocation
    struct_body << "\t\t\t" << structInfo->maxSgprAllocation << "," << std::endl;
// sgprAllocationGranularity
    struct_body << "\t\t\t" << structInfo->sgprAllocationGranularity << "," << std::endl;
// vgprsPerSimd
    struct_body << "\t\t\t" << structInfo->vgprsPerSimd << "," << std::endl;
// minVgprAllocation
    struct_body << "\t\t\t" << structInfo->minVgprAllocation << "," << std::endl;
// maxVgprAllocation
    struct_body << "\t\t\t" << structInfo->maxVgprAllocation << "," << std::endl;
// vgprAllocationGranularity
    struct_body << "\t\t\t" << structInfo->vgprAllocationGranularity << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderCorePropertiesAMD");
    out << "\t\t" << "VkPhysicalDeviceShaderCorePropertiesAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceMemoryOverallocationCreateInfoAMD(std::ostream &out, const VkDeviceMemoryOverallocationCreateInfoAMD* structInfo, Decoded_VkDeviceMemoryOverallocationCreateInfoAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// overallocationBehavior
    struct_body << "\t\t\t" << "VkMemoryOverallocationBehaviorAMD(" << structInfo->overallocationBehavior << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceMemoryOverallocationCreateInfoAMD");
    out << "\t\t" << "VkDeviceMemoryOverallocationCreateInfoAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(std::ostream &out, const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxVertexAttribDivisor
    struct_body << "\t\t\t" << structInfo->maxVertexAttribDivisor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVertexAttributeDivisorPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentFrameTokenGGP(std::ostream &out, const VkPresentFrameTokenGGP* structInfo, Decoded_VkPresentFrameTokenGGP* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// frameToken
    struct_body << "\t\t\t" << structInfo->frameToken << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentFrameTokenGGP");
    out << "\t\t" << "VkPresentFrameTokenGGP " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(std::ostream &out, const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* structInfo, Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// computeDerivativeGroupQuads
    struct_body << "\t\t\t" << structInfo->computeDerivativeGroupQuads << "," << std::endl;
// computeDerivativeGroupLinear
    struct_body << "\t\t\t" << structInfo->computeDerivativeGroupLinear << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceComputeShaderDerivativesFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceComputeShaderDerivativesFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrawMeshTasksIndirectCommandNV(std::ostream &out, const VkDrawMeshTasksIndirectCommandNV* structInfo, Decoded_VkDrawMeshTasksIndirectCommandNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// taskCount
    struct_body << "\t" << structInfo->taskCount << "," << std::endl;
// firstTask
    struct_body << "\t\t\t" << structInfo->firstTask << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drawMeshTasksIndirectCommandNV");
    out << "\t\t" << "VkDrawMeshTasksIndirectCommandNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMeshShaderFeaturesNV(std::ostream &out, const VkPhysicalDeviceMeshShaderFeaturesNV* structInfo, Decoded_VkPhysicalDeviceMeshShaderFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// taskShader
    struct_body << "\t\t\t" << structInfo->taskShader << "," << std::endl;
// meshShader
    struct_body << "\t\t\t" << structInfo->meshShader << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMeshShaderFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceMeshShaderFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMeshShaderPropertiesNV(std::ostream &out, const VkPhysicalDeviceMeshShaderPropertiesNV* structInfo, Decoded_VkPhysicalDeviceMeshShaderPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxDrawMeshTasksCount
    struct_body << "\t\t\t" << structInfo->maxDrawMeshTasksCount << "," << std::endl;
// maxTaskWorkGroupInvocations
    struct_body << "\t\t\t" << structInfo->maxTaskWorkGroupInvocations << "," << std::endl;
// maxTaskWorkGroupSize
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxTaskWorkGroupSize[0]), 3) << "," << std::endl;
// maxTaskTotalMemorySize
    struct_body << "\t\t\t" << structInfo->maxTaskTotalMemorySize << "," << std::endl;
// maxTaskOutputCount
    struct_body << "\t\t\t" << structInfo->maxTaskOutputCount << "," << std::endl;
// maxMeshWorkGroupInvocations
    struct_body << "\t\t\t" << structInfo->maxMeshWorkGroupInvocations << "," << std::endl;
// maxMeshWorkGroupSize
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxMeshWorkGroupSize[0]), 3) << "," << std::endl;
// maxMeshTotalMemorySize
    struct_body << "\t\t\t" << structInfo->maxMeshTotalMemorySize << "," << std::endl;
// maxMeshOutputVertices
    struct_body << "\t\t\t" << structInfo->maxMeshOutputVertices << "," << std::endl;
// maxMeshOutputPrimitives
    struct_body << "\t\t\t" << structInfo->maxMeshOutputPrimitives << "," << std::endl;
// maxMeshMultiviewViewCount
    struct_body << "\t\t\t" << structInfo->maxMeshMultiviewViewCount << "," << std::endl;
// meshOutputPerVertexGranularity
    struct_body << "\t\t\t" << structInfo->meshOutputPerVertexGranularity << "," << std::endl;
// meshOutputPerPrimitiveGranularity
    struct_body << "\t\t\t" << structInfo->meshOutputPerPrimitiveGranularity << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMeshShaderPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceMeshShaderPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderImageFootprintFeaturesNV(std::ostream &out, const VkPhysicalDeviceShaderImageFootprintFeaturesNV* structInfo, Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// imageFootprint
    struct_body << "\t\t\t" << structInfo->imageFootprint << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderImageFootprintFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceShaderImageFootprintFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExclusiveScissorFeaturesNV(std::ostream &out, const VkPhysicalDeviceExclusiveScissorFeaturesNV* structInfo, Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// exclusiveScissor
    struct_body << "\t\t\t" << structInfo->exclusiveScissor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExclusiveScissorFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceExclusiveScissorFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportExclusiveScissorStateCreateInfoNV(std::ostream &out, const VkPipelineViewportExclusiveScissorStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pexclusive_scissors_array = "NULL";
    if (structInfo->pExclusiveScissors != NULL) {
        pexclusive_scissors_array = "pExclusiveScissors_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkRect2D " << pexclusive_scissors_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pExclusiveScissors, structInfo->exclusiveScissorCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// exclusiveScissorCount
    struct_body << "\t\t\t" << structInfo->exclusiveScissorCount << "," << std::endl;
// pExclusiveScissors
    struct_body << "\t\t\t" << pexclusive_scissors_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportExclusiveScissorStateCreateInfoNV");
    out << "\t\t" << "VkPipelineViewportExclusiveScissorStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCheckpointDataNV(std::ostream &out, const VkCheckpointDataNV* structInfo, Decoded_VkCheckpointDataNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stage
    struct_body << "\t\t\t" << "VkPipelineStageFlagBits(" << structInfo->stage << ")" << "," << std::endl;
// pCheckpointMarker
    out << "\t\t" << "// TODO: Support pCheckpointMarker (output?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "checkpointDataNV");
    out << "\t\t" << "VkCheckpointDataNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyCheckpointPropertiesNV(std::ostream &out, const VkQueueFamilyCheckpointPropertiesNV* structInfo, Decoded_VkQueueFamilyCheckpointPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// checkpointExecutionStageMask
    struct_body << "\t\t\t" << "VkPipelineStageFlags(" << structInfo->checkpointExecutionStageMask << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyCheckpointPropertiesNV");
    out << "\t\t" << "VkQueueFamilyCheckpointPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(std::ostream &out, const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* structInfo, Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderIntegerFunctions2
    struct_body << "\t\t\t" << structInfo->shaderIntegerFunctions2 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderIntegerFunctions2FeaturesINTEL");
    out << "\t\t" << "VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkInitializePerformanceApiInfoINTEL(std::ostream &out, const VkInitializePerformanceApiInfoINTEL* structInfo, Decoded_VkInitializePerformanceApiInfoINTEL* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pUserData
    out << "\t\t" << "// TODO: Support pUserData (output?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "initializePerformanceApiInfoINTEL");
    out << "\t\t" << "VkInitializePerformanceApiInfoINTEL " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceConfigurationAcquireInfoINTEL(std::ostream &out, const VkPerformanceConfigurationAcquireInfoINTEL* structInfo, Decoded_VkPerformanceConfigurationAcquireInfoINTEL* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// type
    struct_body << "\t\t\t" << "VkPerformanceConfigurationTypeINTEL(" << structInfo->type << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceConfigurationAcquireInfoINTEL");
    out << "\t\t" << "VkPerformanceConfigurationAcquireInfoINTEL " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceMarkerInfoINTEL(std::ostream &out, const VkPerformanceMarkerInfoINTEL* structInfo, Decoded_VkPerformanceMarkerInfoINTEL* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// marker
    struct_body << "\t\t\t" << structInfo->marker << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceMarkerInfoINTEL");
    out << "\t\t" << "VkPerformanceMarkerInfoINTEL " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceOverrideInfoINTEL(std::ostream &out, const VkPerformanceOverrideInfoINTEL* structInfo, Decoded_VkPerformanceOverrideInfoINTEL* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// type
    struct_body << "\t\t\t" << "VkPerformanceOverrideTypeINTEL(" << structInfo->type << ")" << "," << std::endl;
// enable
    struct_body << "\t\t\t" << structInfo->enable << "," << std::endl;
// parameter
    struct_body << "\t\t\t" << structInfo->parameter << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceOverrideInfoINTEL");
    out << "\t\t" << "VkPerformanceOverrideInfoINTEL " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceStreamMarkerInfoINTEL(std::ostream &out, const VkPerformanceStreamMarkerInfoINTEL* structInfo, Decoded_VkPerformanceStreamMarkerInfoINTEL* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// marker
    struct_body << "\t\t\t" << structInfo->marker << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceStreamMarkerInfoINTEL");
    out << "\t\t" << "VkPerformanceStreamMarkerInfoINTEL " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueryPoolPerformanceQueryCreateInfoINTEL(std::ostream &out, const VkQueryPoolPerformanceQueryCreateInfoINTEL* structInfo, Decoded_VkQueryPoolPerformanceQueryCreateInfoINTEL* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// performanceCountersSampling
    struct_body << "\t\t\t" << "VkQueryPoolSamplingModeINTEL(" << structInfo->performanceCountersSampling << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queryPoolPerformanceQueryCreateInfoINTEL");
    out << "\t\t" << "VkQueryPoolPerformanceQueryCreateInfoINTEL " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePCIBusInfoPropertiesEXT(std::ostream &out, const VkPhysicalDevicePCIBusInfoPropertiesEXT* structInfo, Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pciDomain
    struct_body << "\t\t\t" << structInfo->pciDomain << "," << std::endl;
// pciBus
    struct_body << "\t\t\t" << structInfo->pciBus << "," << std::endl;
// pciDevice
    struct_body << "\t\t\t" << structInfo->pciDevice << "," << std::endl;
// pciFunction
    struct_body << "\t\t\t" << structInfo->pciFunction << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePCIBusInfoPropertiesEXT");
    out << "\t\t" << "VkPhysicalDevicePCIBusInfoPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayNativeHdrSurfaceCapabilitiesAMD(std::ostream &out, const VkDisplayNativeHdrSurfaceCapabilitiesAMD* structInfo, Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// localDimmingSupport
    struct_body << "\t\t\t" << structInfo->localDimmingSupport << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayNativeHdrSurfaceCapabilitiesAMD");
    out << "\t\t" << "VkDisplayNativeHdrSurfaceCapabilitiesAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainDisplayNativeHdrCreateInfoAMD(std::ostream &out, const VkSwapchainDisplayNativeHdrCreateInfoAMD* structInfo, Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// localDimmingEnable
    struct_body << "\t\t\t" << structInfo->localDimmingEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainDisplayNativeHdrCreateInfoAMD");
    out << "\t\t" << "VkSwapchainDisplayNativeHdrCreateInfoAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImagePipeSurfaceCreateInfoFUCHSIA(std::ostream &out, const VkImagePipeSurfaceCreateInfoFUCHSIA* structInfo, Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkImagePipeSurfaceCreateFlagsFUCHSIA(" << structInfo->flags << ")" << "," << std::endl;
// imagePipeHandle
    struct_body << "\t\t\t" << structInfo->imagePipeHandle << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imagePipeSurfaceCreateInfoFUCHSIA");
    out << "\t\t" << "VkImagePipeSurfaceCreateInfoFUCHSIA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMetalSurfaceCreateInfoEXT(std::ostream &out, const VkMetalSurfaceCreateInfoEXT* structInfo, Decoded_VkMetalSurfaceCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkMetalSurfaceCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// pLayer
    struct_body << "\t\t\t" << structInfo->pLayer << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "metalSurfaceCreateInfoEXT");
    out << "\t\t" << "VkMetalSurfaceCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    out << "\t\t" << "OverrideVkMetalSurfaceCreateInfoEXT(&" << variable_name << ", " << "appdata" << ");" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(std::ostream &out, const VkPhysicalDeviceFragmentDensityMapFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fragmentDensityMap
    struct_body << "\t\t\t" << structInfo->fragmentDensityMap << "," << std::endl;
// fragmentDensityMapDynamic
    struct_body << "\t\t\t" << structInfo->fragmentDensityMapDynamic << "," << std::endl;
// fragmentDensityMapNonSubsampledImages
    struct_body << "\t\t\t" << structInfo->fragmentDensityMapNonSubsampledImages << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentDensityMapFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceFragmentDensityMapFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(std::ostream &out, const VkPhysicalDeviceFragmentDensityMapPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string min_fragment_density_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                     &structInfo->minFragmentDensityTexelSize,
                                                                                     metaInfo->minFragmentDensityTexelSize,
                                                                                     consumer);
    std::string max_fragment_density_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                     &structInfo->maxFragmentDensityTexelSize,
                                                                                     metaInfo->maxFragmentDensityTexelSize,
                                                                                     consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// minFragmentDensityTexelSize
    struct_body << "\t\t\t" << min_fragment_density_texel_size_info_var << "," << std::endl;
// maxFragmentDensityTexelSize
    struct_body << "\t\t\t" << max_fragment_density_texel_size_info_var << "," << std::endl;
// fragmentDensityInvocations
    struct_body << "\t\t\t" << structInfo->fragmentDensityInvocations << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentDensityMapPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceFragmentDensityMapPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassFragmentDensityMapCreateInfoEXT(std::ostream &out, const VkRenderPassFragmentDensityMapCreateInfoEXT* structInfo, Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string fragment_density_map_attachment_info_var = GenerateStruct_VkAttachmentReference(out,
                                                                                                &structInfo->fragmentDensityMapAttachment,
                                                                                                metaInfo->fragmentDensityMapAttachment,
                                                                                                consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fragmentDensityMapAttachment
    struct_body << "\t\t\t" << fragment_density_map_attachment_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassFragmentDensityMapCreateInfoEXT");
    out << "\t\t" << "VkRenderPassFragmentDensityMapCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCoreProperties2AMD(std::ostream &out, const VkPhysicalDeviceShaderCoreProperties2AMD* structInfo, Decoded_VkPhysicalDeviceShaderCoreProperties2AMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderCoreFeatures
    struct_body << "\t\t\t" << "VkShaderCorePropertiesFlagsAMD(" << structInfo->shaderCoreFeatures << ")" << "," << std::endl;
// activeComputeUnitCount
    struct_body << "\t\t\t" << structInfo->activeComputeUnitCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderCoreProperties2AMD");
    out << "\t\t" << "VkPhysicalDeviceShaderCoreProperties2AMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCoherentMemoryFeaturesAMD(std::ostream &out, const VkPhysicalDeviceCoherentMemoryFeaturesAMD* structInfo, Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceCoherentMemory
    struct_body << "\t\t\t" << structInfo->deviceCoherentMemory << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCoherentMemoryFeaturesAMD");
    out << "\t\t" << "VkPhysicalDeviceCoherentMemoryFeaturesAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderImageInt64Atomics
    struct_body << "\t\t\t" << structInfo->shaderImageInt64Atomics << "," << std::endl;
// sparseImageInt64Atomics
    struct_body << "\t\t\t" << structInfo->sparseImageInt64Atomics << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderImageAtomicInt64FeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMemoryBudgetPropertiesEXT(std::ostream &out, const VkPhysicalDeviceMemoryBudgetPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string heap_budget_array = "heap_budget_array_" + std::to_string(consumer.GetNextId());
    if (VK_MAX_MEMORY_HEAPS > 0) {
        std::string heap_budget_values = toStringJoin(structInfo->heapBudget,
                                                      structInfo->heapBudget + VK_MAX_MEMORY_HEAPS,
                                                      [](VkDeviceSize current) { return std::to_string(current); },
                                                      ", ");
        if (VK_MAX_MEMORY_HEAPS == 1) {
            heap_budget_array = "&" + heap_budget_values;
        } else if (VK_MAX_MEMORY_HEAPS > 1) {
            out << "\t\t" << "VkDeviceSize " << heap_budget_array << "[] = {" << heap_budget_values << "};" << std::endl;
        }
    }
    std::string heap_usage_array = "heap_usage_array_" + std::to_string(consumer.GetNextId());
    if (VK_MAX_MEMORY_HEAPS > 0) {
        std::string heap_usage_values = toStringJoin(structInfo->heapUsage,
                                                     structInfo->heapUsage + VK_MAX_MEMORY_HEAPS,
                                                     [](VkDeviceSize current) { return std::to_string(current); },
                                                     ", ");
        if (VK_MAX_MEMORY_HEAPS == 1) {
            heap_usage_array = "&" + heap_usage_values;
        } else if (VK_MAX_MEMORY_HEAPS > 1) {
            out << "\t\t" << "VkDeviceSize " << heap_usage_array << "[] = {" << heap_usage_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// heapBudget
    struct_body << "\t\t\t" << "{ *" << heap_budget_array << " }" << "," << std::endl;
// heapUsage
    struct_body << "\t\t\t" << "{ *" << heap_usage_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMemoryBudgetPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceMemoryBudgetPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryPriorityAllocateInfoEXT(std::ostream &out, const VkMemoryPriorityAllocateInfoEXT* structInfo, Decoded_VkMemoryPriorityAllocateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// priority
    struct_body << "\t\t\t" << structInfo->priority << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryPriorityAllocateInfoEXT");
    out << "\t\t" << "VkMemoryPriorityAllocateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMemoryPriorityFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMemoryPriorityFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memoryPriority
    struct_body << "\t\t\t" << structInfo->memoryPriority << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMemoryPriorityFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceMemoryPriorityFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(std::ostream &out, const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// dedicatedAllocationImageAliasing
    struct_body << "\t\t\t" << structInfo->dedicatedAllocationImageAliasing << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDedicatedAllocationImageAliasingFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferDeviceAddressCreateInfoEXT(std::ostream &out, const VkBufferDeviceAddressCreateInfoEXT* structInfo, Decoded_VkBufferDeviceAddressCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceAddress
    struct_body << "\t\t\t" << structInfo->deviceAddress << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferDeviceAddressCreateInfoEXT");
    out << "\t\t" << "VkBufferDeviceAddressCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(std::ostream &out, const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// bufferDeviceAddress
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddress << "," << std::endl;
// bufferDeviceAddressCaptureReplay
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddressCaptureReplay << "," << std::endl;
// bufferDeviceAddressMultiDevice
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddressMultiDevice << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceBufferDeviceAddressFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkValidationFeaturesEXT(std::ostream &out, const VkValidationFeaturesEXT* structInfo, Decoded_VkValidationFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string penabled_validation_features_values;
    std::string penabled_validation_features_array = "NULL";
    if (structInfo->pEnabledValidationFeatures != NULL) {
        for (uint32_t idx = 0; idx < structInfo->enabledValidationFeatureCount; idx++) {
            penabled_validation_features_values += util::ToString<VkValidationFeatureEnableEXT>(structInfo->pEnabledValidationFeatures[idx]) + ", ";
        }
        penabled_validation_features_array = "pEnabledValidationFeatures_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkValidationFeatureEnableEXT " << penabled_validation_features_array << "[] = {" << penabled_validation_features_values << "};" << std::endl;
    }
    std::string pdisabled_validation_features_values;
    std::string pdisabled_validation_features_array = "NULL";
    if (structInfo->pDisabledValidationFeatures != NULL) {
        for (uint32_t idx = 0; idx < structInfo->disabledValidationFeatureCount; idx++) {
            pdisabled_validation_features_values += util::ToString<VkValidationFeatureDisableEXT>(structInfo->pDisabledValidationFeatures[idx]) + ", ";
        }
        pdisabled_validation_features_array = "pDisabledValidationFeatures_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkValidationFeatureDisableEXT " << pdisabled_validation_features_array << "[] = {" << pdisabled_validation_features_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// enabledValidationFeatureCount
    struct_body << "\t\t\t" << structInfo->enabledValidationFeatureCount << "," << std::endl;
// pEnabledValidationFeatures
    struct_body << "\t\t\t" << penabled_validation_features_array << "," << std::endl;
// disabledValidationFeatureCount
    struct_body << "\t\t\t" << structInfo->disabledValidationFeatureCount << "," << std::endl;
// pDisabledValidationFeatures
    struct_body << "\t\t\t" << pdisabled_validation_features_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "validationFeaturesEXT");
    out << "\t\t" << "VkValidationFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCooperativeMatrixPropertiesNV(std::ostream &out, const VkCooperativeMatrixPropertiesNV* structInfo, Decoded_VkCooperativeMatrixPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// MSize
    struct_body << "\t\t\t" << structInfo->MSize << "," << std::endl;
// NSize
    struct_body << "\t\t\t" << structInfo->NSize << "," << std::endl;
// KSize
    struct_body << "\t\t\t" << structInfo->KSize << "," << std::endl;
// AType
    struct_body << "\t\t\t" << "VkComponentTypeNV(" << structInfo->AType << ")" << "," << std::endl;
// BType
    struct_body << "\t\t\t" << "VkComponentTypeNV(" << structInfo->BType << ")" << "," << std::endl;
// CType
    struct_body << "\t\t\t" << "VkComponentTypeNV(" << structInfo->CType << ")" << "," << std::endl;
// DType
    struct_body << "\t\t\t" << "VkComponentTypeNV(" << structInfo->DType << ")" << "," << std::endl;
// scope
    struct_body << "\t\t\t" << "VkScopeNV(" << structInfo->scope << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "cooperativeMatrixPropertiesNV");
    out << "\t\t" << "VkCooperativeMatrixPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeMatrixFeaturesNV(std::ostream &out, const VkPhysicalDeviceCooperativeMatrixFeaturesNV* structInfo, Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// cooperativeMatrix
    struct_body << "\t\t\t" << structInfo->cooperativeMatrix << "," << std::endl;
// cooperativeMatrixRobustBufferAccess
    struct_body << "\t\t\t" << structInfo->cooperativeMatrixRobustBufferAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCooperativeMatrixFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceCooperativeMatrixFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeMatrixPropertiesNV(std::ostream &out, const VkPhysicalDeviceCooperativeMatrixPropertiesNV* structInfo, Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// cooperativeMatrixSupportedStages
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->cooperativeMatrixSupportedStages << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCooperativeMatrixPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceCooperativeMatrixPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFramebufferMixedSamplesCombinationNV(std::ostream &out, const VkFramebufferMixedSamplesCombinationNV* structInfo, Decoded_VkFramebufferMixedSamplesCombinationNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// coverageReductionMode
    struct_body << "\t\t\t" << "VkCoverageReductionModeNV(" << structInfo->coverageReductionMode << ")" << "," << std::endl;
// rasterizationSamples
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->rasterizationSamples << ")" << "," << std::endl;
// depthStencilSamples
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->depthStencilSamples << ")" << "," << std::endl;
// colorSamples
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->colorSamples << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "framebufferMixedSamplesCombinationNV");
    out << "\t\t" << "VkFramebufferMixedSamplesCombinationNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCoverageReductionModeFeaturesNV(std::ostream &out, const VkPhysicalDeviceCoverageReductionModeFeaturesNV* structInfo, Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// coverageReductionMode
    struct_body << "\t\t\t" << structInfo->coverageReductionMode << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCoverageReductionModeFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceCoverageReductionModeFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCoverageReductionStateCreateInfoNV(std::ostream &out, const VkPipelineCoverageReductionStateCreateInfoNV* structInfo, Decoded_VkPipelineCoverageReductionStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineCoverageReductionStateCreateFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
// coverageReductionMode
    struct_body << "\t\t\t" << "VkCoverageReductionModeNV(" << structInfo->coverageReductionMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCoverageReductionStateCreateInfoNV");
    out << "\t\t" << "VkPipelineCoverageReductionStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(std::ostream &out, const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fragmentShaderSampleInterlock
    struct_body << "\t\t\t" << structInfo->fragmentShaderSampleInterlock << "," << std::endl;
// fragmentShaderPixelInterlock
    struct_body << "\t\t\t" << structInfo->fragmentShaderPixelInterlock << "," << std::endl;
// fragmentShaderShadingRateInterlock
    struct_body << "\t\t\t" << structInfo->fragmentShaderShadingRateInterlock << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShaderInterlockFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(std::ostream &out, const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// ycbcrImageArrays
    struct_body << "\t\t\t" << structInfo->ycbcrImageArrays << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceYcbcrImageArraysFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceProvokingVertexFeaturesEXT(std::ostream &out, const VkPhysicalDeviceProvokingVertexFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceProvokingVertexFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// provokingVertexLast
    struct_body << "\t\t\t" << structInfo->provokingVertexLast << "," << std::endl;
// transformFeedbackPreservesProvokingVertex
    struct_body << "\t\t\t" << structInfo->transformFeedbackPreservesProvokingVertex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceProvokingVertexFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceProvokingVertexFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceProvokingVertexPropertiesEXT(std::ostream &out, const VkPhysicalDeviceProvokingVertexPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceProvokingVertexPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// provokingVertexModePerPipeline
    struct_body << "\t\t\t" << structInfo->provokingVertexModePerPipeline << "," << std::endl;
// transformFeedbackPreservesTriangleFanProvokingVertex
    struct_body << "\t\t\t" << structInfo->transformFeedbackPreservesTriangleFanProvokingVertex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceProvokingVertexPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceProvokingVertexPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(std::ostream &out, const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* structInfo, Decoded_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// provokingVertexMode
    struct_body << "\t\t\t" << "VkProvokingVertexModeEXT(" << structInfo->provokingVertexMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRasterizationProvokingVertexStateCreateInfoEXT");
    out << "\t\t" << "VkPipelineRasterizationProvokingVertexStateCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceCapabilitiesFullScreenExclusiveEXT(std::ostream &out, const VkSurfaceCapabilitiesFullScreenExclusiveEXT* structInfo, Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fullScreenExclusiveSupported
    struct_body << "\t\t\t" << structInfo->fullScreenExclusiveSupported << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceCapabilitiesFullScreenExclusiveEXT");
    out << "\t\t" << "VkSurfaceCapabilitiesFullScreenExclusiveEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceFullScreenExclusiveInfoEXT(std::ostream &out, const VkSurfaceFullScreenExclusiveInfoEXT* structInfo, Decoded_VkSurfaceFullScreenExclusiveInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fullScreenExclusive
    struct_body << "\t\t\t" << "VkFullScreenExclusiveEXT(" << structInfo->fullScreenExclusive << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceFullScreenExclusiveInfoEXT");
    out << "\t\t" << "VkSurfaceFullScreenExclusiveInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceFullScreenExclusiveWin32InfoEXT(std::ostream &out, const VkSurfaceFullScreenExclusiveWin32InfoEXT* structInfo, Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// hmonitor
    struct_body << "\t\t\t" << structInfo->hmonitor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceFullScreenExclusiveWin32InfoEXT");
    out << "\t\t" << "VkSurfaceFullScreenExclusiveWin32InfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkHeadlessSurfaceCreateInfoEXT(std::ostream &out, const VkHeadlessSurfaceCreateInfoEXT* structInfo, Decoded_VkHeadlessSurfaceCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkHeadlessSurfaceCreateFlagsEXT(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "headlessSurfaceCreateInfoEXT");
    out << "\t\t" << "VkHeadlessSurfaceCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLineRasterizationFeaturesEXT(std::ostream &out, const VkPhysicalDeviceLineRasterizationFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// rectangularLines
    struct_body << "\t\t\t" << structInfo->rectangularLines << "," << std::endl;
// bresenhamLines
    struct_body << "\t\t\t" << structInfo->bresenhamLines << "," << std::endl;
// smoothLines
    struct_body << "\t\t\t" << structInfo->smoothLines << "," << std::endl;
// stippledRectangularLines
    struct_body << "\t\t\t" << structInfo->stippledRectangularLines << "," << std::endl;
// stippledBresenhamLines
    struct_body << "\t\t\t" << structInfo->stippledBresenhamLines << "," << std::endl;
// stippledSmoothLines
    struct_body << "\t\t\t" << structInfo->stippledSmoothLines << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLineRasterizationFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceLineRasterizationFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLineRasterizationPropertiesEXT(std::ostream &out, const VkPhysicalDeviceLineRasterizationPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// lineSubPixelPrecisionBits
    struct_body << "\t\t\t" << structInfo->lineSubPixelPrecisionBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLineRasterizationPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceLineRasterizationPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRasterizationLineStateCreateInfoEXT(std::ostream &out, const VkPipelineRasterizationLineStateCreateInfoEXT* structInfo, Decoded_VkPipelineRasterizationLineStateCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// lineRasterizationMode
    struct_body << "\t\t\t" << "VkLineRasterizationModeEXT(" << structInfo->lineRasterizationMode << ")" << "," << std::endl;
// stippledLineEnable
    struct_body << "\t\t\t" << structInfo->stippledLineEnable << "," << std::endl;
// lineStippleFactor
    struct_body << "\t\t\t" << structInfo->lineStippleFactor << "," << std::endl;
// lineStipplePattern
    struct_body << "\t\t\t" << structInfo->lineStipplePattern << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRasterizationLineStateCreateInfoEXT");
    out << "\t\t" << "VkPipelineRasterizationLineStateCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderBufferFloat32Atomics
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat32Atomics << "," << std::endl;
// shaderBufferFloat32AtomicAdd
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat32AtomicAdd << "," << std::endl;
// shaderBufferFloat64Atomics
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat64Atomics << "," << std::endl;
// shaderBufferFloat64AtomicAdd
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat64AtomicAdd << "," << std::endl;
// shaderSharedFloat32Atomics
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat32Atomics << "," << std::endl;
// shaderSharedFloat32AtomicAdd
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat32AtomicAdd << "," << std::endl;
// shaderSharedFloat64Atomics
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat64Atomics << "," << std::endl;
// shaderSharedFloat64AtomicAdd
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat64AtomicAdd << "," << std::endl;
// shaderImageFloat32Atomics
    struct_body << "\t\t\t" << structInfo->shaderImageFloat32Atomics << "," << std::endl;
// shaderImageFloat32AtomicAdd
    struct_body << "\t\t\t" << structInfo->shaderImageFloat32AtomicAdd << "," << std::endl;
// sparseImageFloat32Atomics
    struct_body << "\t\t\t" << structInfo->sparseImageFloat32Atomics << "," << std::endl;
// sparseImageFloat32AtomicAdd
    struct_body << "\t\t\t" << structInfo->sparseImageFloat32AtomicAdd << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderAtomicFloatFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(std::ostream &out, const VkPhysicalDeviceIndexTypeUint8FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceIndexTypeUint8FeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// indexTypeUint8
    struct_body << "\t\t\t" << structInfo->indexTypeUint8 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceIndexTypeUint8FeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceIndexTypeUint8FeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(std::ostream &out, const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// extendedDynamicState
    struct_body << "\t\t\t" << structInfo->extendedDynamicState << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExtendedDynamicStateFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceExtendedDynamicStateFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyImageToImageInfoEXT(std::ostream &out, const VkCopyImageToImageInfoEXT* structInfo, Decoded_VkCopyImageToImageInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkImageCopy2(out,
                                                            structInfo->pRegions + idx,
                                                            metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                            consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkImageCopy2 " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkHostImageCopyFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// srcImage
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcImage) << "," << std::endl;
// srcImageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
// dstImage
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstImage) << "," << std::endl;
// dstImageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
// regionCount
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
// pRegions
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyImageToImageInfoEXT");
    out << "\t\t" << "VkCopyImageToImageInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyImageToMemoryInfoEXT(std::ostream &out, const VkCopyImageToMemoryInfoEXT* structInfo, Decoded_VkCopyImageToMemoryInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkImageToMemoryCopyEXT(out,
                                                                      structInfo->pRegions + idx,
                                                                      metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                                      consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkImageToMemoryCopyEXT " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkHostImageCopyFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// srcImage
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcImage) << "," << std::endl;
// srcImageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
// regionCount
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
// pRegions
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyImageToMemoryInfoEXT");
    out << "\t\t" << "VkCopyImageToMemoryInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyMemoryToImageInfoEXT(std::ostream &out, const VkCopyMemoryToImageInfoEXT* structInfo, Decoded_VkCopyMemoryToImageInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkMemoryToImageCopyEXT(out,
                                                                      structInfo->pRegions + idx,
                                                                      metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                                      consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkMemoryToImageCopyEXT " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkHostImageCopyFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// dstImage
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstImage) << "," << std::endl;
// dstImageLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
// regionCount
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
// pRegions
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyMemoryToImageInfoEXT");
    out << "\t\t" << "VkCopyMemoryToImageInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkHostImageCopyDevicePerformanceQueryEXT(std::ostream &out, const VkHostImageCopyDevicePerformanceQueryEXT* structInfo, Decoded_VkHostImageCopyDevicePerformanceQueryEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// optimalDeviceAccess
    struct_body << "\t\t\t" << structInfo->optimalDeviceAccess << "," << std::endl;
// identicalMemoryLayout
    struct_body << "\t\t\t" << structInfo->identicalMemoryLayout << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "hostImageCopyDevicePerformanceQueryEXT");
    out << "\t\t" << "VkHostImageCopyDevicePerformanceQueryEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkHostImageLayoutTransitionInfoEXT(std::ostream &out, const VkHostImageLayoutTransitionInfoEXT* structInfo, Decoded_VkHostImageLayoutTransitionInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string subresource_range_info_var = GenerateStruct_VkImageSubresourceRange(out,
                                                                                    &structInfo->subresourceRange,
                                                                                    metaInfo->subresourceRange,
                                                                                    consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// image
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
// oldLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->oldLayout << ")" << "," << std::endl;
// newLayout
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->newLayout << ")" << "," << std::endl;
// subresourceRange
    struct_body << "\t\t\t" << subresource_range_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "hostImageLayoutTransitionInfoEXT");
    out << "\t\t" << "VkHostImageLayoutTransitionInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageToMemoryCopyEXT(std::ostream &out, const VkImageToMemoryCopyEXT* structInfo, Decoded_VkImageToMemoryCopyEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string image_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                     &structInfo->imageSubresource,
                                                                                     metaInfo->imageSubresource,
                                                                                     consumer);
    std::string image_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->imageOffset,
                                                                  metaInfo->imageOffset,
                                                                  consumer);
    std::string image_extent_info_var = GenerateStruct_VkExtent3D(out,
                                                                  &structInfo->imageExtent,
                                                                  metaInfo->imageExtent,
                                                                  consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pHostPointer
    out << "\t\t" << "// TODO: Support pHostPointer (output?) argument." << std::endl;
// memoryRowLength
    struct_body << "\t\t\t" << structInfo->memoryRowLength << "," << std::endl;
// memoryImageHeight
    struct_body << "\t\t\t" << structInfo->memoryImageHeight << "," << std::endl;
// imageSubresource
    struct_body << "\t\t\t" << image_subresource_info_var << "," << std::endl;
// imageOffset
    struct_body << "\t\t\t" << image_offset_info_var << "," << std::endl;
// imageExtent
    struct_body << "\t\t\t" << image_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageToMemoryCopyEXT");
    out << "\t\t" << "VkImageToMemoryCopyEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryToImageCopyEXT(std::ostream &out, const VkMemoryToImageCopyEXT* structInfo, Decoded_VkMemoryToImageCopyEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string image_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                     &structInfo->imageSubresource,
                                                                                     metaInfo->imageSubresource,
                                                                                     consumer);
    std::string image_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->imageOffset,
                                                                  metaInfo->imageOffset,
                                                                  consumer);
    std::string image_extent_info_var = GenerateStruct_VkExtent3D(out,
                                                                  &structInfo->imageExtent,
                                                                  metaInfo->imageExtent,
                                                                  consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pHostPointer
    struct_body << "\t\t\t" << structInfo->pHostPointer << "," << std::endl;
// memoryRowLength
    struct_body << "\t\t\t" << structInfo->memoryRowLength << "," << std::endl;
// memoryImageHeight
    struct_body << "\t\t\t" << structInfo->memoryImageHeight << "," << std::endl;
// imageSubresource
    struct_body << "\t\t\t" << image_subresource_info_var << "," << std::endl;
// imageOffset
    struct_body << "\t\t\t" << image_offset_info_var << "," << std::endl;
// imageExtent
    struct_body << "\t\t\t" << image_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryToImageCopyEXT");
    out << "\t\t" << "VkMemoryToImageCopyEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceHostImageCopyFeaturesEXT(std::ostream &out, const VkPhysicalDeviceHostImageCopyFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceHostImageCopyFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// hostImageCopy
    struct_body << "\t\t\t" << structInfo->hostImageCopy << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceHostImageCopyFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceHostImageCopyFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceHostImageCopyPropertiesEXT(std::ostream &out, const VkPhysicalDeviceHostImageCopyPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceHostImageCopyPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcopy_src_layouts_array = "NULL";
    if (structInfo->pCopySrcLayouts != NULL) {
        std::string pcopy_src_layouts_values;
        for (uint32_t idx = 0; idx < structInfo->copySrcLayoutCount; idx++) {
            pcopy_src_layouts_values += util::ToString<VkImageLayout>(structInfo->pCopySrcLayouts[idx]) + ", ";
        }
        pcopy_src_layouts_array = "pCopySrcLayouts_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkImageLayout " << pcopy_src_layouts_array << "[] = {" << pcopy_src_layouts_values << "};" << std::endl;
    }
    std::string pcopy_dst_layouts_array = "NULL";
    if (structInfo->pCopyDstLayouts != NULL) {
        std::string pcopy_dst_layouts_values;
        for (uint32_t idx = 0; idx < structInfo->copyDstLayoutCount; idx++) {
            pcopy_dst_layouts_values += util::ToString<VkImageLayout>(structInfo->pCopyDstLayouts[idx]) + ", ";
        }
        pcopy_dst_layouts_array = "pCopyDstLayouts_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkImageLayout " << pcopy_dst_layouts_array << "[] = {" << pcopy_dst_layouts_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// copySrcLayoutCount
    struct_body << "\t\t\t" << structInfo->copySrcLayoutCount << "," << std::endl;
// pCopySrcLayouts
    struct_body << "\t\t\t" << pcopy_src_layouts_array << "," << std::endl;
// copyDstLayoutCount
    struct_body << "\t\t\t" << structInfo->copyDstLayoutCount << "," << std::endl;
// pCopyDstLayouts
    struct_body << "\t\t\t" << pcopy_dst_layouts_array << "," << std::endl;
// optimalTilingLayoutUUID
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->optimalTilingLayoutUUID[0]), VK_UUID_SIZE) << "," << std::endl;
// identicalMemoryTypeRequirements
    struct_body << "\t\t\t" << structInfo->identicalMemoryTypeRequirements << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceHostImageCopyPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceHostImageCopyPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubresourceHostMemcpySizeEXT(std::ostream &out, const VkSubresourceHostMemcpySizeEXT* structInfo, Decoded_VkSubresourceHostMemcpySizeEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subresourceHostMemcpySizeEXT");
    out << "\t\t" << "VkSubresourceHostMemcpySizeEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderBufferFloat16Atomics
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat16Atomics << "," << std::endl;
// shaderBufferFloat16AtomicAdd
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat16AtomicAdd << "," << std::endl;
// shaderBufferFloat16AtomicMinMax
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat16AtomicMinMax << "," << std::endl;
// shaderBufferFloat32AtomicMinMax
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat32AtomicMinMax << "," << std::endl;
// shaderBufferFloat64AtomicMinMax
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat64AtomicMinMax << "," << std::endl;
// shaderSharedFloat16Atomics
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat16Atomics << "," << std::endl;
// shaderSharedFloat16AtomicAdd
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat16AtomicAdd << "," << std::endl;
// shaderSharedFloat16AtomicMinMax
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat16AtomicMinMax << "," << std::endl;
// shaderSharedFloat32AtomicMinMax
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat32AtomicMinMax << "," << std::endl;
// shaderSharedFloat64AtomicMinMax
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat64AtomicMinMax << "," << std::endl;
// shaderImageFloat32AtomicMinMax
    struct_body << "\t\t\t" << structInfo->shaderImageFloat32AtomicMinMax << "," << std::endl;
// sparseImageFloat32AtomicMinMax
    struct_body << "\t\t\t" << structInfo->sparseImageFloat32AtomicMinMax << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderAtomicFloat2FeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfacePresentModeCompatibilityEXT(std::ostream &out, const VkSurfacePresentModeCompatibilityEXT* structInfo, Decoded_VkSurfacePresentModeCompatibilityEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppresent_modes_array = "NULL";
    if (structInfo->pPresentModes != NULL) {
        std::string ppresent_modes_values;
        for (uint32_t idx = 0; idx < structInfo->presentModeCount; idx++) {
            ppresent_modes_values += util::ToString<VkPresentModeKHR>(structInfo->pPresentModes[idx]) + ", ";
        }
        ppresent_modes_array = "pPresentModes_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkPresentModeKHR " << ppresent_modes_array << "[] = {" << ppresent_modes_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// presentModeCount
    struct_body << "\t\t\t" << structInfo->presentModeCount << "," << std::endl;
// pPresentModes
    struct_body << "\t\t\t" << ppresent_modes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfacePresentModeCompatibilityEXT");
    out << "\t\t" << "VkSurfacePresentModeCompatibilityEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfacePresentModeEXT(std::ostream &out, const VkSurfacePresentModeEXT* structInfo, Decoded_VkSurfacePresentModeEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// presentMode
    struct_body << "\t\t\t" << "VkPresentModeKHR(" << structInfo->presentMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfacePresentModeEXT");
    out << "\t\t" << "VkSurfacePresentModeEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfacePresentScalingCapabilitiesEXT(std::ostream &out, const VkSurfacePresentScalingCapabilitiesEXT* structInfo, Decoded_VkSurfacePresentScalingCapabilitiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string min_scaled_image_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                             &structInfo->minScaledImageExtent,
                                                                             metaInfo->minScaledImageExtent,
                                                                             consumer);
    std::string max_scaled_image_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                             &structInfo->maxScaledImageExtent,
                                                                             metaInfo->maxScaledImageExtent,
                                                                             consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// supportedPresentScaling
    struct_body << "\t\t\t" << "VkPresentScalingFlagsEXT(" << structInfo->supportedPresentScaling << ")" << "," << std::endl;
// supportedPresentGravityX
    struct_body << "\t\t\t" << "VkPresentGravityFlagsEXT(" << structInfo->supportedPresentGravityX << ")" << "," << std::endl;
// supportedPresentGravityY
    struct_body << "\t\t\t" << "VkPresentGravityFlagsEXT(" << structInfo->supportedPresentGravityY << ")" << "," << std::endl;
// minScaledImageExtent
    struct_body << "\t\t\t" << min_scaled_image_extent_info_var << "," << std::endl;
// maxScaledImageExtent
    struct_body << "\t\t\t" << max_scaled_image_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfacePresentScalingCapabilitiesEXT");
    out << "\t\t" << "VkSurfacePresentScalingCapabilitiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT(std::ostream &out, const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// swapchainMaintenance1
    struct_body << "\t\t\t" << structInfo->swapchainMaintenance1 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSwapchainMaintenance1FeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkReleaseSwapchainImagesInfoEXT(std::ostream &out, const VkReleaseSwapchainImagesInfoEXT* structInfo, Decoded_VkReleaseSwapchainImagesInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pimage_indices_array = "NULL";
    if (structInfo->pImageIndices != NULL) {
        pimage_indices_array = "pImageIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pimage_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pImageIndices, structInfo->imageIndexCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// swapchain
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->swapchain) << "," << std::endl;
// imageIndexCount
    struct_body << "\t\t\t" << structInfo->imageIndexCount << "," << std::endl;
// pImageIndices
    struct_body << "\t\t\t" << pimage_indices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "releaseSwapchainImagesInfoEXT");
    out << "\t\t" << "VkReleaseSwapchainImagesInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainPresentFenceInfoEXT(std::ostream &out, const VkSwapchainPresentFenceInfoEXT* structInfo, Decoded_VkSwapchainPresentFenceInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pfences_array = "NULL";
    if (metaInfo->pFences.GetPointer() != NULL && structInfo->swapchainCount > 0) {
        pfences_array = "pfences_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_FENCE));
        std::string pfences_values = toStringJoin(metaInfo->pFences.GetPointer(),
                                                  metaInfo->pFences.GetPointer() + structInfo->swapchainCount,
                                                  [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                  ", ");
        if (structInfo->swapchainCount == 1) {
            pfences_array = "&" + pfences_values;
        } else if (structInfo->swapchainCount > 1) {
            out << "\t\t" << "VkFence " << pfences_array << "[] = {" << pfences_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// swapchainCount
    struct_body << "\t\t\t" << structInfo->swapchainCount << "," << std::endl;
// pFences
    struct_body << "\t\t\t" << pfences_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainPresentFenceInfoEXT");
    out << "\t\t" << "VkSwapchainPresentFenceInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainPresentModeInfoEXT(std::ostream &out, const VkSwapchainPresentModeInfoEXT* structInfo, Decoded_VkSwapchainPresentModeInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppresent_modes_values;
    std::string ppresent_modes_array = "NULL";
    if (structInfo->pPresentModes != NULL) {
        for (uint32_t idx = 0; idx < structInfo->swapchainCount; idx++) {
            ppresent_modes_values += util::ToString<VkPresentModeKHR>(structInfo->pPresentModes[idx]) + ", ";
        }
        ppresent_modes_array = "pPresentModes_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkPresentModeKHR " << ppresent_modes_array << "[] = {" << ppresent_modes_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// swapchainCount
    struct_body << "\t\t\t" << structInfo->swapchainCount << "," << std::endl;
// pPresentModes
    struct_body << "\t\t\t" << ppresent_modes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainPresentModeInfoEXT");
    out << "\t\t" << "VkSwapchainPresentModeInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainPresentModesCreateInfoEXT(std::ostream &out, const VkSwapchainPresentModesCreateInfoEXT* structInfo, Decoded_VkSwapchainPresentModesCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppresent_modes_values;
    std::string ppresent_modes_array = "NULL";
    if (structInfo->pPresentModes != NULL) {
        for (uint32_t idx = 0; idx < structInfo->presentModeCount; idx++) {
            ppresent_modes_values += util::ToString<VkPresentModeKHR>(structInfo->pPresentModes[idx]) + ", ";
        }
        ppresent_modes_array = "pPresentModes_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkPresentModeKHR " << ppresent_modes_array << "[] = {" << ppresent_modes_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// presentModeCount
    struct_body << "\t\t\t" << structInfo->presentModeCount << "," << std::endl;
// pPresentModes
    struct_body << "\t\t\t" << ppresent_modes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainPresentModesCreateInfoEXT");
    out << "\t\t" << "VkSwapchainPresentModesCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainPresentScalingCreateInfoEXT(std::ostream &out, const VkSwapchainPresentScalingCreateInfoEXT* structInfo, Decoded_VkSwapchainPresentScalingCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// scalingBehavior
    struct_body << "\t\t\t" << "VkPresentScalingFlagsEXT(" << structInfo->scalingBehavior << ")" << "," << std::endl;
// presentGravityX
    struct_body << "\t\t\t" << "VkPresentGravityFlagsEXT(" << structInfo->presentGravityX << ")" << "," << std::endl;
// presentGravityY
    struct_body << "\t\t\t" << "VkPresentGravityFlagsEXT(" << structInfo->presentGravityY << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainPresentScalingCreateInfoEXT");
    out << "\t\t" << "VkSwapchainPresentScalingCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindIndexBufferIndirectCommandNV(std::ostream &out, const VkBindIndexBufferIndirectCommandNV* structInfo, Decoded_VkBindIndexBufferIndirectCommandNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// bufferAddress
    struct_body << "\t" << structInfo->bufferAddress << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "," << std::endl;
// indexType
    struct_body << "\t\t\t" << "VkIndexType(" << structInfo->indexType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindIndexBufferIndirectCommandNV");
    out << "\t\t" << "VkBindIndexBufferIndirectCommandNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindShaderGroupIndirectCommandNV(std::ostream &out, const VkBindShaderGroupIndirectCommandNV* structInfo, Decoded_VkBindShaderGroupIndirectCommandNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// groupIndex
    struct_body << "\t" << structInfo->groupIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindShaderGroupIndirectCommandNV");
    out << "\t\t" << "VkBindShaderGroupIndirectCommandNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindVertexBufferIndirectCommandNV(std::ostream &out, const VkBindVertexBufferIndirectCommandNV* structInfo, Decoded_VkBindVertexBufferIndirectCommandNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// bufferAddress
    struct_body << "\t" << structInfo->bufferAddress << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "," << std::endl;
// stride
    struct_body << "\t\t\t" << structInfo->stride << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindVertexBufferIndirectCommandNV");
    out << "\t\t" << "VkBindVertexBufferIndirectCommandNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeneratedCommandsInfoNV(std::ostream &out, const VkGeneratedCommandsInfoNV* structInfo, Decoded_VkGeneratedCommandsInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstreams_array = "NULL";
    if (structInfo->pStreams != NULL) {
        pstreams_array = "pStreams_" + std::to_string(consumer.GetNextId());
        std::string pstreams_names;
        for (uint32_t idx = 0; idx < structInfo->streamCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStreams + idx != NULL) {
                variable_name = GenerateStruct_VkIndirectCommandsStreamNV(out,
                                                                          structInfo->pStreams + idx,
                                                                          metaInfo->pStreams->GetMetaStructPointer() + idx,
                                                                          consumer);
            }
            pstreams_names += variable_name + ", ";
        }
        out << "\t\t" << "VkIndirectCommandsStreamNV " << pstreams_array << "[] = {" << pstreams_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pipelineBindPoint
    struct_body << "\t\t\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
// pipeline
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipeline) << "," << std::endl;
// indirectCommandsLayout
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->indirectCommandsLayout) << "," << std::endl;
// streamCount
    struct_body << "\t\t\t" << structInfo->streamCount << "," << std::endl;
// pStreams
    struct_body << "\t\t\t" << pstreams_array << "," << std::endl;
// sequencesCount
    struct_body << "\t\t\t" << structInfo->sequencesCount << "," << std::endl;
// preprocessBuffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->preprocessBuffer) << "," << std::endl;
// preprocessOffset
    struct_body << "\t\t\t" << structInfo->preprocessOffset << "UL" << "," << std::endl;
// preprocessSize
    struct_body << "\t\t\t" << structInfo->preprocessSize << "UL" << "," << std::endl;
// sequencesCountBuffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->sequencesCountBuffer) << "," << std::endl;
// sequencesCountOffset
    struct_body << "\t\t\t" << structInfo->sequencesCountOffset << "UL" << "," << std::endl;
// sequencesIndexBuffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->sequencesIndexBuffer) << "," << std::endl;
// sequencesIndexOffset
    struct_body << "\t\t\t" << structInfo->sequencesIndexOffset << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "generatedCommandsInfoNV");
    out << "\t\t" << "VkGeneratedCommandsInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeneratedCommandsMemoryRequirementsInfoNV(std::ostream &out, const VkGeneratedCommandsMemoryRequirementsInfoNV* structInfo, Decoded_VkGeneratedCommandsMemoryRequirementsInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pipelineBindPoint
    struct_body << "\t\t\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
// pipeline
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipeline) << "," << std::endl;
// indirectCommandsLayout
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->indirectCommandsLayout) << "," << std::endl;
// maxSequencesCount
    struct_body << "\t\t\t" << structInfo->maxSequencesCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "generatedCommandsMemoryRequirementsInfoNV");
    out << "\t\t" << "VkGeneratedCommandsMemoryRequirementsInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGraphicsPipelineShaderGroupsCreateInfoNV(std::ostream &out, const VkGraphicsPipelineShaderGroupsCreateInfoNV* structInfo, Decoded_VkGraphicsPipelineShaderGroupsCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pgroups_array = "NULL";
    if (structInfo->pGroups != NULL) {
        pgroups_array = "pGroups_" + std::to_string(consumer.GetNextId());
        std::string pgroups_names;
        for (uint32_t idx = 0; idx < structInfo->groupCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pGroups + idx != NULL) {
                variable_name = GenerateStruct_VkGraphicsShaderGroupCreateInfoNV(out,
                                                                                 structInfo->pGroups + idx,
                                                                                 metaInfo->pGroups->GetMetaStructPointer() + idx,
                                                                                 consumer);
            }
            pgroups_names += variable_name + ", ";
        }
        out << "\t\t" << "VkGraphicsShaderGroupCreateInfoNV " << pgroups_array << "[] = {" << pgroups_names << "};" << std::endl;
    }
    std::string ppipelines_array = "NULL";
    if (metaInfo->pPipelines.GetPointer() != NULL && structInfo->pipelineCount > 0) {
        ppipelines_array = "ppipelines_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_PIPELINE));
        std::string ppipelines_values = toStringJoin(metaInfo->pPipelines.GetPointer(),
                                                     metaInfo->pPipelines.GetPointer() + structInfo->pipelineCount,
                                                     [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                     ", ");
        if (structInfo->pipelineCount == 1) {
            ppipelines_array = "&" + ppipelines_values;
        } else if (structInfo->pipelineCount > 1) {
            out << "\t\t" << "VkPipeline " << ppipelines_array << "[] = {" << ppipelines_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// groupCount
    struct_body << "\t\t\t" << structInfo->groupCount << "," << std::endl;
// pGroups
    struct_body << "\t\t\t" << pgroups_array << "," << std::endl;
// pipelineCount
    struct_body << "\t\t\t" << structInfo->pipelineCount << "," << std::endl;
// pPipelines
    struct_body << "\t\t\t" << ppipelines_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "graphicsPipelineShaderGroupsCreateInfoNV");
    out << "\t\t" << "VkGraphicsPipelineShaderGroupsCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGraphicsShaderGroupCreateInfoNV(std::ostream &out, const VkGraphicsShaderGroupCreateInfoNV* structInfo, Decoded_VkGraphicsShaderGroupCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstages_array = "NULL";
    if (structInfo->pStages != NULL) {
        pstages_array = "pStages_" + std::to_string(consumer.GetNextId());
        std::string pstages_names;
        for (uint32_t idx = 0; idx < structInfo->stageCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStages + idx != NULL) {
                variable_name = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                                               structInfo->pStages + idx,
                                                                               metaInfo->pStages->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pstages_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPipelineShaderStageCreateInfo " << pstages_array << "[] = {" << pstages_names << "};" << std::endl;
    }
    std::string pvertex_input_state_struct = "NULL";
    if (structInfo->pVertexInputState != NULL) {
        pvertex_input_state_struct = GenerateStruct_VkPipelineVertexInputStateCreateInfo(out,
                                                                                         structInfo->pVertexInputState,
                                                                                         metaInfo->pVertexInputState->GetMetaStructPointer(),
                                                                                         consumer);
        pvertex_input_state_struct.insert(0, "&");
    }
    std::string ptessellation_state_struct = "NULL";
    if (structInfo->pTessellationState != NULL) {
        ptessellation_state_struct = GenerateStruct_VkPipelineTessellationStateCreateInfo(out,
                                                                                          structInfo->pTessellationState,
                                                                                          metaInfo->pTessellationState->GetMetaStructPointer(),
                                                                                          consumer);
        ptessellation_state_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stageCount
    struct_body << "\t\t\t" << structInfo->stageCount << "," << std::endl;
// pStages
    struct_body << "\t\t\t" << pstages_array << "," << std::endl;
// pVertexInputState
    struct_body << "\t\t\t" << pvertex_input_state_struct << "," << std::endl;
// pTessellationState
    struct_body << "\t\t\t" << ptessellation_state_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "graphicsShaderGroupCreateInfoNV");
    out << "\t\t" << "VkGraphicsShaderGroupCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIndirectCommandsLayoutCreateInfoNV(std::ostream &out, const VkIndirectCommandsLayoutCreateInfoNV* structInfo, Decoded_VkIndirectCommandsLayoutCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ptokens_array = "NULL";
    if (structInfo->pTokens != NULL) {
        ptokens_array = "pTokens_" + std::to_string(consumer.GetNextId());
        std::string ptokens_names;
        for (uint32_t idx = 0; idx < structInfo->tokenCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pTokens + idx != NULL) {
                variable_name = GenerateStruct_VkIndirectCommandsLayoutTokenNV(out,
                                                                               structInfo->pTokens + idx,
                                                                               metaInfo->pTokens->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            ptokens_names += variable_name + ", ";
        }
        out << "\t\t" << "VkIndirectCommandsLayoutTokenNV " << ptokens_array << "[] = {" << ptokens_names << "};" << std::endl;
    }
    std::string pstream_strides_array = "NULL";
    if (structInfo->pStreamStrides != NULL) {
        pstream_strides_array = "pStreamStrides_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pstream_strides_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pStreamStrides, structInfo->streamCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkIndirectCommandsLayoutUsageFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
// pipelineBindPoint
    struct_body << "\t\t\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
// tokenCount
    struct_body << "\t\t\t" << structInfo->tokenCount << "," << std::endl;
// pTokens
    struct_body << "\t\t\t" << ptokens_array << "," << std::endl;
// streamCount
    struct_body << "\t\t\t" << structInfo->streamCount << "," << std::endl;
// pStreamStrides
    struct_body << "\t\t\t" << pstream_strides_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "indirectCommandsLayoutCreateInfoNV");
    out << "\t\t" << "VkIndirectCommandsLayoutCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIndirectCommandsLayoutTokenNV(std::ostream &out, const VkIndirectCommandsLayoutTokenNV* structInfo, Decoded_VkIndirectCommandsLayoutTokenNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pindex_types_values;
    std::string pindex_types_array = "NULL";
    if (structInfo->pIndexTypes != NULL) {
        for (uint32_t idx = 0; idx < structInfo->indexTypeCount; idx++) {
            pindex_types_values += util::ToString<VkIndexType>(structInfo->pIndexTypes[idx]) + ", ";
        }
        pindex_types_array = "pIndexTypes_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkIndexType " << pindex_types_array << "[] = {" << pindex_types_values << "};" << std::endl;
    }
    std::string pindex_type_values_array = "NULL";
    if (structInfo->pIndexTypeValues != NULL) {
        pindex_type_values_array = "pIndexTypeValues_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pindex_type_values_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pIndexTypeValues, structInfo->indexTypeCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// tokenType
    struct_body << "\t\t\t" << "VkIndirectCommandsTokenTypeNV(" << structInfo->tokenType << ")" << "," << std::endl;
// stream
    struct_body << "\t\t\t" << structInfo->stream << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << "," << std::endl;
// vertexBindingUnit
    struct_body << "\t\t\t" << structInfo->vertexBindingUnit << "," << std::endl;
// vertexDynamicStride
    struct_body << "\t\t\t" << structInfo->vertexDynamicStride << "," << std::endl;
// pushconstantPipelineLayout
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pushconstantPipelineLayout) << "," << std::endl;
// pushconstantShaderStageFlags
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->pushconstantShaderStageFlags << ")" << "," << std::endl;
// pushconstantOffset
    struct_body << "\t\t\t" << structInfo->pushconstantOffset << "," << std::endl;
// pushconstantSize
    struct_body << "\t\t\t" << structInfo->pushconstantSize << "," << std::endl;
// indirectStateFlags
    struct_body << "\t\t\t" << "VkIndirectStateFlagsNV(" << structInfo->indirectStateFlags << ")" << "," << std::endl;
// indexTypeCount
    struct_body << "\t\t\t" << structInfo->indexTypeCount << "," << std::endl;
// pIndexTypes
    struct_body << "\t\t\t" << pindex_types_array << "," << std::endl;
// pIndexTypeValues
    struct_body << "\t\t\t" << pindex_type_values_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "indirectCommandsLayoutTokenNV");
    out << "\t\t" << "VkIndirectCommandsLayoutTokenNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIndirectCommandsStreamNV(std::ostream &out, const VkIndirectCommandsStreamNV* structInfo, Decoded_VkIndirectCommandsStreamNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// buffer
    struct_body << "\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "indirectCommandsStreamNV");
    out << "\t\t" << "VkIndirectCommandsStreamNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(std::ostream &out, const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceGeneratedCommands
    struct_body << "\t\t\t" << structInfo->deviceGeneratedCommands << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDeviceGeneratedCommandsFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(std::ostream &out, const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* structInfo, Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxGraphicsShaderGroupCount
    struct_body << "\t\t\t" << structInfo->maxGraphicsShaderGroupCount << "," << std::endl;
// maxIndirectSequenceCount
    struct_body << "\t\t\t" << structInfo->maxIndirectSequenceCount << "," << std::endl;
// maxIndirectCommandsTokenCount
    struct_body << "\t\t\t" << structInfo->maxIndirectCommandsTokenCount << "," << std::endl;
// maxIndirectCommandsStreamCount
    struct_body << "\t\t\t" << structInfo->maxIndirectCommandsStreamCount << "," << std::endl;
// maxIndirectCommandsTokenOffset
    struct_body << "\t\t\t" << structInfo->maxIndirectCommandsTokenOffset << "," << std::endl;
// maxIndirectCommandsStreamStride
    struct_body << "\t\t\t" << structInfo->maxIndirectCommandsStreamStride << "," << std::endl;
// minSequencesCountBufferOffsetAlignment
    struct_body << "\t\t\t" << structInfo->minSequencesCountBufferOffsetAlignment << "," << std::endl;
// minSequencesIndexBufferOffsetAlignment
    struct_body << "\t\t\t" << structInfo->minSequencesIndexBufferOffsetAlignment << "," << std::endl;
// minIndirectCommandsBufferOffsetAlignment
    struct_body << "\t\t\t" << structInfo->minIndirectCommandsBufferOffsetAlignment << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDeviceGeneratedCommandsPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSetStateFlagsIndirectCommandNV(std::ostream &out, const VkSetStateFlagsIndirectCommandNV* structInfo, Decoded_VkSetStateFlagsIndirectCommandNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// data
    struct_body << "\t" << structInfo->data << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "setStateFlagsIndirectCommandNV");
    out << "\t\t" << "VkSetStateFlagsIndirectCommandNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferInheritanceViewportScissorInfoNV(std::ostream &out, const VkCommandBufferInheritanceViewportScissorInfoNV* structInfo, Decoded_VkCommandBufferInheritanceViewportScissorInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pviewport_depths_struct = "NULL";
    if (structInfo->pViewportDepths != NULL) {
        pviewport_depths_struct = GenerateStruct_VkViewport(out,
                                                            structInfo->pViewportDepths,
                                                            metaInfo->pViewportDepths->GetMetaStructPointer(),
                                                            consumer);
        pviewport_depths_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// viewportScissor2D
    struct_body << "\t\t\t" << structInfo->viewportScissor2D << "," << std::endl;
// viewportDepthCount
    struct_body << "\t\t\t" << structInfo->viewportDepthCount << "," << std::endl;
// pViewportDepths
    struct_body << "\t\t\t" << pviewport_depths_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferInheritanceViewportScissorInfoNV");
    out << "\t\t" << "VkCommandBufferInheritanceViewportScissorInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceInheritedViewportScissorFeaturesNV(std::ostream &out, const VkPhysicalDeviceInheritedViewportScissorFeaturesNV* structInfo, Decoded_VkPhysicalDeviceInheritedViewportScissorFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// inheritedViewportScissor2D
    struct_body << "\t\t\t" << structInfo->inheritedViewportScissor2D << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceInheritedViewportScissorFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceInheritedViewportScissorFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(std::ostream &out, const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// texelBufferAlignment
    struct_body << "\t\t\t" << structInfo->texelBufferAlignment << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTexelBufferAlignmentFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(std::ostream &out, const VkCommandBufferInheritanceRenderPassTransformInfoQCOM* structInfo, Decoded_VkCommandBufferInheritanceRenderPassTransformInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string render_area_info_var = GenerateStruct_VkRect2D(out,
                                                               &structInfo->renderArea,
                                                               metaInfo->renderArea,
                                                               consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// transform
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->transform << ")" << "," << std::endl;
// renderArea
    struct_body << "\t\t\t" << render_area_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferInheritanceRenderPassTransformInfoQCOM");
    out << "\t\t" << "VkCommandBufferInheritanceRenderPassTransformInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassTransformBeginInfoQCOM(std::ostream &out, const VkRenderPassTransformBeginInfoQCOM* structInfo, Decoded_VkRenderPassTransformBeginInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// transform
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->transform << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassTransformBeginInfoQCOM");
    out << "\t\t" << "VkRenderPassTransformBeginInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDepthBiasInfoEXT(std::ostream &out, const VkDepthBiasInfoEXT* structInfo, Decoded_VkDepthBiasInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// depthBiasConstantFactor
    struct_body << "\t\t\t" << structInfo->depthBiasConstantFactor << "," << std::endl;
// depthBiasClamp
    struct_body << "\t\t\t" << structInfo->depthBiasClamp << "," << std::endl;
// depthBiasSlopeFactor
    struct_body << "\t\t\t" << structInfo->depthBiasSlopeFactor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "depthBiasInfoEXT");
    out << "\t\t" << "VkDepthBiasInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDepthBiasRepresentationInfoEXT(std::ostream &out, const VkDepthBiasRepresentationInfoEXT* structInfo, Decoded_VkDepthBiasRepresentationInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// depthBiasRepresentation
    struct_body << "\t\t\t" << "VkDepthBiasRepresentationEXT(" << structInfo->depthBiasRepresentation << ")" << "," << std::endl;
// depthBiasExact
    struct_body << "\t\t\t" << structInfo->depthBiasExact << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "depthBiasRepresentationInfoEXT");
    out << "\t\t" << "VkDepthBiasRepresentationInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDepthBiasControlFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDepthBiasControlFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDepthBiasControlFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// depthBiasControl
    struct_body << "\t\t\t" << structInfo->depthBiasControl << "," << std::endl;
// leastRepresentableValueForceUnormRepresentation
    struct_body << "\t\t\t" << structInfo->leastRepresentableValueForceUnormRepresentation << "," << std::endl;
// floatRepresentation
    struct_body << "\t\t\t" << structInfo->floatRepresentation << "," << std::endl;
// depthBiasExact
    struct_body << "\t\t\t" << structInfo->depthBiasExact << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDepthBiasControlFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceDepthBiasControlFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceDeviceMemoryReportCreateInfoEXT(std::ostream &out, const VkDeviceDeviceMemoryReportCreateInfoEXT* structInfo, Decoded_VkDeviceDeviceMemoryReportCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDeviceMemoryReportFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// pfnUserCallback
    struct_body << "\t\t\t" << structInfo->pfnUserCallback << "," << std::endl;
// pUserData
    out << "\t\t" << "// TODO: Support pUserData (output?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "deviceDeviceMemoryReportCreateInfoEXT");
    out << "\t\t" << "VkDeviceDeviceMemoryReportCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceMemoryReportCallbackDataEXT(std::ostream &out, const VkDeviceMemoryReportCallbackDataEXT* structInfo, Decoded_VkDeviceMemoryReportCallbackDataEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDeviceMemoryReportFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// type
    struct_body << "\t\t\t" << "VkDeviceMemoryReportEventTypeEXT(" << structInfo->type << ")" << "," << std::endl;
// memoryObjectId
    struct_body << "\t\t\t" << structInfo->memoryObjectId << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
// objectType
    struct_body << "\t\t\t" << "VkObjectType(" << structInfo->objectType << ")" << "," << std::endl;
// objectHandle
    struct_body << "\t\t\t" << structInfo->objectHandle << "UL" << "," << std::endl;
// heapIndex
    struct_body << "\t\t\t" << structInfo->heapIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceMemoryReportCallbackDataEXT");
    out << "\t\t" << "VkDeviceMemoryReportCallbackDataEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceMemoryReport
    struct_body << "\t\t\t" << structInfo->deviceMemoryReport << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDeviceMemoryReportFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceDeviceMemoryReportFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRobustness2FeaturesEXT(std::ostream &out, const VkPhysicalDeviceRobustness2FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceRobustness2FeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// robustBufferAccess2
    struct_body << "\t\t\t" << structInfo->robustBufferAccess2 << "," << std::endl;
// robustImageAccess2
    struct_body << "\t\t\t" << structInfo->robustImageAccess2 << "," << std::endl;
// nullDescriptor
    struct_body << "\t\t\t" << structInfo->nullDescriptor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRobustness2FeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceRobustness2FeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRobustness2PropertiesEXT(std::ostream &out, const VkPhysicalDeviceRobustness2PropertiesEXT* structInfo, Decoded_VkPhysicalDeviceRobustness2PropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// robustStorageBufferAccessSizeAlignment
    struct_body << "\t\t\t" << structInfo->robustStorageBufferAccessSizeAlignment << "UL" << "," << std::endl;
// robustUniformBufferAccessSizeAlignment
    struct_body << "\t\t\t" << structInfo->robustUniformBufferAccessSizeAlignment << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRobustness2PropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceRobustness2PropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCustomBorderColorFeaturesEXT(std::ostream &out, const VkPhysicalDeviceCustomBorderColorFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceCustomBorderColorFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// customBorderColors
    struct_body << "\t\t\t" << structInfo->customBorderColors << "," << std::endl;
// customBorderColorWithoutFormat
    struct_body << "\t\t\t" << structInfo->customBorderColorWithoutFormat << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCustomBorderColorFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceCustomBorderColorFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCustomBorderColorPropertiesEXT(std::ostream &out, const VkPhysicalDeviceCustomBorderColorPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceCustomBorderColorPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxCustomBorderColorSamplers
    struct_body << "\t\t\t" << structInfo->maxCustomBorderColorSamplers << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCustomBorderColorPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceCustomBorderColorPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerCustomBorderColorCreateInfoEXT(std::ostream &out, const VkSamplerCustomBorderColorCreateInfoEXT* structInfo, Decoded_VkSamplerCustomBorderColorCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// customBorderColor
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(structInfo->customBorderColor) << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerCustomBorderColorCreateInfoEXT");
    out << "\t\t" << "VkSamplerCustomBorderColorCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePresentBarrierFeaturesNV(std::ostream &out, const VkPhysicalDevicePresentBarrierFeaturesNV* structInfo, Decoded_VkPhysicalDevicePresentBarrierFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// presentBarrier
    struct_body << "\t\t\t" << structInfo->presentBarrier << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePresentBarrierFeaturesNV");
    out << "\t\t" << "VkPhysicalDevicePresentBarrierFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceCapabilitiesPresentBarrierNV(std::ostream &out, const VkSurfaceCapabilitiesPresentBarrierNV* structInfo, Decoded_VkSurfaceCapabilitiesPresentBarrierNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// presentBarrierSupported
    struct_body << "\t\t\t" << structInfo->presentBarrierSupported << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceCapabilitiesPresentBarrierNV");
    out << "\t\t" << "VkSurfaceCapabilitiesPresentBarrierNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainPresentBarrierCreateInfoNV(std::ostream &out, const VkSwapchainPresentBarrierCreateInfoNV* structInfo, Decoded_VkSwapchainPresentBarrierCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// presentBarrierEnable
    struct_body << "\t\t\t" << structInfo->presentBarrierEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainPresentBarrierCreateInfoNV");
    out << "\t\t" << "VkSwapchainPresentBarrierCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceDiagnosticsConfigCreateInfoNV(std::ostream &out, const VkDeviceDiagnosticsConfigCreateInfoNV* structInfo, Decoded_VkDeviceDiagnosticsConfigCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDeviceDiagnosticsConfigFlagsNV(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceDiagnosticsConfigCreateInfoNV");
    out << "\t\t" << "VkDeviceDiagnosticsConfigCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(std::ostream &out, const VkPhysicalDeviceDiagnosticsConfigFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDiagnosticsConfigFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// diagnosticsConfig
    struct_body << "\t\t\t" << structInfo->diagnosticsConfig << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDiagnosticsConfigFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceDiagnosticsConfigFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueryLowLatencySupportNV(std::ostream &out, const VkQueryLowLatencySupportNV* structInfo, Decoded_VkQueryLowLatencySupportNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pQueriedLowLatencyData
    out << "\t\t" << "// TODO: Support pQueriedLowLatencyData (output?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "queryLowLatencySupportNV");
    out << "\t\t" << "VkQueryLowLatencySupportNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGraphicsPipelineLibraryCreateInfoEXT(std::ostream &out, const VkGraphicsPipelineLibraryCreateInfoEXT* structInfo, Decoded_VkGraphicsPipelineLibraryCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkGraphicsPipelineLibraryFlagsEXT(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "graphicsPipelineLibraryCreateInfoEXT");
    out << "\t\t" << "VkGraphicsPipelineLibraryCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(std::ostream &out, const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// graphicsPipelineLibrary
    struct_body << "\t\t\t" << structInfo->graphicsPipelineLibrary << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceGraphicsPipelineLibraryFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(std::ostream &out, const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// graphicsPipelineLibraryFastLinking
    struct_body << "\t\t\t" << structInfo->graphicsPipelineLibraryFastLinking << "," << std::endl;
// graphicsPipelineLibraryIndependentInterpolationDecoration
    struct_body << "\t\t\t" << structInfo->graphicsPipelineLibraryIndependentInterpolationDecoration << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceGraphicsPipelineLibraryPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(std::ostream &out, const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* structInfo, Decoded_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderEarlyAndLateFragmentTests
    struct_body << "\t\t\t" << structInfo->shaderEarlyAndLateFragmentTests << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD");
    out << "\t\t" << "VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(std::ostream &out, const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fragmentShadingRateEnums
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateEnums << "," << std::endl;
// supersampleFragmentShadingRates
    struct_body << "\t\t\t" << structInfo->supersampleFragmentShadingRates << "," << std::endl;
// noInvocationFragmentShadingRates
    struct_body << "\t\t\t" << structInfo->noInvocationFragmentShadingRates << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShadingRateEnumsFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(std::ostream &out, const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxFragmentShadingRateInvocationCount
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->maxFragmentShadingRateInvocationCount << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShadingRateEnumsPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(std::ostream &out, const VkPipelineFragmentShadingRateEnumStateCreateInfoNV* structInfo, Decoded_VkPipelineFragmentShadingRateEnumStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shadingRateType
    struct_body << "\t\t\t" << "VkFragmentShadingRateTypeNV(" << structInfo->shadingRateType << ")" << "," << std::endl;
// shadingRate
    struct_body << "\t\t\t" << "VkFragmentShadingRateNV(" << structInfo->shadingRate << ")" << "," << std::endl;
// combinerOps
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkFragmentShadingRateCombinerOpKHR*>(&structInfo->combinerOps[0]), 2) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineFragmentShadingRateEnumStateCreateInfoNV");
    out << "\t\t" << "VkPipelineFragmentShadingRateEnumStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureGeometryMotionTrianglesDataNV(std::ostream &out, const VkAccelerationStructureGeometryMotionTrianglesDataNV* structInfo, Decoded_VkAccelerationStructureGeometryMotionTrianglesDataNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// vertexData
    struct_body << "\t\t\t" << structInfo->vertexData.deviceAddress << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureGeometryMotionTrianglesDataNV");
    out << "\t\t" << "VkAccelerationStructureGeometryMotionTrianglesDataNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureMatrixMotionInstanceNV(std::ostream &out, const VkAccelerationStructureMatrixMotionInstanceNV* structInfo, Decoded_VkAccelerationStructureMatrixMotionInstanceNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string transform_t0_info_var = GenerateStruct_VkTransformMatrixKHR(out,
                                                                            &structInfo->transformT0,
                                                                            metaInfo->transformT0,
                                                                            consumer);
    std::string transform_t1_info_var = GenerateStruct_VkTransformMatrixKHR(out,
                                                                            &structInfo->transformT1,
                                                                            metaInfo->transformT1,
                                                                            consumer);
// transformT0
    struct_body << "\t" << transform_t0_info_var << "," << std::endl;
// transformT1
    struct_body << "\t\t\t" << transform_t1_info_var << "," << std::endl;
// instanceCustomIndex
    struct_body << "\t\t\t" << structInfo->instanceCustomIndex << "," << std::endl;
// mask
    struct_body << "\t\t\t" << structInfo->mask << "," << std::endl;
// instanceShaderBindingTableRecordOffset
    struct_body << "\t\t\t" << structInfo->instanceShaderBindingTableRecordOffset << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkGeometryInstanceFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// accelerationStructureReference
    struct_body << "\t\t\t" << structInfo->accelerationStructureReference << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureMatrixMotionInstanceNV");
    out << "\t\t" << "VkAccelerationStructureMatrixMotionInstanceNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureMotionInfoNV(std::ostream &out, const VkAccelerationStructureMotionInfoNV* structInfo, Decoded_VkAccelerationStructureMotionInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxInstances
    struct_body << "\t\t\t" << structInfo->maxInstances << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkAccelerationStructureMotionInfoFlagsNV(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureMotionInfoNV");
    out << "\t\t" << "VkAccelerationStructureMotionInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureSRTMotionInstanceNV(std::ostream &out, const VkAccelerationStructureSRTMotionInstanceNV* structInfo, Decoded_VkAccelerationStructureSRTMotionInstanceNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string transform_t0_info_var = GenerateStruct_VkSRTDataNV(out,
                                                                   &structInfo->transformT0,
                                                                   metaInfo->transformT0,
                                                                   consumer);
    std::string transform_t1_info_var = GenerateStruct_VkSRTDataNV(out,
                                                                   &structInfo->transformT1,
                                                                   metaInfo->transformT1,
                                                                   consumer);
// transformT0
    struct_body << "\t" << transform_t0_info_var << "," << std::endl;
// transformT1
    struct_body << "\t\t\t" << transform_t1_info_var << "," << std::endl;
// instanceCustomIndex
    struct_body << "\t\t\t" << structInfo->instanceCustomIndex << "," << std::endl;
// mask
    struct_body << "\t\t\t" << structInfo->mask << "," << std::endl;
// instanceShaderBindingTableRecordOffset
    struct_body << "\t\t\t" << structInfo->instanceShaderBindingTableRecordOffset << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkGeometryInstanceFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// accelerationStructureReference
    struct_body << "\t\t\t" << structInfo->accelerationStructureReference << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureSRTMotionInstanceNV");
    out << "\t\t" << "VkAccelerationStructureSRTMotionInstanceNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(std::ostream &out, const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* structInfo, Decoded_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// rayTracingMotionBlur
    struct_body << "\t\t\t" << structInfo->rayTracingMotionBlur << "," << std::endl;
// rayTracingMotionBlurPipelineTraceRaysIndirect
    struct_body << "\t\t\t" << structInfo->rayTracingMotionBlurPipelineTraceRaysIndirect << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingMotionBlurFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceRayTracingMotionBlurFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSRTDataNV(std::ostream &out, const VkSRTDataNV* structInfo, Decoded_VkSRTDataNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// sx
    struct_body << "\t" << structInfo->sx << "," << std::endl;
// a
    struct_body << "\t\t\t" << structInfo->a << "," << std::endl;
// b
    struct_body << "\t\t\t" << structInfo->b << "," << std::endl;
// pvx
    struct_body << "\t\t\t" << structInfo->pvx << "," << std::endl;
// sy
    struct_body << "\t\t\t" << structInfo->sy << "," << std::endl;
// c
    struct_body << "\t\t\t" << structInfo->c << "," << std::endl;
// pvy
    struct_body << "\t\t\t" << structInfo->pvy << "," << std::endl;
// sz
    struct_body << "\t\t\t" << structInfo->sz << "," << std::endl;
// pvz
    struct_body << "\t\t\t" << structInfo->pvz << "," << std::endl;
// qx
    struct_body << "\t\t\t" << structInfo->qx << "," << std::endl;
// qy
    struct_body << "\t\t\t" << structInfo->qy << "," << std::endl;
// qz
    struct_body << "\t\t\t" << structInfo->qz << "," << std::endl;
// qw
    struct_body << "\t\t\t" << structInfo->qw << "," << std::endl;
// tx
    struct_body << "\t\t\t" << structInfo->tx << "," << std::endl;
// ty
    struct_body << "\t\t\t" << structInfo->ty << "," << std::endl;
// tz
    struct_body << "\t\t\t" << structInfo->tz << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sRTDataNV");
    out << "\t\t" << "VkSRTDataNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(std::ostream &out, const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// ycbcr2plane444Formats
    struct_body << "\t\t\t" << structInfo->ycbcr2plane444Formats << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceYcbcr2Plane444FormatsFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(std::ostream &out, const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fragmentDensityMapDeferred
    struct_body << "\t\t\t" << structInfo->fragmentDensityMapDeferred << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentDensityMap2FeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceFragmentDensityMap2FeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(std::ostream &out, const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// subsampledLoads
    struct_body << "\t\t\t" << structInfo->subsampledLoads << "," << std::endl;
// subsampledCoarseReconstructionEarlyAccess
    struct_body << "\t\t\t" << structInfo->subsampledCoarseReconstructionEarlyAccess << "," << std::endl;
// maxSubsampledArrayLayers
    struct_body << "\t\t\t" << structInfo->maxSubsampledArrayLayers << "," << std::endl;
// maxDescriptorSetSubsampledSamplers
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetSubsampledSamplers << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentDensityMap2PropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceFragmentDensityMap2PropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyCommandTransformInfoQCOM(std::ostream &out, const VkCopyCommandTransformInfoQCOM* structInfo, Decoded_VkCopyCommandTransformInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// transform
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->transform << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyCommandTransformInfoQCOM");
    out << "\t\t" << "VkCopyCommandTransformInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageCompressionControlEXT(std::ostream &out, const VkImageCompressionControlEXT* structInfo, Decoded_VkImageCompressionControlEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pfixed_rate_flags_array = "NULL";
    if (structInfo->pFixedRateFlags != NULL) {
        std::string pfixed_rate_flags_values;
        for (uint32_t idx = 0; idx < structInfo->compressionControlPlaneCount; idx++) {
            pfixed_rate_flags_values += util::ToString<VkImageCompressionFixedRateFlagsEXT>(structInfo->pFixedRateFlags[idx]) + ", ";
        }
        pfixed_rate_flags_array = "pFixedRateFlags_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkImageCompressionFixedRateFlagsEXT " << pfixed_rate_flags_array << "[] = {" << pfixed_rate_flags_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkImageCompressionFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// compressionControlPlaneCount
    struct_body << "\t\t\t" << structInfo->compressionControlPlaneCount << "," << std::endl;
// pFixedRateFlags
    struct_body << "\t\t\t" << pfixed_rate_flags_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageCompressionControlEXT");
    out << "\t\t" << "VkImageCompressionControlEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageCompressionPropertiesEXT(std::ostream &out, const VkImageCompressionPropertiesEXT* structInfo, Decoded_VkImageCompressionPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// imageCompressionFlags
    struct_body << "\t\t\t" << "VkImageCompressionFlagsEXT(" << structInfo->imageCompressionFlags << ")" << "," << std::endl;
// imageCompressionFixedRateFlags
    struct_body << "\t\t\t" << "VkImageCompressionFixedRateFlagsEXT(" << structInfo->imageCompressionFixedRateFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageCompressionPropertiesEXT");
    out << "\t\t" << "VkImageCompressionPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageCompressionControlFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImageCompressionControlFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImageCompressionControlFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// imageCompressionControl
    struct_body << "\t\t\t" << structInfo->imageCompressionControl << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageCompressionControlFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceImageCompressionControlFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(std::ostream &out, const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// attachmentFeedbackLoopLayout
    struct_body << "\t\t\t" << structInfo->attachmentFeedbackLoopLayout << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevice4444FormatsFeaturesEXT(std::ostream &out, const VkPhysicalDevice4444FormatsFeaturesEXT* structInfo, Decoded_VkPhysicalDevice4444FormatsFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// formatA4R4G4B4
    struct_body << "\t\t\t" << structInfo->formatA4R4G4B4 << "," << std::endl;
// formatA4B4G4R4
    struct_body << "\t\t\t" << structInfo->formatA4B4G4R4 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevice4444FormatsFeaturesEXT");
    out << "\t\t" << "VkPhysicalDevice4444FormatsFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceFaultAddressInfoEXT(std::ostream &out, const VkDeviceFaultAddressInfoEXT* structInfo, Decoded_VkDeviceFaultAddressInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// addressType
    struct_body << "\t" << "VkDeviceFaultAddressTypeEXT(" << structInfo->addressType << ")" << "," << std::endl;
// reportedAddress
    struct_body << "\t\t\t" << structInfo->reportedAddress << "UL" << "," << std::endl;
// addressPrecision
    struct_body << "\t\t\t" << structInfo->addressPrecision << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceFaultAddressInfoEXT");
    out << "\t\t" << "VkDeviceFaultAddressInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceFaultCountsEXT(std::ostream &out, const VkDeviceFaultCountsEXT* structInfo, Decoded_VkDeviceFaultCountsEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// addressInfoCount
    struct_body << "\t\t\t" << structInfo->addressInfoCount << "," << std::endl;
// vendorInfoCount
    struct_body << "\t\t\t" << structInfo->vendorInfoCount << "," << std::endl;
// vendorBinarySize
    struct_body << "\t\t\t" << structInfo->vendorBinarySize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceFaultCountsEXT");
    out << "\t\t" << "VkDeviceFaultCountsEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceFaultInfoEXT(std::ostream &out, const VkDeviceFaultInfoEXT* structInfo, Decoded_VkDeviceFaultInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// description
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << "," << std::endl;
// pAddressInfos
    out << "\t\t" << "// TODO: Support pAddressInfos (output?) argument." << std::endl;
// pVendorInfos
    out << "\t\t" << "// TODO: Support pVendorInfos (output?) argument." << std::endl;
// pVendorBinaryData
    out << "\t\t" << "// TODO: Support pVendorBinaryData (output?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "deviceFaultInfoEXT");
    out << "\t\t" << "VkDeviceFaultInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceFaultVendorBinaryHeaderVersionOneEXT(std::ostream &out, const VkDeviceFaultVendorBinaryHeaderVersionOneEXT* structInfo, Decoded_VkDeviceFaultVendorBinaryHeaderVersionOneEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// headerSize
    struct_body << "\t" << structInfo->headerSize << "," << std::endl;
// headerVersion
    struct_body << "\t\t\t" << "VkDeviceFaultVendorBinaryHeaderVersionEXT(" << structInfo->headerVersion << ")" << "," << std::endl;
// vendorID
    struct_body << "\t\t\t" << structInfo->vendorID << "," << std::endl;
// deviceID
    struct_body << "\t\t\t" << structInfo->deviceID << "," << std::endl;
// driverVersion
    struct_body << "\t\t\t" << structInfo->driverVersion << "," << std::endl;
// pipelineCacheUUID
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->pipelineCacheUUID[0]), VK_UUID_SIZE) << "," << std::endl;
// applicationNameOffset
    struct_body << "\t\t\t" << structInfo->applicationNameOffset << "," << std::endl;
// applicationVersion
    struct_body << "\t\t\t" << structInfo->applicationVersion << "," << std::endl;
// engineNameOffset
    struct_body << "\t\t\t" << structInfo->engineNameOffset << "," << std::endl;
// engineVersion
    struct_body << "\t\t\t" << structInfo->engineVersion << "," << std::endl;
// apiVersion
    struct_body << "\t\t\t" << structInfo->apiVersion << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceFaultVendorBinaryHeaderVersionOneEXT");
    out << "\t\t" << "VkDeviceFaultVendorBinaryHeaderVersionOneEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceFaultVendorInfoEXT(std::ostream &out, const VkDeviceFaultVendorInfoEXT* structInfo, Decoded_VkDeviceFaultVendorInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// description
    struct_body << "\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << "," << std::endl;
// vendorFaultCode
    struct_body << "\t\t\t" << structInfo->vendorFaultCode << "UL" << "," << std::endl;
// vendorFaultData
    struct_body << "\t\t\t" << structInfo->vendorFaultData << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceFaultVendorInfoEXT");
    out << "\t\t" << "VkDeviceFaultVendorInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFaultFeaturesEXT(std::ostream &out, const VkPhysicalDeviceFaultFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFaultFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceFault
    struct_body << "\t\t\t" << structInfo->deviceFault << "," << std::endl;
// deviceFaultVendorBinary
    struct_body << "\t\t\t" << structInfo->deviceFaultVendorBinary << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFaultFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceFaultFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(std::ostream &out, const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// rasterizationOrderColorAttachmentAccess
    struct_body << "\t\t\t" << structInfo->rasterizationOrderColorAttachmentAccess << "," << std::endl;
// rasterizationOrderDepthAttachmentAccess
    struct_body << "\t\t\t" << structInfo->rasterizationOrderDepthAttachmentAccess << "," << std::endl;
// rasterizationOrderStencilAttachmentAccess
    struct_body << "\t\t\t" << structInfo->rasterizationOrderStencilAttachmentAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(std::ostream &out, const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// formatRgba10x6WithoutYCbCrSampler
    struct_body << "\t\t\t" << structInfo->formatRgba10x6WithoutYCbCrSampler << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRGBA10X6FormatsFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDirectFBSurfaceCreateInfoEXT(std::ostream &out, const VkDirectFBSurfaceCreateInfoEXT* structInfo, Decoded_VkDirectFBSurfaceCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDirectFBSurfaceCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// dfb
    struct_body << "\t\t\t" << structInfo->dfb << "," << std::endl;
// surface
    struct_body << "\t\t\t" << structInfo->surface << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "directFBSurfaceCreateInfoEXT");
    out << "\t\t" << "VkDirectFBSurfaceCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMutableDescriptorTypeCreateInfoEXT(std::ostream &out, const VkMutableDescriptorTypeCreateInfoEXT* structInfo, Decoded_VkMutableDescriptorTypeCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pmutable_descriptor_type_lists_array = "NULL";
    if (structInfo->pMutableDescriptorTypeLists != NULL) {
        pmutable_descriptor_type_lists_array = "pMutableDescriptorTypeLists_" + std::to_string(consumer.GetNextId());
        std::string pmutable_descriptor_type_lists_names;
        for (uint32_t idx = 0; idx < structInfo->mutableDescriptorTypeListCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pMutableDescriptorTypeLists + idx != NULL) {
                variable_name = GenerateStruct_VkMutableDescriptorTypeListEXT(out,
                                                                              structInfo->pMutableDescriptorTypeLists + idx,
                                                                              metaInfo->pMutableDescriptorTypeLists->GetMetaStructPointer() + idx,
                                                                              consumer);
            }
            pmutable_descriptor_type_lists_names += variable_name + ", ";
        }
        out << "\t\t" << "VkMutableDescriptorTypeListEXT " << pmutable_descriptor_type_lists_array << "[] = {" << pmutable_descriptor_type_lists_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// mutableDescriptorTypeListCount
    struct_body << "\t\t\t" << structInfo->mutableDescriptorTypeListCount << "," << std::endl;
// pMutableDescriptorTypeLists
    struct_body << "\t\t\t" << pmutable_descriptor_type_lists_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "mutableDescriptorTypeCreateInfoEXT");
    out << "\t\t" << "VkMutableDescriptorTypeCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMutableDescriptorTypeListEXT(std::ostream &out, const VkMutableDescriptorTypeListEXT* structInfo, Decoded_VkMutableDescriptorTypeListEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pdescriptor_types_values;
    std::string pdescriptor_types_array = "NULL";
    if (structInfo->pDescriptorTypes != NULL) {
        for (uint32_t idx = 0; idx < structInfo->descriptorTypeCount; idx++) {
            pdescriptor_types_values += util::ToString<VkDescriptorType>(structInfo->pDescriptorTypes[idx]) + ", ";
        }
        pdescriptor_types_array = "pDescriptorTypes_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkDescriptorType " << pdescriptor_types_array << "[] = {" << pdescriptor_types_values << "};" << std::endl;
    }
// descriptorTypeCount
    struct_body << "\t" << structInfo->descriptorTypeCount << "," << std::endl;
// pDescriptorTypes
    struct_body << "\t\t\t" << pdescriptor_types_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "mutableDescriptorTypeListEXT");
    out << "\t\t" << "VkMutableDescriptorTypeListEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// mutableDescriptorType
    struct_body << "\t\t\t" << structInfo->mutableDescriptorType << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMutableDescriptorTypeFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(std::ostream &out, const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// vertexInputDynamicState
    struct_body << "\t\t\t" << structInfo->vertexInputDynamicState << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVertexInputDynamicStateFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVertexInputAttributeDescription2EXT(std::ostream &out, const VkVertexInputAttributeDescription2EXT* structInfo, Decoded_VkVertexInputAttributeDescription2EXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// location
    struct_body << "\t\t\t" << structInfo->location << "," << std::endl;
// binding
    struct_body << "\t\t\t" << structInfo->binding << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "vertexInputAttributeDescription2EXT");
    out << "\t\t" << "VkVertexInputAttributeDescription2EXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVertexInputBindingDescription2EXT(std::ostream &out, const VkVertexInputBindingDescription2EXT* structInfo, Decoded_VkVertexInputBindingDescription2EXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// binding
    struct_body << "\t\t\t" << structInfo->binding << "," << std::endl;
// stride
    struct_body << "\t\t\t" << structInfo->stride << "," << std::endl;
// inputRate
    struct_body << "\t\t\t" << "VkVertexInputRate(" << structInfo->inputRate << ")" << "," << std::endl;
// divisor
    struct_body << "\t\t\t" << structInfo->divisor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "vertexInputBindingDescription2EXT");
    out << "\t\t" << "VkVertexInputBindingDescription2EXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDrmPropertiesEXT(std::ostream &out, const VkPhysicalDeviceDrmPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceDrmPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// hasPrimary
    struct_body << "\t\t\t" << structInfo->hasPrimary << "," << std::endl;
// hasRender
    struct_body << "\t\t\t" << structInfo->hasRender << "," << std::endl;
// primaryMajor
    struct_body << "\t\t\t" << structInfo->primaryMajor << "," << std::endl;
// primaryMinor
    struct_body << "\t\t\t" << structInfo->primaryMinor << "," << std::endl;
// renderMajor
    struct_body << "\t\t\t" << structInfo->renderMajor << "," << std::endl;
// renderMinor
    struct_body << "\t\t\t" << structInfo->renderMinor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDrmPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceDrmPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceAddressBindingCallbackDataEXT(std::ostream &out, const VkDeviceAddressBindingCallbackDataEXT* structInfo, Decoded_VkDeviceAddressBindingCallbackDataEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDeviceAddressBindingFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// baseAddress
    struct_body << "\t\t\t" << structInfo->baseAddress << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
// bindingType
    struct_body << "\t\t\t" << "VkDeviceAddressBindingTypeEXT(" << structInfo->bindingType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceAddressBindingCallbackDataEXT");
    out << "\t\t" << "VkDeviceAddressBindingCallbackDataEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceAddressBindingReportFeaturesEXT(std::ostream &out, const VkPhysicalDeviceAddressBindingReportFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceAddressBindingReportFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// reportAddressBinding
    struct_body << "\t\t\t" << structInfo->reportAddressBinding << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceAddressBindingReportFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceAddressBindingReportFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDepthClipControlFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDepthClipControlFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDepthClipControlFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// depthClipControl
    struct_body << "\t\t\t" << structInfo->depthClipControl << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDepthClipControlFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceDepthClipControlFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportDepthClipControlCreateInfoEXT(std::ostream &out, const VkPipelineViewportDepthClipControlCreateInfoEXT* structInfo, Decoded_VkPipelineViewportDepthClipControlCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// negativeOneToOne
    struct_body << "\t\t\t" << structInfo->negativeOneToOne << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportDepthClipControlCreateInfoEXT");
    out << "\t\t" << "VkPipelineViewportDepthClipControlCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(std::ostream &out, const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// primitiveTopologyListRestart
    struct_body << "\t\t\t" << structInfo->primitiveTopologyListRestart << "," << std::endl;
// primitiveTopologyPatchListRestart
    struct_body << "\t\t\t" << structInfo->primitiveTopologyPatchListRestart << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePrimitiveTopologyListRestartFeaturesEXT");
    out << "\t\t" << "VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportMemoryZirconHandleInfoFUCHSIA(std::ostream &out, const VkImportMemoryZirconHandleInfoFUCHSIA* structInfo, Decoded_VkImportMemoryZirconHandleInfoFUCHSIA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
// handle
    struct_body << "\t\t\t" << structInfo->handle << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importMemoryZirconHandleInfoFUCHSIA");
    out << "\t\t" << "VkImportMemoryZirconHandleInfoFUCHSIA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryGetZirconHandleInfoFUCHSIA(std::ostream &out, const VkMemoryGetZirconHandleInfoFUCHSIA* structInfo, Decoded_VkMemoryGetZirconHandleInfoFUCHSIA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryGetZirconHandleInfoFUCHSIA");
    out << "\t\t" << "VkMemoryGetZirconHandleInfoFUCHSIA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryZirconHandlePropertiesFUCHSIA(std::ostream &out, const VkMemoryZirconHandlePropertiesFUCHSIA* structInfo, Decoded_VkMemoryZirconHandlePropertiesFUCHSIA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memoryTypeBits
    struct_body << "\t\t\t" << structInfo->memoryTypeBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryZirconHandlePropertiesFUCHSIA");
    out << "\t\t" << "VkMemoryZirconHandlePropertiesFUCHSIA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportSemaphoreZirconHandleInfoFUCHSIA(std::ostream &out, const VkImportSemaphoreZirconHandleInfoFUCHSIA* structInfo, Decoded_VkImportSemaphoreZirconHandleInfoFUCHSIA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// semaphore
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkSemaphoreImportFlags(" << structInfo->flags << ")" << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
// zirconHandle
    struct_body << "\t\t\t" << structInfo->zirconHandle << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importSemaphoreZirconHandleInfoFUCHSIA");
    out << "\t\t" << "VkImportSemaphoreZirconHandleInfoFUCHSIA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreGetZirconHandleInfoFUCHSIA(std::ostream &out, const VkSemaphoreGetZirconHandleInfoFUCHSIA* structInfo, Decoded_VkSemaphoreGetZirconHandleInfoFUCHSIA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// semaphore
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreGetZirconHandleInfoFUCHSIA");
    out << "\t\t" << "VkSemaphoreGetZirconHandleInfoFUCHSIA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(std::ostream &out, const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* structInfo, Decoded_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// invocationMask
    struct_body << "\t\t\t" << structInfo->invocationMask << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceInvocationMaskFeaturesHUAWEI");
    out << "\t\t" << "VkPhysicalDeviceInvocationMaskFeaturesHUAWEI " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryGetRemoteAddressInfoNV(std::ostream &out, const VkMemoryGetRemoteAddressInfoNV* structInfo, Decoded_VkMemoryGetRemoteAddressInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// memory
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
// handleType
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryGetRemoteAddressInfoNV");
    out << "\t\t" << "VkMemoryGetRemoteAddressInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(std::ostream &out, const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* structInfo, Decoded_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// externalMemoryRDMA
    struct_body << "\t\t\t" << structInfo->externalMemoryRDMA << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalMemoryRDMAFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceExternalMemoryRDMAFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFrameBoundaryEXT(std::ostream &out, const VkFrameBoundaryEXT* structInfo, Decoded_VkFrameBoundaryEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pimages_array = "NULL";
    if (metaInfo->pImages.GetPointer() != NULL && structInfo->imageCount > 0) {
        pimages_array = "pimages_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_IMAGE));
        std::string pimages_values = toStringJoin(metaInfo->pImages.GetPointer(),
                                                  metaInfo->pImages.GetPointer() + structInfo->imageCount,
                                                  [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                  ", ");
        if (structInfo->imageCount == 1) {
            pimages_array = "&" + pimages_values;
        } else if (structInfo->imageCount > 1) {
            out << "\t\t" << "VkImage " << pimages_array << "[] = {" << pimages_values << "};" << std::endl;
        }
    }
    std::string pbuffers_array = "NULL";
    if (metaInfo->pBuffers.GetPointer() != NULL && structInfo->bufferCount > 0) {
        pbuffers_array = "pbuffers_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_BUFFER));
        std::string pbuffers_values = toStringJoin(metaInfo->pBuffers.GetPointer(),
                                                   metaInfo->pBuffers.GetPointer() + structInfo->bufferCount,
                                                   [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                   ", ");
        if (structInfo->bufferCount == 1) {
            pbuffers_array = "&" + pbuffers_values;
        } else if (structInfo->bufferCount > 1) {
            out << "\t\t" << "VkBuffer " << pbuffers_array << "[] = {" << pbuffers_values << "};" << std::endl;
        }
    }
    std::string ptag_array = "NULL";
    if (structInfo->pTag != NULL) {
        std::string ptag_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->tagSize; ++idx0) {
            ptag_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pTag)[idx0]) + ", ";
        }
        ptag_array = "pTag_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << ptag_array << "[] = {" << ptag_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkFrameBoundaryFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// frameID
    struct_body << "\t\t\t" << structInfo->frameID << "UL" << "," << std::endl;
// imageCount
    struct_body << "\t\t\t" << structInfo->imageCount << "," << std::endl;
// pImages
    struct_body << "\t\t\t" << pimages_array << "," << std::endl;
// bufferCount
    struct_body << "\t\t\t" << structInfo->bufferCount << "," << std::endl;
// pBuffers
    struct_body << "\t\t\t" << pbuffers_array << "," << std::endl;
// tagName
    struct_body << "\t\t\t" << structInfo->tagName << "UL" << "," << std::endl;
// tagSize
    struct_body << "\t\t\t" << structInfo->tagSize << "," << std::endl;
// pTag
    struct_body << "\t\t\t" << ptag_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "frameBoundaryEXT");
    out << "\t\t" << "VkFrameBoundaryEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFrameBoundaryFeaturesEXT(std::ostream &out, const VkPhysicalDeviceFrameBoundaryFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFrameBoundaryFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// frameBoundary
    struct_body << "\t\t\t" << structInfo->frameBoundary << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFrameBoundaryFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceFrameBoundaryFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMultisampledRenderToSingleSampledInfoEXT(std::ostream &out, const VkMultisampledRenderToSingleSampledInfoEXT* structInfo, Decoded_VkMultisampledRenderToSingleSampledInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// multisampledRenderToSingleSampledEnable
    struct_body << "\t\t\t" << structInfo->multisampledRenderToSingleSampledEnable << "," << std::endl;
// rasterizationSamples
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->rasterizationSamples << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "multisampledRenderToSingleSampledInfoEXT");
    out << "\t\t" << "VkMultisampledRenderToSingleSampledInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// multisampledRenderToSingleSampled
    struct_body << "\t\t\t" << structInfo->multisampledRenderToSingleSampled << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultisampledRenderToSingleSampledFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassResolvePerformanceQueryEXT(std::ostream &out, const VkSubpassResolvePerformanceQueryEXT* structInfo, Decoded_VkSubpassResolvePerformanceQueryEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// optimal
    struct_body << "\t\t\t" << structInfo->optimal << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassResolvePerformanceQueryEXT");
    out << "\t\t" << "VkSubpassResolvePerformanceQueryEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(std::ostream &out, const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// extendedDynamicState2
    struct_body << "\t\t\t" << structInfo->extendedDynamicState2 << "," << std::endl;
// extendedDynamicState2LogicOp
    struct_body << "\t\t\t" << structInfo->extendedDynamicState2LogicOp << "," << std::endl;
// extendedDynamicState2PatchControlPoints
    struct_body << "\t\t\t" << structInfo->extendedDynamicState2PatchControlPoints << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExtendedDynamicState2FeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceExtendedDynamicState2FeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkScreenSurfaceCreateInfoQNX(std::ostream &out, const VkScreenSurfaceCreateInfoQNX* structInfo, Decoded_VkScreenSurfaceCreateInfoQNX* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkScreenSurfaceCreateFlagsQNX(" << structInfo->flags << ")" << "," << std::endl;
// context
    struct_body << "\t\t\t" << structInfo->context << "," << std::endl;
// window
    struct_body << "\t\t\t" << structInfo->window << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "screenSurfaceCreateInfoQNX");
    out << "\t\t" << "VkScreenSurfaceCreateInfoQNX " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceColorWriteEnableFeaturesEXT(std::ostream &out, const VkPhysicalDeviceColorWriteEnableFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceColorWriteEnableFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// colorWriteEnable
    struct_body << "\t\t\t" << structInfo->colorWriteEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceColorWriteEnableFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceColorWriteEnableFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineColorWriteCreateInfoEXT(std::ostream &out, const VkPipelineColorWriteCreateInfoEXT* structInfo, Decoded_VkPipelineColorWriteCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcolor_write_enables_array = "NULL";
    if (structInfo->pColorWriteEnables != NULL) {
        std::string pcolor_write_enables_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->attachmentCount; ++idx0) {
            pcolor_write_enables_values += std::to_string(structInfo->pColorWriteEnables[idx0]) + ", ";
        }
        pcolor_write_enables_array = "pColorWriteEnables_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkBool32 " << pcolor_write_enables_array << "[] = {" << pcolor_write_enables_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// attachmentCount
    struct_body << "\t\t\t" << structInfo->attachmentCount << "," << std::endl;
// pColorWriteEnables
    struct_body << "\t\t\t" << pcolor_write_enables_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineColorWriteCreateInfoEXT");
    out << "\t\t" << "VkPipelineColorWriteCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(std::ostream &out, const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// primitivesGeneratedQuery
    struct_body << "\t\t\t" << structInfo->primitivesGeneratedQuery << "," << std::endl;
// primitivesGeneratedQueryWithRasterizerDiscard
    struct_body << "\t\t\t" << structInfo->primitivesGeneratedQueryWithRasterizerDiscard << "," << std::endl;
// primitivesGeneratedQueryWithNonZeroStreams
    struct_body << "\t\t\t" << structInfo->primitivesGeneratedQueryWithNonZeroStreams << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePrimitivesGeneratedQueryFeaturesEXT");
    out << "\t\t" << "VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewMinLodCreateInfoEXT(std::ostream &out, const VkImageViewMinLodCreateInfoEXT* structInfo, Decoded_VkImageViewMinLodCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// minLod
    struct_body << "\t\t\t" << structInfo->minLod << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewMinLodCreateInfoEXT");
    out << "\t\t" << "VkImageViewMinLodCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageViewMinLodFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImageViewMinLodFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImageViewMinLodFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// minLod
    struct_body << "\t\t\t" << structInfo->minLod << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageViewMinLodFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceImageViewMinLodFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMultiDrawIndexedInfoEXT(std::ostream &out, const VkMultiDrawIndexedInfoEXT* structInfo, Decoded_VkMultiDrawIndexedInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// firstIndex
    struct_body << "\t" << structInfo->firstIndex << "," << std::endl;
// indexCount
    struct_body << "\t\t\t" << structInfo->indexCount << "," << std::endl;
// vertexOffset
    struct_body << "\t\t\t" << structInfo->vertexOffset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "multiDrawIndexedInfoEXT");
    out << "\t\t" << "VkMultiDrawIndexedInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMultiDrawInfoEXT(std::ostream &out, const VkMultiDrawInfoEXT* structInfo, Decoded_VkMultiDrawInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// firstVertex
    struct_body << "\t" << structInfo->firstVertex << "," << std::endl;
// vertexCount
    struct_body << "\t\t\t" << structInfo->vertexCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "multiDrawInfoEXT");
    out << "\t\t" << "VkMultiDrawInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultiDrawFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMultiDrawFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMultiDrawFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// multiDraw
    struct_body << "\t\t\t" << structInfo->multiDraw << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultiDrawFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceMultiDrawFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultiDrawPropertiesEXT(std::ostream &out, const VkPhysicalDeviceMultiDrawPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceMultiDrawPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxMultiDrawCount
    struct_body << "\t\t\t" << structInfo->maxMultiDrawCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultiDrawPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceMultiDrawPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// image2DViewOf3D
    struct_body << "\t\t\t" << structInfo->image2DViewOf3D << "," << std::endl;
// sampler2DViewOf3D
    struct_body << "\t\t\t" << structInfo->sampler2DViewOf3D << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImage2DViewOf3DFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceImage2DViewOf3DFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderTileImageFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderTileImageFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderTileImageFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderTileImageColorReadAccess
    struct_body << "\t\t\t" << structInfo->shaderTileImageColorReadAccess << "," << std::endl;
// shaderTileImageDepthReadAccess
    struct_body << "\t\t\t" << structInfo->shaderTileImageDepthReadAccess << "," << std::endl;
// shaderTileImageStencilReadAccess
    struct_body << "\t\t\t" << structInfo->shaderTileImageStencilReadAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderTileImageFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderTileImageFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderTileImagePropertiesEXT(std::ostream &out, const VkPhysicalDeviceShaderTileImagePropertiesEXT* structInfo, Decoded_VkPhysicalDeviceShaderTileImagePropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderTileImageCoherentReadAccelerated
    struct_body << "\t\t\t" << structInfo->shaderTileImageCoherentReadAccelerated << "," << std::endl;
// shaderTileImageReadSampleFromPixelRateInvocation
    struct_body << "\t\t\t" << structInfo->shaderTileImageReadSampleFromPixelRateInvocation << "," << std::endl;
// shaderTileImageReadFromHelperInvocation
    struct_body << "\t\t\t" << structInfo->shaderTileImageReadFromHelperInvocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderTileImagePropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderTileImagePropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureTrianglesOpacityMicromapEXT(std::ostream &out, const VkAccelerationStructureTrianglesOpacityMicromapEXT* structInfo, Decoded_VkAccelerationStructureTrianglesOpacityMicromapEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pusage_counts_array = "NULL";
    if (structInfo->pUsageCounts != NULL) {
        pusage_counts_array = "pUsageCounts_" + std::to_string(consumer.GetNextId());
        std::string pusage_counts_names;
        for (uint32_t idx = 0; idx < structInfo->usageCountsCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pUsageCounts + idx != NULL) {
                variable_name = GenerateStruct_VkMicromapUsageEXT(out,
                                                                  structInfo->pUsageCounts + idx,
                                                                  metaInfo->pUsageCounts->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pusage_counts_names += variable_name + ", ";
        }
        out << "\t\t" << "VkMicromapUsageEXT " << pusage_counts_array << "[] = {" << pusage_counts_names << "};" << std::endl;
    }
    std::string pp_usage_counts_array = "NULL";
    if (structInfo->ppUsageCounts != NULL) {
        pp_usage_counts_array = "ppUsageCounts_" + std::to_string(consumer.GetNextId());
        std::string pp_usage_counts_names;
        for (uint32_t idx0 = 0; idx0 < structInfo->usageCountsCount; ++idx0) {
            for (uint32_t idx1 = 0; idx1 < 1; ++idx1) {
                std::string variable_name = "NULL";
                variable_name = GenerateStruct_VkMicromapUsageEXT(out,
                                                                  &(structInfo->ppUsageCounts[idx0][idx1]),
                                                                  &(metaInfo->ppUsageCounts->GetMetaStructPointer()[idx0][idx1]),
                                                                  consumer);
                pp_usage_counts_names += variable_name + ", ";
            }
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// indexType
    struct_body << "\t\t\t" << "VkIndexType(" << structInfo->indexType << ")" << "," << std::endl;
// indexBuffer
    struct_body << "\t\t\t" << structInfo->indexBuffer.deviceAddress << "," << std::endl;
// indexStride
    struct_body << "\t\t\t" << structInfo->indexStride << "UL" << "," << std::endl;
// baseTriangle
    struct_body << "\t\t\t" << structInfo->baseTriangle << "," << std::endl;
// usageCountsCount
    struct_body << "\t\t\t" << structInfo->usageCountsCount << "," << std::endl;
// pUsageCounts
    struct_body << "\t\t\t" << pusage_counts_array << "," << std::endl;
// ppUsageCounts
    struct_body << "\t\t\t" << pp_usage_counts_array << "," << std::endl;
// micromap
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->micromap) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureTrianglesOpacityMicromapEXT");
    out << "\t\t" << "VkAccelerationStructureTrianglesOpacityMicromapEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyMemoryToMicromapInfoEXT(std::ostream &out, const VkCopyMemoryToMicromapInfoEXT* structInfo, Decoded_VkCopyMemoryToMicromapInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// src
    struct_body << "\t\t\t" << structInfo->src.deviceAddress << "," << std::endl;
// dst
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dst) << "," << std::endl;
// mode
    struct_body << "\t\t\t" << "VkCopyMicromapModeEXT(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyMemoryToMicromapInfoEXT");
    out << "\t\t" << "VkCopyMemoryToMicromapInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyMicromapInfoEXT(std::ostream &out, const VkCopyMicromapInfoEXT* structInfo, Decoded_VkCopyMicromapInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// src
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->src) << "," << std::endl;
// dst
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dst) << "," << std::endl;
// mode
    struct_body << "\t\t\t" << "VkCopyMicromapModeEXT(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyMicromapInfoEXT");
    out << "\t\t" << "VkCopyMicromapInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyMicromapToMemoryInfoEXT(std::ostream &out, const VkCopyMicromapToMemoryInfoEXT* structInfo, Decoded_VkCopyMicromapToMemoryInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// src
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->src) << "," << std::endl;
// dst
    struct_body << "\t\t\t" << structInfo->dst.deviceAddress << "," << std::endl;
// mode
    struct_body << "\t\t\t" << "VkCopyMicromapModeEXT(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyMicromapToMemoryInfoEXT");
    out << "\t\t" << "VkCopyMicromapToMemoryInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMicromapBuildInfoEXT(std::ostream &out, const VkMicromapBuildInfoEXT* structInfo, Decoded_VkMicromapBuildInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pusage_counts_array = "NULL";
    if (structInfo->pUsageCounts != NULL) {
        pusage_counts_array = "pUsageCounts_" + std::to_string(consumer.GetNextId());
        std::string pusage_counts_names;
        for (uint32_t idx = 0; idx < structInfo->usageCountsCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pUsageCounts + idx != NULL) {
                variable_name = GenerateStruct_VkMicromapUsageEXT(out,
                                                                  structInfo->pUsageCounts + idx,
                                                                  metaInfo->pUsageCounts->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pusage_counts_names += variable_name + ", ";
        }
        out << "\t\t" << "VkMicromapUsageEXT " << pusage_counts_array << "[] = {" << pusage_counts_names << "};" << std::endl;
    }
    std::string pp_usage_counts_array = "NULL";
    if (structInfo->ppUsageCounts != NULL) {
        pp_usage_counts_array = "ppUsageCounts_" + std::to_string(consumer.GetNextId());
        std::string pp_usage_counts_names;
        for (uint32_t idx0 = 0; idx0 < structInfo->usageCountsCount; ++idx0) {
            for (uint32_t idx1 = 0; idx1 < 1; ++idx1) {
                std::string variable_name = "NULL";
                variable_name = GenerateStruct_VkMicromapUsageEXT(out,
                                                                  &(structInfo->ppUsageCounts[idx0][idx1]),
                                                                  &(metaInfo->ppUsageCounts->GetMetaStructPointer()[idx0][idx1]),
                                                                  consumer);
                pp_usage_counts_names += variable_name + ", ";
            }
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// type
    struct_body << "\t\t\t" << "VkMicromapTypeEXT(" << structInfo->type << ")" << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkBuildMicromapFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// mode
    struct_body << "\t\t\t" << "VkBuildMicromapModeEXT(" << structInfo->mode << ")" << "," << std::endl;
// dstMicromap
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstMicromap) << "," << std::endl;
// usageCountsCount
    struct_body << "\t\t\t" << structInfo->usageCountsCount << "," << std::endl;
// pUsageCounts
    struct_body << "\t\t\t" << pusage_counts_array << "," << std::endl;
// ppUsageCounts
    struct_body << "\t\t\t" << pp_usage_counts_array << "," << std::endl;
// data
    struct_body << "\t\t\t" << structInfo->data.deviceAddress << "," << std::endl;
// scratchData
    struct_body << "\t\t\t" << structInfo->scratchData.deviceAddress << "," << std::endl;
// triangleArray
    struct_body << "\t\t\t" << structInfo->triangleArray.deviceAddress << "," << std::endl;
// triangleArrayStride
    struct_body << "\t\t\t" << structInfo->triangleArrayStride << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "micromapBuildInfoEXT");
    out << "\t\t" << "VkMicromapBuildInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMicromapBuildSizesInfoEXT(std::ostream &out, const VkMicromapBuildSizesInfoEXT* structInfo, Decoded_VkMicromapBuildSizesInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// micromapSize
    struct_body << "\t\t\t" << structInfo->micromapSize << "UL" << "," << std::endl;
// buildScratchSize
    struct_body << "\t\t\t" << structInfo->buildScratchSize << "UL" << "," << std::endl;
// discardable
    struct_body << "\t\t\t" << structInfo->discardable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "micromapBuildSizesInfoEXT");
    out << "\t\t" << "VkMicromapBuildSizesInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMicromapCreateInfoEXT(std::ostream &out, const VkMicromapCreateInfoEXT* structInfo, Decoded_VkMicromapCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// createFlags
    struct_body << "\t\t\t" << "VkMicromapCreateFlagsEXT(" << structInfo->createFlags << ")" << "," << std::endl;
// buffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
// type
    struct_body << "\t\t\t" << "VkMicromapTypeEXT(" << structInfo->type << ")" << "," << std::endl;
// deviceAddress
    struct_body << "\t\t\t" << structInfo->deviceAddress << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "micromapCreateInfoEXT");
    out << "\t\t" << "VkMicromapCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMicromapTriangleEXT(std::ostream &out, const VkMicromapTriangleEXT* structInfo, Decoded_VkMicromapTriangleEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// dataOffset
    struct_body << "\t" << structInfo->dataOffset << "," << std::endl;
// subdivisionLevel
    struct_body << "\t\t\t" << structInfo->subdivisionLevel << "," << std::endl;
// format
    struct_body << "\t\t\t" << structInfo->format << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "micromapTriangleEXT");
    out << "\t\t" << "VkMicromapTriangleEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMicromapUsageEXT(std::ostream &out, const VkMicromapUsageEXT* structInfo, Decoded_VkMicromapUsageEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// count
    struct_body << "\t" << structInfo->count << "," << std::endl;
// subdivisionLevel
    struct_body << "\t\t\t" << structInfo->subdivisionLevel << "," << std::endl;
// format
    struct_body << "\t\t\t" << structInfo->format << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "micromapUsageEXT");
    out << "\t\t" << "VkMicromapUsageEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMicromapVersionInfoEXT(std::ostream &out, const VkMicromapVersionInfoEXT* structInfo, Decoded_VkMicromapVersionInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pversion_data_array = "NULL";
    std::string pversion_data_values;
    for (uint32_t idx0 = 0; idx0 < 2*VK_UUID_SIZE; ++idx0) {
        pversion_data_values += std::to_string(structInfo->pVersionData[idx0]) + ", ";
    }
    pversion_data_array = "pVersionData_" + std::to_string(consumer.GetNextId());
    out << "\t\t" << "uint8_t " << pversion_data_array << "[] = {" << pversion_data_values << "};" << std::endl;
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pVersionData
    struct_body << "\t\t\t" << pversion_data_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "micromapVersionInfoEXT");
    out << "\t\t" << "VkMicromapVersionInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceOpacityMicromapFeaturesEXT(std::ostream &out, const VkPhysicalDeviceOpacityMicromapFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceOpacityMicromapFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// micromap
    struct_body << "\t\t\t" << structInfo->micromap << "," << std::endl;
// micromapCaptureReplay
    struct_body << "\t\t\t" << structInfo->micromapCaptureReplay << "," << std::endl;
// micromapHostCommands
    struct_body << "\t\t\t" << structInfo->micromapHostCommands << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceOpacityMicromapFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceOpacityMicromapFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceOpacityMicromapPropertiesEXT(std::ostream &out, const VkPhysicalDeviceOpacityMicromapPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceOpacityMicromapPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxOpacity2StateSubdivisionLevel
    struct_body << "\t\t\t" << structInfo->maxOpacity2StateSubdivisionLevel << "," << std::endl;
// maxOpacity4StateSubdivisionLevel
    struct_body << "\t\t\t" << structInfo->maxOpacity4StateSubdivisionLevel << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceOpacityMicromapPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceOpacityMicromapPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureTrianglesDisplacementMicromapNV(std::ostream &out, const VkAccelerationStructureTrianglesDisplacementMicromapNV* structInfo, Decoded_VkAccelerationStructureTrianglesDisplacementMicromapNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pusage_counts_array = "NULL";
    if (structInfo->pUsageCounts != NULL) {
        pusage_counts_array = "pUsageCounts_" + std::to_string(consumer.GetNextId());
        std::string pusage_counts_names;
        for (uint32_t idx = 0; idx < structInfo->usageCountsCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pUsageCounts + idx != NULL) {
                variable_name = GenerateStruct_VkMicromapUsageEXT(out,
                                                                  structInfo->pUsageCounts + idx,
                                                                  metaInfo->pUsageCounts->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pusage_counts_names += variable_name + ", ";
        }
        out << "\t\t" << "VkMicromapUsageEXT " << pusage_counts_array << "[] = {" << pusage_counts_names << "};" << std::endl;
    }
    std::string pp_usage_counts_array = "NULL";
    if (structInfo->ppUsageCounts != NULL) {
        pp_usage_counts_array = "ppUsageCounts_" + std::to_string(consumer.GetNextId());
        std::string pp_usage_counts_names;
        for (uint32_t idx0 = 0; idx0 < structInfo->usageCountsCount; ++idx0) {
            for (uint32_t idx1 = 0; idx1 < 1; ++idx1) {
                std::string variable_name = "NULL";
                variable_name = GenerateStruct_VkMicromapUsageEXT(out,
                                                                  &(structInfo->ppUsageCounts[idx0][idx1]),
                                                                  &(metaInfo->ppUsageCounts->GetMetaStructPointer()[idx0][idx1]),
                                                                  consumer);
                pp_usage_counts_names += variable_name + ", ";
            }
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// displacementBiasAndScaleFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->displacementBiasAndScaleFormat << ")" << "," << std::endl;
// displacementVectorFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->displacementVectorFormat << ")" << "," << std::endl;
// displacementBiasAndScaleBuffer
    struct_body << "\t\t\t" << structInfo->displacementBiasAndScaleBuffer.deviceAddress << "," << std::endl;
// displacementBiasAndScaleStride
    struct_body << "\t\t\t" << structInfo->displacementBiasAndScaleStride << "UL" << "," << std::endl;
// displacementVectorBuffer
    struct_body << "\t\t\t" << structInfo->displacementVectorBuffer.deviceAddress << "," << std::endl;
// displacementVectorStride
    struct_body << "\t\t\t" << structInfo->displacementVectorStride << "UL" << "," << std::endl;
// displacedMicromapPrimitiveFlags
    struct_body << "\t\t\t" << structInfo->displacedMicromapPrimitiveFlags.deviceAddress << "," << std::endl;
// displacedMicromapPrimitiveFlagsStride
    struct_body << "\t\t\t" << structInfo->displacedMicromapPrimitiveFlagsStride << "UL" << "," << std::endl;
// indexType
    struct_body << "\t\t\t" << "VkIndexType(" << structInfo->indexType << ")" << "," << std::endl;
// indexBuffer
    struct_body << "\t\t\t" << structInfo->indexBuffer.deviceAddress << "," << std::endl;
// indexStride
    struct_body << "\t\t\t" << structInfo->indexStride << "UL" << "," << std::endl;
// baseTriangle
    struct_body << "\t\t\t" << structInfo->baseTriangle << "," << std::endl;
// usageCountsCount
    struct_body << "\t\t\t" << structInfo->usageCountsCount << "," << std::endl;
// pUsageCounts
    struct_body << "\t\t\t" << pusage_counts_array << "," << std::endl;
// ppUsageCounts
    struct_body << "\t\t\t" << pp_usage_counts_array << "," << std::endl;
// micromap
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->micromap) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureTrianglesDisplacementMicromapNV");
    out << "\t\t" << "VkAccelerationStructureTrianglesDisplacementMicromapNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDisplacementMicromapFeaturesNV(std::ostream &out, const VkPhysicalDeviceDisplacementMicromapFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDisplacementMicromapFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// displacementMicromap
    struct_body << "\t\t\t" << structInfo->displacementMicromap << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDisplacementMicromapFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceDisplacementMicromapFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDisplacementMicromapPropertiesNV(std::ostream &out, const VkPhysicalDeviceDisplacementMicromapPropertiesNV* structInfo, Decoded_VkPhysicalDeviceDisplacementMicromapPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxDisplacementMicromapSubdivisionLevel
    struct_body << "\t\t\t" << structInfo->maxDisplacementMicromapSubdivisionLevel << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDisplacementMicromapPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceDisplacementMicromapPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(std::ostream &out, const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* structInfo, Decoded_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// clustercullingShader
    struct_body << "\t\t\t" << structInfo->clustercullingShader << "," << std::endl;
// multiviewClusterCullingShader
    struct_body << "\t\t\t" << structInfo->multiviewClusterCullingShader << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceClusterCullingShaderFeaturesHUAWEI");
    out << "\t\t" << "VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(std::ostream &out, const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* structInfo, Decoded_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxWorkGroupCount
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxWorkGroupCount[0]), 3) << "," << std::endl;
// maxWorkGroupSize
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxWorkGroupSize[0]), 3) << "," << std::endl;
// maxOutputClusterCount
    struct_body << "\t\t\t" << structInfo->maxOutputClusterCount << "," << std::endl;
// indirectBufferOffsetAlignment
    struct_body << "\t\t\t" << structInfo->indirectBufferOffsetAlignment << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceClusterCullingShaderPropertiesHUAWEI");
    out << "\t\t" << "VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(std::ostream &out, const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* structInfo, Decoded_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// clusterShadingRate
    struct_body << "\t\t\t" << structInfo->clusterShadingRate << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceClusterCullingShaderVrsFeaturesHUAWEI");
    out << "\t\t" << "VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(std::ostream &out, const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// borderColorSwizzle
    struct_body << "\t\t\t" << structInfo->borderColorSwizzle << "," << std::endl;
// borderColorSwizzleFromImage
    struct_body << "\t\t\t" << structInfo->borderColorSwizzleFromImage << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceBorderColorSwizzleFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceBorderColorSwizzleFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerBorderColorComponentMappingCreateInfoEXT(std::ostream &out, const VkSamplerBorderColorComponentMappingCreateInfoEXT* structInfo, Decoded_VkSamplerBorderColorComponentMappingCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string components_info_var = GenerateStruct_VkComponentMapping(out,
                                                                        &structInfo->components,
                                                                        metaInfo->components,
                                                                        consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// components
    struct_body << "\t\t\t" << components_info_var << "," << std::endl;
// srgb
    struct_body << "\t\t\t" << structInfo->srgb << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerBorderColorComponentMappingCreateInfoEXT");
    out << "\t\t" << "VkSamplerBorderColorComponentMappingCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(std::ostream &out, const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pageableDeviceLocalMemory
    struct_body << "\t\t\t" << structInfo->pageableDeviceLocalMemory << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePageableDeviceLocalMemoryFeaturesEXT");
    out << "\t\t" << "VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCorePropertiesARM(std::ostream &out, const VkPhysicalDeviceShaderCorePropertiesARM* structInfo, Decoded_VkPhysicalDeviceShaderCorePropertiesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pixelRate
    struct_body << "\t\t\t" << structInfo->pixelRate << "," << std::endl;
// texelRate
    struct_body << "\t\t\t" << structInfo->texelRate << "," << std::endl;
// fmaRate
    struct_body << "\t\t\t" << structInfo->fmaRate << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderCorePropertiesARM");
    out << "\t\t" << "VkPhysicalDeviceShaderCorePropertiesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceQueueShaderCoreControlCreateInfoARM(std::ostream &out, const VkDeviceQueueShaderCoreControlCreateInfoARM* structInfo, Decoded_VkDeviceQueueShaderCoreControlCreateInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderCoreCount
    struct_body << "\t\t\t" << structInfo->shaderCoreCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceQueueShaderCoreControlCreateInfoARM");
    out << "\t\t" << "VkDeviceQueueShaderCoreControlCreateInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSchedulingControlsFeaturesARM(std::ostream &out, const VkPhysicalDeviceSchedulingControlsFeaturesARM* structInfo, Decoded_VkPhysicalDeviceSchedulingControlsFeaturesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// schedulingControls
    struct_body << "\t\t\t" << structInfo->schedulingControls << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSchedulingControlsFeaturesARM");
    out << "\t\t" << "VkPhysicalDeviceSchedulingControlsFeaturesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSchedulingControlsPropertiesARM(std::ostream &out, const VkPhysicalDeviceSchedulingControlsPropertiesARM* structInfo, Decoded_VkPhysicalDeviceSchedulingControlsPropertiesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// schedulingControlsFlags
    struct_body << "\t\t\t" << "VkPhysicalDeviceSchedulingControlsFlagsARM(" << structInfo->schedulingControlsFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSchedulingControlsPropertiesARM");
    out << "\t\t" << "VkPhysicalDeviceSchedulingControlsPropertiesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewSlicedCreateInfoEXT(std::ostream &out, const VkImageViewSlicedCreateInfoEXT* structInfo, Decoded_VkImageViewSlicedCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// sliceOffset
    struct_body << "\t\t\t" << structInfo->sliceOffset << "," << std::endl;
// sliceCount
    struct_body << "\t\t\t" << structInfo->sliceCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewSlicedCreateInfoEXT");
    out << "\t\t" << "VkImageViewSlicedCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// imageSlicedViewOf3D
    struct_body << "\t\t\t" << structInfo->imageSlicedViewOf3D << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageSlicedViewOf3DFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetBindingReferenceVALVE(std::ostream &out, const VkDescriptorSetBindingReferenceVALVE* structInfo, Decoded_VkDescriptorSetBindingReferenceVALVE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// descriptorSetLayout
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->descriptorSetLayout) << "," << std::endl;
// binding
    struct_body << "\t\t\t" << structInfo->binding << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetBindingReferenceVALVE");
    out << "\t\t" << "VkDescriptorSetBindingReferenceVALVE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetLayoutHostMappingInfoVALVE(std::ostream &out, const VkDescriptorSetLayoutHostMappingInfoVALVE* structInfo, Decoded_VkDescriptorSetLayoutHostMappingInfoVALVE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// descriptorOffset
    struct_body << "\t\t\t" << structInfo->descriptorOffset << "," << std::endl;
// descriptorSize
    struct_body << "\t\t\t" << structInfo->descriptorSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetLayoutHostMappingInfoVALVE");
    out << "\t\t" << "VkDescriptorSetLayoutHostMappingInfoVALVE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(std::ostream &out, const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* structInfo, Decoded_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// descriptorSetHostMapping
    struct_body << "\t\t\t" << structInfo->descriptorSetHostMapping << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDescriptorSetHostMappingFeaturesVALVE");
    out << "\t\t" << "VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDepthClampZeroOneFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// depthClampZeroOne
    struct_body << "\t\t\t" << structInfo->depthClampZeroOne << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDepthClampZeroOneFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceDepthClampZeroOneFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(std::ostream &out, const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// nonSeamlessCubeMap
    struct_body << "\t\t\t" << structInfo->nonSeamlessCubeMap << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceNonSeamlessCubeMapFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRenderPassStripedFeaturesARM(std::ostream &out, const VkPhysicalDeviceRenderPassStripedFeaturesARM* structInfo, Decoded_VkPhysicalDeviceRenderPassStripedFeaturesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// renderPassStriped
    struct_body << "\t\t\t" << structInfo->renderPassStriped << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRenderPassStripedFeaturesARM");
    out << "\t\t" << "VkPhysicalDeviceRenderPassStripedFeaturesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRenderPassStripedPropertiesARM(std::ostream &out, const VkPhysicalDeviceRenderPassStripedPropertiesARM* structInfo, Decoded_VkPhysicalDeviceRenderPassStripedPropertiesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string render_pass_stripe_granularity_info_var = GenerateStruct_VkExtent2D(out,
                                                                                    &structInfo->renderPassStripeGranularity,
                                                                                    metaInfo->renderPassStripeGranularity,
                                                                                    consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// renderPassStripeGranularity
    struct_body << "\t\t\t" << render_pass_stripe_granularity_info_var << "," << std::endl;
// maxRenderPassStripes
    struct_body << "\t\t\t" << structInfo->maxRenderPassStripes << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRenderPassStripedPropertiesARM");
    out << "\t\t" << "VkPhysicalDeviceRenderPassStripedPropertiesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassStripeBeginInfoARM(std::ostream &out, const VkRenderPassStripeBeginInfoARM* structInfo, Decoded_VkRenderPassStripeBeginInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstripe_infos_array = "NULL";
    if (structInfo->pStripeInfos != NULL) {
        pstripe_infos_array = "pStripeInfos_" + std::to_string(consumer.GetNextId());
        std::string pstripe_infos_names;
        for (uint32_t idx = 0; idx < structInfo->stripeInfoCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStripeInfos + idx != NULL) {
                variable_name = GenerateStruct_VkRenderPassStripeInfoARM(out,
                                                                         structInfo->pStripeInfos + idx,
                                                                         metaInfo->pStripeInfos->GetMetaStructPointer() + idx,
                                                                         consumer);
            }
            pstripe_infos_names += variable_name + ", ";
        }
        out << "\t\t" << "VkRenderPassStripeInfoARM " << pstripe_infos_array << "[] = {" << pstripe_infos_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stripeInfoCount
    struct_body << "\t\t\t" << structInfo->stripeInfoCount << "," << std::endl;
// pStripeInfos
    struct_body << "\t\t\t" << pstripe_infos_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassStripeBeginInfoARM");
    out << "\t\t" << "VkRenderPassStripeBeginInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassStripeInfoARM(std::ostream &out, const VkRenderPassStripeInfoARM* structInfo, Decoded_VkRenderPassStripeInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string stripe_area_info_var = GenerateStruct_VkRect2D(out,
                                                               &structInfo->stripeArea,
                                                               metaInfo->stripeArea,
                                                               consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stripeArea
    struct_body << "\t\t\t" << stripe_area_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassStripeInfoARM");
    out << "\t\t" << "VkRenderPassStripeInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassStripeSubmitInfoARM(std::ostream &out, const VkRenderPassStripeSubmitInfoARM* structInfo, Decoded_VkRenderPassStripeSubmitInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstripe_semaphore_infos_array = "NULL";
    if (structInfo->pStripeSemaphoreInfos != NULL) {
        pstripe_semaphore_infos_array = "pStripeSemaphoreInfos_" + std::to_string(consumer.GetNextId());
        std::string pstripe_semaphore_infos_names;
        for (uint32_t idx = 0; idx < structInfo->stripeSemaphoreInfoCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStripeSemaphoreInfos + idx != NULL) {
                variable_name = GenerateStruct_VkSemaphoreSubmitInfo(out,
                                                                     structInfo->pStripeSemaphoreInfos + idx,
                                                                     metaInfo->pStripeSemaphoreInfos->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            pstripe_semaphore_infos_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSemaphoreSubmitInfo " << pstripe_semaphore_infos_array << "[] = {" << pstripe_semaphore_infos_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// stripeSemaphoreInfoCount
    struct_body << "\t\t\t" << structInfo->stripeSemaphoreInfoCount << "," << std::endl;
// pStripeSemaphoreInfos
    struct_body << "\t\t\t" << pstripe_semaphore_infos_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassStripeSubmitInfoARM");
    out << "\t\t" << "VkRenderPassStripeSubmitInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fragmentDensityMapOffset
    struct_body << "\t\t\t" << structInfo->fragmentDensityMapOffset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentDensityMapOffsetFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM(std::ostream &out, const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string fragment_density_offset_granularity_info_var = GenerateStruct_VkExtent2D(out,
                                                                                         &structInfo->fragmentDensityOffsetGranularity,
                                                                                         metaInfo->fragmentDensityOffsetGranularity,
                                                                                         consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fragmentDensityOffsetGranularity
    struct_body << "\t\t\t" << fragment_density_offset_granularity_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentDensityMapOffsetPropertiesQCOM");
    out << "\t\t" << "VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassFragmentDensityMapOffsetEndInfoQCOM(std::ostream &out, const VkSubpassFragmentDensityMapOffsetEndInfoQCOM* structInfo, Decoded_VkSubpassFragmentDensityMapOffsetEndInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pfragment_density_offsets_array = "NULL";
    if (structInfo->pFragmentDensityOffsets != NULL) {
        pfragment_density_offsets_array = "pFragmentDensityOffsets_" + std::to_string(consumer.GetNextId());
        std::string pfragment_density_offsets_names;
        for (uint32_t idx = 0; idx < structInfo->fragmentDensityOffsetCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pFragmentDensityOffsets + idx != NULL) {
                variable_name = GenerateStruct_VkOffset2D(out,
                                                          structInfo->pFragmentDensityOffsets + idx,
                                                          metaInfo->pFragmentDensityOffsets->GetMetaStructPointer() + idx,
                                                          consumer);
            }
            pfragment_density_offsets_names += variable_name + ", ";
        }
        out << "\t\t" << "VkOffset2D " << pfragment_density_offsets_array << "[] = {" << pfragment_density_offsets_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// fragmentDensityOffsetCount
    struct_body << "\t\t\t" << structInfo->fragmentDensityOffsetCount << "," << std::endl;
// pFragmentDensityOffsets
    struct_body << "\t\t\t" << pfragment_density_offsets_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassFragmentDensityMapOffsetEndInfoQCOM");
    out << "\t\t" << "VkSubpassFragmentDensityMapOffsetEndInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindPipelineIndirectCommandNV(std::ostream &out, const VkBindPipelineIndirectCommandNV* structInfo, Decoded_VkBindPipelineIndirectCommandNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// pipelineAddress
    struct_body << "\t" << structInfo->pipelineAddress << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindPipelineIndirectCommandNV");
    out << "\t\t" << "VkBindPipelineIndirectCommandNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkComputePipelineIndirectBufferInfoNV(std::ostream &out, const VkComputePipelineIndirectBufferInfoNV* structInfo, Decoded_VkComputePipelineIndirectBufferInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceAddress
    struct_body << "\t\t\t" << structInfo->deviceAddress << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
// pipelineDeviceAddressCaptureReplay
    struct_body << "\t\t\t" << structInfo->pipelineDeviceAddressCaptureReplay << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "computePipelineIndirectBufferInfoNV");
    out << "\t\t" << "VkComputePipelineIndirectBufferInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV(std::ostream &out, const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// deviceGeneratedCompute
    struct_body << "\t\t\t" << structInfo->deviceGeneratedCompute << "," << std::endl;
// deviceGeneratedComputePipelines
    struct_body << "\t\t\t" << structInfo->deviceGeneratedComputePipelines << "," << std::endl;
// deviceGeneratedComputeCaptureReplay
    struct_body << "\t\t\t" << structInfo->deviceGeneratedComputeCaptureReplay << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDeviceGeneratedCommandsComputeFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineIndirectDeviceAddressInfoNV(std::ostream &out, const VkPipelineIndirectDeviceAddressInfoNV* structInfo, Decoded_VkPipelineIndirectDeviceAddressInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pipelineBindPoint
    struct_body << "\t\t\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
// pipeline
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipeline) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineIndirectDeviceAddressInfoNV");
    out << "\t\t" << "VkPipelineIndirectDeviceAddressInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLinearColorAttachmentFeaturesNV(std::ostream &out, const VkPhysicalDeviceLinearColorAttachmentFeaturesNV* structInfo, Decoded_VkPhysicalDeviceLinearColorAttachmentFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// linearColorAttachment
    struct_body << "\t\t\t" << structInfo->linearColorAttachment << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLinearColorAttachmentFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceLinearColorAttachmentFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// imageCompressionControlSwapchain
    struct_body << "\t\t\t" << structInfo->imageCompressionControlSwapchain << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageCompressionControlSwapchainFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewSampleWeightCreateInfoQCOM(std::ostream &out, const VkImageViewSampleWeightCreateInfoQCOM* structInfo, Decoded_VkImageViewSampleWeightCreateInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string filter_center_info_var = GenerateStruct_VkOffset2D(out,
                                                                   &structInfo->filterCenter,
                                                                   metaInfo->filterCenter,
                                                                   consumer);
    std::string filter_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                 &structInfo->filterSize,
                                                                 metaInfo->filterSize,
                                                                 consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// filterCenter
    struct_body << "\t\t\t" << filter_center_info_var << "," << std::endl;
// filterSize
    struct_body << "\t\t\t" << filter_size_info_var << "," << std::endl;
// numPhases
    struct_body << "\t\t\t" << structInfo->numPhases << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewSampleWeightCreateInfoQCOM");
    out << "\t\t" << "VkImageViewSampleWeightCreateInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageProcessingFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceImageProcessingFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceImageProcessingFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// textureSampleWeighted
    struct_body << "\t\t\t" << structInfo->textureSampleWeighted << "," << std::endl;
// textureBoxFilter
    struct_body << "\t\t\t" << structInfo->textureBoxFilter << "," << std::endl;
// textureBlockMatch
    struct_body << "\t\t\t" << structInfo->textureBlockMatch << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageProcessingFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceImageProcessingFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageProcessingPropertiesQCOM(std::ostream &out, const VkPhysicalDeviceImageProcessingPropertiesQCOM* structInfo, Decoded_VkPhysicalDeviceImageProcessingPropertiesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string max_weight_filter_dimension_info_var = GenerateStruct_VkExtent2D(out,
                                                                                 &structInfo->maxWeightFilterDimension,
                                                                                 metaInfo->maxWeightFilterDimension,
                                                                                 consumer);
    std::string max_block_match_region_info_var = GenerateStruct_VkExtent2D(out,
                                                                            &structInfo->maxBlockMatchRegion,
                                                                            metaInfo->maxBlockMatchRegion,
                                                                            consumer);
    std::string max_box_filter_block_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                               &structInfo->maxBoxFilterBlockSize,
                                                                               metaInfo->maxBoxFilterBlockSize,
                                                                               consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxWeightFilterPhases
    struct_body << "\t\t\t" << structInfo->maxWeightFilterPhases << "," << std::endl;
// maxWeightFilterDimension
    struct_body << "\t\t\t" << max_weight_filter_dimension_info_var << "," << std::endl;
// maxBlockMatchRegion
    struct_body << "\t\t\t" << max_block_match_region_info_var << "," << std::endl;
// maxBoxFilterBlockSize
    struct_body << "\t\t\t" << max_box_filter_block_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageProcessingPropertiesQCOM");
    out << "\t\t" << "VkPhysicalDeviceImageProcessingPropertiesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(std::ostream &out, const VkPhysicalDeviceNestedCommandBufferFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceNestedCommandBufferFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// nestedCommandBuffer
    struct_body << "\t\t\t" << structInfo->nestedCommandBuffer << "," << std::endl;
// nestedCommandBufferRendering
    struct_body << "\t\t\t" << structInfo->nestedCommandBufferRendering << "," << std::endl;
// nestedCommandBufferSimultaneousUse
    struct_body << "\t\t\t" << structInfo->nestedCommandBufferSimultaneousUse << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceNestedCommandBufferFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceNestedCommandBufferFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(std::ostream &out, const VkPhysicalDeviceNestedCommandBufferPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceNestedCommandBufferPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxCommandBufferNestingLevel
    struct_body << "\t\t\t" << structInfo->maxCommandBufferNestingLevel << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceNestedCommandBufferPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceNestedCommandBufferPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalMemoryAcquireUnmodifiedEXT(std::ostream &out, const VkExternalMemoryAcquireUnmodifiedEXT* structInfo, Decoded_VkExternalMemoryAcquireUnmodifiedEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// acquireUnmodifiedMemory
    struct_body << "\t\t\t" << structInfo->acquireUnmodifiedMemory << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalMemoryAcquireUnmodifiedEXT");
    out << "\t\t" << "VkExternalMemoryAcquireUnmodifiedEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkColorBlendAdvancedEXT(std::ostream &out, const VkColorBlendAdvancedEXT* structInfo, Decoded_VkColorBlendAdvancedEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// advancedBlendOp
    struct_body << "\t" << "VkBlendOp(" << structInfo->advancedBlendOp << ")" << "," << std::endl;
// srcPremultiplied
    struct_body << "\t\t\t" << structInfo->srcPremultiplied << "," << std::endl;
// dstPremultiplied
    struct_body << "\t\t\t" << structInfo->dstPremultiplied << "," << std::endl;
// blendOverlap
    struct_body << "\t\t\t" << "VkBlendOverlapEXT(" << structInfo->blendOverlap << ")" << "," << std::endl;
// clampResults
    struct_body << "\t\t\t" << structInfo->clampResults << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "colorBlendAdvancedEXT");
    out << "\t\t" << "VkColorBlendAdvancedEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkColorBlendEquationEXT(std::ostream &out, const VkColorBlendEquationEXT* structInfo, Decoded_VkColorBlendEquationEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// srcColorBlendFactor
    struct_body << "\t" << "VkBlendFactor(" << structInfo->srcColorBlendFactor << ")" << "," << std::endl;
// dstColorBlendFactor
    struct_body << "\t\t\t" << "VkBlendFactor(" << structInfo->dstColorBlendFactor << ")" << "," << std::endl;
// colorBlendOp
    struct_body << "\t\t\t" << "VkBlendOp(" << structInfo->colorBlendOp << ")" << "," << std::endl;
// srcAlphaBlendFactor
    struct_body << "\t\t\t" << "VkBlendFactor(" << structInfo->srcAlphaBlendFactor << ")" << "," << std::endl;
// dstAlphaBlendFactor
    struct_body << "\t\t\t" << "VkBlendFactor(" << structInfo->dstAlphaBlendFactor << ")" << "," << std::endl;
// alphaBlendOp
    struct_body << "\t\t\t" << "VkBlendOp(" << structInfo->alphaBlendOp << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "colorBlendEquationEXT");
    out << "\t\t" << "VkColorBlendEquationEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(std::ostream &out, const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// extendedDynamicState3TessellationDomainOrigin
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3TessellationDomainOrigin << "," << std::endl;
// extendedDynamicState3DepthClampEnable
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3DepthClampEnable << "," << std::endl;
// extendedDynamicState3PolygonMode
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3PolygonMode << "," << std::endl;
// extendedDynamicState3RasterizationSamples
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3RasterizationSamples << "," << std::endl;
// extendedDynamicState3SampleMask
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3SampleMask << "," << std::endl;
// extendedDynamicState3AlphaToCoverageEnable
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3AlphaToCoverageEnable << "," << std::endl;
// extendedDynamicState3AlphaToOneEnable
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3AlphaToOneEnable << "," << std::endl;
// extendedDynamicState3LogicOpEnable
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3LogicOpEnable << "," << std::endl;
// extendedDynamicState3ColorBlendEnable
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ColorBlendEnable << "," << std::endl;
// extendedDynamicState3ColorBlendEquation
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ColorBlendEquation << "," << std::endl;
// extendedDynamicState3ColorWriteMask
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ColorWriteMask << "," << std::endl;
// extendedDynamicState3RasterizationStream
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3RasterizationStream << "," << std::endl;
// extendedDynamicState3ConservativeRasterizationMode
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ConservativeRasterizationMode << "," << std::endl;
// extendedDynamicState3ExtraPrimitiveOverestimationSize
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ExtraPrimitiveOverestimationSize << "," << std::endl;
// extendedDynamicState3DepthClipEnable
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3DepthClipEnable << "," << std::endl;
// extendedDynamicState3SampleLocationsEnable
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3SampleLocationsEnable << "," << std::endl;
// extendedDynamicState3ColorBlendAdvanced
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ColorBlendAdvanced << "," << std::endl;
// extendedDynamicState3ProvokingVertexMode
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ProvokingVertexMode << "," << std::endl;
// extendedDynamicState3LineRasterizationMode
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3LineRasterizationMode << "," << std::endl;
// extendedDynamicState3LineStippleEnable
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3LineStippleEnable << "," << std::endl;
// extendedDynamicState3DepthClipNegativeOneToOne
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3DepthClipNegativeOneToOne << "," << std::endl;
// extendedDynamicState3ViewportWScalingEnable
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ViewportWScalingEnable << "," << std::endl;
// extendedDynamicState3ViewportSwizzle
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ViewportSwizzle << "," << std::endl;
// extendedDynamicState3CoverageToColorEnable
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3CoverageToColorEnable << "," << std::endl;
// extendedDynamicState3CoverageToColorLocation
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3CoverageToColorLocation << "," << std::endl;
// extendedDynamicState3CoverageModulationMode
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3CoverageModulationMode << "," << std::endl;
// extendedDynamicState3CoverageModulationTableEnable
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3CoverageModulationTableEnable << "," << std::endl;
// extendedDynamicState3CoverageModulationTable
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3CoverageModulationTable << "," << std::endl;
// extendedDynamicState3CoverageReductionMode
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3CoverageReductionMode << "," << std::endl;
// extendedDynamicState3RepresentativeFragmentTestEnable
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3RepresentativeFragmentTestEnable << "," << std::endl;
// extendedDynamicState3ShadingRateImageEnable
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ShadingRateImageEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExtendedDynamicState3FeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceExtendedDynamicState3FeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(std::ostream &out, const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* structInfo, Decoded_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// dynamicPrimitiveTopologyUnrestricted
    struct_body << "\t\t\t" << structInfo->dynamicPrimitiveTopologyUnrestricted << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExtendedDynamicState3PropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceExtendedDynamicState3PropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(std::ostream &out, const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// subpassMergeFeedback
    struct_body << "\t\t\t" << structInfo->subpassMergeFeedback << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSubpassMergeFeedbackFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassCreationControlEXT(std::ostream &out, const VkRenderPassCreationControlEXT* structInfo, Decoded_VkRenderPassCreationControlEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// disallowMerging
    struct_body << "\t\t\t" << structInfo->disallowMerging << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassCreationControlEXT");
    out << "\t\t" << "VkRenderPassCreationControlEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassCreationFeedbackCreateInfoEXT(std::ostream &out, const VkRenderPassCreationFeedbackCreateInfoEXT* structInfo, Decoded_VkRenderPassCreationFeedbackCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pRenderPassFeedback
    out << "\t\t" << "// TODO: Support pRenderPassFeedback (output?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassCreationFeedbackCreateInfoEXT");
    out << "\t\t" << "VkRenderPassCreationFeedbackCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassCreationFeedbackInfoEXT(std::ostream &out, const VkRenderPassCreationFeedbackInfoEXT* structInfo, Decoded_VkRenderPassCreationFeedbackInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// postMergeSubpassCount
    struct_body << "\t" << structInfo->postMergeSubpassCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassCreationFeedbackInfoEXT");
    out << "\t\t" << "VkRenderPassCreationFeedbackInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassSubpassFeedbackCreateInfoEXT(std::ostream &out, const VkRenderPassSubpassFeedbackCreateInfoEXT* structInfo, Decoded_VkRenderPassSubpassFeedbackCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pSubpassFeedback
    out << "\t\t" << "// TODO: Support pSubpassFeedback (output?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassSubpassFeedbackCreateInfoEXT");
    out << "\t\t" << "VkRenderPassSubpassFeedbackCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassSubpassFeedbackInfoEXT(std::ostream &out, const VkRenderPassSubpassFeedbackInfoEXT* structInfo, Decoded_VkRenderPassSubpassFeedbackInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// subpassMergeStatus
    struct_body << "\t" << "VkSubpassMergeStatusEXT(" << structInfo->subpassMergeStatus << ")" << "," << std::endl;
// description
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << "," << std::endl;
// postMergeIndex
    struct_body << "\t\t\t" << structInfo->postMergeIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassSubpassFeedbackInfoEXT");
    out << "\t\t" << "VkRenderPassSubpassFeedbackInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDirectDriverLoadingInfoLUNARG(std::ostream &out, const VkDirectDriverLoadingInfoLUNARG* structInfo, Decoded_VkDirectDriverLoadingInfoLUNARG* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkDirectDriverLoadingFlagsLUNARG(" << structInfo->flags << ")" << "," << std::endl;
// pfnGetInstanceProcAddr
    struct_body << "\t\t\t" << structInfo->pfnGetInstanceProcAddr << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "directDriverLoadingInfoLUNARG");
    out << "\t\t" << "VkDirectDriverLoadingInfoLUNARG " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDirectDriverLoadingListLUNARG(std::ostream &out, const VkDirectDriverLoadingListLUNARG* structInfo, Decoded_VkDirectDriverLoadingListLUNARG* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdrivers_array = "NULL";
    if (structInfo->pDrivers != NULL) {
        pdrivers_array = "pDrivers_" + std::to_string(consumer.GetNextId());
        std::string pdrivers_names;
        for (uint32_t idx = 0; idx < structInfo->driverCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pDrivers + idx != NULL) {
                variable_name = GenerateStruct_VkDirectDriverLoadingInfoLUNARG(out,
                                                                               structInfo->pDrivers + idx,
                                                                               metaInfo->pDrivers->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pdrivers_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDirectDriverLoadingInfoLUNARG " << pdrivers_array << "[] = {" << pdrivers_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// mode
    struct_body << "\t\t\t" << "VkDirectDriverLoadingModeLUNARG(" << structInfo->mode << ")" << "," << std::endl;
// driverCount
    struct_body << "\t\t\t" << structInfo->driverCount << "," << std::endl;
// pDrivers
    struct_body << "\t\t\t" << pdrivers_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "directDriverLoadingListLUNARG");
    out << "\t\t" << "VkDirectDriverLoadingListLUNARG " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderModuleIdentifier
    struct_body << "\t\t\t" << structInfo->shaderModuleIdentifier << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderModuleIdentifierFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(std::ostream &out, const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderModuleIdentifierAlgorithmUUID
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->shaderModuleIdentifierAlgorithmUUID[0]), VK_UUID_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderModuleIdentifierPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(std::ostream &out, const VkPipelineShaderStageModuleIdentifierCreateInfoEXT* structInfo, Decoded_VkPipelineShaderStageModuleIdentifierCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pidentifier_array = "NULL";
    if (structInfo->pIdentifier != NULL) {
        std::string pidentifier_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->identifierSize; ++idx0) {
            pidentifier_values += std::to_string(structInfo->pIdentifier[idx0]) + ", ";
        }
        pidentifier_array = "pIdentifier_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pidentifier_array << "[] = {" << pidentifier_values << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// identifierSize
    struct_body << "\t\t\t" << structInfo->identifierSize << "," << std::endl;
// pIdentifier
    struct_body << "\t\t\t" << pidentifier_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineShaderStageModuleIdentifierCreateInfoEXT");
    out << "\t\t" << "VkPipelineShaderStageModuleIdentifierCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkShaderModuleIdentifierEXT(std::ostream &out, const VkShaderModuleIdentifierEXT* structInfo, Decoded_VkShaderModuleIdentifierEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// identifierSize
    struct_body << "\t\t\t" << structInfo->identifierSize << "," << std::endl;
// identifier
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->identifier[0]), VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "shaderModuleIdentifierEXT");
    out << "\t\t" << "VkShaderModuleIdentifierEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOpticalFlowExecuteInfoNV(std::ostream &out, const VkOpticalFlowExecuteInfoNV* structInfo, Decoded_VkOpticalFlowExecuteInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkRect2D " << pregions_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pRegions, structInfo->regionCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkOpticalFlowExecuteFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
// regionCount
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
// pRegions
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "opticalFlowExecuteInfoNV");
    out << "\t\t" << "VkOpticalFlowExecuteInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOpticalFlowImageFormatInfoNV(std::ostream &out, const VkOpticalFlowImageFormatInfoNV* structInfo, Decoded_VkOpticalFlowImageFormatInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// usage
    struct_body << "\t\t\t" << "VkOpticalFlowUsageFlagsNV(" << structInfo->usage << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "opticalFlowImageFormatInfoNV");
    out << "\t\t" << "VkOpticalFlowImageFormatInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOpticalFlowImageFormatPropertiesNV(std::ostream &out, const VkOpticalFlowImageFormatPropertiesNV* structInfo, Decoded_VkOpticalFlowImageFormatPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// format
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "opticalFlowImageFormatPropertiesNV");
    out << "\t\t" << "VkOpticalFlowImageFormatPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOpticalFlowSessionCreateInfoNV(std::ostream &out, const VkOpticalFlowSessionCreateInfoNV* structInfo, Decoded_VkOpticalFlowSessionCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// width
    struct_body << "\t\t\t" << structInfo->width << "," << std::endl;
// height
    struct_body << "\t\t\t" << structInfo->height << "," << std::endl;
// imageFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->imageFormat << ")" << "," << std::endl;
// flowVectorFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->flowVectorFormat << ")" << "," << std::endl;
// costFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->costFormat << ")" << "," << std::endl;
// outputGridSize
    struct_body << "\t\t\t" << "VkOpticalFlowGridSizeFlagsNV(" << structInfo->outputGridSize << ")" << "," << std::endl;
// hintGridSize
    struct_body << "\t\t\t" << "VkOpticalFlowGridSizeFlagsNV(" << structInfo->hintGridSize << ")" << "," << std::endl;
// performanceLevel
    struct_body << "\t\t\t" << "VkOpticalFlowPerformanceLevelNV(" << structInfo->performanceLevel << ")" << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkOpticalFlowSessionCreateFlagsNV(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "opticalFlowSessionCreateInfoNV");
    out << "\t\t" << "VkOpticalFlowSessionCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOpticalFlowSessionCreatePrivateDataInfoNV(std::ostream &out, const VkOpticalFlowSessionCreatePrivateDataInfoNV* structInfo, Decoded_VkOpticalFlowSessionCreatePrivateDataInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// id
    struct_body << "\t\t\t" << structInfo->id << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "," << std::endl;
// pPrivateData
    struct_body << "\t\t\t" << structInfo->pPrivateData << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "opticalFlowSessionCreatePrivateDataInfoNV");
    out << "\t\t" << "VkOpticalFlowSessionCreatePrivateDataInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceOpticalFlowFeaturesNV(std::ostream &out, const VkPhysicalDeviceOpticalFlowFeaturesNV* structInfo, Decoded_VkPhysicalDeviceOpticalFlowFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// opticalFlow
    struct_body << "\t\t\t" << structInfo->opticalFlow << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceOpticalFlowFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceOpticalFlowFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceOpticalFlowPropertiesNV(std::ostream &out, const VkPhysicalDeviceOpticalFlowPropertiesNV* structInfo, Decoded_VkPhysicalDeviceOpticalFlowPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// supportedOutputGridSizes
    struct_body << "\t\t\t" << "VkOpticalFlowGridSizeFlagsNV(" << structInfo->supportedOutputGridSizes << ")" << "," << std::endl;
// supportedHintGridSizes
    struct_body << "\t\t\t" << "VkOpticalFlowGridSizeFlagsNV(" << structInfo->supportedHintGridSizes << ")" << "," << std::endl;
// hintSupported
    struct_body << "\t\t\t" << structInfo->hintSupported << "," << std::endl;
// costSupported
    struct_body << "\t\t\t" << structInfo->costSupported << "," << std::endl;
// bidirectionalFlowSupported
    struct_body << "\t\t\t" << structInfo->bidirectionalFlowSupported << "," << std::endl;
// globalFlowSupported
    struct_body << "\t\t\t" << structInfo->globalFlowSupported << "," << std::endl;
// minWidth
    struct_body << "\t\t\t" << structInfo->minWidth << "," << std::endl;
// minHeight
    struct_body << "\t\t\t" << structInfo->minHeight << "," << std::endl;
// maxWidth
    struct_body << "\t\t\t" << structInfo->maxWidth << "," << std::endl;
// maxHeight
    struct_body << "\t\t\t" << structInfo->maxHeight << "," << std::endl;
// maxNumRegionsOfInterest
    struct_body << "\t\t\t" << structInfo->maxNumRegionsOfInterest << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceOpticalFlowPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceOpticalFlowPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLegacyDitheringFeaturesEXT(std::ostream &out, const VkPhysicalDeviceLegacyDitheringFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceLegacyDitheringFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// legacyDithering
    struct_body << "\t\t\t" << structInfo->legacyDithering << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLegacyDitheringFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceLegacyDitheringFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineProtectedAccessFeaturesEXT(std::ostream &out, const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePipelineProtectedAccessFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pipelineProtectedAccess
    struct_body << "\t\t\t" << structInfo->pipelineProtectedAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineProtectedAccessFeaturesEXT");
    out << "\t\t" << "VkPhysicalDevicePipelineProtectedAccessFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAndroidHardwareBufferFormatResolvePropertiesANDROID(std::ostream &out, const VkAndroidHardwareBufferFormatResolvePropertiesANDROID* structInfo, Decoded_VkAndroidHardwareBufferFormatResolvePropertiesANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// colorAttachmentFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->colorAttachmentFormat << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "androidHardwareBufferFormatResolvePropertiesANDROID");
    out << "\t\t" << "VkAndroidHardwareBufferFormatResolvePropertiesANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(std::ostream &out, const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* structInfo, Decoded_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// externalFormatResolve
    struct_body << "\t\t\t" << structInfo->externalFormatResolve << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalFormatResolveFeaturesANDROID");
    out << "\t\t" << "VkPhysicalDeviceExternalFormatResolveFeaturesANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(std::ostream &out, const VkPhysicalDeviceExternalFormatResolvePropertiesANDROID* structInfo, Decoded_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// nullColorAttachmentWithExternalFormatResolve
    struct_body << "\t\t\t" << structInfo->nullColorAttachmentWithExternalFormatResolve << "," << std::endl;
// externalFormatResolveChromaOffsetX
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->externalFormatResolveChromaOffsetX << ")" << "," << std::endl;
// externalFormatResolveChromaOffsetY
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->externalFormatResolveChromaOffsetY << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalFormatResolvePropertiesANDROID");
    out << "\t\t" << "VkPhysicalDeviceExternalFormatResolvePropertiesANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderObjectFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderObjectFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderObjectFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderObject
    struct_body << "\t\t\t" << structInfo->shaderObject << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderObjectFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderObjectFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderObjectPropertiesEXT(std::ostream &out, const VkPhysicalDeviceShaderObjectPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceShaderObjectPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderBinaryUUID
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->shaderBinaryUUID[0]), VK_UUID_SIZE) << "," << std::endl;
// shaderBinaryVersion
    struct_body << "\t\t\t" << structInfo->shaderBinaryVersion << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderObjectPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderObjectPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkShaderCreateInfoEXT(std::ostream &out, const VkShaderCreateInfoEXT* structInfo, Decoded_VkShaderCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcode_array = "NULL";
    if (structInfo->pCode != NULL) {
        std::string pcode_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->codeSize; ++idx0) {
            pcode_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pCode)[idx0]) + ", ";
        }
        pcode_array = "pCode_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pcode_array << "[] = {" << pcode_values << "};" << std::endl;
    }
    std::string pset_layouts_array = "NULL";
    if (metaInfo->pSetLayouts.GetPointer() != NULL && structInfo->setLayoutCount > 0) {
        pset_layouts_array = "pset_layouts_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT));
        std::string pset_layouts_values = toStringJoin(metaInfo->pSetLayouts.GetPointer(),
                                                       metaInfo->pSetLayouts.GetPointer() + structInfo->setLayoutCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->setLayoutCount == 1) {
            pset_layouts_array = "&" + pset_layouts_values;
        } else if (structInfo->setLayoutCount > 1) {
            out << "\t\t" << "VkDescriptorSetLayout " << pset_layouts_array << "[] = {" << pset_layouts_values << "};" << std::endl;
        }
    }
    std::string ppush_constant_ranges_array = "NULL";
    if (structInfo->pPushConstantRanges != NULL) {
        ppush_constant_ranges_array = "pPushConstantRanges_" + std::to_string(consumer.GetNextId());
        std::string ppush_constant_ranges_names;
        for (uint32_t idx = 0; idx < structInfo->pushConstantRangeCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPushConstantRanges + idx != NULL) {
                variable_name = GenerateStruct_VkPushConstantRange(out,
                                                                   structInfo->pPushConstantRanges + idx,
                                                                   metaInfo->pPushConstantRanges->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            ppush_constant_ranges_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPushConstantRange " << ppush_constant_ranges_array << "[] = {" << ppush_constant_ranges_names << "};" << std::endl;
    }
    std::string pspecialization_info_struct = "NULL";
    if (structInfo->pSpecializationInfo != NULL) {
        pspecialization_info_struct = GenerateStruct_VkSpecializationInfo(out,
                                                                          structInfo->pSpecializationInfo,
                                                                          metaInfo->pSpecializationInfo->GetMetaStructPointer(),
                                                                          consumer);
        pspecialization_info_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkShaderCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
// stage
    struct_body << "\t\t\t" << "VkShaderStageFlagBits(" << structInfo->stage << ")" << "," << std::endl;
// nextStage
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->nextStage << ")" << "," << std::endl;
// codeType
    struct_body << "\t\t\t" << "VkShaderCodeTypeEXT(" << structInfo->codeType << ")" << "," << std::endl;
// codeSize
    struct_body << "\t\t\t" << structInfo->codeSize << "," << std::endl;
// pCode
    struct_body << "\t\t\t" << pcode_array << "," << std::endl;
// pName
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pName) << "," << std::endl;
// setLayoutCount
    struct_body << "\t\t\t" << structInfo->setLayoutCount << "," << std::endl;
// pSetLayouts
    struct_body << "\t\t\t" << pset_layouts_array << "," << std::endl;
// pushConstantRangeCount
    struct_body << "\t\t\t" << structInfo->pushConstantRangeCount << "," << std::endl;
// pPushConstantRanges
    struct_body << "\t\t\t" << ppush_constant_ranges_array << "," << std::endl;
// pSpecializationInfo
    struct_body << "\t\t\t" << pspecialization_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "shaderCreateInfoEXT");
    out << "\t\t" << "VkShaderCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTilePropertiesFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceTilePropertiesFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceTilePropertiesFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// tileProperties
    struct_body << "\t\t\t" << structInfo->tileProperties << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTilePropertiesFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceTilePropertiesFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTilePropertiesQCOM(std::ostream &out, const VkTilePropertiesQCOM* structInfo, Decoded_VkTilePropertiesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string tile_size_info_var = GenerateStruct_VkExtent3D(out,
                                                               &structInfo->tileSize,
                                                               metaInfo->tileSize,
                                                               consumer);
    std::string apron_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                &structInfo->apronSize,
                                                                metaInfo->apronSize,
                                                                consumer);
    std::string origin_info_var = GenerateStruct_VkOffset2D(out,
                                                            &structInfo->origin,
                                                            metaInfo->origin,
                                                            consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// tileSize
    struct_body << "\t\t\t" << tile_size_info_var << "," << std::endl;
// apronSize
    struct_body << "\t\t\t" << apron_size_info_var << "," << std::endl;
// origin
    struct_body << "\t\t\t" << origin_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "tilePropertiesQCOM");
    out << "\t\t" << "VkTilePropertiesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAmigoProfilingSubmitInfoSEC(std::ostream &out, const VkAmigoProfilingSubmitInfoSEC* structInfo, Decoded_VkAmigoProfilingSubmitInfoSEC* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// firstDrawTimestamp
    struct_body << "\t\t\t" << structInfo->firstDrawTimestamp << "UL" << "," << std::endl;
// swapBufferTimestamp
    struct_body << "\t\t\t" << structInfo->swapBufferTimestamp << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "amigoProfilingSubmitInfoSEC");
    out << "\t\t" << "VkAmigoProfilingSubmitInfoSEC " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceAmigoProfilingFeaturesSEC(std::ostream &out, const VkPhysicalDeviceAmigoProfilingFeaturesSEC* structInfo, Decoded_VkPhysicalDeviceAmigoProfilingFeaturesSEC* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// amigoProfiling
    struct_body << "\t\t\t" << structInfo->amigoProfiling << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceAmigoProfilingFeaturesSEC");
    out << "\t\t" << "VkPhysicalDeviceAmigoProfilingFeaturesSEC " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// multiviewPerViewViewports
    struct_body << "\t\t\t" << structInfo->multiviewPerViewViewports << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultiviewPerViewViewportsFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(std::ostream &out, const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* structInfo, Decoded_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// rayTracingInvocationReorder
    struct_body << "\t\t\t" << structInfo->rayTracingInvocationReorder << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingInvocationReorderFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(std::ostream &out, const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* structInfo, Decoded_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// rayTracingInvocationReorderReorderingHint
    struct_body << "\t\t\t" << "VkRayTracingInvocationReorderModeNV(" << structInfo->rayTracingInvocationReorderReorderingHint << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingInvocationReorderPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV(std::ostream &out, const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* structInfo, Decoded_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// extendedSparseAddressSpace
    struct_body << "\t\t\t" << structInfo->extendedSparseAddressSpace << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExtendedSparseAddressSpaceFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV(std::ostream &out, const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* structInfo, Decoded_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// extendedSparseAddressSpaceSize
    struct_body << "\t\t\t" << structInfo->extendedSparseAddressSpaceSize << "UL" << "," << std::endl;
// extendedSparseImageUsageFlags
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->extendedSparseImageUsageFlags << ")" << "," << std::endl;
// extendedSparseBufferUsageFlags
    struct_body << "\t\t\t" << "VkBufferUsageFlags(" << structInfo->extendedSparseBufferUsageFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExtendedSparseAddressSpacePropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkLayerSettingEXT(std::ostream &out, const VkLayerSettingEXT* structInfo, Decoded_VkLayerSettingEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pvalues_array = "NULL";
    if (structInfo->pValues != NULL) {
        std::string pvalues_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->valueCount; ++idx0) {
            pvalues_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pValues)[idx0]) + ", ";
        }
        pvalues_array = "pValues_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pvalues_array << "[] = {" << pvalues_values << "};" << std::endl;
    }
// pLayerName
    struct_body << "\t" << VulkanCppConsumerBase::ToEscape(structInfo->pLayerName) << "," << std::endl;
// pSettingName
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pSettingName) << "," << std::endl;
// type
    struct_body << "\t\t\t" << "VkLayerSettingTypeEXT(" << structInfo->type << ")" << "," << std::endl;
// valueCount
    struct_body << "\t\t\t" << structInfo->valueCount << "," << std::endl;
// pValues
    struct_body << "\t\t\t" << pvalues_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "layerSettingEXT");
    out << "\t\t" << "VkLayerSettingEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkLayerSettingsCreateInfoEXT(std::ostream &out, const VkLayerSettingsCreateInfoEXT* structInfo, Decoded_VkLayerSettingsCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string psettings_array = "NULL";
    if (structInfo->pSettings != NULL) {
        psettings_array = "pSettings_" + std::to_string(consumer.GetNextId());
        std::string psettings_names;
        for (uint32_t idx = 0; idx < structInfo->settingCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pSettings + idx != NULL) {
                variable_name = GenerateStruct_VkLayerSettingEXT(out,
                                                                 structInfo->pSettings + idx,
                                                                 metaInfo->pSettings->GetMetaStructPointer() + idx,
                                                                 consumer);
            }
            psettings_names += variable_name + ", ";
        }
        out << "\t\t" << "VkLayerSettingEXT " << psettings_array << "[] = {" << psettings_names << "};" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// settingCount
    struct_body << "\t\t\t" << structInfo->settingCount << "," << std::endl;
// pSettings
    struct_body << "\t\t\t" << psettings_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "layerSettingsCreateInfoEXT");
    out << "\t\t" << "VkLayerSettingsCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM(std::ostream &out, const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* structInfo, Decoded_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderCoreBuiltins
    struct_body << "\t\t\t" << structInfo->shaderCoreBuiltins << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderCoreBuiltinsFeaturesARM");
    out << "\t\t" << "VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM(std::ostream &out, const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* structInfo, Decoded_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderCoreMask
    struct_body << "\t\t\t" << structInfo->shaderCoreMask << "UL" << "," << std::endl;
// shaderCoreCount
    struct_body << "\t\t\t" << structInfo->shaderCoreCount << "," << std::endl;
// shaderWarpsPerCore
    struct_body << "\t\t\t" << structInfo->shaderWarpsPerCore << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderCoreBuiltinsPropertiesARM");
    out << "\t\t" << "VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(std::ostream &out, const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pipelineLibraryGroupHandles
    struct_body << "\t\t\t" << structInfo->pipelineLibraryGroupHandles << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineLibraryGroupHandlesFeaturesEXT");
    out << "\t\t" << "VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// dynamicRenderingUnusedAttachments
    struct_body << "\t\t\t" << structInfo->dynamicRenderingUnusedAttachments << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(std::ostream &out, const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* structInfo, Decoded_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pper_view_render_areas_array = "NULL";
    if (structInfo->pPerViewRenderAreas != NULL) {
        pper_view_render_areas_array = "pPerViewRenderAreas_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkRect2D " << pper_view_render_areas_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pPerViewRenderAreas, structInfo->perViewRenderAreaCount) << ";" << std::endl;
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// perViewRenderAreaCount
    struct_body << "\t\t\t" << structInfo->perViewRenderAreaCount << "," << std::endl;
// pPerViewRenderAreas
    struct_body << "\t\t\t" << pper_view_render_areas_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "multiviewPerViewRenderAreasRenderPassBeginInfoQCOM");
    out << "\t\t" << "VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// multiviewPerViewRenderAreas
    struct_body << "\t\t\t" << structInfo->multiviewPerViewRenderAreas << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageProcessing2FeaturesQCOM(std::ostream &out, const VkPhysicalDeviceImageProcessing2FeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceImageProcessing2FeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// textureBlockMatch2
    struct_body << "\t\t\t" << structInfo->textureBlockMatch2 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageProcessing2FeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceImageProcessing2FeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageProcessing2PropertiesQCOM(std::ostream &out, const VkPhysicalDeviceImageProcessing2PropertiesQCOM* structInfo, Decoded_VkPhysicalDeviceImageProcessing2PropertiesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string max_block_match_window_info_var = GenerateStruct_VkExtent2D(out,
                                                                            &structInfo->maxBlockMatchWindow,
                                                                            metaInfo->maxBlockMatchWindow,
                                                                            consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxBlockMatchWindow
    struct_body << "\t\t\t" << max_block_match_window_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageProcessing2PropertiesQCOM");
    out << "\t\t" << "VkPhysicalDeviceImageProcessing2PropertiesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerBlockMatchWindowCreateInfoQCOM(std::ostream &out, const VkSamplerBlockMatchWindowCreateInfoQCOM* structInfo, Decoded_VkSamplerBlockMatchWindowCreateInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string window_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                   &structInfo->windowExtent,
                                                                   metaInfo->windowExtent,
                                                                   consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// windowExtent
    struct_body << "\t\t\t" << window_extent_info_var << "," << std::endl;
// windowCompareMode
    struct_body << "\t\t\t" << "VkBlockMatchWindowCompareModeQCOM(" << structInfo->windowCompareMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerBlockMatchWindowCreateInfoQCOM");
    out << "\t\t" << "VkSamplerBlockMatchWindowCreateInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBlitImageCubicWeightsInfoQCOM(std::ostream &out, const VkBlitImageCubicWeightsInfoQCOM* structInfo, Decoded_VkBlitImageCubicWeightsInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// cubicWeights
    struct_body << "\t\t\t" << "VkCubicFilterWeightsQCOM(" << structInfo->cubicWeights << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "blitImageCubicWeightsInfoQCOM");
    out << "\t\t" << "VkBlitImageCubicWeightsInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCubicWeightsFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceCubicWeightsFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceCubicWeightsFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// selectableCubicWeights
    struct_body << "\t\t\t" << structInfo->selectableCubicWeights << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCubicWeightsFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceCubicWeightsFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerCubicWeightsCreateInfoQCOM(std::ostream &out, const VkSamplerCubicWeightsCreateInfoQCOM* structInfo, Decoded_VkSamplerCubicWeightsCreateInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// cubicWeights
    struct_body << "\t\t\t" << "VkCubicFilterWeightsQCOM(" << structInfo->cubicWeights << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerCubicWeightsCreateInfoQCOM");
    out << "\t\t" << "VkSamplerCubicWeightsCreateInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// ycbcrDegamma
    struct_body << "\t\t\t" << structInfo->ycbcrDegamma << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceYcbcrDegammaFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceYcbcrDegammaFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM(std::ostream &out, const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* structInfo, Decoded_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// enableYDegamma
    struct_body << "\t\t\t" << structInfo->enableYDegamma << "," << std::endl;
// enableCbCrDegamma
    struct_body << "\t\t\t" << structInfo->enableCbCrDegamma << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerYcbcrConversionYcbcrDegammaCreateInfoQCOM");
    out << "\t\t" << "VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCubicClampFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceCubicClampFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceCubicClampFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// cubicRangeClamp
    struct_body << "\t\t\t" << structInfo->cubicRangeClamp << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCubicClampFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceCubicClampFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(std::ostream &out, const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// attachmentFeedbackLoopDynamicState
    struct_body << "\t\t\t" << structInfo->attachmentFeedbackLoopDynamicState << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLayeredDriverPropertiesMSFT(std::ostream &out, const VkPhysicalDeviceLayeredDriverPropertiesMSFT* structInfo, Decoded_VkPhysicalDeviceLayeredDriverPropertiesMSFT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// underlyingAPI
    struct_body << "\t\t\t" << "VkLayeredDriverUnderlyingApiMSFT(" << structInfo->underlyingAPI << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLayeredDriverPropertiesMSFT");
    out << "\t\t" << "VkPhysicalDeviceLayeredDriverPropertiesMSFT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV(std::ostream &out, const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// descriptorPoolOverallocation
    struct_body << "\t\t\t" << structInfo->descriptorPoolOverallocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDescriptorPoolOverallocationFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureBuildGeometryInfoKHR(std::ostream &out, const VkAccelerationStructureBuildGeometryInfoKHR* structInfo, Decoded_VkAccelerationStructureBuildGeometryInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pgeometries_array = "NULL";
    if (structInfo->pGeometries != NULL) {
        pgeometries_array = "pGeometries_" + std::to_string(consumer.GetNextId());
        std::string pgeometries_names;
        for (uint32_t idx = 0; idx < structInfo->geometryCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pGeometries + idx != NULL) {
                variable_name = GenerateStruct_VkAccelerationStructureGeometryKHR(out,
                                                                                  structInfo->pGeometries + idx,
                                                                                  metaInfo->pGeometries->GetMetaStructPointer() + idx,
                                                                                  consumer);
            }
            pgeometries_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAccelerationStructureGeometryKHR " << pgeometries_array << "[] = {" << pgeometries_names << "};" << std::endl;
    }
    std::string pp_geometries_array = "NULL";
    if (structInfo->ppGeometries != NULL) {
        pp_geometries_array = "ppGeometries_" + std::to_string(consumer.GetNextId());
        std::string pp_geometries_names;
        for (uint32_t idx0 = 0; idx0 < structInfo->geometryCount; ++idx0) {
            for (uint32_t idx1 = 0; idx1 < 1; ++idx1) {
                std::string variable_name = "NULL";
                variable_name = GenerateStruct_VkAccelerationStructureGeometryKHR(out,
                                                                                  &(structInfo->ppGeometries[idx0][idx1]),
                                                                                  &(metaInfo->ppGeometries->GetMetaStructPointer()[idx0][idx1]),
                                                                                  consumer);
                pp_geometries_names += variable_name + ", ";
            }
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// type
    struct_body << "\t\t\t" << "VkAccelerationStructureTypeKHR(" << structInfo->type << ")" << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkBuildAccelerationStructureFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
// mode
    struct_body << "\t\t\t" << "VkBuildAccelerationStructureModeKHR(" << structInfo->mode << ")" << "," << std::endl;
// srcAccelerationStructure
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcAccelerationStructure) << "," << std::endl;
// dstAccelerationStructure
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstAccelerationStructure) << "," << std::endl;
// geometryCount
    struct_body << "\t\t\t" << structInfo->geometryCount << "," << std::endl;
// pGeometries
    struct_body << "\t\t\t" << pgeometries_array << "," << std::endl;
// ppGeometries
    struct_body << "\t\t\t" << pp_geometries_array << "," << std::endl;
// scratchData
    struct_body << "\t\t\t" << structInfo->scratchData.deviceAddress << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureBuildGeometryInfoKHR");
    out << "\t\t" << "VkAccelerationStructureBuildGeometryInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureBuildRangeInfoKHR(std::ostream &out, const VkAccelerationStructureBuildRangeInfoKHR* structInfo, Decoded_VkAccelerationStructureBuildRangeInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// primitiveCount
    struct_body << "\t" << structInfo->primitiveCount << "," << std::endl;
// primitiveOffset
    struct_body << "\t\t\t" << structInfo->primitiveOffset << "," << std::endl;
// firstVertex
    struct_body << "\t\t\t" << structInfo->firstVertex << "," << std::endl;
// transformOffset
    struct_body << "\t\t\t" << structInfo->transformOffset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureBuildRangeInfoKHR");
    out << "\t\t" << "VkAccelerationStructureBuildRangeInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureBuildSizesInfoKHR(std::ostream &out, const VkAccelerationStructureBuildSizesInfoKHR* structInfo, Decoded_VkAccelerationStructureBuildSizesInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// accelerationStructureSize
    struct_body << "\t\t\t" << structInfo->accelerationStructureSize << "UL" << "," << std::endl;
// updateScratchSize
    struct_body << "\t\t\t" << structInfo->updateScratchSize << "UL" << "," << std::endl;
// buildScratchSize
    struct_body << "\t\t\t" << structInfo->buildScratchSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureBuildSizesInfoKHR");
    out << "\t\t" << "VkAccelerationStructureBuildSizesInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureCreateInfoKHR(std::ostream &out, const VkAccelerationStructureCreateInfoKHR* structInfo, Decoded_VkAccelerationStructureCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// createFlags
    struct_body << "\t\t\t" << "VkAccelerationStructureCreateFlagsKHR(" << structInfo->createFlags << ")" << "," << std::endl;
// buffer
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
// offset
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
// type
    struct_body << "\t\t\t" << "VkAccelerationStructureTypeKHR(" << structInfo->type << ")" << "," << std::endl;
// deviceAddress
    struct_body << "\t\t\t" << structInfo->deviceAddress << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureCreateInfoKHR");
    out << "\t\t" << "VkAccelerationStructureCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureDeviceAddressInfoKHR(std::ostream &out, const VkAccelerationStructureDeviceAddressInfoKHR* structInfo, Decoded_VkAccelerationStructureDeviceAddressInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// accelerationStructure
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->accelerationStructure) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureDeviceAddressInfoKHR");
    out << "\t\t" << "VkAccelerationStructureDeviceAddressInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureGeometryAabbsDataKHR(std::ostream &out, const VkAccelerationStructureGeometryAabbsDataKHR* structInfo, Decoded_VkAccelerationStructureGeometryAabbsDataKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// data
    struct_body << "\t\t\t" << structInfo->data.deviceAddress << "," << std::endl;
// stride
    struct_body << "\t\t\t" << structInfo->stride << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureGeometryAabbsDataKHR");
    out << "\t\t" << "VkAccelerationStructureGeometryAabbsDataKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureGeometryInstancesDataKHR(std::ostream &out, const VkAccelerationStructureGeometryInstancesDataKHR* structInfo, Decoded_VkAccelerationStructureGeometryInstancesDataKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// arrayOfPointers
    struct_body << "\t\t\t" << structInfo->arrayOfPointers << "," << std::endl;
// data
    struct_body << "\t\t\t" << structInfo->data.deviceAddress << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureGeometryInstancesDataKHR");
    out << "\t\t" << "VkAccelerationStructureGeometryInstancesDataKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureGeometryTrianglesDataKHR(std::ostream &out, const VkAccelerationStructureGeometryTrianglesDataKHR* structInfo, Decoded_VkAccelerationStructureGeometryTrianglesDataKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// vertexFormat
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->vertexFormat << ")" << "," << std::endl;
// vertexData
    struct_body << "\t\t\t" << structInfo->vertexData.deviceAddress << "," << std::endl;
// vertexStride
    struct_body << "\t\t\t" << structInfo->vertexStride << "UL" << "," << std::endl;
// maxVertex
    struct_body << "\t\t\t" << structInfo->maxVertex << "," << std::endl;
// indexType
    struct_body << "\t\t\t" << "VkIndexType(" << structInfo->indexType << ")" << "," << std::endl;
// indexData
    struct_body << "\t\t\t" << structInfo->indexData.deviceAddress << "," << std::endl;
// transformData
    struct_body << "\t\t\t" << structInfo->transformData.deviceAddress << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureGeometryTrianglesDataKHR");
    out << "\t\t" << "VkAccelerationStructureGeometryTrianglesDataKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureVersionInfoKHR(std::ostream &out, const VkAccelerationStructureVersionInfoKHR* structInfo, Decoded_VkAccelerationStructureVersionInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pversion_data_array = "NULL";
    std::string pversion_data_values;
    for (uint32_t idx0 = 0; idx0 < 2*VK_UUID_SIZE; ++idx0) {
        pversion_data_values += std::to_string(structInfo->pVersionData[idx0]) + ", ";
    }
    pversion_data_array = "pVersionData_" + std::to_string(consumer.GetNextId());
    out << "\t\t" << "uint8_t " << pversion_data_array << "[] = {" << pversion_data_values << "};" << std::endl;
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// pVersionData
    struct_body << "\t\t\t" << pversion_data_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureVersionInfoKHR");
    out << "\t\t" << "VkAccelerationStructureVersionInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyAccelerationStructureInfoKHR(std::ostream &out, const VkCopyAccelerationStructureInfoKHR* structInfo, Decoded_VkCopyAccelerationStructureInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// src
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->src) << "," << std::endl;
// dst
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dst) << "," << std::endl;
// mode
    struct_body << "\t\t\t" << "VkCopyAccelerationStructureModeKHR(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyAccelerationStructureInfoKHR");
    out << "\t\t" << "VkCopyAccelerationStructureInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyAccelerationStructureToMemoryInfoKHR(std::ostream &out, const VkCopyAccelerationStructureToMemoryInfoKHR* structInfo, Decoded_VkCopyAccelerationStructureToMemoryInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// src
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->src) << "," << std::endl;
// dst
    struct_body << "\t\t\t" << structInfo->dst.deviceAddress << "," << std::endl;
// mode
    struct_body << "\t\t\t" << "VkCopyAccelerationStructureModeKHR(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyAccelerationStructureToMemoryInfoKHR");
    out << "\t\t" << "VkCopyAccelerationStructureToMemoryInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyMemoryToAccelerationStructureInfoKHR(std::ostream &out, const VkCopyMemoryToAccelerationStructureInfoKHR* structInfo, Decoded_VkCopyMemoryToAccelerationStructureInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// src
    struct_body << "\t\t\t" << structInfo->src.deviceAddress << "," << std::endl;
// dst
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dst) << "," << std::endl;
// mode
    struct_body << "\t\t\t" << "VkCopyAccelerationStructureModeKHR(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyMemoryToAccelerationStructureInfoKHR");
    out << "\t\t" << "VkCopyMemoryToAccelerationStructureInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceAccelerationStructureFeaturesKHR(std::ostream &out, const VkPhysicalDeviceAccelerationStructureFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceAccelerationStructureFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// accelerationStructure
    struct_body << "\t\t\t" << structInfo->accelerationStructure << "," << std::endl;
// accelerationStructureCaptureReplay
    struct_body << "\t\t\t" << structInfo->accelerationStructureCaptureReplay << "," << std::endl;
// accelerationStructureIndirectBuild
    struct_body << "\t\t\t" << structInfo->accelerationStructureIndirectBuild << "," << std::endl;
// accelerationStructureHostCommands
    struct_body << "\t\t\t" << structInfo->accelerationStructureHostCommands << "," << std::endl;
// descriptorBindingAccelerationStructureUpdateAfterBind
    struct_body << "\t\t\t" << structInfo->descriptorBindingAccelerationStructureUpdateAfterBind << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceAccelerationStructureFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceAccelerationStructureFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceAccelerationStructurePropertiesKHR(std::ostream &out, const VkPhysicalDeviceAccelerationStructurePropertiesKHR* structInfo, Decoded_VkPhysicalDeviceAccelerationStructurePropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxGeometryCount
    struct_body << "\t\t\t" << structInfo->maxGeometryCount << "UL" << "," << std::endl;
// maxInstanceCount
    struct_body << "\t\t\t" << structInfo->maxInstanceCount << "UL" << "," << std::endl;
// maxPrimitiveCount
    struct_body << "\t\t\t" << structInfo->maxPrimitiveCount << "UL" << "," << std::endl;
// maxPerStageDescriptorAccelerationStructures
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorAccelerationStructures << "," << std::endl;
// maxPerStageDescriptorUpdateAfterBindAccelerationStructures
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindAccelerationStructures << "," << std::endl;
// maxDescriptorSetAccelerationStructures
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetAccelerationStructures << "," << std::endl;
// maxDescriptorSetUpdateAfterBindAccelerationStructures
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindAccelerationStructures << "," << std::endl;
// minAccelerationStructureScratchOffsetAlignment
    struct_body << "\t\t\t" << structInfo->minAccelerationStructureScratchOffsetAlignment << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceAccelerationStructurePropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceAccelerationStructurePropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWriteDescriptorSetAccelerationStructureKHR(std::ostream &out, const VkWriteDescriptorSetAccelerationStructureKHR* structInfo, Decoded_VkWriteDescriptorSetAccelerationStructureKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pacceleration_structures_array = "NULL";
    if (metaInfo->pAccelerationStructures.GetPointer() != NULL && structInfo->accelerationStructureCount > 0) {
        pacceleration_structures_array = "pacceleration_structures_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR));
        std::string pacceleration_structures_values = toStringJoin(metaInfo->pAccelerationStructures.GetPointer(),
                                                                   metaInfo->pAccelerationStructures.GetPointer() + structInfo->accelerationStructureCount,
                                                                   [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                                   ", ");
        if (structInfo->accelerationStructureCount == 1) {
            pacceleration_structures_array = "&" + pacceleration_structures_values;
        } else if (structInfo->accelerationStructureCount > 1) {
            out << "\t\t" << "VkAccelerationStructureKHR " << pacceleration_structures_array << "[] = {" << pacceleration_structures_values << "};" << std::endl;
        }
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// accelerationStructureCount
    struct_body << "\t\t\t" << structInfo->accelerationStructureCount << "," << std::endl;
// pAccelerationStructures
    struct_body << "\t\t\t" << pacceleration_structures_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "writeDescriptorSetAccelerationStructureKHR");
    out << "\t\t" << "VkWriteDescriptorSetAccelerationStructureKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(std::ostream &out, const VkPhysicalDeviceRayTracingPipelineFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceRayTracingPipelineFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// rayTracingPipeline
    struct_body << "\t\t\t" << structInfo->rayTracingPipeline << "," << std::endl;
// rayTracingPipelineShaderGroupHandleCaptureReplay
    struct_body << "\t\t\t" << structInfo->rayTracingPipelineShaderGroupHandleCaptureReplay << "," << std::endl;
// rayTracingPipelineShaderGroupHandleCaptureReplayMixed
    struct_body << "\t\t\t" << structInfo->rayTracingPipelineShaderGroupHandleCaptureReplayMixed << "," << std::endl;
// rayTracingPipelineTraceRaysIndirect
    struct_body << "\t\t\t" << structInfo->rayTracingPipelineTraceRaysIndirect << "," << std::endl;
// rayTraversalPrimitiveCulling
    struct_body << "\t\t\t" << structInfo->rayTraversalPrimitiveCulling << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingPipelineFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceRayTracingPipelineFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(std::ostream &out, const VkPhysicalDeviceRayTracingPipelinePropertiesKHR* structInfo, Decoded_VkPhysicalDeviceRayTracingPipelinePropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// shaderGroupHandleSize
    struct_body << "\t\t\t" << structInfo->shaderGroupHandleSize << "," << std::endl;
// maxRayRecursionDepth
    struct_body << "\t\t\t" << structInfo->maxRayRecursionDepth << "," << std::endl;
// maxShaderGroupStride
    struct_body << "\t\t\t" << structInfo->maxShaderGroupStride << "," << std::endl;
// shaderGroupBaseAlignment
    struct_body << "\t\t\t" << structInfo->shaderGroupBaseAlignment << "," << std::endl;
// shaderGroupHandleCaptureReplaySize
    struct_body << "\t\t\t" << structInfo->shaderGroupHandleCaptureReplaySize << "," << std::endl;
// maxRayDispatchInvocationCount
    struct_body << "\t\t\t" << structInfo->maxRayDispatchInvocationCount << "," << std::endl;
// shaderGroupHandleAlignment
    struct_body << "\t\t\t" << structInfo->shaderGroupHandleAlignment << "," << std::endl;
// maxRayHitAttributeSize
    struct_body << "\t\t\t" << structInfo->maxRayHitAttributeSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingPipelinePropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceRayTracingPipelinePropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRayTracingPipelineCreateInfoKHR(std::ostream &out, const VkRayTracingPipelineCreateInfoKHR* structInfo, Decoded_VkRayTracingPipelineCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstages_array = "NULL";
    if (structInfo->pStages != NULL) {
        pstages_array = "pStages_" + std::to_string(consumer.GetNextId());
        std::string pstages_names;
        for (uint32_t idx = 0; idx < structInfo->stageCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStages + idx != NULL) {
                variable_name = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                                               structInfo->pStages + idx,
                                                                               metaInfo->pStages->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pstages_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPipelineShaderStageCreateInfo " << pstages_array << "[] = {" << pstages_names << "};" << std::endl;
    }
    std::string pgroups_array = "NULL";
    if (structInfo->pGroups != NULL) {
        pgroups_array = "pGroups_" + std::to_string(consumer.GetNextId());
        std::string pgroups_names;
        for (uint32_t idx = 0; idx < structInfo->groupCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pGroups + idx != NULL) {
                variable_name = GenerateStruct_VkRayTracingShaderGroupCreateInfoKHR(out,
                                                                                    structInfo->pGroups + idx,
                                                                                    metaInfo->pGroups->GetMetaStructPointer() + idx,
                                                                                    consumer);
            }
            pgroups_names += variable_name + ", ";
        }
        out << "\t\t" << "VkRayTracingShaderGroupCreateInfoKHR " << pgroups_array << "[] = {" << pgroups_names << "};" << std::endl;
    }
    std::string plibrary_info_struct = "NULL";
    if (structInfo->pLibraryInfo != NULL) {
        plibrary_info_struct = GenerateStruct_VkPipelineLibraryCreateInfoKHR(out,
                                                                             structInfo->pLibraryInfo,
                                                                             metaInfo->pLibraryInfo->GetMetaStructPointer(),
                                                                             consumer);
        plibrary_info_struct.insert(0, "&");
    }
    std::string plibrary_interface_struct = "NULL";
    if (structInfo->pLibraryInterface != NULL) {
        plibrary_interface_struct = GenerateStruct_VkRayTracingPipelineInterfaceCreateInfoKHR(out,
                                                                                              structInfo->pLibraryInterface,
                                                                                              metaInfo->pLibraryInterface->GetMetaStructPointer(),
                                                                                              consumer);
        plibrary_interface_struct.insert(0, "&");
    }
    std::string pdynamic_state_struct = "NULL";
    if (structInfo->pDynamicState != NULL) {
        pdynamic_state_struct = GenerateStruct_VkPipelineDynamicStateCreateInfo(out,
                                                                                structInfo->pDynamicState,
                                                                                metaInfo->pDynamicState->GetMetaStructPointer(),
                                                                                consumer);
        pdynamic_state_struct.insert(0, "&");
    }
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// flags
    struct_body << "\t\t\t" << "VkPipelineCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
// stageCount
    struct_body << "\t\t\t" << structInfo->stageCount << "," << std::endl;
// pStages
    struct_body << "\t\t\t" << pstages_array << "," << std::endl;
// groupCount
    struct_body << "\t\t\t" << structInfo->groupCount << "," << std::endl;
// pGroups
    struct_body << "\t\t\t" << pgroups_array << "," << std::endl;
// maxPipelineRayRecursionDepth
    struct_body << "\t\t\t" << structInfo->maxPipelineRayRecursionDepth << "," << std::endl;
// pLibraryInfo
    struct_body << "\t\t\t" << plibrary_info_struct << "," << std::endl;
// pLibraryInterface
    struct_body << "\t\t\t" << plibrary_interface_struct << "," << std::endl;
// pDynamicState
    struct_body << "\t\t\t" << pdynamic_state_struct << "," << std::endl;
// layout
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->layout) << "," << std::endl;
// basePipelineHandle
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->basePipelineHandle) << "," << std::endl;
// basePipelineIndex
    struct_body << "\t\t\t" << structInfo->basePipelineIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "rayTracingPipelineCreateInfoKHR");
    out << "\t\t" << "VkRayTracingPipelineCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRayTracingPipelineInterfaceCreateInfoKHR(std::ostream &out, const VkRayTracingPipelineInterfaceCreateInfoKHR* structInfo, Decoded_VkRayTracingPipelineInterfaceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxPipelineRayPayloadSize
    struct_body << "\t\t\t" << structInfo->maxPipelineRayPayloadSize << "," << std::endl;
// maxPipelineRayHitAttributeSize
    struct_body << "\t\t\t" << structInfo->maxPipelineRayHitAttributeSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "rayTracingPipelineInterfaceCreateInfoKHR");
    out << "\t\t" << "VkRayTracingPipelineInterfaceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRayTracingShaderGroupCreateInfoKHR(std::ostream &out, const VkRayTracingShaderGroupCreateInfoKHR* structInfo, Decoded_VkRayTracingShaderGroupCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// type
    struct_body << "\t\t\t" << "VkRayTracingShaderGroupTypeKHR(" << structInfo->type << ")" << "," << std::endl;
// generalShader
    struct_body << "\t\t\t" << structInfo->generalShader << "," << std::endl;
// closestHitShader
    struct_body << "\t\t\t" << structInfo->closestHitShader << "," << std::endl;
// anyHitShader
    struct_body << "\t\t\t" << structInfo->anyHitShader << "," << std::endl;
// intersectionShader
    struct_body << "\t\t\t" << structInfo->intersectionShader << "," << std::endl;
// pShaderGroupCaptureReplayHandle
    struct_body << "\t\t\t" << structInfo->pShaderGroupCaptureReplayHandle << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "rayTracingShaderGroupCreateInfoKHR");
    out << "\t\t" << "VkRayTracingShaderGroupCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkStridedDeviceAddressRegionKHR(std::ostream &out, const VkStridedDeviceAddressRegionKHR* structInfo, Decoded_VkStridedDeviceAddressRegionKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// deviceAddress
    struct_body << "\t" << structInfo->deviceAddress << "UL" << "," << std::endl;
// stride
    struct_body << "\t\t\t" << structInfo->stride << "UL" << "," << std::endl;
// size
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stridedDeviceAddressRegionKHR");
    out << "\t\t" << "VkStridedDeviceAddressRegionKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTraceRaysIndirectCommandKHR(std::ostream &out, const VkTraceRaysIndirectCommandKHR* structInfo, Decoded_VkTraceRaysIndirectCommandKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// width
    struct_body << "\t" << structInfo->width << "," << std::endl;
// height
    struct_body << "\t\t\t" << structInfo->height << "," << std::endl;
// depth
    struct_body << "\t\t\t" << structInfo->depth << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "traceRaysIndirectCommandKHR");
    out << "\t\t" << "VkTraceRaysIndirectCommandKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayQueryFeaturesKHR(std::ostream &out, const VkPhysicalDeviceRayQueryFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceRayQueryFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// rayQuery
    struct_body << "\t\t\t" << structInfo->rayQuery << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayQueryFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceRayQueryFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrawMeshTasksIndirectCommandEXT(std::ostream &out, const VkDrawMeshTasksIndirectCommandEXT* structInfo, Decoded_VkDrawMeshTasksIndirectCommandEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
// groupCountX
    struct_body << "\t" << structInfo->groupCountX << "," << std::endl;
// groupCountY
    struct_body << "\t\t\t" << structInfo->groupCountY << "," << std::endl;
// groupCountZ
    struct_body << "\t\t\t" << structInfo->groupCountZ << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drawMeshTasksIndirectCommandEXT");
    out << "\t\t" << "VkDrawMeshTasksIndirectCommandEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMeshShaderFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMeshShaderFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMeshShaderFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// taskShader
    struct_body << "\t\t\t" << structInfo->taskShader << "," << std::endl;
// meshShader
    struct_body << "\t\t\t" << structInfo->meshShader << "," << std::endl;
// multiviewMeshShader
    struct_body << "\t\t\t" << structInfo->multiviewMeshShader << "," << std::endl;
// primitiveFragmentShadingRateMeshShader
    struct_body << "\t\t\t" << structInfo->primitiveFragmentShadingRateMeshShader << "," << std::endl;
// meshShaderQueries
    struct_body << "\t\t\t" << structInfo->meshShaderQueries << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMeshShaderFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceMeshShaderFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMeshShaderPropertiesEXT(std::ostream &out, const VkPhysicalDeviceMeshShaderPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceMeshShaderPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
// sType
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
// pNext
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
// maxTaskWorkGroupTotalCount
    struct_body << "\t\t\t" << structInfo->maxTaskWorkGroupTotalCount << "," << std::endl;
// maxTaskWorkGroupCount
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxTaskWorkGroupCount[0]), 3) << "," << std::endl;
// maxTaskWorkGroupInvocations
    struct_body << "\t\t\t" << structInfo->maxTaskWorkGroupInvocations << "," << std::endl;
// maxTaskWorkGroupSize
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxTaskWorkGroupSize[0]), 3) << "," << std::endl;
// maxTaskPayloadSize
    struct_body << "\t\t\t" << structInfo->maxTaskPayloadSize << "," << std::endl;
// maxTaskSharedMemorySize
    struct_body << "\t\t\t" << structInfo->maxTaskSharedMemorySize << "," << std::endl;
// maxTaskPayloadAndSharedMemorySize
    struct_body << "\t\t\t" << structInfo->maxTaskPayloadAndSharedMemorySize << "," << std::endl;
// maxMeshWorkGroupTotalCount
    struct_body << "\t\t\t" << structInfo->maxMeshWorkGroupTotalCount << "," << std::endl;
// maxMeshWorkGroupCount
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxMeshWorkGroupCount[0]), 3) << "," << std::endl;
// maxMeshWorkGroupInvocations
    struct_body << "\t\t\t" << structInfo->maxMeshWorkGroupInvocations << "," << std::endl;
// maxMeshWorkGroupSize
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxMeshWorkGroupSize[0]), 3) << "," << std::endl;
// maxMeshSharedMemorySize
    struct_body << "\t\t\t" << structInfo->maxMeshSharedMemorySize << "," << std::endl;
// maxMeshPayloadAndSharedMemorySize
    struct_body << "\t\t\t" << structInfo->maxMeshPayloadAndSharedMemorySize << "," << std::endl;
// maxMeshOutputMemorySize
    struct_body << "\t\t\t" << structInfo->maxMeshOutputMemorySize << "," << std::endl;
// maxMeshPayloadAndOutputMemorySize
    struct_body << "\t\t\t" << structInfo->maxMeshPayloadAndOutputMemorySize << "," << std::endl;
// maxMeshOutputComponents
    struct_body << "\t\t\t" << structInfo->maxMeshOutputComponents << "," << std::endl;
// maxMeshOutputVertices
    struct_body << "\t\t\t" << structInfo->maxMeshOutputVertices << "," << std::endl;
// maxMeshOutputPrimitives
    struct_body << "\t\t\t" << structInfo->maxMeshOutputPrimitives << "," << std::endl;
// maxMeshOutputLayers
    struct_body << "\t\t\t" << structInfo->maxMeshOutputLayers << "," << std::endl;
// maxMeshMultiviewViewCount
    struct_body << "\t\t\t" << structInfo->maxMeshMultiviewViewCount << "," << std::endl;
// meshOutputPerVertexGranularity
    struct_body << "\t\t\t" << structInfo->meshOutputPerVertexGranularity << "," << std::endl;
// meshOutputPerPrimitiveGranularity
    struct_body << "\t\t\t" << structInfo->meshOutputPerPrimitiveGranularity << "," << std::endl;
// maxPreferredTaskWorkGroupInvocations
    struct_body << "\t\t\t" << structInfo->maxPreferredTaskWorkGroupInvocations << "," << std::endl;
// maxPreferredMeshWorkGroupInvocations
    struct_body << "\t\t\t" << structInfo->maxPreferredMeshWorkGroupInvocations << "," << std::endl;
// prefersLocalInvocationVertexOutput
    struct_body << "\t\t\t" << structInfo->prefersLocalInvocationVertexOutput << "," << std::endl;
// prefersLocalInvocationPrimitiveOutput
    struct_body << "\t\t\t" << structInfo->prefersLocalInvocationPrimitiveOutput << "," << std::endl;
// prefersCompactVertexOutput
    struct_body << "\t\t\t" << structInfo->prefersCompactVertexOutput << "," << std::endl;
// prefersCompactPrimitiveOutput
    struct_body << "\t\t\t" << structInfo->prefersCompactPrimitiveOutput << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMeshShaderPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceMeshShaderPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


GFXRECON_END_NAMESPACE(decode)
GFXRECON_END_NAMESPACE(gfxrecon)

