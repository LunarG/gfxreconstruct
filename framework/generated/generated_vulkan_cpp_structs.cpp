/*
** Copyright (c) 2021 Samsung
** Copyright (c) 2023 Google
** Copyright (c) 2023 LunarG, Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following conditions:
**
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
** FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
*/

/*
** This file is generated from the Khronos Vulkan XML API Registry.
**
*/

#include "decode/vulkan_cpp_structs.h"
#include "generated/generated_vulkan_cpp_structs.h"
#include "generated/generated_vulkan_cpp_consumer.h"
#include "generated/generated_vulkan_cpp_consumer_extension.h"
#include "generated/generated_vulkan_enum_to_string.h"

GFXRECON_BEGIN_NAMESPACE(gfxrecon)
GFXRECON_BEGIN_NAMESPACE(decode)

std::string GenerateStruct_StdVideoAV1CDEF(std::ostream &out, const StdVideoAV1CDEF* structInfo, Decoded_StdVideoAV1CDEF* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << std::to_string(structInfo->cdef_damping_minus_3) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->cdef_bits) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->cdef_y_pri_strength[0]), STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->cdef_y_sec_strength[0]), STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->cdef_uv_pri_strength[0]), STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->cdef_uv_sec_strength[0]), STD_VIDEO_AV1_MAX_CDEF_FILTER_STRENGTHS) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1CDEF");
    out << "\t\t" << "StdVideoAV1CDEF " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1ColorConfig(std::ostream &out, const StdVideoAV1ColorConfig* structInfo, Decoded_StdVideoAV1ColorConfig* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoAV1ColorConfigFlags(out,
                                                                            &structInfo->flags,
                                                                            metaInfo->flags,
                                                                            consumer);
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->BitDepth) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->subsampling_x) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->subsampling_y) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1ColorPrimaries(" << structInfo->color_primaries << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1TransferCharacteristics(" << structInfo->transfer_characteristics << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1MatrixCoefficients(" << structInfo->matrix_coefficients << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1ChromaSamplePosition(" << structInfo->chroma_sample_position << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1ColorConfig");
    out << "\t\t" << "StdVideoAV1ColorConfig " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1ColorConfigFlags(std::ostream &out, const StdVideoAV1ColorConfigFlags* structInfo, Decoded_StdVideoAV1ColorConfigFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->mono_chrome << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->color_range << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->separate_uv_delta_q << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->color_description_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1ColorConfigFlags");
    out << "\t\t" << "StdVideoAV1ColorConfigFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1FilmGrain(std::ostream &out, const StdVideoAV1FilmGrain* structInfo, Decoded_StdVideoAV1FilmGrain* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoAV1FilmGrainFlags(out,
                                                                          &structInfo->flags,
                                                                          metaInfo->flags,
                                                                          consumer);
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->grain_scaling_minus_8) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->ar_coeff_lag) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->ar_coeff_shift_minus_6) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->grain_scale_shift) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->grain_seed << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->film_grain_params_ref_idx) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->num_y_points) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->point_y_value[0]), STD_VIDEO_AV1_MAX_NUM_Y_POINTS) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->point_y_scaling[0]), STD_VIDEO_AV1_MAX_NUM_Y_POINTS) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->num_cb_points) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->point_cb_value[0]), STD_VIDEO_AV1_MAX_NUM_CB_POINTS) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->point_cb_scaling[0]), STD_VIDEO_AV1_MAX_NUM_CB_POINTS) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->num_cr_points) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->point_cr_value[0]), STD_VIDEO_AV1_MAX_NUM_CR_POINTS) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->point_cr_scaling[0]), STD_VIDEO_AV1_MAX_NUM_CR_POINTS) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->ar_coeffs_y_plus_128[0]), STD_VIDEO_AV1_MAX_NUM_POS_LUMA) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->ar_coeffs_cb_plus_128[0]), STD_VIDEO_AV1_MAX_NUM_POS_CHROMA) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->ar_coeffs_cr_plus_128[0]), STD_VIDEO_AV1_MAX_NUM_POS_CHROMA) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->cb_mult) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->cb_luma_mult) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cb_offset << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->cr_mult) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->cr_luma_mult) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cr_offset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1FilmGrain");
    out << "\t\t" << "StdVideoAV1FilmGrain " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1FilmGrainFlags(std::ostream &out, const StdVideoAV1FilmGrainFlags* structInfo, Decoded_StdVideoAV1FilmGrainFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->chroma_scaling_from_luma << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->overlap_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->clip_to_restricted_range << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->update_grain << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1FilmGrainFlags");
    out << "\t\t" << "StdVideoAV1FilmGrainFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1GlobalMotion(std::ostream &out, const StdVideoAV1GlobalMotion* structInfo, Decoded_StdVideoAV1GlobalMotion* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->GmType[0]), STD_VIDEO_AV1_NUM_REF_FRAMES) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int32_t*>(&structInfo->gm_params[0][0]), STD_VIDEO_AV1_NUM_REF_FRAMES) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1GlobalMotion");
    out << "\t\t" << "StdVideoAV1GlobalMotion " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1LoopFilter(std::ostream &out, const StdVideoAV1LoopFilter* structInfo, Decoded_StdVideoAV1LoopFilter* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoAV1LoopFilterFlags(out,
                                                                           &structInfo->flags,
                                                                           metaInfo->flags,
                                                                           consumer);
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->loop_filter_level[0]), STD_VIDEO_AV1_MAX_LOOP_FILTER_STRENGTHS) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->loop_filter_sharpness) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->update_ref_delta) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->loop_filter_ref_deltas[0]), STD_VIDEO_AV1_TOTAL_REFS_PER_FRAME) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->update_mode_delta) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->loop_filter_mode_deltas[0]), STD_VIDEO_AV1_LOOP_FILTER_ADJUSTMENTS) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1LoopFilter");
    out << "\t\t" << "StdVideoAV1LoopFilter " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1LoopFilterFlags(std::ostream &out, const StdVideoAV1LoopFilterFlags* structInfo, Decoded_StdVideoAV1LoopFilterFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->loop_filter_delta_enabled << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->loop_filter_delta_update << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1LoopFilterFlags");
    out << "\t\t" << "StdVideoAV1LoopFilterFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1LoopRestoration(std::ostream &out, const StdVideoAV1LoopRestoration* structInfo, Decoded_StdVideoAV1LoopRestoration* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const StdVideoAV1FrameRestorationType*>(&structInfo->FrameRestorationType[0]), STD_VIDEO_AV1_MAX_NUM_PLANES) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->LoopRestorationSize[0]), STD_VIDEO_AV1_MAX_NUM_PLANES) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1LoopRestoration");
    out << "\t\t" << "StdVideoAV1LoopRestoration " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1Quantization(std::ostream &out, const StdVideoAV1Quantization* structInfo, Decoded_StdVideoAV1Quantization* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoAV1QuantizationFlags(out,
                                                                             &structInfo->flags,
                                                                             metaInfo->flags,
                                                                             consumer);
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->base_q_idx) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->DeltaQYDc) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->DeltaQUDc) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->DeltaQUAc) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->DeltaQVDc) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->DeltaQVAc) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->qm_y) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->qm_u) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->qm_v) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1Quantization");
    out << "\t\t" << "StdVideoAV1Quantization " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1QuantizationFlags(std::ostream &out, const StdVideoAV1QuantizationFlags* structInfo, Decoded_StdVideoAV1QuantizationFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->using_qmatrix << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->diff_uv_delta << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1QuantizationFlags");
    out << "\t\t" << "StdVideoAV1QuantizationFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1Segmentation(std::ostream &out, const StdVideoAV1Segmentation* structInfo, Decoded_StdVideoAV1Segmentation* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->FeatureEnabled[0]), STD_VIDEO_AV1_MAX_SEGMENTS) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int16_t*>(&structInfo->FeatureData[0][0]), STD_VIDEO_AV1_MAX_SEGMENTS) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1Segmentation");
    out << "\t\t" << "StdVideoAV1Segmentation " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1SequenceHeader(std::ostream &out, const StdVideoAV1SequenceHeader* structInfo, Decoded_StdVideoAV1SequenceHeader* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoAV1SequenceHeaderFlags(out,
                                                                               &structInfo->flags,
                                                                               metaInfo->flags,
                                                                               consumer);
    std::string pcolor_config_struct = "NULL";
    if (structInfo->pColorConfig != NULL) {
        pcolor_config_struct = GenerateStruct_StdVideoAV1ColorConfig(out,
                                                                     structInfo->pColorConfig,
                                                                     metaInfo->pColorConfig->GetMetaStructPointer(),
                                                                     consumer);
        pcolor_config_struct.insert(0, "&");
    }
    std::string ptiming_info_struct = "NULL";
    if (structInfo->pTimingInfo != NULL) {
        ptiming_info_struct = GenerateStruct_StdVideoAV1TimingInfo(out,
                                                                   structInfo->pTimingInfo,
                                                                   metaInfo->pTimingInfo->GetMetaStructPointer(),
                                                                   consumer);
        ptiming_info_struct.insert(0, "&");
    }
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1Profile(" << structInfo->seq_profile << ")" << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->frame_width_bits_minus_1) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->frame_height_bits_minus_1) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->max_frame_width_minus_1 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->max_frame_height_minus_1 << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->delta_frame_id_length_minus_2) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->additional_frame_id_length_minus_1) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->order_hint_bits_minus_1) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->seq_force_integer_mv) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->seq_force_screen_content_tools) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->reserved1[0]), 5) << "," << std::endl;
    struct_body << "\t\t\t" << pcolor_config_struct << "," << std::endl;
    struct_body << "\t\t\t" << ptiming_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1SequenceHeader");
    out << "\t\t" << "StdVideoAV1SequenceHeader " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1SequenceHeaderFlags(std::ostream &out, const StdVideoAV1SequenceHeaderFlags* structInfo, Decoded_StdVideoAV1SequenceHeaderFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->still_picture << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reduced_still_picture_header << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->use_128x128_superblock << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enable_filter_intra << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enable_intra_edge_filter << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enable_interintra_compound << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enable_masked_compound << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enable_warped_motion << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enable_dual_filter << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enable_order_hint << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enable_jnt_comp << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enable_ref_frame_mvs << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_id_numbers_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enable_superres << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enable_cdef << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enable_restoration << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->film_grain_params_present << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timing_info_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->initial_display_delay_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1SequenceHeaderFlags");
    out << "\t\t" << "StdVideoAV1SequenceHeaderFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1TileInfo(std::ostream &out, const StdVideoAV1TileInfo* structInfo, Decoded_StdVideoAV1TileInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoAV1TileInfoFlags(out,
                                                                         &structInfo->flags,
                                                                         metaInfo->flags,
                                                                         consumer);
    std::string pmi_col_starts_array = "NULL";
    if (structInfo->pMiColStarts != NULL) {
        std::string pmi_col_starts_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->TileCols; ++idx0) {
            pmi_col_starts_values += std::to_string(structInfo->pMiColStarts[idx0]) + ", ";
        }
        pmi_col_starts_array = "pMiColStarts_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint16_t " << pmi_col_starts_array << "[] = {" << pmi_col_starts_values << "};" << std::endl;
    }
    std::string pmi_row_starts_array = "NULL";
    if (structInfo->pMiRowStarts != NULL) {
        std::string pmi_row_starts_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->TileRows; ++idx0) {
            pmi_row_starts_values += std::to_string(structInfo->pMiRowStarts[idx0]) + ", ";
        }
        pmi_row_starts_array = "pMiRowStarts_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint16_t " << pmi_row_starts_array << "[] = {" << pmi_row_starts_values << "};" << std::endl;
    }
    std::string pwidth_in_sbs_minus1_array = "NULL";
    if (structInfo->pWidthInSbsMinus1 != NULL) {
        std::string pwidth_in_sbs_minus1_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->TileCols; ++idx0) {
            pwidth_in_sbs_minus1_values += std::to_string(structInfo->pWidthInSbsMinus1[idx0]) + ", ";
        }
        pwidth_in_sbs_minus1_array = "pWidthInSbsMinus1_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint16_t " << pwidth_in_sbs_minus1_array << "[] = {" << pwidth_in_sbs_minus1_values << "};" << std::endl;
    }
    std::string pheight_in_sbs_minus1_array = "NULL";
    if (structInfo->pHeightInSbsMinus1 != NULL) {
        std::string pheight_in_sbs_minus1_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->TileRows; ++idx0) {
            pheight_in_sbs_minus1_values += std::to_string(structInfo->pHeightInSbsMinus1[idx0]) + ", ";
        }
        pheight_in_sbs_minus1_array = "pHeightInSbsMinus1_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint16_t " << pheight_in_sbs_minus1_array << "[] = {" << pheight_in_sbs_minus1_values << "};" << std::endl;
    }
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->TileCols) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->TileRows) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->context_update_tile_id << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->tile_size_bytes_minus_1) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->reserved1[0]), 7) << "," << std::endl;
    struct_body << "\t\t\t" << pmi_col_starts_array << "," << std::endl;
    struct_body << "\t\t\t" << pmi_row_starts_array << "," << std::endl;
    struct_body << "\t\t\t" << pwidth_in_sbs_minus1_array << "," << std::endl;
    struct_body << "\t\t\t" << pheight_in_sbs_minus1_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1TileInfo");
    out << "\t\t" << "StdVideoAV1TileInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1TileInfoFlags(std::ostream &out, const StdVideoAV1TileInfoFlags* structInfo, Decoded_StdVideoAV1TileInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->uniform_tile_spacing_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1TileInfoFlags");
    out << "\t\t" << "StdVideoAV1TileInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1TimingInfo(std::ostream &out, const StdVideoAV1TimingInfo* structInfo, Decoded_StdVideoAV1TimingInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoAV1TimingInfoFlags(out,
                                                                           &structInfo->flags,
                                                                           metaInfo->flags,
                                                                           consumer);
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->num_units_in_display_tick << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->time_scale << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->num_ticks_per_picture_minus_1 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1TimingInfo");
    out << "\t\t" << "StdVideoAV1TimingInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoAV1TimingInfoFlags(std::ostream &out, const StdVideoAV1TimingInfoFlags* structInfo, Decoded_StdVideoAV1TimingInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->equal_picture_interval << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoAV1TimingInfoFlags");
    out << "\t\t" << "StdVideoAV1TimingInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeAV1PictureInfo(std::ostream &out, const StdVideoDecodeAV1PictureInfo* structInfo, Decoded_StdVideoDecodeAV1PictureInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoDecodeAV1PictureInfoFlags(out,
                                                                                  &structInfo->flags,
                                                                                  metaInfo->flags,
                                                                                  consumer);
    std::string ptile_info_struct = "NULL";
    if (structInfo->pTileInfo != NULL) {
        ptile_info_struct = GenerateStruct_StdVideoAV1TileInfo(out,
                                                               structInfo->pTileInfo,
                                                               metaInfo->pTileInfo->GetMetaStructPointer(),
                                                               consumer);
        ptile_info_struct.insert(0, "&");
    }
    std::string pquantization_struct = "NULL";
    if (structInfo->pQuantization != NULL) {
        pquantization_struct = GenerateStruct_StdVideoAV1Quantization(out,
                                                                      structInfo->pQuantization,
                                                                      metaInfo->pQuantization->GetMetaStructPointer(),
                                                                      consumer);
        pquantization_struct.insert(0, "&");
    }
    std::string psegmentation_struct = "NULL";
    if (structInfo->pSegmentation != NULL) {
        psegmentation_struct = GenerateStruct_StdVideoAV1Segmentation(out,
                                                                      structInfo->pSegmentation,
                                                                      metaInfo->pSegmentation->GetMetaStructPointer(),
                                                                      consumer);
        psegmentation_struct.insert(0, "&");
    }
    std::string ploop_filter_struct = "NULL";
    if (structInfo->pLoopFilter != NULL) {
        ploop_filter_struct = GenerateStruct_StdVideoAV1LoopFilter(out,
                                                                   structInfo->pLoopFilter,
                                                                   metaInfo->pLoopFilter->GetMetaStructPointer(),
                                                                   consumer);
        ploop_filter_struct.insert(0, "&");
    }
    std::string pc_d_e_f_struct = "NULL";
    if (structInfo->pCDEF != NULL) {
        pc_d_e_f_struct = GenerateStruct_StdVideoAV1CDEF(out,
                                                         structInfo->pCDEF,
                                                         metaInfo->pCDEF->GetMetaStructPointer(),
                                                         consumer);
        pc_d_e_f_struct.insert(0, "&");
    }
    std::string ploop_restoration_struct = "NULL";
    if (structInfo->pLoopRestoration != NULL) {
        ploop_restoration_struct = GenerateStruct_StdVideoAV1LoopRestoration(out,
                                                                             structInfo->pLoopRestoration,
                                                                             metaInfo->pLoopRestoration->GetMetaStructPointer(),
                                                                             consumer);
        ploop_restoration_struct.insert(0, "&");
    }
    std::string pglobal_motion_struct = "NULL";
    if (structInfo->pGlobalMotion != NULL) {
        pglobal_motion_struct = GenerateStruct_StdVideoAV1GlobalMotion(out,
                                                                       structInfo->pGlobalMotion,
                                                                       metaInfo->pGlobalMotion->GetMetaStructPointer(),
                                                                       consumer);
        pglobal_motion_struct.insert(0, "&");
    }
    std::string pfilm_grain_struct = "NULL";
    if (structInfo->pFilmGrain != NULL) {
        pfilm_grain_struct = GenerateStruct_StdVideoAV1FilmGrain(out,
                                                                 structInfo->pFilmGrain,
                                                                 metaInfo->pFilmGrain->GetMetaStructPointer(),
                                                                 consumer);
        pfilm_grain_struct.insert(0, "&");
    }
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1FrameType(" << structInfo->frame_type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->current_frame_id << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->OrderHint) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->primary_ref_frame) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->refresh_frame_flags) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1InterpolationFilter(" << structInfo->interpolation_filter << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1TxMode(" << structInfo->TxMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->delta_q_res) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->delta_lf_res) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->SkipModeFrame[0]), STD_VIDEO_AV1_SKIP_MODE_FRAMES) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->coded_denom) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->reserved2[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->OrderHints[0]), STD_VIDEO_AV1_NUM_REF_FRAMES) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->expectedFrameId[0]), STD_VIDEO_AV1_NUM_REF_FRAMES) << "," << std::endl;
    struct_body << "\t\t\t" << ptile_info_struct << "," << std::endl;
    struct_body << "\t\t\t" << pquantization_struct << "," << std::endl;
    struct_body << "\t\t\t" << psegmentation_struct << "," << std::endl;
    struct_body << "\t\t\t" << ploop_filter_struct << "," << std::endl;
    struct_body << "\t\t\t" << pc_d_e_f_struct << "," << std::endl;
    struct_body << "\t\t\t" << ploop_restoration_struct << "," << std::endl;
    struct_body << "\t\t\t" << pglobal_motion_struct << "," << std::endl;
    struct_body << "\t\t\t" << pfilm_grain_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeAV1PictureInfo");
    out << "\t\t" << "StdVideoDecodeAV1PictureInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeAV1PictureInfoFlags(std::ostream &out, const StdVideoDecodeAV1PictureInfoFlags* structInfo, Decoded_StdVideoDecodeAV1PictureInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->error_resilient_mode << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->disable_cdf_update << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->use_superres << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->render_and_frame_size_different << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->allow_screen_content_tools << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->is_filter_switchable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->force_integer_mv << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_size_override_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->buffer_removal_time_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->allow_intrabc << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_refs_short_signaling << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->allow_high_precision_mv << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->is_motion_mode_switchable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->use_ref_frame_mvs << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->disable_frame_end_update_cdf << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->allow_warped_motion << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reduced_tx_set << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reference_select << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->skip_mode_present << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->delta_q_present << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->delta_lf_present << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->delta_lf_multi << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->segmentation_enabled << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->segmentation_update_map << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->segmentation_temporal_update << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->segmentation_update_data << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->UsesLr << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->usesChromaLr << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->apply_grain << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeAV1PictureInfoFlags");
    out << "\t\t" << "StdVideoDecodeAV1PictureInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeAV1ReferenceInfo(std::ostream &out, const StdVideoDecodeAV1ReferenceInfo* structInfo, Decoded_StdVideoDecodeAV1ReferenceInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoDecodeAV1ReferenceInfoFlags(out,
                                                                                    &structInfo->flags,
                                                                                    metaInfo->flags,
                                                                                    consumer);
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->frame_type) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->RefFrameSignBias) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->OrderHint) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->SavedOrderHints[0]), STD_VIDEO_AV1_NUM_REF_FRAMES) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeAV1ReferenceInfo");
    out << "\t\t" << "StdVideoDecodeAV1ReferenceInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeAV1ReferenceInfoFlags(std::ostream &out, const StdVideoDecodeAV1ReferenceInfoFlags* structInfo, Decoded_StdVideoDecodeAV1ReferenceInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->disable_frame_end_update_cdf << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->segmentation_enabled << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeAV1ReferenceInfoFlags");
    out << "\t\t" << "StdVideoDecodeAV1ReferenceInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeH264PictureInfo(std::ostream &out, const StdVideoDecodeH264PictureInfo* structInfo, Decoded_StdVideoDecodeH264PictureInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoDecodeH264PictureInfoFlags(out,
                                                                                   &structInfo->flags,
                                                                                   metaInfo->flags,
                                                                                   consumer);
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->seq_parameter_set_id) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->pic_parameter_set_id) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved2) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_num << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->idr_pic_id << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int32_t*>(&structInfo->PicOrderCnt[0]), STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeH264PictureInfo");
    out << "\t\t" << "StdVideoDecodeH264PictureInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeH264PictureInfoFlags(std::ostream &out, const StdVideoDecodeH264PictureInfoFlags* structInfo, Decoded_StdVideoDecodeH264PictureInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->field_pic_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->is_intra << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->IdrPicFlag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bottom_field_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->is_reference << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->complementary_field_pair << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeH264PictureInfoFlags");
    out << "\t\t" << "StdVideoDecodeH264PictureInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeH264ReferenceInfo(std::ostream &out, const StdVideoDecodeH264ReferenceInfo* structInfo, Decoded_StdVideoDecodeH264ReferenceInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoDecodeH264ReferenceInfoFlags(out,
                                                                                     &structInfo->flags,
                                                                                     metaInfo->flags,
                                                                                     consumer);
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->FrameNum << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int32_t*>(&structInfo->PicOrderCnt[0]), STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeH264ReferenceInfo");
    out << "\t\t" << "StdVideoDecodeH264ReferenceInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeH264ReferenceInfoFlags(std::ostream &out, const StdVideoDecodeH264ReferenceInfoFlags* structInfo, Decoded_StdVideoDecodeH264ReferenceInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->top_field_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bottom_field_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->used_for_long_term_reference << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->is_non_existing << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeH264ReferenceInfoFlags");
    out << "\t\t" << "StdVideoDecodeH264ReferenceInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeVP9PictureInfo(std::ostream &out, const StdVideoDecodeVP9PictureInfo* structInfo, Decoded_StdVideoDecodeVP9PictureInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoDecodeVP9PictureInfoFlags(out,
                                                                                  &structInfo->flags,
                                                                                  metaInfo->flags,
                                                                                  consumer);
    std::string pcolor_config_struct = "NULL";
    if (structInfo->pColorConfig != NULL) {
        pcolor_config_struct = GenerateStruct_StdVideoVP9ColorConfig(out,
                                                                     structInfo->pColorConfig,
                                                                     metaInfo->pColorConfig->GetMetaStructPointer(),
                                                                     consumer);
        pcolor_config_struct.insert(0, "&");
    }
    std::string ploop_filter_struct = "NULL";
    if (structInfo->pLoopFilter != NULL) {
        ploop_filter_struct = GenerateStruct_StdVideoVP9LoopFilter(out,
                                                                   structInfo->pLoopFilter,
                                                                   metaInfo->pLoopFilter->GetMetaStructPointer(),
                                                                   consumer);
        ploop_filter_struct.insert(0, "&");
    }
    std::string psegmentation_struct = "NULL";
    if (structInfo->pSegmentation != NULL) {
        psegmentation_struct = GenerateStruct_StdVideoVP9Segmentation(out,
                                                                      structInfo->pSegmentation,
                                                                      metaInfo->pSegmentation->GetMetaStructPointer(),
                                                                      consumer);
        psegmentation_struct.insert(0, "&");
    }
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoVP9Profile(" << structInfo->profile << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoVP9FrameType(" << structInfo->frame_type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->frame_context_idx) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->reset_frame_context) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->refresh_frame_flags) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->ref_frame_sign_bias_mask) << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoVP9InterpolationFilter(" << structInfo->interpolation_filter << ")" << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->base_q_idx) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->delta_q_y_dc) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->delta_q_uv_dc) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->delta_q_uv_ac) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->tile_cols_log2) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->tile_rows_log2) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->reserved1[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << pcolor_config_struct << "," << std::endl;
    struct_body << "\t\t\t" << ploop_filter_struct << "," << std::endl;
    struct_body << "\t\t\t" << psegmentation_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeVP9PictureInfo");
    out << "\t\t" << "StdVideoDecodeVP9PictureInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoDecodeVP9PictureInfoFlags(std::ostream &out, const StdVideoDecodeVP9PictureInfoFlags* structInfo, Decoded_StdVideoDecodeVP9PictureInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->error_resilient_mode << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->intra_only << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->allow_high_precision_mv << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->refresh_frame_context << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_parallel_decoding_mode << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->segmentation_enabled << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->show_frame << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->UsePrevFrameMvs << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoDecodeVP9PictureInfoFlags");
    out << "\t\t" << "StdVideoDecodeVP9PictureInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeAV1DecoderModelInfo(std::ostream &out, const StdVideoEncodeAV1DecoderModelInfo* structInfo, Decoded_StdVideoEncodeAV1DecoderModelInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << std::to_string(structInfo->buffer_delay_length_minus_1) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->buffer_removal_time_length_minus_1) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->frame_presentation_time_length_minus_1) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->num_units_in_decoding_tick << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeAV1DecoderModelInfo");
    out << "\t\t" << "StdVideoEncodeAV1DecoderModelInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeAV1ExtensionHeader(std::ostream &out, const StdVideoEncodeAV1ExtensionHeader* structInfo, Decoded_StdVideoEncodeAV1ExtensionHeader* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << std::to_string(structInfo->temporal_id) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->spatial_id) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeAV1ExtensionHeader");
    out << "\t\t" << "StdVideoEncodeAV1ExtensionHeader " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeAV1OperatingPointInfo(std::ostream &out, const StdVideoEncodeAV1OperatingPointInfo* structInfo, Decoded_StdVideoEncodeAV1OperatingPointInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeAV1OperatingPointInfoFlags(out,
                                                                                         &structInfo->flags,
                                                                                         metaInfo->flags,
                                                                                         consumer);
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->operating_point_idc << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->seq_level_idx) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->seq_tier) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->decoder_buffer_delay << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->encoder_buffer_delay << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->initial_display_delay_minus_1) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeAV1OperatingPointInfo");
    out << "\t\t" << "StdVideoEncodeAV1OperatingPointInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeAV1OperatingPointInfoFlags(std::ostream &out, const StdVideoEncodeAV1OperatingPointInfoFlags* structInfo, Decoded_StdVideoEncodeAV1OperatingPointInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->decoder_model_present_for_this_op << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->low_delay_mode_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->initial_display_delay_present_for_this_op << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeAV1OperatingPointInfoFlags");
    out << "\t\t" << "StdVideoEncodeAV1OperatingPointInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeAV1PictureInfo(std::ostream &out, const StdVideoEncodeAV1PictureInfo* structInfo, Decoded_StdVideoEncodeAV1PictureInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeAV1PictureInfoFlags(out,
                                                                                  &structInfo->flags,
                                                                                  metaInfo->flags,
                                                                                  consumer);
    std::string ptile_info_struct = "NULL";
    if (structInfo->pTileInfo != NULL) {
        ptile_info_struct = GenerateStruct_StdVideoAV1TileInfo(out,
                                                               structInfo->pTileInfo,
                                                               metaInfo->pTileInfo->GetMetaStructPointer(),
                                                               consumer);
        ptile_info_struct.insert(0, "&");
    }
    std::string pquantization_struct = "NULL";
    if (structInfo->pQuantization != NULL) {
        pquantization_struct = GenerateStruct_StdVideoAV1Quantization(out,
                                                                      structInfo->pQuantization,
                                                                      metaInfo->pQuantization->GetMetaStructPointer(),
                                                                      consumer);
        pquantization_struct.insert(0, "&");
    }
    std::string psegmentation_struct = "NULL";
    if (structInfo->pSegmentation != NULL) {
        psegmentation_struct = GenerateStruct_StdVideoAV1Segmentation(out,
                                                                      structInfo->pSegmentation,
                                                                      metaInfo->pSegmentation->GetMetaStructPointer(),
                                                                      consumer);
        psegmentation_struct.insert(0, "&");
    }
    std::string ploop_filter_struct = "NULL";
    if (structInfo->pLoopFilter != NULL) {
        ploop_filter_struct = GenerateStruct_StdVideoAV1LoopFilter(out,
                                                                   structInfo->pLoopFilter,
                                                                   metaInfo->pLoopFilter->GetMetaStructPointer(),
                                                                   consumer);
        ploop_filter_struct.insert(0, "&");
    }
    std::string pc_d_e_f_struct = "NULL";
    if (structInfo->pCDEF != NULL) {
        pc_d_e_f_struct = GenerateStruct_StdVideoAV1CDEF(out,
                                                         structInfo->pCDEF,
                                                         metaInfo->pCDEF->GetMetaStructPointer(),
                                                         consumer);
        pc_d_e_f_struct.insert(0, "&");
    }
    std::string ploop_restoration_struct = "NULL";
    if (structInfo->pLoopRestoration != NULL) {
        ploop_restoration_struct = GenerateStruct_StdVideoAV1LoopRestoration(out,
                                                                             structInfo->pLoopRestoration,
                                                                             metaInfo->pLoopRestoration->GetMetaStructPointer(),
                                                                             consumer);
        ploop_restoration_struct.insert(0, "&");
    }
    std::string pglobal_motion_struct = "NULL";
    if (structInfo->pGlobalMotion != NULL) {
        pglobal_motion_struct = GenerateStruct_StdVideoAV1GlobalMotion(out,
                                                                       structInfo->pGlobalMotion,
                                                                       metaInfo->pGlobalMotion->GetMetaStructPointer(),
                                                                       consumer);
        pglobal_motion_struct.insert(0, "&");
    }
    std::string pextension_header_struct = "NULL";
    if (structInfo->pExtensionHeader != NULL) {
        pextension_header_struct = GenerateStruct_StdVideoEncodeAV1ExtensionHeader(out,
                                                                                   structInfo->pExtensionHeader,
                                                                                   metaInfo->pExtensionHeader->GetMetaStructPointer(),
                                                                                   consumer);
        pextension_header_struct.insert(0, "&");
    }
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1FrameType(" << structInfo->frame_type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_presentation_time << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->current_frame_id << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->order_hint) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->primary_ref_frame) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->refresh_frame_flags) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->coded_denom) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->render_width_minus_1 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->render_height_minus_1 << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1InterpolationFilter(" << structInfo->interpolation_filter << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1TxMode(" << structInfo->TxMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->delta_q_res) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->delta_lf_res) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ref_order_hint[0]), STD_VIDEO_AV1_NUM_REF_FRAMES) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->ref_frame_idx[0]), STD_VIDEO_AV1_REFS_PER_FRAME) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->reserved1[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->delta_frame_id_minus_1[0]), STD_VIDEO_AV1_REFS_PER_FRAME) << "," << std::endl;
    struct_body << "\t\t\t" << ptile_info_struct << "," << std::endl;
    struct_body << "\t\t\t" << pquantization_struct << "," << std::endl;
    struct_body << "\t\t\t" << psegmentation_struct << "," << std::endl;
    struct_body << "\t\t\t" << ploop_filter_struct << "," << std::endl;
    struct_body << "\t\t\t" << pc_d_e_f_struct << "," << std::endl;
    struct_body << "\t\t\t" << ploop_restoration_struct << "," << std::endl;
    struct_body << "\t\t\t" << pglobal_motion_struct << "," << std::endl;
    struct_body << "\t\t\t" << pextension_header_struct << "," << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeAV1PictureInfo");
    out << "\t\t" << "StdVideoEncodeAV1PictureInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeAV1PictureInfoFlags(std::ostream &out, const StdVideoEncodeAV1PictureInfoFlags* structInfo, Decoded_StdVideoEncodeAV1PictureInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->error_resilient_mode << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->disable_cdf_update << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->use_superres << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->render_and_frame_size_different << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->allow_screen_content_tools << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->is_filter_switchable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->force_integer_mv << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_size_override_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->buffer_removal_time_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->allow_intrabc << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_refs_short_signaling << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->allow_high_precision_mv << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->is_motion_mode_switchable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->use_ref_frame_mvs << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->disable_frame_end_update_cdf << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->allow_warped_motion << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reduced_tx_set << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->skip_mode_present << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->delta_q_present << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->delta_lf_present << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->delta_lf_multi << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->segmentation_enabled << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->segmentation_update_map << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->segmentation_temporal_update << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->segmentation_update_data << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->UsesLr << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->usesChromaLr << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->show_frame << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->showable_frame << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeAV1PictureInfoFlags");
    out << "\t\t" << "StdVideoEncodeAV1PictureInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeAV1ReferenceInfo(std::ostream &out, const StdVideoEncodeAV1ReferenceInfo* structInfo, Decoded_StdVideoEncodeAV1ReferenceInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeAV1ReferenceInfoFlags(out,
                                                                                    &structInfo->flags,
                                                                                    metaInfo->flags,
                                                                                    consumer);
    std::string pextension_header_struct = "NULL";
    if (structInfo->pExtensionHeader != NULL) {
        pextension_header_struct = GenerateStruct_StdVideoEncodeAV1ExtensionHeader(out,
                                                                                   structInfo->pExtensionHeader,
                                                                                   metaInfo->pExtensionHeader->GetMetaStructPointer(),
                                                                                   consumer);
        pextension_header_struct.insert(0, "&");
    }
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->RefFrameId << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1FrameType(" << structInfo->frame_type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->OrderHint) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->reserved1[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << pextension_header_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeAV1ReferenceInfo");
    out << "\t\t" << "StdVideoEncodeAV1ReferenceInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeAV1ReferenceInfoFlags(std::ostream &out, const StdVideoEncodeAV1ReferenceInfoFlags* structInfo, Decoded_StdVideoEncodeAV1ReferenceInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->disable_frame_end_update_cdf << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->segmentation_enabled << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeAV1ReferenceInfoFlags");
    out << "\t\t" << "StdVideoEncodeAV1ReferenceInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264PictureInfo(std::ostream &out, const StdVideoEncodeH264PictureInfo* structInfo, Decoded_StdVideoEncodeH264PictureInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH264PictureInfoFlags(out,
                                                                                   &structInfo->flags,
                                                                                   metaInfo->flags,
                                                                                   consumer);
    std::string pref_lists_struct = "NULL";
    if (structInfo->pRefLists != NULL) {
        pref_lists_struct = GenerateStruct_StdVideoEncodeH264ReferenceListsInfo(out,
                                                                                structInfo->pRefLists,
                                                                                metaInfo->pRefLists->GetMetaStructPointer(),
                                                                                consumer);
        pref_lists_struct.insert(0, "&");
    }
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->seq_parameter_set_id) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->pic_parameter_set_id) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->idr_pic_id << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264PictureType(" << structInfo->primary_pic_type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_num << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->PicOrderCnt << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->temporal_id) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->reserved1[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << pref_lists_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264PictureInfo");
    out << "\t\t" << "StdVideoEncodeH264PictureInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264PictureInfoFlags(std::ostream &out, const StdVideoEncodeH264PictureInfoFlags* structInfo, Decoded_StdVideoEncodeH264PictureInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->IdrPicFlag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->is_reference << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->no_output_of_prior_pics_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->long_term_reference_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->adaptive_ref_pic_marking_mode_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264PictureInfoFlags");
    out << "\t\t" << "StdVideoEncodeH264PictureInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264RefListModEntry(std::ostream &out, const StdVideoEncodeH264RefListModEntry* structInfo, Decoded_StdVideoEncodeH264RefListModEntry* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "StdVideoH264ModificationOfPicNumsIdc(" << structInfo->modification_of_pic_nums_idc << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->abs_diff_pic_num_minus1 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->long_term_pic_num << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264RefListModEntry");
    out << "\t\t" << "StdVideoEncodeH264RefListModEntry " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264RefPicMarkingEntry(std::ostream &out, const StdVideoEncodeH264RefPicMarkingEntry* structInfo, Decoded_StdVideoEncodeH264RefPicMarkingEntry* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "StdVideoH264MemMgmtControlOp(" << structInfo->memory_management_control_operation << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->difference_of_pic_nums_minus1 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->long_term_pic_num << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->long_term_frame_idx << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->max_long_term_frame_idx_plus1 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264RefPicMarkingEntry");
    out << "\t\t" << "StdVideoEncodeH264RefPicMarkingEntry " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264ReferenceInfo(std::ostream &out, const StdVideoEncodeH264ReferenceInfo* structInfo, Decoded_StdVideoEncodeH264ReferenceInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH264ReferenceInfoFlags(out,
                                                                                     &structInfo->flags,
                                                                                     metaInfo->flags,
                                                                                     consumer);
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264PictureType(" << structInfo->primary_pic_type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->FrameNum << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->PicOrderCnt << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->long_term_pic_num << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->long_term_frame_idx << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->temporal_id) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264ReferenceInfo");
    out << "\t\t" << "StdVideoEncodeH264ReferenceInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264ReferenceInfoFlags(std::ostream &out, const StdVideoEncodeH264ReferenceInfoFlags* structInfo, Decoded_StdVideoEncodeH264ReferenceInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->used_for_long_term_reference << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264ReferenceInfoFlags");
    out << "\t\t" << "StdVideoEncodeH264ReferenceInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264ReferenceListsInfo(std::ostream &out, const StdVideoEncodeH264ReferenceListsInfo* structInfo, Decoded_StdVideoEncodeH264ReferenceListsInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH264ReferenceListsInfoFlags(out,
                                                                                          &structInfo->flags,
                                                                                          metaInfo->flags,
                                                                                          consumer);
    std::string pref_list0_mod_operations_array = "NULL";
    if (structInfo->pRefList0ModOperations != NULL) {
        pref_list0_mod_operations_array = "pRefList0ModOperations_" + std::to_string(consumer.GetNextId());
        std::string pref_list0_mod_operations_names;
        for (uint32_t idx = 0; idx < structInfo->refList0ModOpCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRefList0ModOperations + idx != NULL) {
                variable_name = GenerateStruct_StdVideoEncodeH264RefListModEntry(out,
                                                                                 structInfo->pRefList0ModOperations + idx,
                                                                                 metaInfo->pRefList0ModOperations->GetMetaStructPointer() + idx,
                                                                                 consumer);
            }
            pref_list0_mod_operations_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoEncodeH264RefListModEntry " << pref_list0_mod_operations_array << "[] = {" << pref_list0_mod_operations_names << "};" << std::endl;
    }
    std::string pref_list1_mod_operations_array = "NULL";
    if (structInfo->pRefList1ModOperations != NULL) {
        pref_list1_mod_operations_array = "pRefList1ModOperations_" + std::to_string(consumer.GetNextId());
        std::string pref_list1_mod_operations_names;
        for (uint32_t idx = 0; idx < structInfo->refList1ModOpCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRefList1ModOperations + idx != NULL) {
                variable_name = GenerateStruct_StdVideoEncodeH264RefListModEntry(out,
                                                                                 structInfo->pRefList1ModOperations + idx,
                                                                                 metaInfo->pRefList1ModOperations->GetMetaStructPointer() + idx,
                                                                                 consumer);
            }
            pref_list1_mod_operations_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoEncodeH264RefListModEntry " << pref_list1_mod_operations_array << "[] = {" << pref_list1_mod_operations_names << "};" << std::endl;
    }
    std::string pref_pic_marking_operations_array = "NULL";
    if (structInfo->pRefPicMarkingOperations != NULL) {
        pref_pic_marking_operations_array = "pRefPicMarkingOperations_" + std::to_string(consumer.GetNextId());
        std::string pref_pic_marking_operations_names;
        for (uint32_t idx = 0; idx < structInfo->refPicMarkingOpCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRefPicMarkingOperations + idx != NULL) {
                variable_name = GenerateStruct_StdVideoEncodeH264RefPicMarkingEntry(out,
                                                                                    structInfo->pRefPicMarkingOperations + idx,
                                                                                    metaInfo->pRefPicMarkingOperations->GetMetaStructPointer() + idx,
                                                                                    consumer);
            }
            pref_pic_marking_operations_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoEncodeH264RefPicMarkingEntry " << pref_pic_marking_operations_array << "[] = {" << pref_pic_marking_operations_names << "};" << std::endl;
    }
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->num_ref_idx_l0_active_minus1) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->num_ref_idx_l1_active_minus1) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicList0[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicList1[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->refList0ModOpCount) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->refList1ModOpCount) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->refPicMarkingOpCount) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->reserved1[0]), 7) << "," << std::endl;
    struct_body << "\t\t\t" << pref_list0_mod_operations_array << "," << std::endl;
    struct_body << "\t\t\t" << pref_list1_mod_operations_array << "," << std::endl;
    struct_body << "\t\t\t" << pref_pic_marking_operations_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264ReferenceListsInfo");
    out << "\t\t" << "StdVideoEncodeH264ReferenceListsInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264ReferenceListsInfoFlags(std::ostream &out, const StdVideoEncodeH264ReferenceListsInfoFlags* structInfo, Decoded_StdVideoEncodeH264ReferenceListsInfoFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->ref_pic_list_modification_flag_l0 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->ref_pic_list_modification_flag_l1 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264ReferenceListsInfoFlags");
    out << "\t\t" << "StdVideoEncodeH264ReferenceListsInfoFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264SliceHeader(std::ostream &out, const StdVideoEncodeH264SliceHeader* structInfo, Decoded_StdVideoEncodeH264SliceHeader* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH264SliceHeaderFlags(out,
                                                                                   &structInfo->flags,
                                                                                   metaInfo->flags,
                                                                                   consumer);
    std::string pweight_table_struct = "NULL";
    if (structInfo->pWeightTable != NULL) {
        pweight_table_struct = GenerateStruct_StdVideoEncodeH264WeightTable(out,
                                                                            structInfo->pWeightTable,
                                                                            metaInfo->pWeightTable->GetMetaStructPointer(),
                                                                            consumer);
        pweight_table_struct.insert(0, "&");
    }
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->first_mb_in_slice << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264SliceType(" << structInfo->slice_type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->slice_alpha_c0_offset_div2) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->slice_beta_offset_div2) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->slice_qp_delta) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264CabacInitIdc(" << structInfo->cabac_init_idc << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264DisableDeblockingFilterIdc(" << structInfo->disable_deblocking_filter_idc << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pweight_table_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264SliceHeader");
    out << "\t\t" << "StdVideoEncodeH264SliceHeader " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264SliceHeaderFlags(std::ostream &out, const StdVideoEncodeH264SliceHeaderFlags* structInfo, Decoded_StdVideoEncodeH264SliceHeaderFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->direct_spatial_mv_pred_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->num_ref_idx_active_override_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264SliceHeaderFlags");
    out << "\t\t" << "StdVideoEncodeH264SliceHeaderFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264WeightTable(std::ostream &out, const StdVideoEncodeH264WeightTable* structInfo, Decoded_StdVideoEncodeH264WeightTable* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoEncodeH264WeightTableFlags(out,
                                                                                   &structInfo->flags,
                                                                                   metaInfo->flags,
                                                                                   consumer);
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->luma_log2_weight_denom) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->chroma_log2_weight_denom) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_weight_l0[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_offset_l0[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->chroma_weight_l0[0][0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->chroma_offset_l0[0][0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_weight_l1[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_offset_l1[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->chroma_weight_l1[0][0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->chroma_offset_l1[0][0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264WeightTable");
    out << "\t\t" << "StdVideoEncodeH264WeightTable " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoEncodeH264WeightTableFlags(std::ostream &out, const StdVideoEncodeH264WeightTableFlags* structInfo, Decoded_StdVideoEncodeH264WeightTableFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->luma_weight_l0_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->chroma_weight_l0_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->luma_weight_l1_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->chroma_weight_l1_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoEncodeH264WeightTableFlags");
    out << "\t\t" << "StdVideoEncodeH264WeightTableFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264HrdParameters(std::ostream &out, const StdVideoH264HrdParameters* structInfo, Decoded_StdVideoH264HrdParameters* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << std::to_string(structInfo->cpb_cnt_minus1) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->bit_rate_scale) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->cpb_size_scale) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->bit_rate_value_minus1[0]), STD_VIDEO_H264_CPB_CNT_LIST_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->cpb_size_value_minus1[0]), STD_VIDEO_H264_CPB_CNT_LIST_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->cbr_flag[0]), STD_VIDEO_H264_CPB_CNT_LIST_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->initial_cpb_removal_delay_length_minus1 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cpb_removal_delay_length_minus1 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dpb_output_delay_length_minus1 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->time_offset_length << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264HrdParameters");
    out << "\t\t" << "StdVideoH264HrdParameters " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264PictureParameterSet(std::ostream &out, const StdVideoH264PictureParameterSet* structInfo, Decoded_StdVideoH264PictureParameterSet* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoH264PpsFlags(out,
                                                                     &structInfo->flags,
                                                                     metaInfo->flags,
                                                                     consumer);
    std::string pscaling_lists_struct = "NULL";
    if (structInfo->pScalingLists != NULL) {
        pscaling_lists_struct = GenerateStruct_StdVideoH264ScalingLists(out,
                                                                        structInfo->pScalingLists,
                                                                        metaInfo->pScalingLists->GetMetaStructPointer(),
                                                                        consumer);
        pscaling_lists_struct.insert(0, "&");
    }
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->seq_parameter_set_id) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->pic_parameter_set_id) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->num_ref_idx_l0_default_active_minus1) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->num_ref_idx_l1_default_active_minus1) << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264WeightedBipredIdc(" << structInfo->weighted_bipred_idc << ")" << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->pic_init_qp_minus26) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->pic_init_qs_minus26) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->chroma_qp_index_offset) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->second_chroma_qp_index_offset) << "," << std::endl;
    struct_body << "\t\t\t" << pscaling_lists_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264PictureParameterSet");
    out << "\t\t" << "StdVideoH264PictureParameterSet " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264PpsFlags(std::ostream &out, const StdVideoH264PpsFlags* structInfo, Decoded_StdVideoH264PpsFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->transform_8x8_mode_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->redundant_pic_cnt_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->constrained_intra_pred_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deblocking_filter_control_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->weighted_pred_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bottom_field_pic_order_in_frame_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->entropy_coding_mode_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pic_scaling_matrix_present_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264PpsFlags");
    out << "\t\t" << "StdVideoH264PpsFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264ScalingLists(std::ostream &out, const StdVideoH264ScalingLists* structInfo, Decoded_StdVideoH264ScalingLists* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->scaling_list_present_mask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->use_default_scaling_matrix_mask << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingList4x4[0][0]), STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingList8x8[0][0]), STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264ScalingLists");
    out << "\t\t" << "StdVideoH264ScalingLists " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264SequenceParameterSet(std::ostream &out, const StdVideoH264SequenceParameterSet* structInfo, Decoded_StdVideoH264SequenceParameterSet* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoH264SpsFlags(out,
                                                                     &structInfo->flags,
                                                                     metaInfo->flags,
                                                                     consumer);
    std::string poffset_for_ref_frame_array = "NULL";
    if (structInfo->pOffsetForRefFrame != NULL) {
        poffset_for_ref_frame_array = "pOffsetForRefFrame_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "int32_t " << poffset_for_ref_frame_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pOffsetForRefFrame, structInfo->num_ref_frames_in_pic_order_cnt_cycle) << ";" << std::endl;
    }
    std::string pscaling_lists_struct = "NULL";
    if (structInfo->pScalingLists != NULL) {
        pscaling_lists_struct = GenerateStruct_StdVideoH264ScalingLists(out,
                                                                        structInfo->pScalingLists,
                                                                        metaInfo->pScalingLists->GetMetaStructPointer(),
                                                                        consumer);
        pscaling_lists_struct.insert(0, "&");
    }
    std::string psequence_parameter_set_vui_struct = "NULL";
    if (structInfo->pSequenceParameterSetVui != NULL) {
        psequence_parameter_set_vui_struct = GenerateStruct_StdVideoH264SequenceParameterSetVui(out,
                                                                                                structInfo->pSequenceParameterSetVui,
                                                                                                metaInfo->pSequenceParameterSetVui->GetMetaStructPointer(),
                                                                                                consumer);
        psequence_parameter_set_vui_struct.insert(0, "&");
    }
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264ProfileIdc(" << structInfo->profile_idc << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264LevelIdc(" << structInfo->level_idc << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264ChromaFormatIdc(" << structInfo->chroma_format_idc << ")" << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->seq_parameter_set_id) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->bit_depth_luma_minus8) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->bit_depth_chroma_minus8) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_max_frame_num_minus4) << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264PocType(" << structInfo->pic_order_cnt_type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset_for_non_ref_pic << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset_for_top_to_bottom_field << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->log2_max_pic_order_cnt_lsb_minus4) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->num_ref_frames_in_pic_order_cnt_cycle) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->max_num_ref_frames) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pic_width_in_mbs_minus1 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pic_height_in_map_units_minus1 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_crop_left_offset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_crop_right_offset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_crop_top_offset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_crop_bottom_offset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved2 << "," << std::endl;
    struct_body << "\t\t\t" << poffset_for_ref_frame_array << "," << std::endl;
    struct_body << "\t\t\t" << pscaling_lists_struct << "," << std::endl;
    struct_body << "\t\t\t" << psequence_parameter_set_vui_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264SequenceParameterSet");
    out << "\t\t" << "StdVideoH264SequenceParameterSet " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264SequenceParameterSetVui(std::ostream &out, const StdVideoH264SequenceParameterSetVui* structInfo, Decoded_StdVideoH264SequenceParameterSetVui* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoH264SpsVuiFlags(out,
                                                                        &structInfo->flags,
                                                                        metaInfo->flags,
                                                                        consumer);
    std::string phrd_parameters_struct = "NULL";
    if (structInfo->pHrdParameters != NULL) {
        phrd_parameters_struct = GenerateStruct_StdVideoH264HrdParameters(out,
                                                                          structInfo->pHrdParameters,
                                                                          metaInfo->pHrdParameters->GetMetaStructPointer(),
                                                                          consumer);
        phrd_parameters_struct.insert(0, "&");
    }
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264AspectRatioIdc(" << structInfo->aspect_ratio_idc << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sar_width << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sar_height << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->video_format) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->colour_primaries) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->transfer_characteristics) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->matrix_coefficients) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->num_units_in_tick << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->time_scale << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->max_num_reorder_frames) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->max_dec_frame_buffering) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->chroma_sample_loc_type_top_field) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->chroma_sample_loc_type_bottom_field) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved1 << "," << std::endl;
    struct_body << "\t\t\t" << phrd_parameters_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264SequenceParameterSetVui");
    out << "\t\t" << "StdVideoH264SequenceParameterSetVui " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264SpsFlags(std::ostream &out, const StdVideoH264SpsFlags* structInfo, Decoded_StdVideoH264SpsFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->constraint_set0_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->constraint_set1_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->constraint_set2_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->constraint_set3_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->constraint_set4_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->constraint_set5_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->direct_8x8_inference_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->mb_adaptive_frame_field_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_mbs_only_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->delta_pic_order_always_zero_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->separate_colour_plane_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->gaps_in_frame_num_value_allowed_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->qpprime_y_zero_transform_bypass_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frame_cropping_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->seq_scaling_matrix_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vui_parameters_present_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264SpsFlags");
    out << "\t\t" << "StdVideoH264SpsFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoH264SpsVuiFlags(std::ostream &out, const StdVideoH264SpsVuiFlags* structInfo, Decoded_StdVideoH264SpsVuiFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->aspect_ratio_info_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->overscan_info_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->overscan_appropriate_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->video_signal_type_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->video_full_range_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->color_description_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->chroma_loc_info_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timing_info_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fixed_frame_rate_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bitstream_restriction_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->nal_hrd_parameters_present_flag << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vcl_hrd_parameters_present_flag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoH264SpsVuiFlags");
    out << "\t\t" << "StdVideoH264SpsVuiFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoVP9ColorConfig(std::ostream &out, const StdVideoVP9ColorConfig* structInfo, Decoded_StdVideoVP9ColorConfig* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoVP9ColorConfigFlags(out,
                                                                            &structInfo->flags,
                                                                            metaInfo->flags,
                                                                            consumer);
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->BitDepth) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->subsampling_x) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->subsampling_y) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->reserved1) << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoVP9ColorSpace(" << structInfo->color_space << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoVP9ColorConfig");
    out << "\t\t" << "StdVideoVP9ColorConfig " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoVP9ColorConfigFlags(std::ostream &out, const StdVideoVP9ColorConfigFlags* structInfo, Decoded_StdVideoVP9ColorConfigFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->color_range << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoVP9ColorConfigFlags");
    out << "\t\t" << "StdVideoVP9ColorConfigFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoVP9LoopFilter(std::ostream &out, const StdVideoVP9LoopFilter* structInfo, Decoded_StdVideoVP9LoopFilter* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoVP9LoopFilterFlags(out,
                                                                           &structInfo->flags,
                                                                           metaInfo->flags,
                                                                           consumer);
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->loop_filter_level) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->loop_filter_sharpness) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->update_ref_delta) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->loop_filter_ref_deltas[0]), STD_VIDEO_VP9_MAX_REF_FRAMES) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->update_mode_delta) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->loop_filter_mode_deltas[0]), STD_VIDEO_VP9_LOOP_FILTER_ADJUSTMENTS) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoVP9LoopFilter");
    out << "\t\t" << "StdVideoVP9LoopFilter " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoVP9LoopFilterFlags(std::ostream &out, const StdVideoVP9LoopFilterFlags* structInfo, Decoded_StdVideoVP9LoopFilterFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->loop_filter_delta_enabled << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->loop_filter_delta_update << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoVP9LoopFilterFlags");
    out << "\t\t" << "StdVideoVP9LoopFilterFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoVP9Segmentation(std::ostream &out, const StdVideoVP9Segmentation* structInfo, Decoded_StdVideoVP9Segmentation* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string flags_info_var = GenerateStruct_StdVideoVP9SegmentationFlags(out,
                                                                             &structInfo->flags,
                                                                             metaInfo->flags,
                                                                             consumer);
    struct_body << "\t" << flags_info_var << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->segmentation_tree_probs[0]), STD_VIDEO_VP9_MAX_SEGMENTATION_TREE_PROBS) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->segmentation_pred_prob[0]), STD_VIDEO_VP9_MAX_SEGMENTATION_PRED_PROB) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->FeatureEnabled[0]), STD_VIDEO_VP9_MAX_SEGMENTS) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int16_t*>(&structInfo->FeatureData[0][0]), STD_VIDEO_VP9_MAX_SEGMENTS) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoVP9Segmentation");
    out << "\t\t" << "StdVideoVP9Segmentation " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_StdVideoVP9SegmentationFlags(std::ostream &out, const StdVideoVP9SegmentationFlags* structInfo, Decoded_StdVideoVP9SegmentationFlags* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->segmentation_update_map << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->segmentation_temporal_update << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->segmentation_update_data << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->segmentation_abs_or_delta_update << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reserved << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stdVideoVP9SegmentationFlags");
    out << "\t\t" << "StdVideoVP9SegmentationFlags " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAllocationCallbacks(std::ostream &out, const VkAllocationCallbacks* structInfo, Decoded_VkAllocationCallbacks* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    out << "\t\t" << "// TODO: Support pUserData (non-struct output) argument." << std::endl;
    struct_body << "\t\t\t" << structInfo->pfnAllocation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pfnReallocation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pfnFree << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pfnInternalAllocation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pfnInternalFree << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "allocationCallbacks");
    out << "\t\t" << "VkAllocationCallbacks " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkApplicationInfo(std::ostream &out, const VkApplicationInfo* structInfo, Decoded_VkApplicationInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pApplicationName) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->applicationVersion << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pEngineName) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->engineVersion << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->apiVersion << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "applicationInfo");
    out << "\t\t" << "VkApplicationInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentDescription(std::ostream &out, const VkAttachmentDescription* structInfo, Decoded_VkAttachmentDescription* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkAttachmentDescriptionFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->samples << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAttachmentLoadOp(" << structInfo->loadOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAttachmentStoreOp(" << structInfo->storeOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAttachmentLoadOp(" << structInfo->stencilLoadOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAttachmentStoreOp(" << structInfo->stencilStoreOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->initialLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->finalLayout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentDescription");
    out << "\t\t" << "VkAttachmentDescription " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentReference(std::ostream &out, const VkAttachmentReference* structInfo, Decoded_VkAttachmentReference* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->attachment << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->layout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentReference");
    out << "\t\t" << "VkAttachmentReference " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferCopy(std::ostream &out, const VkBufferCopy* structInfo, Decoded_VkBufferCopy* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->srcOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferCopy");
    out << "\t\t" << "VkBufferCopy " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferCreateInfo(std::ostream &out, const VkBufferCreateInfo* structInfo, Decoded_VkBufferCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pqueue_family_indices_array = "NULL";
    if (structInfo->pQueueFamilyIndices != NULL) {
        pqueue_family_indices_array = "pQueueFamilyIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pqueue_family_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pQueueFamilyIndices, structInfo->queueFamilyIndexCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkBufferCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBufferUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSharingMode(" << structInfo->sharingMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueFamilyIndexCount << "," << std::endl;
    struct_body << "\t\t\t" << pqueue_family_indices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferCreateInfo");
    out << "\t\t" << "VkBufferCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferImageCopy(std::ostream &out, const VkBufferImageCopy* structInfo, Decoded_VkBufferImageCopy* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string image_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                     &structInfo->imageSubresource,
                                                                                     metaInfo->imageSubresource,
                                                                                     consumer);
    std::string image_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->imageOffset,
                                                                  metaInfo->imageOffset,
                                                                  consumer);
    std::string image_extent_info_var = GenerateStruct_VkExtent3D(out,
                                                                  &structInfo->imageExtent,
                                                                  metaInfo->imageExtent,
                                                                  consumer);
    struct_body << "\t" << structInfo->bufferOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferRowLength << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferImageHeight << "," << std::endl;
    struct_body << "\t\t\t" << image_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << image_offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << image_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferImageCopy");
    out << "\t\t" << "VkBufferImageCopy " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferMemoryBarrier(std::ostream &out, const VkBufferMemoryBarrier* structInfo, Decoded_VkBufferMemoryBarrier* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcQueueFamilyIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstQueueFamilyIndex << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferMemoryBarrier");
    out << "\t\t" << "VkBufferMemoryBarrier " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferViewCreateInfo(std::ostream &out, const VkBufferViewCreateInfo* structInfo, Decoded_VkBufferViewCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkBufferViewCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->range << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferViewCreateInfo");
    out << "\t\t" << "VkBufferViewCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkClearAttachment(std::ostream &out, const VkClearAttachment* structInfo, Decoded_VkClearAttachment* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->colorAttachment << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(structInfo->clearValue) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "clearAttachment");
    out << "\t\t" << "VkClearAttachment " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkClearDepthStencilValue(std::ostream &out, const VkClearDepthStencilValue* structInfo, Decoded_VkClearDepthStencilValue* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->depth << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stencil << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "clearDepthStencilValue");
    out << "\t\t" << "VkClearDepthStencilValue " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkClearRect(std::ostream &out, const VkClearRect* structInfo, Decoded_VkClearRect* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string rect_info_var = GenerateStruct_VkRect2D(out,
                                                        &structInfo->rect,
                                                        metaInfo->rect,
                                                        consumer);
    struct_body << "\t" << rect_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->baseArrayLayer << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->layerCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "clearRect");
    out << "\t\t" << "VkClearRect " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferAllocateInfo(std::ostream &out, const VkCommandBufferAllocateInfo* structInfo, Decoded_VkCommandBufferAllocateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->commandPool) << "," << std::endl;
    struct_body << "\t\t\t" << "VkCommandBufferLevel(" << structInfo->level << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->commandBufferCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferAllocateInfo");
    out << "\t\t" << "VkCommandBufferAllocateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferBeginInfo(std::ostream &out, const VkCommandBufferBeginInfo* structInfo, Decoded_VkCommandBufferBeginInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pinheritance_info_struct = "NULL";
    if (structInfo->pInheritanceInfo != NULL) {
        pinheritance_info_struct = GenerateStruct_VkCommandBufferInheritanceInfo(out,
                                                                                 structInfo->pInheritanceInfo,
                                                                                 metaInfo->pInheritanceInfo->GetMetaStructPointer(),
                                                                                 consumer);
        pinheritance_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkCommandBufferUsageFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pinheritance_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferBeginInfo");
    out << "\t\t" << "VkCommandBufferBeginInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferInheritanceInfo(std::ostream &out, const VkCommandBufferInheritanceInfo* structInfo, Decoded_VkCommandBufferInheritanceInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->renderPass) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subpass << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->framebuffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->occlusionQueryEnable << "," << std::endl;
    struct_body << "\t\t\t" << "VkQueryControlFlags(" << structInfo->queryFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkQueryPipelineStatisticFlags(" << structInfo->pipelineStatistics << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferInheritanceInfo");
    out << "\t\t" << "VkCommandBufferInheritanceInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandPoolCreateInfo(std::ostream &out, const VkCommandPoolCreateInfo* structInfo, Decoded_VkCommandPoolCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkCommandPoolCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueFamilyIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandPoolCreateInfo");
    out << "\t\t" << "VkCommandPoolCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkComponentMapping(std::ostream &out, const VkComponentMapping* structInfo, Decoded_VkComponentMapping* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkComponentSwizzle(" << structInfo->r << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentSwizzle(" << structInfo->g << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentSwizzle(" << structInfo->b << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentSwizzle(" << structInfo->a << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "componentMapping");
    out << "\t\t" << "VkComponentMapping " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkComputePipelineCreateInfo(std::ostream &out, const VkComputePipelineCreateInfo* structInfo, Decoded_VkComputePipelineCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string stage_info_var = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                                                &structInfo->stage,
                                                                                metaInfo->stage,
                                                                                consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << stage_info_var << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->layout) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->basePipelineHandle) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->basePipelineIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "computePipelineCreateInfo");
    out << "\t\t" << "VkComputePipelineCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyDescriptorSet(std::ostream &out, const VkCopyDescriptorSet* structInfo, Decoded_VkCopyDescriptorSet* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcSet) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcBinding << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcArrayElement << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstSet) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstBinding << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstArrayElement << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyDescriptorSet");
    out << "\t\t" << "VkCopyDescriptorSet " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorBufferInfo(std::ostream &out, const VkDescriptorBufferInfo* structInfo, Decoded_VkDescriptorBufferInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->range << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorBufferInfo");
    out << "\t\t" << "VkDescriptorBufferInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorPoolCreateInfo(std::ostream &out, const VkDescriptorPoolCreateInfo* structInfo, Decoded_VkDescriptorPoolCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppool_sizes_array = "NULL";
    if (structInfo->pPoolSizes != NULL) {
        ppool_sizes_array = "pPoolSizes_" + std::to_string(consumer.GetNextId());
        std::string ppool_sizes_names;
        for (uint32_t idx = 0; idx < structInfo->poolSizeCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPoolSizes + idx != NULL) {
                variable_name = GenerateStruct_VkDescriptorPoolSize(out,
                                                                    structInfo->pPoolSizes + idx,
                                                                    metaInfo->pPoolSizes->GetMetaStructPointer() + idx,
                                                                    consumer);
            }
            ppool_sizes_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDescriptorPoolSize " << ppool_sizes_array << "[] = {" << ppool_sizes_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDescriptorPoolCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSets << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->poolSizeCount << "," << std::endl;
    struct_body << "\t\t\t" << ppool_sizes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorPoolCreateInfo");
    out << "\t\t" << "VkDescriptorPoolCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorPoolSize(std::ostream &out, const VkDescriptorPoolSize* structInfo, Decoded_VkDescriptorPoolSize* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkDescriptorType(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorPoolSize");
    out << "\t\t" << "VkDescriptorPoolSize " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetAllocateInfo(std::ostream &out, const VkDescriptorSetAllocateInfo* structInfo, Decoded_VkDescriptorSetAllocateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pset_layouts_array = "NULL";
    if (metaInfo->pSetLayouts.GetPointer() != NULL && structInfo->descriptorSetCount > 0) {
        pset_layouts_array = "pset_layouts_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT));
        std::string pset_layouts_values = toStringJoin(metaInfo->pSetLayouts.GetPointer(),
                                                       metaInfo->pSetLayouts.GetPointer() + structInfo->descriptorSetCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->descriptorSetCount == 1) {
            pset_layouts_array = "&" + pset_layouts_values;
        } else if (structInfo->descriptorSetCount > 1) {
            out << "\t\t" << "VkDescriptorSetLayout " << pset_layouts_array << "[] = {" << pset_layouts_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->descriptorPool) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorSetCount << "," << std::endl;
    struct_body << "\t\t\t" << pset_layouts_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetAllocateInfo");
    out << "\t\t" << "VkDescriptorSetAllocateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetLayoutBinding(std::ostream &out, const VkDescriptorSetLayoutBinding* structInfo, Decoded_VkDescriptorSetLayoutBinding* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pimmutable_samplers_array = "NULL";
    if (metaInfo->pImmutableSamplers.GetPointer() != NULL && structInfo->descriptorCount > 0) {
        pimmutable_samplers_array = "pimmutable_samplers_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_SAMPLER));
        std::string pimmutable_samplers_values = toStringJoin(metaInfo->pImmutableSamplers.GetPointer(),
                                                              metaInfo->pImmutableSamplers.GetPointer() + structInfo->descriptorCount,
                                                              [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                              ", ");
        if (structInfo->descriptorCount == 1) {
            pimmutable_samplers_array = "&" + pimmutable_samplers_values;
        } else if (structInfo->descriptorCount > 1) {
            out << "\t\t" << "VkSampler " << pimmutable_samplers_array << "[] = {" << pimmutable_samplers_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << structInfo->binding << "," << std::endl;
    struct_body << "\t\t\t" << "VkDescriptorType(" << structInfo->descriptorType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorCount << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->stageFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pimmutable_samplers_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetLayoutBinding");
    out << "\t\t" << "VkDescriptorSetLayoutBinding " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetLayoutCreateInfo(std::ostream &out, const VkDescriptorSetLayoutCreateInfo* structInfo, Decoded_VkDescriptorSetLayoutCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pbindings_array = "NULL";
    if (structInfo->pBindings != NULL) {
        pbindings_array = "pBindings_" + std::to_string(consumer.GetNextId());
        std::string pbindings_names;
        for (uint32_t idx = 0; idx < structInfo->bindingCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pBindings + idx != NULL) {
                variable_name = GenerateStruct_VkDescriptorSetLayoutBinding(out,
                                                                            structInfo->pBindings + idx,
                                                                            metaInfo->pBindings->GetMetaStructPointer() + idx,
                                                                            consumer);
            }
            pbindings_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDescriptorSetLayoutBinding " << pbindings_array << "[] = {" << pbindings_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDescriptorSetLayoutCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bindingCount << "," << std::endl;
    struct_body << "\t\t\t" << pbindings_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetLayoutCreateInfo");
    out << "\t\t" << "VkDescriptorSetLayoutCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceCreateInfo(std::ostream &out, const VkDeviceCreateInfo* structInfo, Decoded_VkDeviceCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pqueue_create_infos_array = "NULL";
    if (structInfo->pQueueCreateInfos != NULL) {
        pqueue_create_infos_array = "pQueueCreateInfos_" + std::to_string(consumer.GetNextId());
        std::string pqueue_create_infos_names;
        for (uint32_t idx = 0; idx < structInfo->queueCreateInfoCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pQueueCreateInfos + idx != NULL) {
                variable_name = GenerateStruct_VkDeviceQueueCreateInfo(out,
                                                                       structInfo->pQueueCreateInfos + idx,
                                                                       metaInfo->pQueueCreateInfos->GetMetaStructPointer() + idx,
                                                                       consumer);
            }
            pqueue_create_infos_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDeviceQueueCreateInfo " << pqueue_create_infos_array << "[] = {" << pqueue_create_infos_names << "};" << std::endl;
    }
    std::string pp_enabled_layer_names_var = "NULL";
    if (structInfo->enabledLayerCount) {
    pp_enabled_layer_names_var = "ppEnabledLayerNames_" + std::to_string(consumer.GetNextId());
    out << "\t\t" << "const char* " << pp_enabled_layer_names_var << "[] = " << VulkanCppConsumerBase::EscapeStringArray(structInfo->ppEnabledLayerNames, structInfo->enabledLayerCount) << ";" << std::endl;
    }
    std::string pp_enabled_extension_names_var = "NULL";
    if (structInfo->enabledExtensionCount) {
    pp_enabled_extension_names_var = "ppEnabledExtensionNames_" + std::to_string(consumer.GetNextId());
    out << "\t\t" << "const char* " << pp_enabled_extension_names_var << "[] = " << VulkanCppConsumerBase::EscapeStringArray(structInfo->ppEnabledExtensionNames, structInfo->enabledExtensionCount) << ";" << std::endl;
    }
    std::string penabled_features_struct = "NULL";
    if (structInfo->pEnabledFeatures != NULL) {
        penabled_features_struct = GenerateStruct_VkPhysicalDeviceFeatures(out,
                                                                           structInfo->pEnabledFeatures,
                                                                           metaInfo->pEnabledFeatures->GetMetaStructPointer(),
                                                                           consumer);
        penabled_features_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDeviceCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueCreateInfoCount << "," << std::endl;
    struct_body << "\t\t\t" << pqueue_create_infos_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enabledLayerCount << "," << std::endl;
    struct_body << "\t\t\t" << pp_enabled_layer_names_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enabledExtensionCount << "," << std::endl;
    struct_body << "\t\t\t" << pp_enabled_extension_names_var << "," << std::endl;
    struct_body << "\t\t\t" << penabled_features_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceCreateInfo");
    out << "\t\t" << "VkDeviceCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceQueueCreateInfo(std::ostream &out, const VkDeviceQueueCreateInfo* structInfo, Decoded_VkDeviceQueueCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pqueue_priorities_array = "NULL";
    if (structInfo->pQueuePriorities != NULL) {
        pqueue_priorities_array = "pQueuePriorities_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "float " << pqueue_priorities_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pQueuePriorities, structInfo->queueCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDeviceQueueCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueFamilyIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueCount << "," << std::endl;
    struct_body << "\t\t\t" << pqueue_priorities_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceQueueCreateInfo");
    out << "\t\t" << "VkDeviceQueueCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDispatchIndirectCommand(std::ostream &out, const VkDispatchIndirectCommand* structInfo, Decoded_VkDispatchIndirectCommand* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->x << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->y << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->z << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dispatchIndirectCommand");
    out << "\t\t" << "VkDispatchIndirectCommand " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrawIndexedIndirectCommand(std::ostream &out, const VkDrawIndexedIndirectCommand* structInfo, Decoded_VkDrawIndexedIndirectCommand* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->indexCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->firstIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->firstInstance << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drawIndexedIndirectCommand");
    out << "\t\t" << "VkDrawIndexedIndirectCommand " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrawIndirectCommand(std::ostream &out, const VkDrawIndirectCommand* structInfo, Decoded_VkDrawIndirectCommand* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->vertexCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->firstVertex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->firstInstance << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drawIndirectCommand");
    out << "\t\t" << "VkDrawIndirectCommand " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkEventCreateInfo(std::ostream &out, const VkEventCreateInfo* structInfo, Decoded_VkEventCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkEventCreateFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "eventCreateInfo");
    out << "\t\t" << "VkEventCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExtensionProperties(std::ostream &out, const VkExtensionProperties* structInfo, Decoded_VkExtensionProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << VulkanCppConsumerBase::ToEscape(structInfo->extensionName) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->specVersion << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "extensionProperties");
    out << "\t\t" << "VkExtensionProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExtent2D(std::ostream &out, const VkExtent2D* structInfo, Decoded_VkExtent2D* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->width << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->height << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "extent2D");
    out << "\t\t" << "VkExtent2D " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExtent3D(std::ostream &out, const VkExtent3D* structInfo, Decoded_VkExtent3D* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->width << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->height << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depth << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "extent3D");
    out << "\t\t" << "VkExtent3D " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFenceCreateInfo(std::ostream &out, const VkFenceCreateInfo* structInfo, Decoded_VkFenceCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFenceCreateFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "fenceCreateInfo");
    out << "\t\t" << "VkFenceCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFormatProperties(std::ostream &out, const VkFormatProperties* structInfo, Decoded_VkFormatProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkFormatFeatureFlags(" << structInfo->linearTilingFeatures << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormatFeatureFlags(" << structInfo->optimalTilingFeatures << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormatFeatureFlags(" << structInfo->bufferFeatures << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "formatProperties");
    out << "\t\t" << "VkFormatProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFramebufferCreateInfo(std::ostream &out, const VkFramebufferCreateInfo* structInfo, Decoded_VkFramebufferCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pattachments_array = "NULL";
    if (metaInfo->pAttachments.GetPointer() != NULL && structInfo->attachmentCount > 0) {
        pattachments_array = "pattachments_array_" + std::to_string(consumer.GetNextId());
        std::string pattachments_values = toStringJoin(metaInfo->pAttachments.GetPointer(),
                                                       metaInfo->pAttachments.GetPointer() + structInfo->attachmentCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->attachmentCount == 1) {
            pattachments_array = "&" + pattachments_values;
        } else if (structInfo->attachmentCount > 1) {
            out << "\t\t" << "VkImageView " << pattachments_array << "[] = {" << pattachments_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFramebufferCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->renderPass) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->attachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pattachments_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->width << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->height << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->layers << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "framebufferCreateInfo");
    out << "\t\t" << "VkFramebufferCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGraphicsPipelineCreateInfo(std::ostream &out, const VkGraphicsPipelineCreateInfo* structInfo, Decoded_VkGraphicsPipelineCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstages_array = "NULL";
    if (structInfo->pStages != NULL) {
        pstages_array = "pStages_" + std::to_string(consumer.GetNextId());
        std::string pstages_names;
        for (uint32_t idx = 0; idx < structInfo->stageCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStages + idx != NULL) {
                variable_name = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                                               structInfo->pStages + idx,
                                                                               metaInfo->pStages->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pstages_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPipelineShaderStageCreateInfo " << pstages_array << "[] = {" << pstages_names << "};" << std::endl;
    }
    std::string pvertex_input_state_struct = "NULL";
    if (structInfo->pVertexInputState != NULL) {
        pvertex_input_state_struct = GenerateStruct_VkPipelineVertexInputStateCreateInfo(out,
                                                                                         structInfo->pVertexInputState,
                                                                                         metaInfo->pVertexInputState->GetMetaStructPointer(),
                                                                                         consumer);
        pvertex_input_state_struct.insert(0, "&");
    }
    std::string pinput_assembly_state_struct = "NULL";
    if (structInfo->pInputAssemblyState != NULL) {
        pinput_assembly_state_struct = GenerateStruct_VkPipelineInputAssemblyStateCreateInfo(out,
                                                                                             structInfo->pInputAssemblyState,
                                                                                             metaInfo->pInputAssemblyState->GetMetaStructPointer(),
                                                                                             consumer);
        pinput_assembly_state_struct.insert(0, "&");
    }
    std::string ptessellation_state_struct = "NULL";
    if (structInfo->pTessellationState != NULL) {
        ptessellation_state_struct = GenerateStruct_VkPipelineTessellationStateCreateInfo(out,
                                                                                          structInfo->pTessellationState,
                                                                                          metaInfo->pTessellationState->GetMetaStructPointer(),
                                                                                          consumer);
        ptessellation_state_struct.insert(0, "&");
    }
    std::string pviewport_state_struct = "NULL";
    if (structInfo->pViewportState != NULL) {
        pviewport_state_struct = GenerateStruct_VkPipelineViewportStateCreateInfo(out,
                                                                                  structInfo->pViewportState,
                                                                                  metaInfo->pViewportState->GetMetaStructPointer(),
                                                                                  consumer);
        pviewport_state_struct.insert(0, "&");
    }
    std::string prasterization_state_struct = "NULL";
    if (structInfo->pRasterizationState != NULL) {
        prasterization_state_struct = GenerateStruct_VkPipelineRasterizationStateCreateInfo(out,
                                                                                            structInfo->pRasterizationState,
                                                                                            metaInfo->pRasterizationState->GetMetaStructPointer(),
                                                                                            consumer);
        prasterization_state_struct.insert(0, "&");
    }
    std::string pmultisample_state_struct = "NULL";
    if (structInfo->pMultisampleState != NULL) {
        pmultisample_state_struct = GenerateStruct_VkPipelineMultisampleStateCreateInfo(out,
                                                                                        structInfo->pMultisampleState,
                                                                                        metaInfo->pMultisampleState->GetMetaStructPointer(),
                                                                                        consumer);
        pmultisample_state_struct.insert(0, "&");
    }
    std::string pdepth_stencil_state_struct = "NULL";
    if (structInfo->pDepthStencilState != NULL) {
        pdepth_stencil_state_struct = GenerateStruct_VkPipelineDepthStencilStateCreateInfo(out,
                                                                                           structInfo->pDepthStencilState,
                                                                                           metaInfo->pDepthStencilState->GetMetaStructPointer(),
                                                                                           consumer);
        pdepth_stencil_state_struct.insert(0, "&");
    }
    std::string pcolor_blend_state_struct = "NULL";
    if (structInfo->pColorBlendState != NULL) {
        pcolor_blend_state_struct = GenerateStruct_VkPipelineColorBlendStateCreateInfo(out,
                                                                                       structInfo->pColorBlendState,
                                                                                       metaInfo->pColorBlendState->GetMetaStructPointer(),
                                                                                       consumer);
        pcolor_blend_state_struct.insert(0, "&");
    }
    std::string pdynamic_state_struct = "NULL";
    if (structInfo->pDynamicState != NULL) {
        pdynamic_state_struct = GenerateStruct_VkPipelineDynamicStateCreateInfo(out,
                                                                                structInfo->pDynamicState,
                                                                                metaInfo->pDynamicState->GetMetaStructPointer(),
                                                                                consumer);
        pdynamic_state_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stageCount << "," << std::endl;
    struct_body << "\t\t\t" << pstages_array << "," << std::endl;
    struct_body << "\t\t\t" << pvertex_input_state_struct << "," << std::endl;
    struct_body << "\t\t\t" << pinput_assembly_state_struct << "," << std::endl;
    struct_body << "\t\t\t" << ptessellation_state_struct << "," << std::endl;
    struct_body << "\t\t\t" << pviewport_state_struct << "," << std::endl;
    struct_body << "\t\t\t" << prasterization_state_struct << "," << std::endl;
    struct_body << "\t\t\t" << pmultisample_state_struct << "," << std::endl;
    struct_body << "\t\t\t" << pdepth_stencil_state_struct << "," << std::endl;
    struct_body << "\t\t\t" << pcolor_blend_state_struct << "," << std::endl;
    struct_body << "\t\t\t" << pdynamic_state_struct << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->layout) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->renderPass) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subpass << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->basePipelineHandle) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->basePipelineIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "graphicsPipelineCreateInfo");
    out << "\t\t" << "VkGraphicsPipelineCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageBlit(std::ostream &out, const VkImageBlit* structInfo, Decoded_VkImageBlit* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string src_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->srcSubresource,
                                                                                   metaInfo->srcSubresource,
                                                                                   consumer);
    std::string dst_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->dstSubresource,
                                                                                   metaInfo->dstSubresource,
                                                                                   consumer);
    struct_body << "\t" << src_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkOffset3D*>(&structInfo->srcOffsets[0]), 2) << "," << std::endl;
    struct_body << "\t\t\t" << dst_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkOffset3D*>(&structInfo->dstOffsets[0]), 2) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageBlit");
    out << "\t\t" << "VkImageBlit " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageCopy(std::ostream &out, const VkImageCopy* structInfo, Decoded_VkImageCopy* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string src_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->srcSubresource,
                                                                                   metaInfo->srcSubresource,
                                                                                   consumer);
    std::string src_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->srcOffset,
                                                                metaInfo->srcOffset,
                                                                consumer);
    std::string dst_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->dstSubresource,
                                                                                   metaInfo->dstSubresource,
                                                                                   consumer);
    std::string dst_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->dstOffset,
                                                                metaInfo->dstOffset,
                                                                consumer);
    std::string extent_info_var = GenerateStruct_VkExtent3D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
    struct_body << "\t" << src_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << src_offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << dst_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << dst_offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageCopy");
    out << "\t\t" << "VkImageCopy " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageCreateInfo(std::ostream &out, const VkImageCreateInfo* structInfo, Decoded_VkImageCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string extent_info_var = GenerateStruct_VkExtent3D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
    std::string pqueue_family_indices_array = "NULL";
    if (structInfo->pQueueFamilyIndices != NULL) {
        pqueue_family_indices_array = "pQueueFamilyIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pqueue_family_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pQueueFamilyIndices, structInfo->queueFamilyIndexCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageType(" << structInfo->imageType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->mipLevels << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->arrayLayers << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->samples << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageTiling(" << structInfo->tiling << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSharingMode(" << structInfo->sharingMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueFamilyIndexCount << "," << std::endl;
    struct_body << "\t\t\t" << pqueue_family_indices_array << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->initialLayout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageCreateInfo");
    out << "\t\t" << "VkImageCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageFormatProperties(std::ostream &out, const VkImageFormatProperties* structInfo, Decoded_VkImageFormatProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string max_extent_info_var = GenerateStruct_VkExtent3D(out,
                                                                &structInfo->maxExtent,
                                                                metaInfo->maxExtent,
                                                                consumer);
    struct_body << "\t" << max_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMipLevels << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxArrayLayers << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->sampleCounts << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxResourceSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageFormatProperties");
    out << "\t\t" << "VkImageFormatProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageMemoryBarrier(std::ostream &out, const VkImageMemoryBarrier* structInfo, Decoded_VkImageMemoryBarrier* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string subresource_range_info_var = GenerateStruct_VkImageSubresourceRange(out,
                                                                                    &structInfo->subresourceRange,
                                                                                    metaInfo->subresourceRange,
                                                                                    consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->oldLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->newLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcQueueFamilyIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstQueueFamilyIndex << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
    struct_body << "\t\t\t" << subresource_range_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageMemoryBarrier");
    out << "\t\t" << "VkImageMemoryBarrier " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageResolve(std::ostream &out, const VkImageResolve* structInfo, Decoded_VkImageResolve* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string src_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->srcSubresource,
                                                                                   metaInfo->srcSubresource,
                                                                                   consumer);
    std::string src_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->srcOffset,
                                                                metaInfo->srcOffset,
                                                                consumer);
    std::string dst_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->dstSubresource,
                                                                                   metaInfo->dstSubresource,
                                                                                   consumer);
    std::string dst_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->dstOffset,
                                                                metaInfo->dstOffset,
                                                                consumer);
    std::string extent_info_var = GenerateStruct_VkExtent3D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
    struct_body << "\t" << src_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << src_offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << dst_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << dst_offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageResolve");
    out << "\t\t" << "VkImageResolve " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageSubresource(std::ostream &out, const VkImageSubresource* structInfo, Decoded_VkImageSubresource* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->mipLevel << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->arrayLayer << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageSubresource");
    out << "\t\t" << "VkImageSubresource " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageSubresourceLayers(std::ostream &out, const VkImageSubresourceLayers* structInfo, Decoded_VkImageSubresourceLayers* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->mipLevel << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->baseArrayLayer << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->layerCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageSubresourceLayers");
    out << "\t\t" << "VkImageSubresourceLayers " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageSubresourceRange(std::ostream &out, const VkImageSubresourceRange* structInfo, Decoded_VkImageSubresourceRange* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->baseMipLevel << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->levelCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->baseArrayLayer << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->layerCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageSubresourceRange");
    out << "\t\t" << "VkImageSubresourceRange " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewCreateInfo(std::ostream &out, const VkImageViewCreateInfo* structInfo, Decoded_VkImageViewCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string components_info_var = GenerateStruct_VkComponentMapping(out,
                                                                        &structInfo->components,
                                                                        metaInfo->components,
                                                                        consumer);
    std::string subresource_range_info_var = GenerateStruct_VkImageSubresourceRange(out,
                                                                                    &structInfo->subresourceRange,
                                                                                    metaInfo->subresourceRange,
                                                                                    consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageViewCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageViewType(" << structInfo->viewType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << components_info_var << "," << std::endl;
    struct_body << "\t\t\t" << subresource_range_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewCreateInfo");
    out << "\t\t" << "VkImageViewCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkLayerProperties(std::ostream &out, const VkLayerProperties* structInfo, Decoded_VkLayerProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << VulkanCppConsumerBase::ToEscape(structInfo->layerName) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->specVersion << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->implementationVersion << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "layerProperties");
    out << "\t\t" << "VkLayerProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMappedMemoryRange(std::ostream &out, const VkMappedMemoryRange* structInfo, Decoded_VkMappedMemoryRange* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "mappedMemoryRange");
    out << "\t\t" << "VkMappedMemoryRange " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryBarrier(std::ostream &out, const VkMemoryBarrier* structInfo, Decoded_VkMemoryBarrier* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryBarrier");
    out << "\t\t" << "VkMemoryBarrier " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryHeap(std::ostream &out, const VkMemoryHeap* structInfo, Decoded_VkMemoryHeap* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->size << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkMemoryHeapFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryHeap");
    out << "\t\t" << "VkMemoryHeap " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryRequirements(std::ostream &out, const VkMemoryRequirements* structInfo, Decoded_VkMemoryRequirements* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->size << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->alignment << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryTypeBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryRequirements");
    out << "\t\t" << "VkMemoryRequirements " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryType(std::ostream &out, const VkMemoryType* structInfo, Decoded_VkMemoryType* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkMemoryPropertyFlags(" << structInfo->propertyFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->heapIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryType");
    out << "\t\t" << "VkMemoryType " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOffset2D(std::ostream &out, const VkOffset2D* structInfo, Decoded_VkOffset2D* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->x << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->y << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "offset2D");
    out << "\t\t" << "VkOffset2D " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOffset3D(std::ostream &out, const VkOffset3D* structInfo, Decoded_VkOffset3D* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->x << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->y << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->z << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "offset3D");
    out << "\t\t" << "VkOffset3D " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFeatures(std::ostream &out, const VkPhysicalDeviceFeatures* structInfo, Decoded_VkPhysicalDeviceFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->robustBufferAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fullDrawIndexUint32 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageCubeArray << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->independentBlend << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->geometryShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tessellationShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sampleRateShading << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dualSrcBlend << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->logicOp << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multiDrawIndirect << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->drawIndirectFirstInstance << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthClamp << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthBiasClamp << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fillModeNonSolid << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthBounds << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->wideLines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->largePoints << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->alphaToOne << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multiViewport << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->samplerAnisotropy << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->textureCompressionETC2 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->textureCompressionASTC_LDR << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->textureCompressionBC << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->occlusionQueryPrecise << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineStatisticsQuery << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexPipelineStoresAndAtomics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentStoresAndAtomics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderTessellationAndGeometryPointSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderImageGatherExtended << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageImageExtendedFormats << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageImageMultisample << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageImageReadWithoutFormat << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageImageWriteWithoutFormat << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderUniformBufferArrayDynamicIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSampledImageArrayDynamicIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageBufferArrayDynamicIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageImageArrayDynamicIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderClipDistance << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderCullDistance << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderFloat64 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderInt64 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderInt16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderResourceResidency << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderResourceMinLod << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sparseBinding << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sparseResidencyBuffer << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sparseResidencyImage2D << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sparseResidencyImage3D << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sparseResidency2Samples << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sparseResidency4Samples << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sparseResidency8Samples << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sparseResidency16Samples << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sparseResidencyAliased << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->variableMultisampleRate << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->inheritedQueries << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFeatures");
    out << "\t\t" << "VkPhysicalDeviceFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLimits(std::ostream &out, const VkPhysicalDeviceLimits* structInfo, Decoded_VkPhysicalDeviceLimits* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->maxImageDimension1D << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxImageDimension2D << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxImageDimension3D << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxImageDimensionCube << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxImageArrayLayers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTexelBufferElements << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxUniformBufferRange << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxStorageBufferRange << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPushConstantsSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMemoryAllocationCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSamplerAllocationCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferImageGranularity << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sparseAddressSpaceSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxBoundDescriptorSets << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorSamplers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUniformBuffers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorStorageBuffers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorSampledImages << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorStorageImages << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorInputAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageResources << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetSamplers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUniformBuffers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUniformBuffersDynamic << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetStorageBuffers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetStorageBuffersDynamic << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetSampledImages << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetStorageImages << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetInputAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxVertexInputAttributes << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxVertexInputBindings << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxVertexInputAttributeOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxVertexInputBindingStride << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxVertexOutputComponents << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTessellationGenerationLevel << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTessellationPatchSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTessellationControlPerVertexInputComponents << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTessellationControlPerVertexOutputComponents << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTessellationControlPerPatchOutputComponents << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTessellationControlTotalOutputComponents << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTessellationEvaluationInputComponents << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTessellationEvaluationOutputComponents << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxGeometryShaderInvocations << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxGeometryInputComponents << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxGeometryOutputComponents << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxGeometryOutputVertices << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxGeometryTotalOutputComponents << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxFragmentInputComponents << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxFragmentOutputAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxFragmentDualSrcAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxFragmentCombinedOutputResources << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxComputeSharedMemorySize << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxComputeWorkGroupCount[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxComputeWorkGroupInvocations << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxComputeWorkGroupSize[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subPixelPrecisionBits << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subTexelPrecisionBits << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->mipmapPrecisionBits << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDrawIndexedIndexValue << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDrawIndirectCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSamplerLodBias << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSamplerAnisotropy << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxViewports << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxViewportDimensions[0]), 2) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->viewportBoundsRange[0]), 2) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewportSubPixelBits << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minMemoryMapAlignment << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minTexelBufferOffsetAlignment << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minUniformBufferOffsetAlignment << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minStorageBufferOffsetAlignment << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minTexelOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTexelOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minTexelGatherOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTexelGatherOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minInterpolationOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxInterpolationOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subPixelInterpolationOffsetBits << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxFramebufferWidth << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxFramebufferHeight << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxFramebufferLayers << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->framebufferColorSampleCounts << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->framebufferDepthSampleCounts << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->framebufferStencilSampleCounts << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->framebufferNoAttachmentsSampleCounts << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxColorAttachments << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->sampledImageColorSampleCounts << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->sampledImageIntegerSampleCounts << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->sampledImageDepthSampleCounts << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->sampledImageStencilSampleCounts << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->storageImageSampleCounts << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSampleMaskWords << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timestampComputeAndGraphics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timestampPeriod << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxClipDistances << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxCullDistances << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxCombinedClipAndCullDistances << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->discreteQueuePriorities << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->pointSizeRange[0]), 2) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->lineWidthRange[0]), 2) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pointSizeGranularity << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->lineWidthGranularity << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->strictLines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->standardSampleLocations << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->optimalBufferCopyOffsetAlignment << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->optimalBufferCopyRowPitchAlignment << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->nonCoherentAtomSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLimits");
    out << "\t\t" << "VkPhysicalDeviceLimits " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMemoryProperties(std::ostream &out, const VkPhysicalDeviceMemoryProperties* structInfo, Decoded_VkPhysicalDeviceMemoryProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->memoryTypeCount << "," << std::endl;
	struct_body << "\t\t\t{}," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryHeapCount << "," << std::endl;
	struct_body << "\t\t\t{}," << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMemoryProperties");
    out << "\t\t" << "VkPhysicalDeviceMemoryProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceProperties(std::ostream &out, const VkPhysicalDeviceProperties* structInfo, Decoded_VkPhysicalDeviceProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string limits_info_var = GenerateStruct_VkPhysicalDeviceLimits(out,
                                                                        &structInfo->limits,
                                                                        metaInfo->limits,
                                                                        consumer);
    std::string sparse_properties_info_var = GenerateStruct_VkPhysicalDeviceSparseProperties(out,
                                                                                             &structInfo->sparseProperties,
                                                                                             metaInfo->sparseProperties,
                                                                                             consumer);
    struct_body << "\t" << structInfo->apiVersion << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->driverVersion << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vendorID << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceID << "," << std::endl;
    struct_body << "\t\t\t" << "VkPhysicalDeviceType(" << structInfo->deviceType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->deviceName) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->pipelineCacheUUID[0]), VK_UUID_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << limits_info_var << "," << std::endl;
    struct_body << "\t\t\t" << sparse_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceProperties");
    out << "\t\t" << "VkPhysicalDeviceProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSparseProperties(std::ostream &out, const VkPhysicalDeviceSparseProperties* structInfo, Decoded_VkPhysicalDeviceSparseProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->residencyStandard2DBlockShape << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->residencyStandard2DMultisampleBlockShape << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->residencyStandard3DBlockShape << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->residencyAlignedMipSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->residencyNonResidentStrict << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSparseProperties");
    out << "\t\t" << "VkPhysicalDeviceSparseProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCacheCreateInfo(std::ostream &out, const VkPipelineCacheCreateInfo* structInfo, Decoded_VkPipelineCacheCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pinitial_data_array = "NULL";
    if (structInfo->pInitialData != NULL) {
        std::string pinitial_data_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->initialDataSize; ++idx0) {
            pinitial_data_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pInitialData)[idx0]) + ", ";
        }
        pinitial_data_array = "pInitialData_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pinitial_data_array << "[] = {" << pinitial_data_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineCacheCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->initialDataSize << "," << std::endl;
    struct_body << "\t\t\t" << pinitial_data_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCacheCreateInfo");
    out << "\t\t" << "VkPipelineCacheCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCacheHeaderVersionOne(std::ostream &out, const VkPipelineCacheHeaderVersionOne* structInfo, Decoded_VkPipelineCacheHeaderVersionOne* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->headerSize << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineCacheHeaderVersion(" << structInfo->headerVersion << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vendorID << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceID << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->pipelineCacheUUID[0]), VK_UUID_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCacheHeaderVersionOne");
    out << "\t\t" << "VkPipelineCacheHeaderVersionOne " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineColorBlendAttachmentState(std::ostream &out, const VkPipelineColorBlendAttachmentState* structInfo, Decoded_VkPipelineColorBlendAttachmentState* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->blendEnable << "," << std::endl;
    struct_body << "\t\t\t" << "VkBlendFactor(" << structInfo->srcColorBlendFactor << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBlendFactor(" << structInfo->dstColorBlendFactor << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBlendOp(" << structInfo->colorBlendOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBlendFactor(" << structInfo->srcAlphaBlendFactor << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBlendFactor(" << structInfo->dstAlphaBlendFactor << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBlendOp(" << structInfo->alphaBlendOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkColorComponentFlags(" << structInfo->colorWriteMask << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineColorBlendAttachmentState");
    out << "\t\t" << "VkPipelineColorBlendAttachmentState " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineColorBlendStateCreateInfo(std::ostream &out, const VkPipelineColorBlendStateCreateInfo* structInfo, Decoded_VkPipelineColorBlendStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pattachments_array = "NULL";
    if (structInfo->pAttachments != NULL) {
        pattachments_array = "pAttachments_" + std::to_string(consumer.GetNextId());
        std::string pattachments_names;
        for (uint32_t idx = 0; idx < structInfo->attachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkPipelineColorBlendAttachmentState(out,
                                                                                   structInfo->pAttachments + idx,
                                                                                   metaInfo->pAttachments->GetMetaStructPointer() + idx,
                                                                                   consumer);
            }
            pattachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPipelineColorBlendAttachmentState " << pattachments_array << "[] = {" << pattachments_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineColorBlendStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->logicOpEnable << "," << std::endl;
    struct_body << "\t\t\t" << "VkLogicOp(" << structInfo->logicOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->attachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pattachments_array << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->blendConstants[0]), 4) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineColorBlendStateCreateInfo");
    out << "\t\t" << "VkPipelineColorBlendStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineDepthStencilStateCreateInfo(std::ostream &out, const VkPipelineDepthStencilStateCreateInfo* structInfo, Decoded_VkPipelineDepthStencilStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string front_info_var = GenerateStruct_VkStencilOpState(out,
                                                                 &structInfo->front,
                                                                 metaInfo->front,
                                                                 consumer);
    std::string back_info_var = GenerateStruct_VkStencilOpState(out,
                                                                &structInfo->back,
                                                                metaInfo->back,
                                                                consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineDepthStencilStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthTestEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthWriteEnable << "," << std::endl;
    struct_body << "\t\t\t" << "VkCompareOp(" << structInfo->depthCompareOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthBoundsTestEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stencilTestEnable << "," << std::endl;
    struct_body << "\t\t\t" << front_info_var << "," << std::endl;
    struct_body << "\t\t\t" << back_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minDepthBounds << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDepthBounds << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineDepthStencilStateCreateInfo");
    out << "\t\t" << "VkPipelineDepthStencilStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineDynamicStateCreateInfo(std::ostream &out, const VkPipelineDynamicStateCreateInfo* structInfo, Decoded_VkPipelineDynamicStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdynamic_states_values;
    std::string pdynamic_states_array = "NULL";
    if (structInfo->pDynamicStates != NULL) {
        for (uint32_t idx = 0; idx < structInfo->dynamicStateCount; idx++) {
            pdynamic_states_values += util::ToString<VkDynamicState>(structInfo->pDynamicStates[idx]) + ", ";
        }
        pdynamic_states_array = "pDynamicStates_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkDynamicState " << pdynamic_states_array << "[] = {" << pdynamic_states_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineDynamicStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dynamicStateCount << "," << std::endl;
    struct_body << "\t\t\t" << pdynamic_states_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineDynamicStateCreateInfo");
    out << "\t\t" << "VkPipelineDynamicStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineInputAssemblyStateCreateInfo(std::ostream &out, const VkPipelineInputAssemblyStateCreateInfo* structInfo, Decoded_VkPipelineInputAssemblyStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineInputAssemblyStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPrimitiveTopology(" << structInfo->topology << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primitiveRestartEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineInputAssemblyStateCreateInfo");
    out << "\t\t" << "VkPipelineInputAssemblyStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineLayoutCreateInfo(std::ostream &out, const VkPipelineLayoutCreateInfo* structInfo, Decoded_VkPipelineLayoutCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pset_layouts_array = "NULL";
    if (metaInfo->pSetLayouts.GetPointer() != NULL && structInfo->setLayoutCount > 0) {
        pset_layouts_array = "pset_layouts_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT));
        std::string pset_layouts_values = toStringJoin(metaInfo->pSetLayouts.GetPointer(),
                                                       metaInfo->pSetLayouts.GetPointer() + structInfo->setLayoutCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->setLayoutCount == 1) {
            pset_layouts_array = "&" + pset_layouts_values;
        } else if (structInfo->setLayoutCount > 1) {
            out << "\t\t" << "VkDescriptorSetLayout " << pset_layouts_array << "[] = {" << pset_layouts_values << "};" << std::endl;
        }
    }
    std::string ppush_constant_ranges_array = "NULL";
    if (structInfo->pPushConstantRanges != NULL) {
        ppush_constant_ranges_array = "pPushConstantRanges_" + std::to_string(consumer.GetNextId());
        std::string ppush_constant_ranges_names;
        for (uint32_t idx = 0; idx < structInfo->pushConstantRangeCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPushConstantRanges + idx != NULL) {
                variable_name = GenerateStruct_VkPushConstantRange(out,
                                                                   structInfo->pPushConstantRanges + idx,
                                                                   metaInfo->pPushConstantRanges->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            ppush_constant_ranges_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPushConstantRange " << ppush_constant_ranges_array << "[] = {" << ppush_constant_ranges_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineLayoutCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->setLayoutCount << "," << std::endl;
    struct_body << "\t\t\t" << pset_layouts_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pushConstantRangeCount << "," << std::endl;
    struct_body << "\t\t\t" << ppush_constant_ranges_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineLayoutCreateInfo");
    out << "\t\t" << "VkPipelineLayoutCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineMultisampleStateCreateInfo(std::ostream &out, const VkPipelineMultisampleStateCreateInfo* structInfo, Decoded_VkPipelineMultisampleStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string psample_mask_array = "NULL";
    if (structInfo->pSampleMask != NULL) {
        std::string psample_mask_values;
        for (uint32_t idx0 = 0; idx0 < (structInfo->rasterizationSamples + 31) / 32; ++idx0) {
            psample_mask_values += std::to_string(structInfo->pSampleMask[idx0]) + ", ";
        }
        psample_mask_array = "pSampleMask_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkSampleMask " << psample_mask_array << "[] = {" << psample_mask_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineMultisampleStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->rasterizationSamples << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sampleShadingEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minSampleShading << "," << std::endl;
    struct_body << "\t\t\t" << psample_mask_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->alphaToCoverageEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->alphaToOneEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineMultisampleStateCreateInfo");
    out << "\t\t" << "VkPipelineMultisampleStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRasterizationStateCreateInfo(std::ostream &out, const VkPipelineRasterizationStateCreateInfo* structInfo, Decoded_VkPipelineRasterizationStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRasterizationStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthClampEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rasterizerDiscardEnable << "," << std::endl;
    struct_body << "\t\t\t" << "VkPolygonMode(" << structInfo->polygonMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkCullModeFlags(" << structInfo->cullMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFrontFace(" << structInfo->frontFace << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthBiasEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthBiasConstantFactor << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthBiasClamp << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthBiasSlopeFactor << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->lineWidth << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRasterizationStateCreateInfo");
    out << "\t\t" << "VkPipelineRasterizationStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineShaderStageCreateInfo(std::ostream &out, const VkPipelineShaderStageCreateInfo* structInfo, Decoded_VkPipelineShaderStageCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pspecialization_info_struct = "NULL";
    if (structInfo->pSpecializationInfo != NULL) {
        pspecialization_info_struct = GenerateStruct_VkSpecializationInfo(out,
                                                                          structInfo->pSpecializationInfo,
                                                                          metaInfo->pSpecializationInfo->GetMetaStructPointer(),
                                                                          consumer);
        pspecialization_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineShaderStageCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlagBits(" << structInfo->stage << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->module) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pName) << "," << std::endl;
    struct_body << "\t\t\t" << pspecialization_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineShaderStageCreateInfo");
    out << "\t\t" << "VkPipelineShaderStageCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineTessellationStateCreateInfo(std::ostream &out, const VkPipelineTessellationStateCreateInfo* structInfo, Decoded_VkPipelineTessellationStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineTessellationStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->patchControlPoints << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineTessellationStateCreateInfo");
    out << "\t\t" << "VkPipelineTessellationStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineVertexInputStateCreateInfo(std::ostream &out, const VkPipelineVertexInputStateCreateInfo* structInfo, Decoded_VkPipelineVertexInputStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pvertex_binding_descriptions_array = "NULL";
    if (structInfo->pVertexBindingDescriptions != NULL) {
        pvertex_binding_descriptions_array = "pVertexBindingDescriptions_" + std::to_string(consumer.GetNextId());
        std::string pvertex_binding_descriptions_names;
        for (uint32_t idx = 0; idx < structInfo->vertexBindingDescriptionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pVertexBindingDescriptions + idx != NULL) {
                variable_name = GenerateStruct_VkVertexInputBindingDescription(out,
                                                                               structInfo->pVertexBindingDescriptions + idx,
                                                                               metaInfo->pVertexBindingDescriptions->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pvertex_binding_descriptions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVertexInputBindingDescription " << pvertex_binding_descriptions_array << "[] = {" << pvertex_binding_descriptions_names << "};" << std::endl;
    }
    std::string pvertex_attribute_descriptions_array = "NULL";
    if (structInfo->pVertexAttributeDescriptions != NULL) {
        pvertex_attribute_descriptions_array = "pVertexAttributeDescriptions_" + std::to_string(consumer.GetNextId());
        std::string pvertex_attribute_descriptions_names;
        for (uint32_t idx = 0; idx < structInfo->vertexAttributeDescriptionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pVertexAttributeDescriptions + idx != NULL) {
                variable_name = GenerateStruct_VkVertexInputAttributeDescription(out,
                                                                                 structInfo->pVertexAttributeDescriptions + idx,
                                                                                 metaInfo->pVertexAttributeDescriptions->GetMetaStructPointer() + idx,
                                                                                 consumer);
            }
            pvertex_attribute_descriptions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVertexInputAttributeDescription " << pvertex_attribute_descriptions_array << "[] = {" << pvertex_attribute_descriptions_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineVertexInputStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexBindingDescriptionCount << "," << std::endl;
    struct_body << "\t\t\t" << pvertex_binding_descriptions_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexAttributeDescriptionCount << "," << std::endl;
    struct_body << "\t\t\t" << pvertex_attribute_descriptions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineVertexInputStateCreateInfo");
    out << "\t\t" << "VkPipelineVertexInputStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportStateCreateInfo(std::ostream &out, const VkPipelineViewportStateCreateInfo* structInfo, Decoded_VkPipelineViewportStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pviewports_array = "NULL";
    if (structInfo->pViewports != NULL) {
        pviewports_array = "pViewports_" + std::to_string(consumer.GetNextId());
        std::string pviewports_names;
        for (uint32_t idx = 0; idx < structInfo->viewportCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pViewports + idx != NULL) {
                variable_name = GenerateStruct_VkViewport(out,
                                                          structInfo->pViewports + idx,
                                                          metaInfo->pViewports->GetMetaStructPointer() + idx,
                                                          consumer);
            }
            pviewports_names += variable_name + ", ";
        }
        out << "\t\t" << "VkViewport " << pviewports_array << "[] = {" << pviewports_names << "};" << std::endl;
    }
    std::string pscissors_array = "NULL";
    if (structInfo->pScissors != NULL) {
        pscissors_array = "pScissors_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkRect2D " << pscissors_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pScissors, structInfo->scissorCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineViewportStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewportCount << "," << std::endl;
    struct_body << "\t\t\t" << pviewports_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->scissorCount << "," << std::endl;
    struct_body << "\t\t\t" << pscissors_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportStateCreateInfo");
    out << "\t\t" << "VkPipelineViewportStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPushConstantRange(std::ostream &out, const VkPushConstantRange* structInfo, Decoded_VkPushConstantRange* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkShaderStageFlags(" << structInfo->stageFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pushConstantRange");
    out << "\t\t" << "VkPushConstantRange " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueryPoolCreateInfo(std::ostream &out, const VkQueryPoolCreateInfo* structInfo, Decoded_VkQueryPoolCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkQueryPoolCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkQueryType(" << structInfo->queryType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queryCount << "," << std::endl;
    struct_body << "\t\t\t" << "VkQueryPipelineStatisticFlags(" << structInfo->pipelineStatistics << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queryPoolCreateInfo");
    out << "\t\t" << "VkQueryPoolCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyProperties(std::ostream &out, const VkQueueFamilyProperties* structInfo, Decoded_VkQueueFamilyProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string min_image_transfer_granularity_info_var = GenerateStruct_VkExtent3D(out,
                                                                                    &structInfo->minImageTransferGranularity,
                                                                                    metaInfo->minImageTransferGranularity,
                                                                                    consumer);
    struct_body << "\t" << "VkQueueFlags(" << structInfo->queueFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timestampValidBits << "," << std::endl;
    struct_body << "\t\t\t" << min_image_transfer_granularity_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyProperties");
    out << "\t\t" << "VkQueueFamilyProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRect2D(std::ostream &out, const VkRect2D* structInfo, Decoded_VkRect2D* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string offset_info_var = GenerateStruct_VkOffset2D(out,
                                                            &structInfo->offset,
                                                            metaInfo->offset,
                                                            consumer);
    std::string extent_info_var = GenerateStruct_VkExtent2D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
    struct_body << "\t" << offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "rect2D");
    out << "\t\t" << "VkRect2D " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassBeginInfo(std::ostream &out, const VkRenderPassBeginInfo* structInfo, Decoded_VkRenderPassBeginInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string render_area_info_var = GenerateStruct_VkRect2D(out,
                                                               &structInfo->renderArea,
                                                               metaInfo->renderArea,
                                                               consumer);
    std::string pclear_values_array = "NULL";
    if (structInfo->pClearValues != NULL) {
        pclear_values_array = "pClearValues_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkClearValue " << pclear_values_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pClearValues, structInfo->clearValueCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->renderPass) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->framebuffer) << "," << std::endl;
    struct_body << "\t\t\t" << render_area_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->clearValueCount << "," << std::endl;
    struct_body << "\t\t\t" << pclear_values_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassBeginInfo");
    out << "\t\t" << "VkRenderPassBeginInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassCreateInfo(std::ostream &out, const VkRenderPassCreateInfo* structInfo, Decoded_VkRenderPassCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pattachments_array = "NULL";
    if (structInfo->pAttachments != NULL) {
        pattachments_array = "pAttachments_" + std::to_string(consumer.GetNextId());
        std::string pattachments_names;
        for (uint32_t idx = 0; idx < structInfo->attachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentDescription(out,
                                                                       structInfo->pAttachments + idx,
                                                                       metaInfo->pAttachments->GetMetaStructPointer() + idx,
                                                                       consumer);
            }
            pattachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentDescription " << pattachments_array << "[] = {" << pattachments_names << "};" << std::endl;
    }
    std::string psubpasses_array = "NULL";
    if (structInfo->pSubpasses != NULL) {
        psubpasses_array = "pSubpasses_" + std::to_string(consumer.GetNextId());
        std::string psubpasses_names;
        for (uint32_t idx = 0; idx < structInfo->subpassCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pSubpasses + idx != NULL) {
                variable_name = GenerateStruct_VkSubpassDescription(out,
                                                                    structInfo->pSubpasses + idx,
                                                                    metaInfo->pSubpasses->GetMetaStructPointer() + idx,
                                                                    consumer);
            }
            psubpasses_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSubpassDescription " << psubpasses_array << "[] = {" << psubpasses_names << "};" << std::endl;
    }
    std::string pdependencies_array = "NULL";
    if (structInfo->pDependencies != NULL) {
        pdependencies_array = "pDependencies_" + std::to_string(consumer.GetNextId());
        std::string pdependencies_names;
        for (uint32_t idx = 0; idx < structInfo->dependencyCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pDependencies + idx != NULL) {
                variable_name = GenerateStruct_VkSubpassDependency(out,
                                                                   structInfo->pDependencies + idx,
                                                                   metaInfo->pDependencies->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            pdependencies_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSubpassDependency " << pdependencies_array << "[] = {" << pdependencies_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkRenderPassCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->attachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pattachments_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subpassCount << "," << std::endl;
    struct_body << "\t\t\t" << psubpasses_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dependencyCount << "," << std::endl;
    struct_body << "\t\t\t" << pdependencies_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassCreateInfo");
    out << "\t\t" << "VkRenderPassCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerCreateInfo(std::ostream &out, const VkSamplerCreateInfo* structInfo, Decoded_VkSamplerCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSamplerCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFilter(" << structInfo->magFilter << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFilter(" << structInfo->minFilter << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSamplerMipmapMode(" << structInfo->mipmapMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSamplerAddressMode(" << structInfo->addressModeU << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSamplerAddressMode(" << structInfo->addressModeV << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSamplerAddressMode(" << structInfo->addressModeW << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->mipLodBias << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->anisotropyEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxAnisotropy << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->compareEnable << "," << std::endl;
    struct_body << "\t\t\t" << "VkCompareOp(" << structInfo->compareOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minLod << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxLod << "," << std::endl;
    struct_body << "\t\t\t" << "VkBorderColor(" << structInfo->borderColor << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->unnormalizedCoordinates << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerCreateInfo");
    out << "\t\t" << "VkSamplerCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreCreateInfo(std::ostream &out, const VkSemaphoreCreateInfo* structInfo, Decoded_VkSemaphoreCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSemaphoreCreateFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreCreateInfo");
    out << "\t\t" << "VkSemaphoreCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkShaderModuleCreateInfo(std::ostream &out, const VkShaderModuleCreateInfo* structInfo, Decoded_VkShaderModuleCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcode_array = "NULL";
    if (structInfo->pCode != NULL) {
        pcode_array = "pCode_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pcode_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCode, structInfo->codeSize / 4) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderModuleCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->codeSize << "," << std::endl;
    struct_body << "\t\t\t" << pcode_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "shaderModuleCreateInfo");
    out << "\t\t" << "VkShaderModuleCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseBufferMemoryBindInfo(std::ostream &out, const VkSparseBufferMemoryBindInfo* structInfo, Decoded_VkSparseBufferMemoryBindInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pbinds_array = "NULL";
    if (structInfo->pBinds != NULL) {
        pbinds_array = "pBinds_" + std::to_string(consumer.GetNextId());
        std::string pbinds_names;
        for (uint32_t idx = 0; idx < structInfo->bindCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pBinds + idx != NULL) {
                variable_name = GenerateStruct_VkSparseMemoryBind(out,
                                                                  structInfo->pBinds + idx,
                                                                  metaInfo->pBinds->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pbinds_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSparseMemoryBind " << pbinds_array << "[] = {" << pbinds_names << "};" << std::endl;
    }
    struct_body << "\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bindCount << "," << std::endl;
    struct_body << "\t\t\t" << pbinds_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseBufferMemoryBindInfo");
    out << "\t\t" << "VkSparseBufferMemoryBindInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseImageFormatProperties(std::ostream &out, const VkSparseImageFormatProperties* structInfo, Decoded_VkSparseImageFormatProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string image_granularity_info_var = GenerateStruct_VkExtent3D(out,
                                                                       &structInfo->imageGranularity,
                                                                       metaInfo->imageGranularity,
                                                                       consumer);
    struct_body << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << image_granularity_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "VkSparseImageFormatFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseImageFormatProperties");
    out << "\t\t" << "VkSparseImageFormatProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseImageMemoryBind(std::ostream &out, const VkSparseImageMemoryBind* structInfo, Decoded_VkSparseImageMemoryBind* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string subresource_info_var = GenerateStruct_VkImageSubresource(out,
                                                                         &structInfo->subresource,
                                                                         metaInfo->subresource,
                                                                         consumer);
    std::string offset_info_var = GenerateStruct_VkOffset3D(out,
                                                            &structInfo->offset,
                                                            metaInfo->offset,
                                                            consumer);
    std::string extent_info_var = GenerateStruct_VkExtent3D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
    struct_body << "\t" << subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSparseMemoryBindFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseImageMemoryBind");
    out << "\t\t" << "VkSparseImageMemoryBind " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseImageMemoryBindInfo(std::ostream &out, const VkSparseImageMemoryBindInfo* structInfo, Decoded_VkSparseImageMemoryBindInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pbinds_array = "NULL";
    if (structInfo->pBinds != NULL) {
        pbinds_array = "pBinds_" + std::to_string(consumer.GetNextId());
        std::string pbinds_names;
        for (uint32_t idx = 0; idx < structInfo->bindCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pBinds + idx != NULL) {
                variable_name = GenerateStruct_VkSparseImageMemoryBind(out,
                                                                       structInfo->pBinds + idx,
                                                                       metaInfo->pBinds->GetMetaStructPointer() + idx,
                                                                       consumer);
            }
            pbinds_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSparseImageMemoryBind " << pbinds_array << "[] = {" << pbinds_names << "};" << std::endl;
    }
    struct_body << "\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bindCount << "," << std::endl;
    struct_body << "\t\t\t" << pbinds_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseImageMemoryBindInfo");
    out << "\t\t" << "VkSparseImageMemoryBindInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseImageMemoryRequirements(std::ostream &out, const VkSparseImageMemoryRequirements* structInfo, Decoded_VkSparseImageMemoryRequirements* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string format_properties_info_var = GenerateStruct_VkSparseImageFormatProperties(out,
                                                                                          &structInfo->formatProperties,
                                                                                          metaInfo->formatProperties,
                                                                                          consumer);
    struct_body << "\t" << format_properties_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageMipTailFirstLod << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageMipTailSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageMipTailOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageMipTailStride << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseImageMemoryRequirements");
    out << "\t\t" << "VkSparseImageMemoryRequirements " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseImageOpaqueMemoryBindInfo(std::ostream &out, const VkSparseImageOpaqueMemoryBindInfo* structInfo, Decoded_VkSparseImageOpaqueMemoryBindInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pbinds_array = "NULL";
    if (structInfo->pBinds != NULL) {
        pbinds_array = "pBinds_" + std::to_string(consumer.GetNextId());
        std::string pbinds_names;
        for (uint32_t idx = 0; idx < structInfo->bindCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pBinds + idx != NULL) {
                variable_name = GenerateStruct_VkSparseMemoryBind(out,
                                                                  structInfo->pBinds + idx,
                                                                  metaInfo->pBinds->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pbinds_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSparseMemoryBind " << pbinds_array << "[] = {" << pbinds_names << "};" << std::endl;
    }
    struct_body << "\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bindCount << "," << std::endl;
    struct_body << "\t\t\t" << pbinds_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseImageOpaqueMemoryBindInfo");
    out << "\t\t" << "VkSparseImageOpaqueMemoryBindInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseMemoryBind(std::ostream &out, const VkSparseMemoryBind* structInfo, Decoded_VkSparseMemoryBind* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->resourceOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSparseMemoryBindFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseMemoryBind");
    out << "\t\t" << "VkSparseMemoryBind " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSpecializationInfo(std::ostream &out, const VkSpecializationInfo* structInfo, Decoded_VkSpecializationInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pmap_entries_array = "NULL";
    if (structInfo->pMapEntries != NULL) {
        pmap_entries_array = "pMapEntries_" + std::to_string(consumer.GetNextId());
        std::string pmap_entries_names;
        for (uint32_t idx = 0; idx < structInfo->mapEntryCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pMapEntries + idx != NULL) {
                variable_name = GenerateStruct_VkSpecializationMapEntry(out,
                                                                        structInfo->pMapEntries + idx,
                                                                        metaInfo->pMapEntries->GetMetaStructPointer() + idx,
                                                                        consumer);
            }
            pmap_entries_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSpecializationMapEntry " << pmap_entries_array << "[] = {" << pmap_entries_names << "};" << std::endl;
    }
    std::string pdata_array = "NULL";
    if (structInfo->pData != NULL) {
        std::string pdata_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->dataSize; ++idx0) {
            pdata_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pData)[idx0]) + ", ";
        }
        pdata_array = "pData_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pdata_array << "[] = {" << pdata_values << "};" << std::endl;
    }
    struct_body << "\t" << structInfo->mapEntryCount << "," << std::endl;
    struct_body << "\t\t\t" << pmap_entries_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dataSize << "," << std::endl;
    struct_body << "\t\t\t" << pdata_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "specializationInfo");
    out << "\t\t" << "VkSpecializationInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSpecializationMapEntry(std::ostream &out, const VkSpecializationMapEntry* structInfo, Decoded_VkSpecializationMapEntry* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->constantID << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "specializationMapEntry");
    out << "\t\t" << "VkSpecializationMapEntry " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkStencilOpState(std::ostream &out, const VkStencilOpState* structInfo, Decoded_VkStencilOpState* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkStencilOp(" << structInfo->failOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkStencilOp(" << structInfo->passOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkStencilOp(" << structInfo->depthFailOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkCompareOp(" << structInfo->compareOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->compareMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->writeMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reference << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stencilOpState");
    out << "\t\t" << "VkStencilOpState " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassDependency(std::ostream &out, const VkSubpassDependency* structInfo, Decoded_VkSubpassDependency* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->srcSubpass << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstSubpass << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlags(" << structInfo->srcStageMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlags(" << structInfo->dstStageMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkDependencyFlags(" << structInfo->dependencyFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassDependency");
    out << "\t\t" << "VkSubpassDependency " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassDescription(std::ostream &out, const VkSubpassDescription* structInfo, Decoded_VkSubpassDescription* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pinput_attachments_array = "NULL";
    if (structInfo->pInputAttachments != NULL) {
        pinput_attachments_array = "pInputAttachments_" + std::to_string(consumer.GetNextId());
        std::string pinput_attachments_names;
        for (uint32_t idx = 0; idx < structInfo->inputAttachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pInputAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentReference(out,
                                                                     structInfo->pInputAttachments + idx,
                                                                     metaInfo->pInputAttachments->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            pinput_attachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentReference " << pinput_attachments_array << "[] = {" << pinput_attachments_names << "};" << std::endl;
    }
    std::string pcolor_attachments_array = "NULL";
    if (structInfo->pColorAttachments != NULL) {
        pcolor_attachments_array = "pColorAttachments_" + std::to_string(consumer.GetNextId());
        std::string pcolor_attachments_names;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pColorAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentReference(out,
                                                                     structInfo->pColorAttachments + idx,
                                                                     metaInfo->pColorAttachments->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            pcolor_attachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentReference " << pcolor_attachments_array << "[] = {" << pcolor_attachments_names << "};" << std::endl;
    }
    std::string presolve_attachments_array = "NULL";
    if (structInfo->pResolveAttachments != NULL) {
        presolve_attachments_array = "pResolveAttachments_" + std::to_string(consumer.GetNextId());
        std::string presolve_attachments_names;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pResolveAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentReference(out,
                                                                     structInfo->pResolveAttachments + idx,
                                                                     metaInfo->pResolveAttachments->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            presolve_attachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentReference " << presolve_attachments_array << "[] = {" << presolve_attachments_names << "};" << std::endl;
    }
    std::string pdepth_stencil_attachment_struct = "NULL";
    if (structInfo->pDepthStencilAttachment != NULL) {
        pdepth_stencil_attachment_struct = GenerateStruct_VkAttachmentReference(out,
                                                                                structInfo->pDepthStencilAttachment,
                                                                                metaInfo->pDepthStencilAttachment->GetMetaStructPointer(),
                                                                                consumer);
        pdepth_stencil_attachment_struct.insert(0, "&");
    }
    std::string ppreserve_attachments_array = "NULL";
    if (structInfo->pPreserveAttachments != NULL) {
        ppreserve_attachments_array = "pPreserveAttachments_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << ppreserve_attachments_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pPreserveAttachments, structInfo->preserveAttachmentCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkSubpassDescriptionFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->inputAttachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pinput_attachments_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pcolor_attachments_array << "," << std::endl;
    struct_body << "\t\t\t" << presolve_attachments_array << "," << std::endl;
    struct_body << "\t\t\t" << pdepth_stencil_attachment_struct << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preserveAttachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << ppreserve_attachments_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassDescription");
    out << "\t\t" << "VkSubpassDescription " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubresourceLayout(std::ostream &out, const VkSubresourceLayout* structInfo, Decoded_VkSubresourceLayout* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->offset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rowPitch << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->arrayPitch << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthPitch << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subresourceLayout");
    out << "\t\t" << "VkSubresourceLayout " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVertexInputAttributeDescription(std::ostream &out, const VkVertexInputAttributeDescription* structInfo, Decoded_VkVertexInputAttributeDescription* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->location << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->binding << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "vertexInputAttributeDescription");
    out << "\t\t" << "VkVertexInputAttributeDescription " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVertexInputBindingDescription(std::ostream &out, const VkVertexInputBindingDescription* structInfo, Decoded_VkVertexInputBindingDescription* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->binding << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stride << "," << std::endl;
    struct_body << "\t\t\t" << "VkVertexInputRate(" << structInfo->inputRate << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "vertexInputBindingDescription");
    out << "\t\t" << "VkVertexInputBindingDescription " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkViewport(std::ostream &out, const VkViewport* structInfo, Decoded_VkViewport* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->x << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->y << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->width << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->height << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minDepth << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDepth << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "viewport");
    out << "\t\t" << "VkViewport " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindBufferMemoryDeviceGroupInfo(std::ostream &out, const VkBindBufferMemoryDeviceGroupInfo* structInfo, Decoded_VkBindBufferMemoryDeviceGroupInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdevice_indices_array = "NULL";
    if (structInfo->pDeviceIndices != NULL) {
        pdevice_indices_array = "pDeviceIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pdevice_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceIndices, structInfo->deviceIndexCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceIndexCount << "," << std::endl;
    struct_body << "\t\t\t" << pdevice_indices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindBufferMemoryDeviceGroupInfo");
    out << "\t\t" << "VkBindBufferMemoryDeviceGroupInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindBufferMemoryInfo(std::ostream &out, const VkBindBufferMemoryInfo* structInfo, Decoded_VkBindBufferMemoryInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryOffset << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindBufferMemoryInfo");
    out << "\t\t" << "VkBindBufferMemoryInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindImageMemoryDeviceGroupInfo(std::ostream &out, const VkBindImageMemoryDeviceGroupInfo* structInfo, Decoded_VkBindImageMemoryDeviceGroupInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdevice_indices_array = "NULL";
    if (structInfo->pDeviceIndices != NULL) {
        pdevice_indices_array = "pDeviceIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pdevice_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceIndices, structInfo->deviceIndexCount) << ";" << std::endl;
    }
    std::string psplit_instance_bind_regions_array = "NULL";
    if (structInfo->pSplitInstanceBindRegions != NULL) {
        psplit_instance_bind_regions_array = "pSplitInstanceBindRegions_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkRect2D " << psplit_instance_bind_regions_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pSplitInstanceBindRegions, structInfo->splitInstanceBindRegionCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceIndexCount << "," << std::endl;
    struct_body << "\t\t\t" << pdevice_indices_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->splitInstanceBindRegionCount << "," << std::endl;
    struct_body << "\t\t\t" << psplit_instance_bind_regions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindImageMemoryDeviceGroupInfo");
    out << "\t\t" << "VkBindImageMemoryDeviceGroupInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindImageMemoryInfo(std::ostream &out, const VkBindImageMemoryInfo* structInfo, Decoded_VkBindImageMemoryInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryOffset << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindImageMemoryInfo");
    out << "\t\t" << "VkBindImageMemoryInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindImagePlaneMemoryInfo(std::ostream &out, const VkBindImagePlaneMemoryInfo* structInfo, Decoded_VkBindImagePlaneMemoryInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageAspectFlagBits(" << structInfo->planeAspect << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindImagePlaneMemoryInfo");
    out << "\t\t" << "VkBindImagePlaneMemoryInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferMemoryRequirementsInfo2(std::ostream &out, const VkBufferMemoryRequirementsInfo2* structInfo, Decoded_VkBufferMemoryRequirementsInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferMemoryRequirementsInfo2");
    out << "\t\t" << "VkBufferMemoryRequirementsInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetLayoutSupport(std::ostream &out, const VkDescriptorSetLayoutSupport* structInfo, Decoded_VkDescriptorSetLayoutSupport* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->supported << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetLayoutSupport");
    out << "\t\t" << "VkDescriptorSetLayoutSupport " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorUpdateTemplateCreateInfo(std::ostream &out, const VkDescriptorUpdateTemplateCreateInfo* structInfo, Decoded_VkDescriptorUpdateTemplateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdescriptor_update_entries_array = "NULL";
    if (structInfo->pDescriptorUpdateEntries != NULL) {
        pdescriptor_update_entries_array = "pDescriptorUpdateEntries_" + std::to_string(consumer.GetNextId());
        std::string pdescriptor_update_entries_names;
        for (uint32_t idx = 0; idx < structInfo->descriptorUpdateEntryCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pDescriptorUpdateEntries + idx != NULL) {
                variable_name = GenerateStruct_VkDescriptorUpdateTemplateEntry(out,
                                                                               structInfo->pDescriptorUpdateEntries + idx,
                                                                               metaInfo->pDescriptorUpdateEntries->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pdescriptor_update_entries_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDescriptorUpdateTemplateEntry " << pdescriptor_update_entries_array << "[] = {" << pdescriptor_update_entries_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDescriptorUpdateTemplateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorUpdateEntryCount << "," << std::endl;
    struct_body << "\t\t\t" << pdescriptor_update_entries_array << "," << std::endl;
    struct_body << "\t\t\t" << "VkDescriptorUpdateTemplateType(" << structInfo->templateType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->descriptorSetLayout) << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipelineLayout) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->set << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorUpdateTemplateCreateInfo");
    out << "\t\t" << "VkDescriptorUpdateTemplateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupBindSparseInfo(std::ostream &out, const VkDeviceGroupBindSparseInfo* structInfo, Decoded_VkDeviceGroupBindSparseInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->resourceDeviceIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryDeviceIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupBindSparseInfo");
    out << "\t\t" << "VkDeviceGroupBindSparseInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupCommandBufferBeginInfo(std::ostream &out, const VkDeviceGroupCommandBufferBeginInfo* structInfo, Decoded_VkDeviceGroupCommandBufferBeginInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceMask << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupCommandBufferBeginInfo");
    out << "\t\t" << "VkDeviceGroupCommandBufferBeginInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupDeviceCreateInfo(std::ostream &out, const VkDeviceGroupDeviceCreateInfo* structInfo, Decoded_VkDeviceGroupDeviceCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pphysical_devices_array = "NULL";
    if (metaInfo->pPhysicalDevices.GetPointer() != NULL && structInfo->physicalDeviceCount > 0) {
        pphysical_devices_array = "pphysical_devices_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_PHYSICAL_DEVICE));
        std::string pphysical_devices_values = toStringJoin(metaInfo->pPhysicalDevices.GetPointer(),
                                                            metaInfo->pPhysicalDevices.GetPointer() + structInfo->physicalDeviceCount,
                                                            [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                            ", ");
        if (structInfo->physicalDeviceCount == 1) {
            pphysical_devices_array = "&" + pphysical_devices_values;
        } else if (structInfo->physicalDeviceCount > 1) {
            out << "\t\t" << "VkPhysicalDevice " << pphysical_devices_array << "[] = {" << pphysical_devices_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->physicalDeviceCount << "," << std::endl;
    struct_body << "\t\t\t" << pphysical_devices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupDeviceCreateInfo");
    out << "\t\t" << "VkDeviceGroupDeviceCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupRenderPassBeginInfo(std::ostream &out, const VkDeviceGroupRenderPassBeginInfo* structInfo, Decoded_VkDeviceGroupRenderPassBeginInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdevice_render_areas_array = "NULL";
    if (structInfo->pDeviceRenderAreas != NULL) {
        pdevice_render_areas_array = "pDeviceRenderAreas_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkRect2D " << pdevice_render_areas_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceRenderAreas, structInfo->deviceRenderAreaCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceRenderAreaCount << "," << std::endl;
    struct_body << "\t\t\t" << pdevice_render_areas_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupRenderPassBeginInfo");
    out << "\t\t" << "VkDeviceGroupRenderPassBeginInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupSubmitInfo(std::ostream &out, const VkDeviceGroupSubmitInfo* structInfo, Decoded_VkDeviceGroupSubmitInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pwait_semaphore_device_indices_array = "NULL";
    if (structInfo->pWaitSemaphoreDeviceIndices != NULL) {
        pwait_semaphore_device_indices_array = "pWaitSemaphoreDeviceIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pwait_semaphore_device_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pWaitSemaphoreDeviceIndices, structInfo->waitSemaphoreCount) << ";" << std::endl;
    }
    std::string pcommand_buffer_device_masks_array = "NULL";
    if (structInfo->pCommandBufferDeviceMasks != NULL) {
        pcommand_buffer_device_masks_array = "pCommandBufferDeviceMasks_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pcommand_buffer_device_masks_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCommandBufferDeviceMasks, structInfo->commandBufferCount) << ";" << std::endl;
    }
    std::string psignal_semaphore_device_indices_array = "NULL";
    if (structInfo->pSignalSemaphoreDeviceIndices != NULL) {
        psignal_semaphore_device_indices_array = "pSignalSemaphoreDeviceIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << psignal_semaphore_device_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pSignalSemaphoreDeviceIndices, structInfo->signalSemaphoreCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->waitSemaphoreCount << "," << std::endl;
    struct_body << "\t\t\t" << pwait_semaphore_device_indices_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->commandBufferCount << "," << std::endl;
    struct_body << "\t\t\t" << pcommand_buffer_device_masks_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->signalSemaphoreCount << "," << std::endl;
    struct_body << "\t\t\t" << psignal_semaphore_device_indices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupSubmitInfo");
    out << "\t\t" << "VkDeviceGroupSubmitInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceQueueInfo2(std::ostream &out, const VkDeviceQueueInfo2* structInfo, Decoded_VkDeviceQueueInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDeviceQueueCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueFamilyIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceQueueInfo2");
    out << "\t\t" << "VkDeviceQueueInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportFenceCreateInfo(std::ostream &out, const VkExportFenceCreateInfo* structInfo, Decoded_VkExportFenceCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlags(" << structInfo->handleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportFenceCreateInfo");
    out << "\t\t" << "VkExportFenceCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportMemoryAllocateInfo(std::ostream &out, const VkExportMemoryAllocateInfo* structInfo, Decoded_VkExportMemoryAllocateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->handleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportMemoryAllocateInfo");
    out << "\t\t" << "VkExportMemoryAllocateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportSemaphoreCreateInfo(std::ostream &out, const VkExportSemaphoreCreateInfo* structInfo, Decoded_VkExportSemaphoreCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlags(" << structInfo->handleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportSemaphoreCreateInfo");
    out << "\t\t" << "VkExportSemaphoreCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalBufferProperties(std::ostream &out, const VkExternalBufferProperties* structInfo, Decoded_VkExternalBufferProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string external_memory_properties_info_var = GenerateStruct_VkExternalMemoryProperties(out,
                                                                                                &structInfo->externalMemoryProperties,
                                                                                                metaInfo->externalMemoryProperties,
                                                                                                consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << external_memory_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalBufferProperties");
    out << "\t\t" << "VkExternalBufferProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalFenceProperties(std::ostream &out, const VkExternalFenceProperties* structInfo, Decoded_VkExternalFenceProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlags(" << structInfo->exportFromImportedHandleTypes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlags(" << structInfo->compatibleHandleTypes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalFenceFeatureFlags(" << structInfo->externalFenceFeatures << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalFenceProperties");
    out << "\t\t" << "VkExternalFenceProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalImageFormatProperties(std::ostream &out, const VkExternalImageFormatProperties* structInfo, Decoded_VkExternalImageFormatProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string external_memory_properties_info_var = GenerateStruct_VkExternalMemoryProperties(out,
                                                                                                &structInfo->externalMemoryProperties,
                                                                                                metaInfo->externalMemoryProperties,
                                                                                                consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << external_memory_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalImageFormatProperties");
    out << "\t\t" << "VkExternalImageFormatProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalMemoryBufferCreateInfo(std::ostream &out, const VkExternalMemoryBufferCreateInfo* structInfo, Decoded_VkExternalMemoryBufferCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->handleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalMemoryBufferCreateInfo");
    out << "\t\t" << "VkExternalMemoryBufferCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalMemoryImageCreateInfo(std::ostream &out, const VkExternalMemoryImageCreateInfo* structInfo, Decoded_VkExternalMemoryImageCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->handleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalMemoryImageCreateInfo");
    out << "\t\t" << "VkExternalMemoryImageCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalMemoryProperties(std::ostream &out, const VkExternalMemoryProperties* structInfo, Decoded_VkExternalMemoryProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkExternalMemoryFeatureFlags(" << structInfo->externalMemoryFeatures << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->exportFromImportedHandleTypes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->compatibleHandleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalMemoryProperties");
    out << "\t\t" << "VkExternalMemoryProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalSemaphoreProperties(std::ostream &out, const VkExternalSemaphoreProperties* structInfo, Decoded_VkExternalSemaphoreProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlags(" << structInfo->exportFromImportedHandleTypes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlags(" << structInfo->compatibleHandleTypes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalSemaphoreFeatureFlags(" << structInfo->externalSemaphoreFeatures << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalSemaphoreProperties");
    out << "\t\t" << "VkExternalSemaphoreProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFormatProperties2(std::ostream &out, const VkFormatProperties2* structInfo, Decoded_VkFormatProperties2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string format_properties_info_var = GenerateStruct_VkFormatProperties(out,
                                                                               &structInfo->formatProperties,
                                                                               metaInfo->formatProperties,
                                                                               consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << format_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "formatProperties2");
    out << "\t\t" << "VkFormatProperties2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageFormatProperties2(std::ostream &out, const VkImageFormatProperties2* structInfo, Decoded_VkImageFormatProperties2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string image_format_properties_info_var = GenerateStruct_VkImageFormatProperties(out,
                                                                                          &structInfo->imageFormatProperties,
                                                                                          metaInfo->imageFormatProperties,
                                                                                          consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << image_format_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageFormatProperties2");
    out << "\t\t" << "VkImageFormatProperties2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageMemoryRequirementsInfo2(std::ostream &out, const VkImageMemoryRequirementsInfo2* structInfo, Decoded_VkImageMemoryRequirementsInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageMemoryRequirementsInfo2");
    out << "\t\t" << "VkImageMemoryRequirementsInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImagePlaneMemoryRequirementsInfo(std::ostream &out, const VkImagePlaneMemoryRequirementsInfo* structInfo, Decoded_VkImagePlaneMemoryRequirementsInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageAspectFlagBits(" << structInfo->planeAspect << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imagePlaneMemoryRequirementsInfo");
    out << "\t\t" << "VkImagePlaneMemoryRequirementsInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageSparseMemoryRequirementsInfo2(std::ostream &out, const VkImageSparseMemoryRequirementsInfo2* structInfo, Decoded_VkImageSparseMemoryRequirementsInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageSparseMemoryRequirementsInfo2");
    out << "\t\t" << "VkImageSparseMemoryRequirementsInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewUsageCreateInfo(std::ostream &out, const VkImageViewUsageCreateInfo* structInfo, Decoded_VkImageViewUsageCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewUsageCreateInfo");
    out << "\t\t" << "VkImageViewUsageCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkInputAttachmentAspectReference(std::ostream &out, const VkInputAttachmentAspectReference* structInfo, Decoded_VkInputAttachmentAspectReference* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->subpass << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->inputAttachmentIndex << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "inputAttachmentAspectReference");
    out << "\t\t" << "VkInputAttachmentAspectReference " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryDedicatedAllocateInfo(std::ostream &out, const VkMemoryDedicatedAllocateInfo* structInfo, Decoded_VkMemoryDedicatedAllocateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryDedicatedAllocateInfo");
    out << "\t\t" << "VkMemoryDedicatedAllocateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryDedicatedRequirements(std::ostream &out, const VkMemoryDedicatedRequirements* structInfo, Decoded_VkMemoryDedicatedRequirements* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->prefersDedicatedAllocation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->requiresDedicatedAllocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryDedicatedRequirements");
    out << "\t\t" << "VkMemoryDedicatedRequirements " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryRequirements2(std::ostream &out, const VkMemoryRequirements2* structInfo, Decoded_VkMemoryRequirements2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string memory_requirements_info_var = GenerateStruct_VkMemoryRequirements(out,
                                                                                   &structInfo->memoryRequirements,
                                                                                   metaInfo->memoryRequirements,
                                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << memory_requirements_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryRequirements2");
    out << "\t\t" << variable_name << " = {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevice16BitStorageFeatures(std::ostream &out, const VkPhysicalDevice16BitStorageFeatures* structInfo, Decoded_VkPhysicalDevice16BitStorageFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->storageBuffer16BitAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->uniformAndStorageBuffer16BitAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->storagePushConstant16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->storageInputOutput16 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevice16BitStorageFeatures");
    out << "\t\t" << "VkPhysicalDevice16BitStorageFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalBufferInfo(std::ostream &out, const VkPhysicalDeviceExternalBufferInfo* structInfo, Decoded_VkPhysicalDeviceExternalBufferInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkBufferCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBufferUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalBufferInfo");
    out << "\t\t" << "VkPhysicalDeviceExternalBufferInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalFenceInfo(std::ostream &out, const VkPhysicalDeviceExternalFenceInfo* structInfo, Decoded_VkPhysicalDeviceExternalFenceInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalFenceInfo");
    out << "\t\t" << "VkPhysicalDeviceExternalFenceInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalImageFormatInfo(std::ostream &out, const VkPhysicalDeviceExternalImageFormatInfo* structInfo, Decoded_VkPhysicalDeviceExternalImageFormatInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalImageFormatInfo");
    out << "\t\t" << "VkPhysicalDeviceExternalImageFormatInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalSemaphoreInfo(std::ostream &out, const VkPhysicalDeviceExternalSemaphoreInfo* structInfo, Decoded_VkPhysicalDeviceExternalSemaphoreInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalSemaphoreInfo");
    out << "\t\t" << "VkPhysicalDeviceExternalSemaphoreInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFeatures2(std::ostream &out, const VkPhysicalDeviceFeatures2* structInfo, Decoded_VkPhysicalDeviceFeatures2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string features_info_var = GenerateStruct_VkPhysicalDeviceFeatures(out,
                                                                            &structInfo->features,
                                                                            metaInfo->features,
                                                                            consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << features_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFeatures2");
    out << "\t\t" << "VkPhysicalDeviceFeatures2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceGroupProperties(std::ostream &out, const VkPhysicalDeviceGroupProperties* structInfo, Decoded_VkPhysicalDeviceGroupProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->physicalDeviceCount << "," << std::endl;
    out << "\t\t" << "// TODO: Support physicalDevices (output with array length value?) argument." << std::endl;
    struct_body << "\t\t\t" << structInfo->subsetAllocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceGroupProperties");
    out << "\t\t" << "VkPhysicalDeviceGroupProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceIDProperties(std::ostream &out, const VkPhysicalDeviceIDProperties* structInfo, Decoded_VkPhysicalDeviceIDProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->deviceUUID[0]), VK_UUID_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->driverUUID[0]), VK_UUID_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->deviceLUID[0]), VK_LUID_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceNodeMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceLUIDValid << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceIDProperties");
    out << "\t\t" << "VkPhysicalDeviceIDProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageFormatInfo2(std::ostream &out, const VkPhysicalDeviceImageFormatInfo2* structInfo, Decoded_VkPhysicalDeviceImageFormatInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageType(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageTiling(" << structInfo->tiling << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageCreateFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageFormatInfo2");
    out << "\t\t" << "VkPhysicalDeviceImageFormatInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance3Properties(std::ostream &out, const VkPhysicalDeviceMaintenance3Properties* structInfo, Decoded_VkPhysicalDeviceMaintenance3Properties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerSetDescriptors << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMemoryAllocationSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance3Properties");
    out << "\t\t" << "VkPhysicalDeviceMaintenance3Properties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMemoryProperties2(std::ostream &out, const VkPhysicalDeviceMemoryProperties2* structInfo, Decoded_VkPhysicalDeviceMemoryProperties2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string memory_properties_info_var = GenerateStruct_VkPhysicalDeviceMemoryProperties(out,
                                                                                             &structInfo->memoryProperties,
                                                                                             metaInfo->memoryProperties,
                                                                                             consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << memory_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMemoryProperties2");
    out << "\t\t" << "VkPhysicalDeviceMemoryProperties2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewFeatures(std::ostream &out, const VkPhysicalDeviceMultiviewFeatures* structInfo, Decoded_VkPhysicalDeviceMultiviewFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multiview << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multiviewGeometryShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multiviewTessellationShader << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultiviewFeatures");
    out << "\t\t" << "VkPhysicalDeviceMultiviewFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewProperties(std::ostream &out, const VkPhysicalDeviceMultiviewProperties* structInfo, Decoded_VkPhysicalDeviceMultiviewProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMultiviewViewCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMultiviewInstanceIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultiviewProperties");
    out << "\t\t" << "VkPhysicalDeviceMultiviewProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePointClippingProperties(std::ostream &out, const VkPhysicalDevicePointClippingProperties* structInfo, Decoded_VkPhysicalDevicePointClippingProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPointClippingBehavior(" << structInfo->pointClippingBehavior << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePointClippingProperties");
    out << "\t\t" << "VkPhysicalDevicePointClippingProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceProperties2(std::ostream &out, const VkPhysicalDeviceProperties2* structInfo, Decoded_VkPhysicalDeviceProperties2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string properties_info_var = GenerateStruct_VkPhysicalDeviceProperties(out,
                                                                                &structInfo->properties,
                                                                                metaInfo->properties,
                                                                                consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceProperties2");
    out << "\t\t" << "VkPhysicalDeviceProperties2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceProtectedMemoryFeatures(std::ostream &out, const VkPhysicalDeviceProtectedMemoryFeatures* structInfo, Decoded_VkPhysicalDeviceProtectedMemoryFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->protectedMemory << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceProtectedMemoryFeatures");
    out << "\t\t" << "VkPhysicalDeviceProtectedMemoryFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceProtectedMemoryProperties(std::ostream &out, const VkPhysicalDeviceProtectedMemoryProperties* structInfo, Decoded_VkPhysicalDeviceProtectedMemoryProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->protectedNoFault << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceProtectedMemoryProperties");
    out << "\t\t" << "VkPhysicalDeviceProtectedMemoryProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSamplerYcbcrConversionFeatures(std::ostream &out, const VkPhysicalDeviceSamplerYcbcrConversionFeatures* structInfo, Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->samplerYcbcrConversion << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSamplerYcbcrConversionFeatures");
    out << "\t\t" << "VkPhysicalDeviceSamplerYcbcrConversionFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderDrawParametersFeatures(std::ostream &out, const VkPhysicalDeviceShaderDrawParametersFeatures* structInfo, Decoded_VkPhysicalDeviceShaderDrawParametersFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDrawParameters << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderDrawParametersFeatures");
    out << "\t\t" << "VkPhysicalDeviceShaderDrawParametersFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSparseImageFormatInfo2(std::ostream &out, const VkPhysicalDeviceSparseImageFormatInfo2* structInfo, Decoded_VkPhysicalDeviceSparseImageFormatInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageType(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->samples << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageTiling(" << structInfo->tiling << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSparseImageFormatInfo2");
    out << "\t\t" << "VkPhysicalDeviceSparseImageFormatInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSubgroupProperties(std::ostream &out, const VkPhysicalDeviceSubgroupProperties* structInfo, Decoded_VkPhysicalDeviceSubgroupProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subgroupSize << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->supportedStages << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSubgroupFeatureFlags(" << structInfo->supportedOperations << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->quadOperationsInAllStages << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSubgroupProperties");
    out << "\t\t" << "VkPhysicalDeviceSubgroupProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVariablePointersFeatures(std::ostream &out, const VkPhysicalDeviceVariablePointersFeatures* structInfo, Decoded_VkPhysicalDeviceVariablePointersFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->variablePointersStorageBuffer << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->variablePointers << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVariablePointersFeatures");
    out << "\t\t" << "VkPhysicalDeviceVariablePointersFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineTessellationDomainOriginStateCreateInfo(std::ostream &out, const VkPipelineTessellationDomainOriginStateCreateInfo* structInfo, Decoded_VkPipelineTessellationDomainOriginStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkTessellationDomainOrigin(" << structInfo->domainOrigin << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineTessellationDomainOriginStateCreateInfo");
    out << "\t\t" << "VkPipelineTessellationDomainOriginStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkProtectedSubmitInfo(std::ostream &out, const VkProtectedSubmitInfo* structInfo, Decoded_VkProtectedSubmitInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->protectedSubmit << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "protectedSubmitInfo");
    out << "\t\t" << "VkProtectedSubmitInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyProperties2(std::ostream &out, const VkQueueFamilyProperties2* structInfo, Decoded_VkQueueFamilyProperties2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string queue_family_properties_info_var = GenerateStruct_VkQueueFamilyProperties(out,
                                                                                          &structInfo->queueFamilyProperties,
                                                                                          metaInfo->queueFamilyProperties,
                                                                                          consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << queue_family_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyProperties2");
    out << "\t\t" << "VkQueueFamilyProperties2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassInputAttachmentAspectCreateInfo(std::ostream &out, const VkRenderPassInputAttachmentAspectCreateInfo* structInfo, Decoded_VkRenderPassInputAttachmentAspectCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string paspect_references_array = "NULL";
    if (structInfo->pAspectReferences != NULL) {
        paspect_references_array = "pAspectReferences_" + std::to_string(consumer.GetNextId());
        std::string paspect_references_names;
        for (uint32_t idx = 0; idx < structInfo->aspectReferenceCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pAspectReferences + idx != NULL) {
                variable_name = GenerateStruct_VkInputAttachmentAspectReference(out,
                                                                                structInfo->pAspectReferences + idx,
                                                                                metaInfo->pAspectReferences->GetMetaStructPointer() + idx,
                                                                                consumer);
            }
            paspect_references_names += variable_name + ", ";
        }
        out << "\t\t" << "VkInputAttachmentAspectReference " << paspect_references_array << "[] = {" << paspect_references_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->aspectReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << paspect_references_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassInputAttachmentAspectCreateInfo");
    out << "\t\t" << "VkRenderPassInputAttachmentAspectCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassMultiviewCreateInfo(std::ostream &out, const VkRenderPassMultiviewCreateInfo* structInfo, Decoded_VkRenderPassMultiviewCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pview_masks_array = "NULL";
    if (structInfo->pViewMasks != NULL) {
        pview_masks_array = "pViewMasks_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pview_masks_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pViewMasks, structInfo->subpassCount) << ";" << std::endl;
    }
    std::string pview_offsets_array = "NULL";
    if (structInfo->pViewOffsets != NULL) {
        pview_offsets_array = "pViewOffsets_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "int32_t " << pview_offsets_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pViewOffsets, structInfo->dependencyCount) << ";" << std::endl;
    }
    std::string pcorrelation_masks_array = "NULL";
    if (structInfo->pCorrelationMasks != NULL) {
        pcorrelation_masks_array = "pCorrelationMasks_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pcorrelation_masks_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCorrelationMasks, structInfo->correlationMaskCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subpassCount << "," << std::endl;
    struct_body << "\t\t\t" << pview_masks_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dependencyCount << "," << std::endl;
    struct_body << "\t\t\t" << pview_offsets_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->correlationMaskCount << "," << std::endl;
    struct_body << "\t\t\t" << pcorrelation_masks_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassMultiviewCreateInfo");
    out << "\t\t" << "VkRenderPassMultiviewCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerYcbcrConversionCreateInfo(std::ostream &out, const VkSamplerYcbcrConversionCreateInfo* structInfo, Decoded_VkSamplerYcbcrConversionCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string components_info_var = GenerateStruct_VkComponentMapping(out,
                                                                        &structInfo->components,
                                                                        metaInfo->components,
                                                                        consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSamplerYcbcrModelConversion(" << structInfo->ycbcrModel << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSamplerYcbcrRange(" << structInfo->ycbcrRange << ")" << "," << std::endl;
    struct_body << "\t\t\t" << components_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->xChromaOffset << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->yChromaOffset << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFilter(" << structInfo->chromaFilter << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->forceExplicitReconstruction << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerYcbcrConversionCreateInfo");
    out << "\t\t" << "VkSamplerYcbcrConversionCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerYcbcrConversionImageFormatProperties(std::ostream &out, const VkSamplerYcbcrConversionImageFormatProperties* structInfo, Decoded_VkSamplerYcbcrConversionImageFormatProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->combinedImageSamplerDescriptorCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerYcbcrConversionImageFormatProperties");
    out << "\t\t" << "VkSamplerYcbcrConversionImageFormatProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerYcbcrConversionInfo(std::ostream &out, const VkSamplerYcbcrConversionInfo* structInfo, Decoded_VkSamplerYcbcrConversionInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->conversion) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerYcbcrConversionInfo");
    out << "\t\t" << "VkSamplerYcbcrConversionInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseImageFormatProperties2(std::ostream &out, const VkSparseImageFormatProperties2* structInfo, Decoded_VkSparseImageFormatProperties2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string properties_info_var = GenerateStruct_VkSparseImageFormatProperties(out,
                                                                                   &structInfo->properties,
                                                                                   metaInfo->properties,
                                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseImageFormatProperties2");
    out << "\t\t" << "VkSparseImageFormatProperties2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSparseImageMemoryRequirements2(std::ostream &out, const VkSparseImageMemoryRequirements2* structInfo, Decoded_VkSparseImageMemoryRequirements2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string memory_requirements_info_var = GenerateStruct_VkSparseImageMemoryRequirements(out,
                                                                                              &structInfo->memoryRequirements,
                                                                                              metaInfo->memoryRequirements,
                                                                                              consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << memory_requirements_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sparseImageMemoryRequirements2");
    out << "\t\t" << "VkSparseImageMemoryRequirements2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentDescription2(std::ostream &out, const VkAttachmentDescription2* structInfo, Decoded_VkAttachmentDescription2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAttachmentDescriptionFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->samples << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAttachmentLoadOp(" << structInfo->loadOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAttachmentStoreOp(" << structInfo->storeOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAttachmentLoadOp(" << structInfo->stencilLoadOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAttachmentStoreOp(" << structInfo->stencilStoreOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->initialLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->finalLayout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentDescription2");
    out << "\t\t" << "VkAttachmentDescription2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentDescriptionStencilLayout(std::ostream &out, const VkAttachmentDescriptionStencilLayout* structInfo, Decoded_VkAttachmentDescriptionStencilLayout* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->stencilInitialLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->stencilFinalLayout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentDescriptionStencilLayout");
    out << "\t\t" << "VkAttachmentDescriptionStencilLayout " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentReference2(std::ostream &out, const VkAttachmentReference2* structInfo, Decoded_VkAttachmentReference2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->attachment << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->layout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentReference2");
    out << "\t\t" << "VkAttachmentReference2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentReferenceStencilLayout(std::ostream &out, const VkAttachmentReferenceStencilLayout* structInfo, Decoded_VkAttachmentReferenceStencilLayout* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->stencilLayout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentReferenceStencilLayout");
    out << "\t\t" << "VkAttachmentReferenceStencilLayout " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferDeviceAddressInfo(std::ostream &out, const VkBufferDeviceAddressInfo* structInfo, Decoded_VkBufferDeviceAddressInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferDeviceAddressInfo");
    out << "\t\t" << "VkBufferDeviceAddressInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferOpaqueCaptureAddressCreateInfo(std::ostream &out, const VkBufferOpaqueCaptureAddressCreateInfo* structInfo, Decoded_VkBufferOpaqueCaptureAddressCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->opaqueCaptureAddress << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferOpaqueCaptureAddressCreateInfo");
    out << "\t\t" << "VkBufferOpaqueCaptureAddressCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkConformanceVersion(std::ostream &out, const VkConformanceVersion* structInfo, Decoded_VkConformanceVersion* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << std::to_string(structInfo->major) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->minor) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->subminor) << "," << std::endl;
    struct_body << "\t\t\t" << std::to_string(structInfo->patch) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "conformanceVersion");
    out << "\t\t" << "VkConformanceVersion " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetLayoutBindingFlagsCreateInfo(std::ostream &out, const VkDescriptorSetLayoutBindingFlagsCreateInfo* structInfo, Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pbinding_flags_values;
    std::string pbinding_flags_array = "NULL";
    if (structInfo->pBindingFlags != NULL) {
        for (uint32_t idx = 0; idx < structInfo->bindingCount; idx++) {
            pbinding_flags_values += util::ToString<VkDescriptorBindingFlags>(structInfo->pBindingFlags[idx]) + ", ";
        }
        pbinding_flags_array = "pBindingFlags_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkDescriptorBindingFlags " << pbinding_flags_array << "[] = {" << pbinding_flags_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bindingCount << "," << std::endl;
    struct_body << "\t\t\t" << pbinding_flags_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetLayoutBindingFlagsCreateInfo");
    out << "\t\t" << "VkDescriptorSetLayoutBindingFlagsCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetVariableDescriptorCountAllocateInfo(std::ostream &out, const VkDescriptorSetVariableDescriptorCountAllocateInfo* structInfo, Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdescriptor_counts_array = "NULL";
    if (structInfo->pDescriptorCounts != NULL) {
        pdescriptor_counts_array = "pDescriptorCounts_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pdescriptor_counts_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDescriptorCounts, structInfo->descriptorSetCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorSetCount << "," << std::endl;
    struct_body << "\t\t\t" << pdescriptor_counts_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetVariableDescriptorCountAllocateInfo");
    out << "\t\t" << "VkDescriptorSetVariableDescriptorCountAllocateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetVariableDescriptorCountLayoutSupport(std::ostream &out, const VkDescriptorSetVariableDescriptorCountLayoutSupport* structInfo, Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupport* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxVariableDescriptorCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetVariableDescriptorCountLayoutSupport");
    out << "\t\t" << "VkDescriptorSetVariableDescriptorCountLayoutSupport " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceMemoryOpaqueCaptureAddressInfo(std::ostream &out, const VkDeviceMemoryOpaqueCaptureAddressInfo* structInfo, Decoded_VkDeviceMemoryOpaqueCaptureAddressInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceMemoryOpaqueCaptureAddressInfo");
    out << "\t\t" << "VkDeviceMemoryOpaqueCaptureAddressInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFramebufferAttachmentImageInfo(std::ostream &out, const VkFramebufferAttachmentImageInfo* structInfo, Decoded_VkFramebufferAttachmentImageInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pview_formats_values;
    std::string pview_formats_array = "NULL";
    if (structInfo->pViewFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->viewFormatCount; idx++) {
            pview_formats_values += util::ToString<VkFormat>(structInfo->pViewFormats[idx]) + ", ";
        }
        pview_formats_array = "pViewFormats_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkFormat " << pview_formats_array << "[] = {" << pview_formats_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->width << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->height << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->layerCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewFormatCount << "," << std::endl;
    struct_body << "\t\t\t" << pview_formats_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "framebufferAttachmentImageInfo");
    out << "\t\t" << "VkFramebufferAttachmentImageInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFramebufferAttachmentsCreateInfo(std::ostream &out, const VkFramebufferAttachmentsCreateInfo* structInfo, Decoded_VkFramebufferAttachmentsCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pattachment_image_infos_array = "NULL";
    if (structInfo->pAttachmentImageInfos != NULL) {
        pattachment_image_infos_array = "pAttachmentImageInfos_" + std::to_string(consumer.GetNextId());
        std::string pattachment_image_infos_names;
        for (uint32_t idx = 0; idx < structInfo->attachmentImageInfoCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pAttachmentImageInfos + idx != NULL) {
                variable_name = GenerateStruct_VkFramebufferAttachmentImageInfo(out,
                                                                                structInfo->pAttachmentImageInfos + idx,
                                                                                metaInfo->pAttachmentImageInfos->GetMetaStructPointer() + idx,
                                                                                consumer);
            }
            pattachment_image_infos_names += variable_name + ", ";
        }
        out << "\t\t" << "VkFramebufferAttachmentImageInfo " << pattachment_image_infos_array << "[] = {" << pattachment_image_infos_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->attachmentImageInfoCount << "," << std::endl;
    struct_body << "\t\t\t" << pattachment_image_infos_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "framebufferAttachmentsCreateInfo");
    out << "\t\t" << "VkFramebufferAttachmentsCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageFormatListCreateInfo(std::ostream &out, const VkImageFormatListCreateInfo* structInfo, Decoded_VkImageFormatListCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pview_formats_values;
    std::string pview_formats_array = "NULL";
    if (structInfo->pViewFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->viewFormatCount; idx++) {
            pview_formats_values += util::ToString<VkFormat>(structInfo->pViewFormats[idx]) + ", ";
        }
        pview_formats_array = "pViewFormats_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkFormat " << pview_formats_array << "[] = {" << pview_formats_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewFormatCount << "," << std::endl;
    struct_body << "\t\t\t" << pview_formats_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageFormatListCreateInfo");
    out << "\t\t" << "VkImageFormatListCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageStencilUsageCreateInfo(std::ostream &out, const VkImageStencilUsageCreateInfo* structInfo, Decoded_VkImageStencilUsageCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->stencilUsage << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageStencilUsageCreateInfo");
    out << "\t\t" << "VkImageStencilUsageCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryOpaqueCaptureAddressAllocateInfo(std::ostream &out, const VkMemoryOpaqueCaptureAddressAllocateInfo* structInfo, Decoded_VkMemoryOpaqueCaptureAddressAllocateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->opaqueCaptureAddress << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryOpaqueCaptureAddressAllocateInfo");
    out << "\t\t" << "VkMemoryOpaqueCaptureAddressAllocateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevice8BitStorageFeatures(std::ostream &out, const VkPhysicalDevice8BitStorageFeatures* structInfo, Decoded_VkPhysicalDevice8BitStorageFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->storageBuffer8BitAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->uniformAndStorageBuffer8BitAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->storagePushConstant8 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevice8BitStorageFeatures");
    out << "\t\t" << "VkPhysicalDevice8BitStorageFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceBufferDeviceAddressFeatures(std::ostream &out, const VkPhysicalDeviceBufferDeviceAddressFeatures* structInfo, Decoded_VkPhysicalDeviceBufferDeviceAddressFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddressCaptureReplay << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddressMultiDevice << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceBufferDeviceAddressFeatures");
    out << "\t\t" << "VkPhysicalDeviceBufferDeviceAddressFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDepthStencilResolveProperties(std::ostream &out, const VkPhysicalDeviceDepthStencilResolveProperties* structInfo, Decoded_VkPhysicalDeviceDepthStencilResolveProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkResolveModeFlags(" << structInfo->supportedDepthResolveModes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkResolveModeFlags(" << structInfo->supportedStencilResolveModes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->independentResolveNone << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->independentResolve << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDepthStencilResolveProperties");
    out << "\t\t" << "VkPhysicalDeviceDepthStencilResolveProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDescriptorIndexingFeatures(std::ostream &out, const VkPhysicalDeviceDescriptorIndexingFeatures* structInfo, Decoded_VkPhysicalDeviceDescriptorIndexingFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderInputAttachmentArrayDynamicIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderUniformTexelBufferArrayDynamicIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageTexelBufferArrayDynamicIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderUniformBufferArrayNonUniformIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSampledImageArrayNonUniformIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageBufferArrayNonUniformIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageImageArrayNonUniformIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderInputAttachmentArrayNonUniformIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderUniformTexelBufferArrayNonUniformIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageTexelBufferArrayNonUniformIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingUniformBufferUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingSampledImageUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingStorageImageUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingStorageBufferUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingUniformTexelBufferUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingStorageTexelBufferUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingUpdateUnusedWhilePending << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingPartiallyBound << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingVariableDescriptorCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->runtimeDescriptorArray << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDescriptorIndexingFeatures");
    out << "\t\t" << "VkPhysicalDeviceDescriptorIndexingFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDescriptorIndexingProperties(std::ostream &out, const VkPhysicalDeviceDescriptorIndexingProperties* structInfo, Decoded_VkPhysicalDeviceDescriptorIndexingProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxUpdateAfterBindDescriptorsInAllPools << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderUniformBufferArrayNonUniformIndexingNative << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSampledImageArrayNonUniformIndexingNative << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageBufferArrayNonUniformIndexingNative << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageImageArrayNonUniformIndexingNative << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderInputAttachmentArrayNonUniformIndexingNative << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->robustBufferAccessUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->quadDivergentImplicitLod << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindSamplers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindUniformBuffers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindStorageBuffers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindSampledImages << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindStorageImages << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindInputAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageUpdateAfterBindResources << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindSamplers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindUniformBuffers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageBuffers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindSampledImages << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageImages << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindInputAttachments << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDescriptorIndexingProperties");
    out << "\t\t" << "VkPhysicalDeviceDescriptorIndexingProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDriverProperties(std::ostream &out, const VkPhysicalDeviceDriverProperties* structInfo, Decoded_VkPhysicalDeviceDriverProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string conformance_version_info_var = GenerateStruct_VkConformanceVersion(out,
                                                                                   &structInfo->conformanceVersion,
                                                                                   metaInfo->conformanceVersion,
                                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDriverId(" << structInfo->driverID << ")" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->driverName) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->driverInfo) << "," << std::endl;
    struct_body << "\t\t\t" << conformance_version_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDriverProperties");
    out << "\t\t" << "VkPhysicalDeviceDriverProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFloatControlsProperties(std::ostream &out, const VkPhysicalDeviceFloatControlsProperties* structInfo, Decoded_VkPhysicalDeviceFloatControlsProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderFloatControlsIndependence(" << structInfo->denormBehaviorIndependence << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderFloatControlsIndependence(" << structInfo->roundingModeIndependence << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSignedZeroInfNanPreserveFloat16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSignedZeroInfNanPreserveFloat32 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSignedZeroInfNanPreserveFloat64 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDenormPreserveFloat16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDenormPreserveFloat32 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDenormPreserveFloat64 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDenormFlushToZeroFloat16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDenormFlushToZeroFloat32 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDenormFlushToZeroFloat64 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTEFloat16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTEFloat32 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTEFloat64 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTZFloat16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTZFloat32 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTZFloat64 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFloatControlsProperties");
    out << "\t\t" << "VkPhysicalDeviceFloatControlsProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceHostQueryResetFeatures(std::ostream &out, const VkPhysicalDeviceHostQueryResetFeatures* structInfo, Decoded_VkPhysicalDeviceHostQueryResetFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hostQueryReset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceHostQueryResetFeatures");
    out << "\t\t" << "VkPhysicalDeviceHostQueryResetFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImagelessFramebufferFeatures(std::ostream &out, const VkPhysicalDeviceImagelessFramebufferFeatures* structInfo, Decoded_VkPhysicalDeviceImagelessFramebufferFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imagelessFramebuffer << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImagelessFramebufferFeatures");
    out << "\t\t" << "VkPhysicalDeviceImagelessFramebufferFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSamplerFilterMinmaxProperties(std::ostream &out, const VkPhysicalDeviceSamplerFilterMinmaxProperties* structInfo, Decoded_VkPhysicalDeviceSamplerFilterMinmaxProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->filterMinmaxSingleComponentFormats << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->filterMinmaxImageComponentMapping << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSamplerFilterMinmaxProperties");
    out << "\t\t" << "VkPhysicalDeviceSamplerFilterMinmaxProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceScalarBlockLayoutFeatures(std::ostream &out, const VkPhysicalDeviceScalarBlockLayoutFeatures* structInfo, Decoded_VkPhysicalDeviceScalarBlockLayoutFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->scalarBlockLayout << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceScalarBlockLayoutFeatures");
    out << "\t\t" << "VkPhysicalDeviceScalarBlockLayoutFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(std::ostream &out, const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* structInfo, Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->separateDepthStencilLayouts << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSeparateDepthStencilLayoutsFeatures");
    out << "\t\t" << "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderAtomicInt64Features(std::ostream &out, const VkPhysicalDeviceShaderAtomicInt64Features* structInfo, Decoded_VkPhysicalDeviceShaderAtomicInt64Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBufferInt64Atomics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSharedInt64Atomics << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderAtomicInt64Features");
    out << "\t\t" << "VkPhysicalDeviceShaderAtomicInt64Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderFloat16Int8Features(std::ostream &out, const VkPhysicalDeviceShaderFloat16Int8Features* structInfo, Decoded_VkPhysicalDeviceShaderFloat16Int8Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderFloat16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderInt8 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderFloat16Int8Features");
    out << "\t\t" << "VkPhysicalDeviceShaderFloat16Int8Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(std::ostream &out, const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* structInfo, Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSubgroupExtendedTypes << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderSubgroupExtendedTypesFeatures");
    out << "\t\t" << "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTimelineSemaphoreFeatures(std::ostream &out, const VkPhysicalDeviceTimelineSemaphoreFeatures* structInfo, Decoded_VkPhysicalDeviceTimelineSemaphoreFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timelineSemaphore << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTimelineSemaphoreFeatures");
    out << "\t\t" << "VkPhysicalDeviceTimelineSemaphoreFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTimelineSemaphoreProperties(std::ostream &out, const VkPhysicalDeviceTimelineSemaphoreProperties* structInfo, Decoded_VkPhysicalDeviceTimelineSemaphoreProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTimelineSemaphoreValueDifference << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTimelineSemaphoreProperties");
    out << "\t\t" << "VkPhysicalDeviceTimelineSemaphoreProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(std::ostream &out, const VkPhysicalDeviceUniformBufferStandardLayoutFeatures* structInfo, Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->uniformBufferStandardLayout << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceUniformBufferStandardLayoutFeatures");
    out << "\t\t" << "VkPhysicalDeviceUniformBufferStandardLayoutFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan11Features(std::ostream &out, const VkPhysicalDeviceVulkan11Features* structInfo, Decoded_VkPhysicalDeviceVulkan11Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->storageBuffer16BitAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->uniformAndStorageBuffer16BitAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->storagePushConstant16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->storageInputOutput16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multiview << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multiviewGeometryShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multiviewTessellationShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->variablePointersStorageBuffer << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->variablePointers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->protectedMemory << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->samplerYcbcrConversion << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDrawParameters << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkan11Features");
    out << "\t\t" << "VkPhysicalDeviceVulkan11Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan11Properties(std::ostream &out, const VkPhysicalDeviceVulkan11Properties* structInfo, Decoded_VkPhysicalDeviceVulkan11Properties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->deviceUUID[0]), VK_UUID_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->driverUUID[0]), VK_UUID_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->deviceLUID[0]), VK_LUID_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceNodeMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceLUIDValid << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subgroupSize << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->subgroupSupportedStages << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSubgroupFeatureFlags(" << structInfo->subgroupSupportedOperations << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subgroupQuadOperationsInAllStages << "," << std::endl;
    struct_body << "\t\t\t" << "VkPointClippingBehavior(" << structInfo->pointClippingBehavior << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMultiviewViewCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMultiviewInstanceIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->protectedNoFault << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerSetDescriptors << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMemoryAllocationSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkan11Properties");
    out << "\t\t" << "VkPhysicalDeviceVulkan11Properties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan12Features(std::ostream &out, const VkPhysicalDeviceVulkan12Features* structInfo, Decoded_VkPhysicalDeviceVulkan12Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->samplerMirrorClampToEdge << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->drawIndirectCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->storageBuffer8BitAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->uniformAndStorageBuffer8BitAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->storagePushConstant8 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBufferInt64Atomics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSharedInt64Atomics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderFloat16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderInt8 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderInputAttachmentArrayDynamicIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderUniformTexelBufferArrayDynamicIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageTexelBufferArrayDynamicIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderUniformBufferArrayNonUniformIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSampledImageArrayNonUniformIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageBufferArrayNonUniformIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageImageArrayNonUniformIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderInputAttachmentArrayNonUniformIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderUniformTexelBufferArrayNonUniformIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageTexelBufferArrayNonUniformIndexing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingUniformBufferUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingSampledImageUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingStorageImageUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingStorageBufferUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingUniformTexelBufferUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingStorageTexelBufferUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingUpdateUnusedWhilePending << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingPartiallyBound << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingVariableDescriptorCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->runtimeDescriptorArray << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->samplerFilterMinmax << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->scalarBlockLayout << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imagelessFramebuffer << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->uniformBufferStandardLayout << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSubgroupExtendedTypes << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->separateDepthStencilLayouts << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hostQueryReset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timelineSemaphore << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddressCaptureReplay << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddressMultiDevice << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vulkanMemoryModel << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vulkanMemoryModelDeviceScope << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vulkanMemoryModelAvailabilityVisibilityChains << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderOutputViewportIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderOutputLayer << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subgroupBroadcastDynamicId << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkan12Features");
    out << "\t\t" << "VkPhysicalDeviceVulkan12Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan12Properties(std::ostream &out, const VkPhysicalDeviceVulkan12Properties* structInfo, Decoded_VkPhysicalDeviceVulkan12Properties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string conformance_version_info_var = GenerateStruct_VkConformanceVersion(out,
                                                                                   &structInfo->conformanceVersion,
                                                                                   metaInfo->conformanceVersion,
                                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDriverId(" << structInfo->driverID << ")" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->driverName) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->driverInfo) << "," << std::endl;
    struct_body << "\t\t\t" << conformance_version_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderFloatControlsIndependence(" << structInfo->denormBehaviorIndependence << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderFloatControlsIndependence(" << structInfo->roundingModeIndependence << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSignedZeroInfNanPreserveFloat16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSignedZeroInfNanPreserveFloat32 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSignedZeroInfNanPreserveFloat64 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDenormPreserveFloat16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDenormPreserveFloat32 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDenormPreserveFloat64 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDenormFlushToZeroFloat16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDenormFlushToZeroFloat32 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDenormFlushToZeroFloat64 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTEFloat16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTEFloat32 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTEFloat64 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTZFloat16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTZFloat32 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderRoundingModeRTZFloat64 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxUpdateAfterBindDescriptorsInAllPools << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderUniformBufferArrayNonUniformIndexingNative << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSampledImageArrayNonUniformIndexingNative << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageBufferArrayNonUniformIndexingNative << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderStorageImageArrayNonUniformIndexingNative << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderInputAttachmentArrayNonUniformIndexingNative << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->robustBufferAccessUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->quadDivergentImplicitLod << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindSamplers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindUniformBuffers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindStorageBuffers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindSampledImages << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindStorageImages << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindInputAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageUpdateAfterBindResources << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindSamplers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindUniformBuffers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageBuffers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindSampledImages << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageImages << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindInputAttachments << "," << std::endl;
    struct_body << "\t\t\t" << "VkResolveModeFlags(" << structInfo->supportedDepthResolveModes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkResolveModeFlags(" << structInfo->supportedStencilResolveModes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->independentResolveNone << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->independentResolve << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->filterMinmaxSingleComponentFormats << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->filterMinmaxImageComponentMapping << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTimelineSemaphoreValueDifference << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->framebufferIntegerColorSampleCounts << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkan12Properties");
    out << "\t\t" << "VkPhysicalDeviceVulkan12Properties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkanMemoryModelFeatures(std::ostream &out, const VkPhysicalDeviceVulkanMemoryModelFeatures* structInfo, Decoded_VkPhysicalDeviceVulkanMemoryModelFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vulkanMemoryModel << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vulkanMemoryModelDeviceScope << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vulkanMemoryModelAvailabilityVisibilityChains << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkanMemoryModelFeatures");
    out << "\t\t" << "VkPhysicalDeviceVulkanMemoryModelFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassAttachmentBeginInfo(std::ostream &out, const VkRenderPassAttachmentBeginInfo* structInfo, Decoded_VkRenderPassAttachmentBeginInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pattachments_array = "NULL";
    if (metaInfo->pAttachments.GetPointer() != NULL && structInfo->attachmentCount > 0) {
        pattachments_array = "pattachments_array_" + std::to_string(consumer.GetNextId());
        std::string pattachments_values = toStringJoin(metaInfo->pAttachments.GetPointer(),
                                                       metaInfo->pAttachments.GetPointer() + structInfo->attachmentCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->attachmentCount == 1) {
            pattachments_array = "&" + pattachments_values;
        } else if (structInfo->attachmentCount > 1) {
            out << "\t\t" << "VkImageView " << pattachments_array << "[] = {" << pattachments_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->attachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pattachments_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassAttachmentBeginInfo");
    out << "\t\t" << "VkRenderPassAttachmentBeginInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassCreateInfo2(std::ostream &out, const VkRenderPassCreateInfo2* structInfo, Decoded_VkRenderPassCreateInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pattachments_array = "NULL";
    if (structInfo->pAttachments != NULL) {
        pattachments_array = "pAttachments_" + std::to_string(consumer.GetNextId());
        std::string pattachments_names;
        for (uint32_t idx = 0; idx < structInfo->attachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentDescription2(out,
                                                                        structInfo->pAttachments + idx,
                                                                        metaInfo->pAttachments->GetMetaStructPointer() + idx,
                                                                        consumer);
            }
            pattachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentDescription2 " << pattachments_array << "[] = {" << pattachments_names << "};" << std::endl;
    }
    std::string psubpasses_array = "NULL";
    if (structInfo->pSubpasses != NULL) {
        psubpasses_array = "pSubpasses_" + std::to_string(consumer.GetNextId());
        std::string psubpasses_names;
        for (uint32_t idx = 0; idx < structInfo->subpassCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pSubpasses + idx != NULL) {
                variable_name = GenerateStruct_VkSubpassDescription2(out,
                                                                     structInfo->pSubpasses + idx,
                                                                     metaInfo->pSubpasses->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            psubpasses_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSubpassDescription2 " << psubpasses_array << "[] = {" << psubpasses_names << "};" << std::endl;
    }
    std::string pdependencies_array = "NULL";
    if (structInfo->pDependencies != NULL) {
        pdependencies_array = "pDependencies_" + std::to_string(consumer.GetNextId());
        std::string pdependencies_names;
        for (uint32_t idx = 0; idx < structInfo->dependencyCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pDependencies + idx != NULL) {
                variable_name = GenerateStruct_VkSubpassDependency2(out,
                                                                    structInfo->pDependencies + idx,
                                                                    metaInfo->pDependencies->GetMetaStructPointer() + idx,
                                                                    consumer);
            }
            pdependencies_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSubpassDependency2 " << pdependencies_array << "[] = {" << pdependencies_names << "};" << std::endl;
    }
    std::string pcorrelated_view_masks_array = "NULL";
    if (structInfo->pCorrelatedViewMasks != NULL) {
        pcorrelated_view_masks_array = "pCorrelatedViewMasks_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pcorrelated_view_masks_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCorrelatedViewMasks, structInfo->correlatedViewMaskCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkRenderPassCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->attachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pattachments_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subpassCount << "," << std::endl;
    struct_body << "\t\t\t" << psubpasses_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dependencyCount << "," << std::endl;
    struct_body << "\t\t\t" << pdependencies_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->correlatedViewMaskCount << "," << std::endl;
    struct_body << "\t\t\t" << pcorrelated_view_masks_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassCreateInfo2");
    out << "\t\t" << "VkRenderPassCreateInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerReductionModeCreateInfo(std::ostream &out, const VkSamplerReductionModeCreateInfo* structInfo, Decoded_VkSamplerReductionModeCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSamplerReductionMode(" << structInfo->reductionMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerReductionModeCreateInfo");
    out << "\t\t" << "VkSamplerReductionModeCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreSignalInfo(std::ostream &out, const VkSemaphoreSignalInfo* structInfo, Decoded_VkSemaphoreSignalInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->value << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreSignalInfo");
    out << "\t\t" << "VkSemaphoreSignalInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreTypeCreateInfo(std::ostream &out, const VkSemaphoreTypeCreateInfo* structInfo, Decoded_VkSemaphoreTypeCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSemaphoreType(" << structInfo->semaphoreType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->initialValue << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreTypeCreateInfo");
    out << "\t\t" << "VkSemaphoreTypeCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreWaitInfo(std::ostream &out, const VkSemaphoreWaitInfo* structInfo, Decoded_VkSemaphoreWaitInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string psemaphores_array = "NULL";
    if (metaInfo->pSemaphores.GetPointer() != NULL && structInfo->semaphoreCount > 0) {
        psemaphores_array = "psemaphores_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_SEMAPHORE));
        std::string psemaphores_values = toStringJoin(metaInfo->pSemaphores.GetPointer(),
                                                      metaInfo->pSemaphores.GetPointer() + structInfo->semaphoreCount,
                                                      [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                      ", ");
        if (structInfo->semaphoreCount == 1) {
            psemaphores_array = "&" + psemaphores_values;
        } else if (structInfo->semaphoreCount > 1) {
            out << "\t\t" << "VkSemaphore " << psemaphores_array << "[] = {" << psemaphores_values << "};" << std::endl;
        }
    }
    std::string pvalues_array = "pvalues_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->semaphoreCount > 0) {
        std::string pvalues_values = toStringJoin(structInfo->pValues,
                                                  structInfo->pValues + structInfo->semaphoreCount,
                                                  [](uint64_t current) { return std::to_string(current); },
                                                  ", ");
        if (structInfo->semaphoreCount == 1) {
            pvalues_array = "&" + pvalues_values;
        } else if (structInfo->semaphoreCount > 1) {
            out << "\t\t" << "uint64_t " << pvalues_array << "[] = {" << pvalues_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSemaphoreWaitFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->semaphoreCount << "," << std::endl;
    struct_body << "\t\t\t" << psemaphores_array << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << pvalues_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreWaitInfo");
    out << "\t\t" << "VkSemaphoreWaitInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassBeginInfo(std::ostream &out, const VkSubpassBeginInfo* structInfo, Decoded_VkSubpassBeginInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSubpassContents(" << structInfo->contents << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassBeginInfo");
    out << "\t\t" << "VkSubpassBeginInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassDependency2(std::ostream &out, const VkSubpassDependency2* structInfo, Decoded_VkSubpassDependency2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcSubpass << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstSubpass << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlags(" << structInfo->srcStageMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlags(" << structInfo->dstStageMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkDependencyFlags(" << structInfo->dependencyFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewOffset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassDependency2");
    out << "\t\t" << "VkSubpassDependency2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassDescription2(std::ostream &out, const VkSubpassDescription2* structInfo, Decoded_VkSubpassDescription2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pinput_attachments_array = "NULL";
    if (structInfo->pInputAttachments != NULL) {
        pinput_attachments_array = "pInputAttachments_" + std::to_string(consumer.GetNextId());
        std::string pinput_attachments_names;
        for (uint32_t idx = 0; idx < structInfo->inputAttachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pInputAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentReference2(out,
                                                                      structInfo->pInputAttachments + idx,
                                                                      metaInfo->pInputAttachments->GetMetaStructPointer() + idx,
                                                                      consumer);
            }
            pinput_attachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentReference2 " << pinput_attachments_array << "[] = {" << pinput_attachments_names << "};" << std::endl;
    }
    std::string pcolor_attachments_array = "NULL";
    if (structInfo->pColorAttachments != NULL) {
        pcolor_attachments_array = "pColorAttachments_" + std::to_string(consumer.GetNextId());
        std::string pcolor_attachments_names;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pColorAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentReference2(out,
                                                                      structInfo->pColorAttachments + idx,
                                                                      metaInfo->pColorAttachments->GetMetaStructPointer() + idx,
                                                                      consumer);
            }
            pcolor_attachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentReference2 " << pcolor_attachments_array << "[] = {" << pcolor_attachments_names << "};" << std::endl;
    }
    std::string presolve_attachments_array = "NULL";
    if (structInfo->pResolveAttachments != NULL) {
        presolve_attachments_array = "pResolveAttachments_" + std::to_string(consumer.GetNextId());
        std::string presolve_attachments_names;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pResolveAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentReference2(out,
                                                                      structInfo->pResolveAttachments + idx,
                                                                      metaInfo->pResolveAttachments->GetMetaStructPointer() + idx,
                                                                      consumer);
            }
            presolve_attachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentReference2 " << presolve_attachments_array << "[] = {" << presolve_attachments_names << "};" << std::endl;
    }
    std::string pdepth_stencil_attachment_struct = "NULL";
    if (structInfo->pDepthStencilAttachment != NULL) {
        pdepth_stencil_attachment_struct = GenerateStruct_VkAttachmentReference2(out,
                                                                                 structInfo->pDepthStencilAttachment,
                                                                                 metaInfo->pDepthStencilAttachment->GetMetaStructPointer(),
                                                                                 consumer);
        pdepth_stencil_attachment_struct.insert(0, "&");
    }
    std::string ppreserve_attachments_array = "NULL";
    if (structInfo->pPreserveAttachments != NULL) {
        ppreserve_attachments_array = "pPreserveAttachments_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << ppreserve_attachments_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pPreserveAttachments, structInfo->preserveAttachmentCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSubpassDescriptionFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->inputAttachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pinput_attachments_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pcolor_attachments_array << "," << std::endl;
    struct_body << "\t\t\t" << presolve_attachments_array << "," << std::endl;
    struct_body << "\t\t\t" << pdepth_stencil_attachment_struct << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preserveAttachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << ppreserve_attachments_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassDescription2");
    out << "\t\t" << "VkSubpassDescription2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassDescriptionDepthStencilResolve(std::ostream &out, const VkSubpassDescriptionDepthStencilResolve* structInfo, Decoded_VkSubpassDescriptionDepthStencilResolve* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdepth_stencil_resolve_attachment_struct = "NULL";
    if (structInfo->pDepthStencilResolveAttachment != NULL) {
        pdepth_stencil_resolve_attachment_struct = GenerateStruct_VkAttachmentReference2(out,
                                                                                         structInfo->pDepthStencilResolveAttachment,
                                                                                         metaInfo->pDepthStencilResolveAttachment->GetMetaStructPointer(),
                                                                                         consumer);
        pdepth_stencil_resolve_attachment_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkResolveModeFlagBits(" << structInfo->depthResolveMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkResolveModeFlagBits(" << structInfo->stencilResolveMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pdepth_stencil_resolve_attachment_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassDescriptionDepthStencilResolve");
    out << "\t\t" << "VkSubpassDescriptionDepthStencilResolve " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassEndInfo(std::ostream &out, const VkSubpassEndInfo* structInfo, Decoded_VkSubpassEndInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassEndInfo");
    out << "\t\t" << "VkSubpassEndInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTimelineSemaphoreSubmitInfo(std::ostream &out, const VkTimelineSemaphoreSubmitInfo* structInfo, Decoded_VkTimelineSemaphoreSubmitInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pwait_semaphore_values_array = "pwait_semaphore_values_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->waitSemaphoreValueCount > 0) {
        std::string pwait_semaphore_values_values = toStringJoin(structInfo->pWaitSemaphoreValues,
                                                                 structInfo->pWaitSemaphoreValues + structInfo->waitSemaphoreValueCount,
                                                                 [](uint64_t current) { return std::to_string(current); },
                                                                 ", ");
        if (structInfo->waitSemaphoreValueCount == 1) {
            pwait_semaphore_values_array = "&" + pwait_semaphore_values_values;
        } else if (structInfo->waitSemaphoreValueCount > 1) {
            out << "\t\t" << "uint64_t " << pwait_semaphore_values_array << "[] = {" << pwait_semaphore_values_values << "};" << std::endl;
        }
    }
    std::string psignal_semaphore_values_array = "psignal_semaphore_values_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->signalSemaphoreValueCount > 0) {
        std::string psignal_semaphore_values_values = toStringJoin(structInfo->pSignalSemaphoreValues,
                                                                   structInfo->pSignalSemaphoreValues + structInfo->signalSemaphoreValueCount,
                                                                   [](uint64_t current) { return std::to_string(current); },
                                                                   ", ");
        if (structInfo->signalSemaphoreValueCount == 1) {
            psignal_semaphore_values_array = "&" + psignal_semaphore_values_values;
        } else if (structInfo->signalSemaphoreValueCount > 1) {
            out << "\t\t" << "uint64_t " << psignal_semaphore_values_array << "[] = {" << psignal_semaphore_values_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->waitSemaphoreValueCount << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << pwait_semaphore_values_array << " }" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->signalSemaphoreValueCount << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << psignal_semaphore_values_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "timelineSemaphoreSubmitInfo");
    out << "\t\t" << "VkTimelineSemaphoreSubmitInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBlitImageInfo2(std::ostream &out, const VkBlitImageInfo2* structInfo, Decoded_VkBlitImageInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkImageBlit2(out,
                                                            structInfo->pRegions + idx,
                                                            metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                            consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkImageBlit2 " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcImage) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstImage) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
    struct_body << "\t\t\t" << pregions_array << "," << std::endl;
    struct_body << "\t\t\t" << "VkFilter(" << structInfo->filter << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "blitImageInfo2");
    out << "\t\t" << "VkBlitImageInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferCopy2(std::ostream &out, const VkBufferCopy2* structInfo, Decoded_VkBufferCopy2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferCopy2");
    out << "\t\t" << "VkBufferCopy2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferImageCopy2(std::ostream &out, const VkBufferImageCopy2* structInfo, Decoded_VkBufferImageCopy2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string image_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                     &structInfo->imageSubresource,
                                                                                     metaInfo->imageSubresource,
                                                                                     consumer);
    std::string image_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->imageOffset,
                                                                  metaInfo->imageOffset,
                                                                  consumer);
    std::string image_extent_info_var = GenerateStruct_VkExtent3D(out,
                                                                  &structInfo->imageExtent,
                                                                  metaInfo->imageExtent,
                                                                  consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferRowLength << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferImageHeight << "," << std::endl;
    struct_body << "\t\t\t" << image_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << image_offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << image_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferImageCopy2");
    out << "\t\t" << "VkBufferImageCopy2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferMemoryBarrier2(std::ostream &out, const VkBufferMemoryBarrier2* structInfo, Decoded_VkBufferMemoryBarrier2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->srcStageMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags2(" << structInfo->srcAccessMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->dstStageMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags2(" << structInfo->dstAccessMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcQueueFamilyIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstQueueFamilyIndex << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferMemoryBarrier2");
    out << "\t\t" << "VkBufferMemoryBarrier2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferInheritanceRenderingInfo(std::ostream &out, const VkCommandBufferInheritanceRenderingInfo* structInfo, Decoded_VkCommandBufferInheritanceRenderingInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcolor_attachment_formats_values;
    std::string pcolor_attachment_formats_array = "NULL";
    if (structInfo->pColorAttachmentFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            pcolor_attachment_formats_values += util::ToString<VkFormat>(structInfo->pColorAttachmentFormats[idx]) + ", ";
        }
        pcolor_attachment_formats_array = "pColorAttachmentFormats_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkFormat " << pcolor_attachment_formats_array << "[] = {" << pcolor_attachment_formats_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkRenderingFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pcolor_attachment_formats_array << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->depthAttachmentFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->stencilAttachmentFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->rasterizationSamples << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferInheritanceRenderingInfo");
    out << "\t\t" << "VkCommandBufferInheritanceRenderingInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferSubmitInfo(std::ostream &out, const VkCommandBufferSubmitInfo* structInfo, Decoded_VkCommandBufferSubmitInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->commandBuffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceMask << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferSubmitInfo");
    out << "\t\t" << "VkCommandBufferSubmitInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyBufferInfo2(std::ostream &out, const VkCopyBufferInfo2* structInfo, Decoded_VkCopyBufferInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkBufferCopy2(out,
                                                             structInfo->pRegions + idx,
                                                             metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                             consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkBufferCopy2 " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcBuffer) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstBuffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyBufferInfo2");
    out << "\t\t" << "VkCopyBufferInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyBufferToImageInfo2(std::ostream &out, const VkCopyBufferToImageInfo2* structInfo, Decoded_VkCopyBufferToImageInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkBufferImageCopy2(out,
                                                                  structInfo->pRegions + idx,
                                                                  metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkBufferImageCopy2 " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcBuffer) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstImage) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyBufferToImageInfo2");
    out << "\t\t" << "VkCopyBufferToImageInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyImageInfo2(std::ostream &out, const VkCopyImageInfo2* structInfo, Decoded_VkCopyImageInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkImageCopy2(out,
                                                            structInfo->pRegions + idx,
                                                            metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                            consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkImageCopy2 " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcImage) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstImage) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyImageInfo2");
    out << "\t\t" << "VkCopyImageInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyImageToBufferInfo2(std::ostream &out, const VkCopyImageToBufferInfo2* structInfo, Decoded_VkCopyImageToBufferInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkBufferImageCopy2(out,
                                                                  structInfo->pRegions + idx,
                                                                  metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkBufferImageCopy2 " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcImage) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstBuffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyImageToBufferInfo2");
    out << "\t\t" << "VkCopyImageToBufferInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDependencyInfo(std::ostream &out, const VkDependencyInfo* structInfo, Decoded_VkDependencyInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pmemory_barriers_array = "NULL";
    if (structInfo->pMemoryBarriers != NULL) {
        pmemory_barriers_array = "pMemoryBarriers_" + std::to_string(consumer.GetNextId());
        std::string pmemory_barriers_names;
        for (uint32_t idx = 0; idx < structInfo->memoryBarrierCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pMemoryBarriers + idx != NULL) {
                variable_name = GenerateStruct_VkMemoryBarrier2(out,
                                                                structInfo->pMemoryBarriers + idx,
                                                                metaInfo->pMemoryBarriers->GetMetaStructPointer() + idx,
                                                                consumer);
            }
            pmemory_barriers_names += variable_name + ", ";
        }
        out << "\t\t" << "VkMemoryBarrier2 " << pmemory_barriers_array << "[] = {" << pmemory_barriers_names << "};" << std::endl;
    }
    std::string pbuffer_memory_barriers_array = "NULL";
    if (structInfo->pBufferMemoryBarriers != NULL) {
        pbuffer_memory_barriers_array = "pBufferMemoryBarriers_" + std::to_string(consumer.GetNextId());
        std::string pbuffer_memory_barriers_names;
        for (uint32_t idx = 0; idx < structInfo->bufferMemoryBarrierCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pBufferMemoryBarriers + idx != NULL) {
                variable_name = GenerateStruct_VkBufferMemoryBarrier2(out,
                                                                      structInfo->pBufferMemoryBarriers + idx,
                                                                      metaInfo->pBufferMemoryBarriers->GetMetaStructPointer() + idx,
                                                                      consumer);
            }
            pbuffer_memory_barriers_names += variable_name + ", ";
        }
        out << "\t\t" << "VkBufferMemoryBarrier2 " << pbuffer_memory_barriers_array << "[] = {" << pbuffer_memory_barriers_names << "};" << std::endl;
    }
    std::string pimage_memory_barriers_array = "NULL";
    if (structInfo->pImageMemoryBarriers != NULL) {
        pimage_memory_barriers_array = "pImageMemoryBarriers_" + std::to_string(consumer.GetNextId());
        std::string pimage_memory_barriers_names;
        for (uint32_t idx = 0; idx < structInfo->imageMemoryBarrierCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pImageMemoryBarriers + idx != NULL) {
                variable_name = GenerateStruct_VkImageMemoryBarrier2(out,
                                                                     structInfo->pImageMemoryBarriers + idx,
                                                                     metaInfo->pImageMemoryBarriers->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            pimage_memory_barriers_names += variable_name + ", ";
        }
        out << "\t\t" << "VkImageMemoryBarrier2 " << pimage_memory_barriers_array << "[] = {" << pimage_memory_barriers_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDependencyFlags(" << structInfo->dependencyFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryBarrierCount << "," << std::endl;
    struct_body << "\t\t\t" << pmemory_barriers_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferMemoryBarrierCount << "," << std::endl;
    struct_body << "\t\t\t" << pbuffer_memory_barriers_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageMemoryBarrierCount << "," << std::endl;
    struct_body << "\t\t\t" << pimage_memory_barriers_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dependencyInfo");
    out << "\t\t" << "VkDependencyInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorPoolInlineUniformBlockCreateInfo(std::ostream &out, const VkDescriptorPoolInlineUniformBlockCreateInfo* structInfo, Decoded_VkDescriptorPoolInlineUniformBlockCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxInlineUniformBlockBindings << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorPoolInlineUniformBlockCreateInfo");
    out << "\t\t" << "VkDescriptorPoolInlineUniformBlockCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceBufferMemoryRequirements(std::ostream &out, const VkDeviceBufferMemoryRequirements* structInfo, Decoded_VkDeviceBufferMemoryRequirements* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcreate_info_struct = "NULL";
    if (structInfo->pCreateInfo != NULL) {
        pcreate_info_struct = GenerateStruct_VkBufferCreateInfo(out,
                                                                structInfo->pCreateInfo,
                                                                metaInfo->pCreateInfo->GetMetaStructPointer(),
                                                                consumer);
        pcreate_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pcreate_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceBufferMemoryRequirements");
    out << "\t\t" << "VkDeviceBufferMemoryRequirements " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceImageMemoryRequirements(std::ostream &out, const VkDeviceImageMemoryRequirements* structInfo, Decoded_VkDeviceImageMemoryRequirements* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcreate_info_struct = "NULL";
    if (structInfo->pCreateInfo != NULL) {
        pcreate_info_struct = GenerateStruct_VkImageCreateInfo(out,
                                                               structInfo->pCreateInfo,
                                                               metaInfo->pCreateInfo->GetMetaStructPointer(),
                                                               consumer);
        pcreate_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pcreate_info_struct << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageAspectFlagBits(" << structInfo->planeAspect << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceImageMemoryRequirements");
    out << "\t\t" << "VkDeviceImageMemoryRequirements " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDevicePrivateDataCreateInfo(std::ostream &out, const VkDevicePrivateDataCreateInfo* structInfo, Decoded_VkDevicePrivateDataCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->privateDataSlotRequestCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "devicePrivateDataCreateInfo");
    out << "\t\t" << "VkDevicePrivateDataCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFormatProperties3(std::ostream &out, const VkFormatProperties3* structInfo, Decoded_VkFormatProperties3* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormatFeatureFlags2(" << structInfo->linearTilingFeatures << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormatFeatureFlags2(" << structInfo->optimalTilingFeatures << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormatFeatureFlags2(" << structInfo->bufferFeatures << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "formatProperties3");
    out << "\t\t" << "VkFormatProperties3 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageBlit2(std::ostream &out, const VkImageBlit2* structInfo, Decoded_VkImageBlit2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string src_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->srcSubresource,
                                                                                   metaInfo->srcSubresource,
                                                                                   consumer);
    std::string dst_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->dstSubresource,
                                                                                   metaInfo->dstSubresource,
                                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << src_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkOffset3D*>(&structInfo->srcOffsets[0]), 2) << "," << std::endl;
    struct_body << "\t\t\t" << dst_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkOffset3D*>(&structInfo->dstOffsets[0]), 2) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageBlit2");
    out << "\t\t" << "VkImageBlit2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageCopy2(std::ostream &out, const VkImageCopy2* structInfo, Decoded_VkImageCopy2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string src_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->srcSubresource,
                                                                                   metaInfo->srcSubresource,
                                                                                   consumer);
    std::string src_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->srcOffset,
                                                                metaInfo->srcOffset,
                                                                consumer);
    std::string dst_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->dstSubresource,
                                                                                   metaInfo->dstSubresource,
                                                                                   consumer);
    std::string dst_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->dstOffset,
                                                                metaInfo->dstOffset,
                                                                consumer);
    std::string extent_info_var = GenerateStruct_VkExtent3D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << src_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << src_offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << dst_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << dst_offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageCopy2");
    out << "\t\t" << "VkImageCopy2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageMemoryBarrier2(std::ostream &out, const VkImageMemoryBarrier2* structInfo, Decoded_VkImageMemoryBarrier2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string subresource_range_info_var = GenerateStruct_VkImageSubresourceRange(out,
                                                                                    &structInfo->subresourceRange,
                                                                                    metaInfo->subresourceRange,
                                                                                    consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->srcStageMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags2(" << structInfo->srcAccessMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->dstStageMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags2(" << structInfo->dstAccessMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->oldLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->newLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcQueueFamilyIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstQueueFamilyIndex << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
    struct_body << "\t\t\t" << subresource_range_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageMemoryBarrier2");
    out << "\t\t" << "VkImageMemoryBarrier2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageResolve2(std::ostream &out, const VkImageResolve2* structInfo, Decoded_VkImageResolve2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string src_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->srcSubresource,
                                                                                   metaInfo->srcSubresource,
                                                                                   consumer);
    std::string src_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->srcOffset,
                                                                metaInfo->srcOffset,
                                                                consumer);
    std::string dst_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                   &structInfo->dstSubresource,
                                                                                   metaInfo->dstSubresource,
                                                                                   consumer);
    std::string dst_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                &structInfo->dstOffset,
                                                                metaInfo->dstOffset,
                                                                consumer);
    std::string extent_info_var = GenerateStruct_VkExtent3D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << src_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << src_offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << dst_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << dst_offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageResolve2");
    out << "\t\t" << "VkImageResolve2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryBarrier2(std::ostream &out, const VkMemoryBarrier2* structInfo, Decoded_VkMemoryBarrier2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->srcStageMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags2(" << structInfo->srcAccessMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->dstStageMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags2(" << structInfo->dstAccessMask << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryBarrier2");
    out << "\t\t" << "VkMemoryBarrier2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDynamicRenderingFeatures(std::ostream &out, const VkPhysicalDeviceDynamicRenderingFeatures* structInfo, Decoded_VkPhysicalDeviceDynamicRenderingFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dynamicRendering << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDynamicRenderingFeatures");
    out << "\t\t" << "VkPhysicalDeviceDynamicRenderingFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageRobustnessFeatures(std::ostream &out, const VkPhysicalDeviceImageRobustnessFeatures* structInfo, Decoded_VkPhysicalDeviceImageRobustnessFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->robustImageAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageRobustnessFeatures");
    out << "\t\t" << "VkPhysicalDeviceImageRobustnessFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceInlineUniformBlockFeatures(std::ostream &out, const VkPhysicalDeviceInlineUniformBlockFeatures* structInfo, Decoded_VkPhysicalDeviceInlineUniformBlockFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->inlineUniformBlock << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingInlineUniformBlockUpdateAfterBind << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceInlineUniformBlockFeatures");
    out << "\t\t" << "VkPhysicalDeviceInlineUniformBlockFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceInlineUniformBlockProperties(std::ostream &out, const VkPhysicalDeviceInlineUniformBlockProperties* structInfo, Decoded_VkPhysicalDeviceInlineUniformBlockProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxInlineUniformBlockSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorInlineUniformBlocks << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetInlineUniformBlocks << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindInlineUniformBlocks << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceInlineUniformBlockProperties");
    out << "\t\t" << "VkPhysicalDeviceInlineUniformBlockProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance4Features(std::ostream &out, const VkPhysicalDeviceMaintenance4Features* structInfo, Decoded_VkPhysicalDeviceMaintenance4Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maintenance4 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance4Features");
    out << "\t\t" << "VkPhysicalDeviceMaintenance4Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance4Properties(std::ostream &out, const VkPhysicalDeviceMaintenance4Properties* structInfo, Decoded_VkPhysicalDeviceMaintenance4Properties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxBufferSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance4Properties");
    out << "\t\t" << "VkPhysicalDeviceMaintenance4Properties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineCreationCacheControlFeatures(std::ostream &out, const VkPhysicalDevicePipelineCreationCacheControlFeatures* structInfo, Decoded_VkPhysicalDevicePipelineCreationCacheControlFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineCreationCacheControl << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineCreationCacheControlFeatures");
    out << "\t\t" << "VkPhysicalDevicePipelineCreationCacheControlFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePrivateDataFeatures(std::ostream &out, const VkPhysicalDevicePrivateDataFeatures* structInfo, Decoded_VkPhysicalDevicePrivateDataFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->privateData << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePrivateDataFeatures");
    out << "\t\t" << "VkPhysicalDevicePrivateDataFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(std::ostream &out, const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* structInfo, Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDemoteToHelperInvocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderDemoteToHelperInvocationFeatures");
    out << "\t\t" << "VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderIntegerDotProductFeatures(std::ostream &out, const VkPhysicalDeviceShaderIntegerDotProductFeatures* structInfo, Decoded_VkPhysicalDeviceShaderIntegerDotProductFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderIntegerDotProduct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderIntegerDotProductFeatures");
    out << "\t\t" << "VkPhysicalDeviceShaderIntegerDotProductFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderIntegerDotProductProperties(std::ostream &out, const VkPhysicalDeviceShaderIntegerDotProductProperties* structInfo, Decoded_VkPhysicalDeviceShaderIntegerDotProductProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct8BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct8BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct8BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct4x8BitPackedUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct4x8BitPackedSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct4x8BitPackedMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct16BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct16BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct16BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct32BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct32BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct32BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct64BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct64BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct64BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating8BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating16BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating32BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating64BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderIntegerDotProductProperties");
    out << "\t\t" << "VkPhysicalDeviceShaderIntegerDotProductProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderTerminateInvocationFeatures(std::ostream &out, const VkPhysicalDeviceShaderTerminateInvocationFeatures* structInfo, Decoded_VkPhysicalDeviceShaderTerminateInvocationFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderTerminateInvocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderTerminateInvocationFeatures");
    out << "\t\t" << "VkPhysicalDeviceShaderTerminateInvocationFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSubgroupSizeControlFeatures(std::ostream &out, const VkPhysicalDeviceSubgroupSizeControlFeatures* structInfo, Decoded_VkPhysicalDeviceSubgroupSizeControlFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subgroupSizeControl << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->computeFullSubgroups << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSubgroupSizeControlFeatures");
    out << "\t\t" << "VkPhysicalDeviceSubgroupSizeControlFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSubgroupSizeControlProperties(std::ostream &out, const VkPhysicalDeviceSubgroupSizeControlProperties* structInfo, Decoded_VkPhysicalDeviceSubgroupSizeControlProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minSubgroupSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSubgroupSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxComputeWorkgroupSubgroups << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->requiredSubgroupSizeStages << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSubgroupSizeControlProperties");
    out << "\t\t" << "VkPhysicalDeviceSubgroupSizeControlProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSynchronization2Features(std::ostream &out, const VkPhysicalDeviceSynchronization2Features* structInfo, Decoded_VkPhysicalDeviceSynchronization2Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->synchronization2 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSynchronization2Features");
    out << "\t\t" << "VkPhysicalDeviceSynchronization2Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTexelBufferAlignmentProperties(std::ostream &out, const VkPhysicalDeviceTexelBufferAlignmentProperties* structInfo, Decoded_VkPhysicalDeviceTexelBufferAlignmentProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->storageTexelBufferOffsetAlignmentBytes << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->storageTexelBufferOffsetSingleTexelAlignment << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->uniformTexelBufferOffsetAlignmentBytes << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->uniformTexelBufferOffsetSingleTexelAlignment << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTexelBufferAlignmentProperties");
    out << "\t\t" << "VkPhysicalDeviceTexelBufferAlignmentProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(std::ostream &out, const VkPhysicalDeviceTextureCompressionASTCHDRFeatures* structInfo, Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->textureCompressionASTC_HDR << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTextureCompressionASTCHDRFeatures");
    out << "\t\t" << "VkPhysicalDeviceTextureCompressionASTCHDRFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceToolProperties(std::ostream &out, const VkPhysicalDeviceToolProperties* structInfo, Decoded_VkPhysicalDeviceToolProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->name) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->version) << "," << std::endl;
    struct_body << "\t\t\t" << "VkToolPurposeFlags(" << structInfo->purposes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->layer) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceToolProperties");
    out << "\t\t" << "VkPhysicalDeviceToolProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan13Features(std::ostream &out, const VkPhysicalDeviceVulkan13Features* structInfo, Decoded_VkPhysicalDeviceVulkan13Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->robustImageAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->inlineUniformBlock << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingInlineUniformBlockUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineCreationCacheControl << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->privateData << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDemoteToHelperInvocation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderTerminateInvocation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subgroupSizeControl << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->computeFullSubgroups << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->synchronization2 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->textureCompressionASTC_HDR << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderZeroInitializeWorkgroupMemory << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dynamicRendering << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderIntegerDotProduct << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maintenance4 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkan13Features");
    out << "\t\t" << "VkPhysicalDeviceVulkan13Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan13Properties(std::ostream &out, const VkPhysicalDeviceVulkan13Properties* structInfo, Decoded_VkPhysicalDeviceVulkan13Properties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minSubgroupSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSubgroupSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxComputeWorkgroupSubgroups << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->requiredSubgroupSizeStages << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxInlineUniformBlockSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorInlineUniformBlocks << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetInlineUniformBlocks << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindInlineUniformBlocks << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxInlineUniformTotalSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct8BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct8BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct8BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct4x8BitPackedUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct4x8BitPackedSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct4x8BitPackedMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct16BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct16BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct16BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct32BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct32BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct32BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct64BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct64BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProduct64BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating8BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating16BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating32BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating64BitSignedAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->storageTexelBufferOffsetAlignmentBytes << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->storageTexelBufferOffsetSingleTexelAlignment << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->uniformTexelBufferOffsetAlignmentBytes << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->uniformTexelBufferOffsetSingleTexelAlignment << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxBufferSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkan13Properties");
    out << "\t\t" << "VkPhysicalDeviceVulkan13Properties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(std::ostream &out, const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* structInfo, Decoded_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderZeroInitializeWorkgroupMemory << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceZeroInitializeWorkgroupMemoryFeatures");
    out << "\t\t" << "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCreationFeedback(std::ostream &out, const VkPipelineCreationFeedback* structInfo, Decoded_VkPipelineCreationFeedback* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkPipelineCreationFeedbackFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->duration << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCreationFeedback");
    out << "\t\t" << "VkPipelineCreationFeedback " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCreationFeedbackCreateInfo(std::ostream &out, const VkPipelineCreationFeedbackCreateInfo* structInfo, Decoded_VkPipelineCreationFeedbackCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppipeline_creation_feedback_name = "NULL";
    if (structInfo->pPipelineCreationFeedback != NULL) {
        ppipeline_creation_feedback_name = GenerateStruct_VkPipelineCreationFeedback(out,
                                                                                     structInfo->pPipelineCreationFeedback,
                                                                                     metaInfo->pPipelineCreationFeedback->GetMetaStructPointer(),
                                                                                     consumer);
        ppipeline_creation_feedback_name.insert(0, "&");
    }
    std::string ppipeline_stage_creation_feedbacks_array = "NULL";
    if (structInfo->pPipelineStageCreationFeedbacks != NULL) {
        ppipeline_stage_creation_feedbacks_array = "pPipelineStageCreationFeedbacks_" + std::to_string(consumer.GetNextId());
        std::string ppipeline_stage_creation_feedbacks_names;
        for (uint32_t idx = 0; idx < structInfo->pipelineStageCreationFeedbackCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPipelineStageCreationFeedbacks + idx != NULL) {
                variable_name = GenerateStruct_VkPipelineCreationFeedback(out,
                                                                          structInfo->pPipelineStageCreationFeedbacks + idx,
                                                                          metaInfo->pPipelineStageCreationFeedbacks->GetMetaStructPointer() + idx,
                                                                          consumer);
            }
            ppipeline_stage_creation_feedbacks_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPipelineCreationFeedback " << ppipeline_stage_creation_feedbacks_array << "[] = {" << ppipeline_stage_creation_feedbacks_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << ppipeline_creation_feedback_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineStageCreationFeedbackCount << "," << std::endl;
    struct_body << "\t\t\t" << ppipeline_stage_creation_feedbacks_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCreationFeedbackCreateInfo");
    out << "\t\t" << "VkPipelineCreationFeedbackCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRenderingCreateInfo(std::ostream &out, const VkPipelineRenderingCreateInfo* structInfo, Decoded_VkPipelineRenderingCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcolor_attachment_formats_values;
    std::string pcolor_attachment_formats_array = "NULL";
    if (structInfo->pColorAttachmentFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            pcolor_attachment_formats_values += util::ToString<VkFormat>(structInfo->pColorAttachmentFormats[idx]) + ", ";
        }
        pcolor_attachment_formats_array = "pColorAttachmentFormats_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkFormat " << pcolor_attachment_formats_array << "[] = {" << pcolor_attachment_formats_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pcolor_attachment_formats_array << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->depthAttachmentFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->stencilAttachmentFormat << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRenderingCreateInfo");
    out << "\t\t" << "VkPipelineRenderingCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(std::ostream &out, const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* structInfo, Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->requiredSubgroupSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineShaderStageRequiredSubgroupSizeCreateInfo");
    out << "\t\t" << "VkPipelineShaderStageRequiredSubgroupSizeCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPrivateDataSlotCreateInfo(std::ostream &out, const VkPrivateDataSlotCreateInfo* structInfo, Decoded_VkPrivateDataSlotCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPrivateDataSlotCreateFlags(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "privateDataSlotCreateInfo");
    out << "\t\t" << "VkPrivateDataSlotCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderingAttachmentInfo(std::ostream &out, const VkRenderingAttachmentInfo* structInfo, Decoded_VkRenderingAttachmentInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->imageView) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->imageLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkResolveModeFlagBits(" << structInfo->resolveMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->resolveImageView) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->resolveImageLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAttachmentLoadOp(" << structInfo->loadOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAttachmentStoreOp(" << structInfo->storeOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(structInfo->clearValue) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderingAttachmentInfo");
    out << "\t\t" << "VkRenderingAttachmentInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderingInfo(std::ostream &out, const VkRenderingInfo* structInfo, Decoded_VkRenderingInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string render_area_info_var = GenerateStruct_VkRect2D(out,
                                                               &structInfo->renderArea,
                                                               metaInfo->renderArea,
                                                               consumer);
    std::string pcolor_attachments_array = "NULL";
    if (structInfo->pColorAttachments != NULL) {
        pcolor_attachments_array = "pColorAttachments_" + std::to_string(consumer.GetNextId());
        std::string pcolor_attachments_names;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pColorAttachments + idx != NULL) {
                variable_name = GenerateStruct_VkRenderingAttachmentInfo(out,
                                                                         structInfo->pColorAttachments + idx,
                                                                         metaInfo->pColorAttachments->GetMetaStructPointer() + idx,
                                                                         consumer);
            }
            pcolor_attachments_names += variable_name + ", ";
        }
        out << "\t\t" << "VkRenderingAttachmentInfo " << pcolor_attachments_array << "[] = {" << pcolor_attachments_names << "};" << std::endl;
    }
    std::string pdepth_attachment_struct = "NULL";
    if (structInfo->pDepthAttachment != NULL) {
        pdepth_attachment_struct = GenerateStruct_VkRenderingAttachmentInfo(out,
                                                                            structInfo->pDepthAttachment,
                                                                            metaInfo->pDepthAttachment->GetMetaStructPointer(),
                                                                            consumer);
        pdepth_attachment_struct.insert(0, "&");
    }
    std::string pstencil_attachment_struct = "NULL";
    if (structInfo->pStencilAttachment != NULL) {
        pstencil_attachment_struct = GenerateStruct_VkRenderingAttachmentInfo(out,
                                                                              structInfo->pStencilAttachment,
                                                                              metaInfo->pStencilAttachment->GetMetaStructPointer(),
                                                                              consumer);
        pstencil_attachment_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkRenderingFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << render_area_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->layerCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pcolor_attachments_array << "," << std::endl;
    struct_body << "\t\t\t" << pdepth_attachment_struct << "," << std::endl;
    struct_body << "\t\t\t" << pstencil_attachment_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderingInfo");
    out << "\t\t" << "VkRenderingInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkResolveImageInfo2(std::ostream &out, const VkResolveImageInfo2* structInfo, Decoded_VkResolveImageInfo2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkImageResolve2(out,
                                                               structInfo->pRegions + idx,
                                                               metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                               consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkImageResolve2 " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcImage) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstImage) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "resolveImageInfo2");
    out << "\t\t" << "VkResolveImageInfo2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreSubmitInfo(std::ostream &out, const VkSemaphoreSubmitInfo* structInfo, Decoded_VkSemaphoreSubmitInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->value << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->stageMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreSubmitInfo");
    out << "\t\t" << "VkSemaphoreSubmitInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWriteDescriptorSetInlineUniformBlock(std::ostream &out, const VkWriteDescriptorSetInlineUniformBlock* structInfo, Decoded_VkWriteDescriptorSetInlineUniformBlock* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdata_array = "NULL";
    if (structInfo->pData != NULL) {
        std::string pdata_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->dataSize; ++idx0) {
            pdata_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pData)[idx0]) + ", ";
        }
        pdata_array = "pData_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pdata_array << "[] = {" << pdata_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dataSize << "," << std::endl;
    struct_body << "\t\t\t" << pdata_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "writeDescriptorSetInlineUniformBlock");
    out << "\t\t" << "VkWriteDescriptorSetInlineUniformBlock " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindDescriptorSetsInfo(std::ostream &out, const VkBindDescriptorSetsInfo* structInfo, Decoded_VkBindDescriptorSetsInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdescriptor_sets_array = "NULL";
    if (metaInfo->pDescriptorSets.GetPointer() != NULL && structInfo->descriptorSetCount > 0) {
        pdescriptor_sets_array = "pdescriptor_sets_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DESCRIPTOR_SET));
        std::string pdescriptor_sets_values = toStringJoin(metaInfo->pDescriptorSets.GetPointer(),
                                                           metaInfo->pDescriptorSets.GetPointer() + structInfo->descriptorSetCount,
                                                           [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                           ", ");
        if (structInfo->descriptorSetCount == 1) {
            pdescriptor_sets_array = "&" + pdescriptor_sets_values;
        } else if (structInfo->descriptorSetCount > 1) {
            out << "\t\t" << "VkDescriptorSet " << pdescriptor_sets_array << "[] = {" << pdescriptor_sets_values << "};" << std::endl;
        }
    }
    std::string pdynamic_offsets_array = "NULL";
    if (structInfo->pDynamicOffsets != NULL) {
        pdynamic_offsets_array = "pDynamicOffsets_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pdynamic_offsets_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDynamicOffsets, structInfo->dynamicOffsetCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->stageFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->layout) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->firstSet << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorSetCount << "," << std::endl;
    struct_body << "\t\t\t" << pdescriptor_sets_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dynamicOffsetCount << "," << std::endl;
    struct_body << "\t\t\t" << pdynamic_offsets_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindDescriptorSetsInfo");
    out << "\t\t" << "VkBindDescriptorSetsInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindMemoryStatus(std::ostream &out, const VkBindMemoryStatus* structInfo, Decoded_VkBindMemoryStatus* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    out << "\t\t" << "// TODO: Support pResult (non-struct output) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "bindMemoryStatus");
    out << "\t\t" << "VkBindMemoryStatus " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferUsageFlags2CreateInfo(std::ostream &out, const VkBufferUsageFlags2CreateInfo* structInfo, Decoded_VkBufferUsageFlags2CreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkBufferUsageFlags2(" << structInfo->usage << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferUsageFlags2CreateInfo");
    out << "\t\t" << "VkBufferUsageFlags2CreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyImageToImageInfo(std::ostream &out, const VkCopyImageToImageInfo* structInfo, Decoded_VkCopyImageToImageInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkImageCopy2(out,
                                                            structInfo->pRegions + idx,
                                                            metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                            consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkImageCopy2 " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkHostImageCopyFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcImage) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstImage) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyImageToImageInfo");
    out << "\t\t" << "VkCopyImageToImageInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceImageSubresourceInfo(std::ostream &out, const VkDeviceImageSubresourceInfo* structInfo, Decoded_VkDeviceImageSubresourceInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcreate_info_struct = "NULL";
    if (structInfo->pCreateInfo != NULL) {
        pcreate_info_struct = GenerateStruct_VkImageCreateInfo(out,
                                                               structInfo->pCreateInfo,
                                                               metaInfo->pCreateInfo->GetMetaStructPointer(),
                                                               consumer);
        pcreate_info_struct.insert(0, "&");
    }
    std::string psubresource_struct = "NULL";
    if (structInfo->pSubresource != NULL) {
        psubresource_struct = GenerateStruct_VkImageSubresource2(out,
                                                                 structInfo->pSubresource,
                                                                 metaInfo->pSubresource->GetMetaStructPointer(),
                                                                 consumer);
        psubresource_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pcreate_info_struct << "," << std::endl;
    struct_body << "\t\t\t" << psubresource_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceImageSubresourceInfo");
    out << "\t\t" << "VkDeviceImageSubresourceInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceQueueGlobalPriorityCreateInfo(std::ostream &out, const VkDeviceQueueGlobalPriorityCreateInfo* structInfo, Decoded_VkDeviceQueueGlobalPriorityCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkQueueGlobalPriority(" << structInfo->globalPriority << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceQueueGlobalPriorityCreateInfo");
    out << "\t\t" << "VkDeviceQueueGlobalPriorityCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkHostImageCopyDevicePerformanceQuery(std::ostream &out, const VkHostImageCopyDevicePerformanceQuery* structInfo, Decoded_VkHostImageCopyDevicePerformanceQuery* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->optimalDeviceAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->identicalMemoryLayout << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "hostImageCopyDevicePerformanceQuery");
    out << "\t\t" << "VkHostImageCopyDevicePerformanceQuery " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkHostImageLayoutTransitionInfo(std::ostream &out, const VkHostImageLayoutTransitionInfo* structInfo, Decoded_VkHostImageLayoutTransitionInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string subresource_range_info_var = GenerateStruct_VkImageSubresourceRange(out,
                                                                                    &structInfo->subresourceRange,
                                                                                    metaInfo->subresourceRange,
                                                                                    consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->oldLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->newLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << subresource_range_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "hostImageLayoutTransitionInfo");
    out << "\t\t" << "VkHostImageLayoutTransitionInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageSubresource2(std::ostream &out, const VkImageSubresource2* structInfo, Decoded_VkImageSubresource2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string image_subresource_info_var = GenerateStruct_VkImageSubresource(out,
                                                                               &structInfo->imageSubresource,
                                                                               metaInfo->imageSubresource,
                                                                               consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << image_subresource_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageSubresource2");
    out << "\t\t" << "VkImageSubresource2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryMapInfo(std::ostream &out, const VkMemoryMapInfo* structInfo, Decoded_VkMemoryMapInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkMemoryMapFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryMapInfo");
    out << "\t\t" << "VkMemoryMapInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryUnmapInfo(std::ostream &out, const VkMemoryUnmapInfo* structInfo, Decoded_VkMemoryUnmapInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkMemoryUnmapFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryUnmapInfo");
    out << "\t\t" << "VkMemoryUnmapInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDynamicRenderingLocalReadFeatures(std::ostream &out, const VkPhysicalDeviceDynamicRenderingLocalReadFeatures* structInfo, Decoded_VkPhysicalDeviceDynamicRenderingLocalReadFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dynamicRenderingLocalRead << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDynamicRenderingLocalReadFeatures");
    out << "\t\t" << "VkPhysicalDeviceDynamicRenderingLocalReadFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceGlobalPriorityQueryFeatures(std::ostream &out, const VkPhysicalDeviceGlobalPriorityQueryFeatures* structInfo, Decoded_VkPhysicalDeviceGlobalPriorityQueryFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->globalPriorityQuery << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceGlobalPriorityQueryFeatures");
    out << "\t\t" << "VkPhysicalDeviceGlobalPriorityQueryFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceHostImageCopyFeatures(std::ostream &out, const VkPhysicalDeviceHostImageCopyFeatures* structInfo, Decoded_VkPhysicalDeviceHostImageCopyFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hostImageCopy << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceHostImageCopyFeatures");
    out << "\t\t" << "VkPhysicalDeviceHostImageCopyFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceHostImageCopyProperties(std::ostream &out, const VkPhysicalDeviceHostImageCopyProperties* structInfo, Decoded_VkPhysicalDeviceHostImageCopyProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcopy_src_layouts_array = "NULL";
    if (structInfo->pCopySrcLayouts != NULL) {
        std::string pcopy_src_layouts_values;
        for (uint32_t idx = 0; idx < structInfo->copySrcLayoutCount; idx++) {
            pcopy_src_layouts_values += util::ToString<VkImageLayout>(structInfo->pCopySrcLayouts[idx]) + ", ";
        }
        pcopy_src_layouts_array = "pCopySrcLayouts_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkImageLayout " << pcopy_src_layouts_array << "[] = {" << pcopy_src_layouts_values << "};" << std::endl;
    }
    std::string pcopy_dst_layouts_array = "NULL";
    if (structInfo->pCopyDstLayouts != NULL) {
        std::string pcopy_dst_layouts_values;
        for (uint32_t idx = 0; idx < structInfo->copyDstLayoutCount; idx++) {
            pcopy_dst_layouts_values += util::ToString<VkImageLayout>(structInfo->pCopyDstLayouts[idx]) + ", ";
        }
        pcopy_dst_layouts_array = "pCopyDstLayouts_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkImageLayout " << pcopy_dst_layouts_array << "[] = {" << pcopy_dst_layouts_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->copySrcLayoutCount << "," << std::endl;
    struct_body << "\t\t\t" << pcopy_src_layouts_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->copyDstLayoutCount << "," << std::endl;
    struct_body << "\t\t\t" << pcopy_dst_layouts_array << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->optimalTilingLayoutUUID[0]), VK_UUID_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->identicalMemoryTypeRequirements << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceHostImageCopyProperties");
    out << "\t\t" << "VkPhysicalDeviceHostImageCopyProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceIndexTypeUint8Features(std::ostream &out, const VkPhysicalDeviceIndexTypeUint8Features* structInfo, Decoded_VkPhysicalDeviceIndexTypeUint8Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexTypeUint8 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceIndexTypeUint8Features");
    out << "\t\t" << "VkPhysicalDeviceIndexTypeUint8Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLineRasterizationFeatures(std::ostream &out, const VkPhysicalDeviceLineRasterizationFeatures* structInfo, Decoded_VkPhysicalDeviceLineRasterizationFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rectangularLines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bresenhamLines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->smoothLines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stippledRectangularLines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stippledBresenhamLines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stippledSmoothLines << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLineRasterizationFeatures");
    out << "\t\t" << "VkPhysicalDeviceLineRasterizationFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLineRasterizationProperties(std::ostream &out, const VkPhysicalDeviceLineRasterizationProperties* structInfo, Decoded_VkPhysicalDeviceLineRasterizationProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->lineSubPixelPrecisionBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLineRasterizationProperties");
    out << "\t\t" << "VkPhysicalDeviceLineRasterizationProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance5Features(std::ostream &out, const VkPhysicalDeviceMaintenance5Features* structInfo, Decoded_VkPhysicalDeviceMaintenance5Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maintenance5 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance5Features");
    out << "\t\t" << "VkPhysicalDeviceMaintenance5Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance5Properties(std::ostream &out, const VkPhysicalDeviceMaintenance5Properties* structInfo, Decoded_VkPhysicalDeviceMaintenance5Properties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->earlyFragmentMultisampleCoverageAfterSampleCounting << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->earlyFragmentSampleMaskTestBeforeSampleCounting << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthStencilSwizzleOneSupport << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->polygonModePointSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->nonStrictSinglePixelWideLinesUseParallelogram << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->nonStrictWideLinesUseParallelogram << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance5Properties");
    out << "\t\t" << "VkPhysicalDeviceMaintenance5Properties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance6Features(std::ostream &out, const VkPhysicalDeviceMaintenance6Features* structInfo, Decoded_VkPhysicalDeviceMaintenance6Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maintenance6 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance6Features");
    out << "\t\t" << "VkPhysicalDeviceMaintenance6Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance6Properties(std::ostream &out, const VkPhysicalDeviceMaintenance6Properties* structInfo, Decoded_VkPhysicalDeviceMaintenance6Properties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->blockTexelViewCompatibleMultipleLayers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxCombinedImageSamplerDescriptorCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateClampCombinerInputs << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance6Properties");
    out << "\t\t" << "VkPhysicalDeviceMaintenance6Properties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineProtectedAccessFeatures(std::ostream &out, const VkPhysicalDevicePipelineProtectedAccessFeatures* structInfo, Decoded_VkPhysicalDevicePipelineProtectedAccessFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineProtectedAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineProtectedAccessFeatures");
    out << "\t\t" << "VkPhysicalDevicePipelineProtectedAccessFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineRobustnessFeatures(std::ostream &out, const VkPhysicalDevicePipelineRobustnessFeatures* structInfo, Decoded_VkPhysicalDevicePipelineRobustnessFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineRobustness << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineRobustnessFeatures");
    out << "\t\t" << "VkPhysicalDevicePipelineRobustnessFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineRobustnessProperties(std::ostream &out, const VkPhysicalDevicePipelineRobustnessProperties* structInfo, Decoded_VkPhysicalDevicePipelineRobustnessProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehavior(" << structInfo->defaultRobustnessStorageBuffers << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehavior(" << structInfo->defaultRobustnessUniformBuffers << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehavior(" << structInfo->defaultRobustnessVertexInputs << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRobustnessImageBehavior(" << structInfo->defaultRobustnessImages << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineRobustnessProperties");
    out << "\t\t" << "VkPhysicalDevicePipelineRobustnessProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePushDescriptorProperties(std::ostream &out, const VkPhysicalDevicePushDescriptorProperties* structInfo, Decoded_VkPhysicalDevicePushDescriptorProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPushDescriptors << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePushDescriptorProperties");
    out << "\t\t" << "VkPhysicalDevicePushDescriptorProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderExpectAssumeFeatures(std::ostream &out, const VkPhysicalDeviceShaderExpectAssumeFeatures* structInfo, Decoded_VkPhysicalDeviceShaderExpectAssumeFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderExpectAssume << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderExpectAssumeFeatures");
    out << "\t\t" << "VkPhysicalDeviceShaderExpectAssumeFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderFloatControls2Features(std::ostream &out, const VkPhysicalDeviceShaderFloatControls2Features* structInfo, Decoded_VkPhysicalDeviceShaderFloatControls2Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderFloatControls2 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderFloatControls2Features");
    out << "\t\t" << "VkPhysicalDeviceShaderFloatControls2Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderSubgroupRotateFeatures(std::ostream &out, const VkPhysicalDeviceShaderSubgroupRotateFeatures* structInfo, Decoded_VkPhysicalDeviceShaderSubgroupRotateFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSubgroupRotate << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSubgroupRotateClustered << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderSubgroupRotateFeatures");
    out << "\t\t" << "VkPhysicalDeviceShaderSubgroupRotateFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVertexAttributeDivisorFeatures(std::ostream &out, const VkPhysicalDeviceVertexAttributeDivisorFeatures* structInfo, Decoded_VkPhysicalDeviceVertexAttributeDivisorFeatures* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexAttributeInstanceRateDivisor << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexAttributeInstanceRateZeroDivisor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVertexAttributeDivisorFeatures");
    out << "\t\t" << "VkPhysicalDeviceVertexAttributeDivisorFeatures " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVertexAttributeDivisorProperties(std::ostream &out, const VkPhysicalDeviceVertexAttributeDivisorProperties* structInfo, Decoded_VkPhysicalDeviceVertexAttributeDivisorProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxVertexAttribDivisor << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->supportsNonZeroFirstInstance << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVertexAttributeDivisorProperties");
    out << "\t\t" << "VkPhysicalDeviceVertexAttributeDivisorProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan14Features(std::ostream &out, const VkPhysicalDeviceVulkan14Features* structInfo, Decoded_VkPhysicalDeviceVulkan14Features* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->globalPriorityQuery << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSubgroupRotate << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSubgroupRotateClustered << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderFloatControls2 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderExpectAssume << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rectangularLines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bresenhamLines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->smoothLines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stippledRectangularLines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stippledBresenhamLines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stippledSmoothLines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexAttributeInstanceRateDivisor << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexAttributeInstanceRateZeroDivisor << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexTypeUint8 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dynamicRenderingLocalRead << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maintenance5 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maintenance6 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineProtectedAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineRobustness << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hostImageCopy << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pushDescriptor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkan14Features");
    out << "\t\t" << "VkPhysicalDeviceVulkan14Features " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan14Properties(std::ostream &out, const VkPhysicalDeviceVulkan14Properties* structInfo, Decoded_VkPhysicalDeviceVulkan14Properties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcopy_src_layouts_array = "NULL";
    if (structInfo->pCopySrcLayouts != NULL) {
        std::string pcopy_src_layouts_values;
        for (uint32_t idx = 0; idx < structInfo->copySrcLayoutCount; idx++) {
            pcopy_src_layouts_values += util::ToString<VkImageLayout>(structInfo->pCopySrcLayouts[idx]) + ", ";
        }
        pcopy_src_layouts_array = "pCopySrcLayouts_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkImageLayout " << pcopy_src_layouts_array << "[] = {" << pcopy_src_layouts_values << "};" << std::endl;
    }
    std::string pcopy_dst_layouts_array = "NULL";
    if (structInfo->pCopyDstLayouts != NULL) {
        std::string pcopy_dst_layouts_values;
        for (uint32_t idx = 0; idx < structInfo->copyDstLayoutCount; idx++) {
            pcopy_dst_layouts_values += util::ToString<VkImageLayout>(structInfo->pCopyDstLayouts[idx]) + ", ";
        }
        pcopy_dst_layouts_array = "pCopyDstLayouts_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkImageLayout " << pcopy_dst_layouts_array << "[] = {" << pcopy_dst_layouts_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->lineSubPixelPrecisionBits << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxVertexAttribDivisor << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->supportsNonZeroFirstInstance << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPushDescriptors << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dynamicRenderingLocalReadDepthStencilAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dynamicRenderingLocalReadMultisampledAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->earlyFragmentMultisampleCoverageAfterSampleCounting << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->earlyFragmentSampleMaskTestBeforeSampleCounting << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthStencilSwizzleOneSupport << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->polygonModePointSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->nonStrictSinglePixelWideLinesUseParallelogram << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->nonStrictWideLinesUseParallelogram << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->blockTexelViewCompatibleMultipleLayers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxCombinedImageSamplerDescriptorCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateClampCombinerInputs << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehavior(" << structInfo->defaultRobustnessStorageBuffers << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehavior(" << structInfo->defaultRobustnessUniformBuffers << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehavior(" << structInfo->defaultRobustnessVertexInputs << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRobustnessImageBehavior(" << structInfo->defaultRobustnessImages << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->copySrcLayoutCount << "," << std::endl;
    struct_body << "\t\t\t" << pcopy_src_layouts_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->copyDstLayoutCount << "," << std::endl;
    struct_body << "\t\t\t" << pcopy_dst_layouts_array << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->optimalTilingLayoutUUID[0]), VK_UUID_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->identicalMemoryTypeRequirements << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVulkan14Properties");
    out << "\t\t" << "VkPhysicalDeviceVulkan14Properties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCreateFlags2CreateInfo(std::ostream &out, const VkPipelineCreateFlags2CreateInfo* structInfo, Decoded_VkPipelineCreateFlags2CreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineCreateFlags2(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCreateFlags2CreateInfo");
    out << "\t\t" << "VkPipelineCreateFlags2CreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRasterizationLineStateCreateInfo(std::ostream &out, const VkPipelineRasterizationLineStateCreateInfo* structInfo, Decoded_VkPipelineRasterizationLineStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkLineRasterizationMode(" << structInfo->lineRasterizationMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stippledLineEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->lineStippleFactor << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->lineStipplePattern << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRasterizationLineStateCreateInfo");
    out << "\t\t" << "VkPipelineRasterizationLineStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRobustnessCreateInfo(std::ostream &out, const VkPipelineRobustnessCreateInfo* structInfo, Decoded_VkPipelineRobustnessCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehavior(" << structInfo->storageBuffers << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehavior(" << structInfo->uniformBuffers << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRobustnessBufferBehavior(" << structInfo->vertexInputs << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRobustnessImageBehavior(" << structInfo->images << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRobustnessCreateInfo");
    out << "\t\t" << "VkPipelineRobustnessCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineVertexInputDivisorStateCreateInfo(std::ostream &out, const VkPipelineVertexInputDivisorStateCreateInfo* structInfo, Decoded_VkPipelineVertexInputDivisorStateCreateInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pvertex_binding_divisors_array = "NULL";
    if (structInfo->pVertexBindingDivisors != NULL) {
        pvertex_binding_divisors_array = "pVertexBindingDivisors_" + std::to_string(consumer.GetNextId());
        std::string pvertex_binding_divisors_names;
        for (uint32_t idx = 0; idx < structInfo->vertexBindingDivisorCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pVertexBindingDivisors + idx != NULL) {
                variable_name = GenerateStruct_VkVertexInputBindingDivisorDescription(out,
                                                                                      structInfo->pVertexBindingDivisors + idx,
                                                                                      metaInfo->pVertexBindingDivisors->GetMetaStructPointer() + idx,
                                                                                      consumer);
            }
            pvertex_binding_divisors_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVertexInputBindingDivisorDescription " << pvertex_binding_divisors_array << "[] = {" << pvertex_binding_divisors_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexBindingDivisorCount << "," << std::endl;
    struct_body << "\t\t\t" << pvertex_binding_divisors_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineVertexInputDivisorStateCreateInfo");
    out << "\t\t" << "VkPipelineVertexInputDivisorStateCreateInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPushConstantsInfo(std::ostream &out, const VkPushConstantsInfo* structInfo, Decoded_VkPushConstantsInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pvalues_array = "NULL";
    if (structInfo->pValues != NULL) {
        std::string pvalues_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->size; ++idx0) {
            pvalues_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pValues)[idx0]) + ", ";
        }
        pvalues_array = "pValues_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pvalues_array << "[] = {" << pvalues_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->layout) << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->stageFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "," << std::endl;
    struct_body << "\t\t\t" << pvalues_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pushConstantsInfo");
    out << "\t\t" << "VkPushConstantsInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPushDescriptorSetInfo(std::ostream &out, const VkPushDescriptorSetInfo* structInfo, Decoded_VkPushDescriptorSetInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdescriptor_writes_array = "NULL";
    if (structInfo->pDescriptorWrites != NULL) {
        pdescriptor_writes_array = "pDescriptorWrites_" + std::to_string(consumer.GetNextId());
        std::string pdescriptor_writes_names;
        for (uint32_t idx = 0; idx < structInfo->descriptorWriteCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pDescriptorWrites + idx != NULL) {
                variable_name = GenerateStruct_VkWriteDescriptorSet(out,
                                                                    structInfo->pDescriptorWrites + idx,
                                                                    metaInfo->pDescriptorWrites->GetMetaStructPointer() + idx,
                                                                    consumer);
            }
            pdescriptor_writes_names += variable_name + ", ";
        }
        out << "\t\t" << "VkWriteDescriptorSet " << pdescriptor_writes_array << "[] = {" << pdescriptor_writes_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->stageFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->layout) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->set << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorWriteCount << "," << std::endl;
    struct_body << "\t\t\t" << pdescriptor_writes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pushDescriptorSetInfo");
    out << "\t\t" << "VkPushDescriptorSetInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyGlobalPriorityProperties(std::ostream &out, const VkQueueFamilyGlobalPriorityProperties* structInfo, Decoded_VkQueueFamilyGlobalPriorityProperties* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->priorityCount << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkQueueGlobalPriority*>(&structInfo->priorities[0]), VK_MAX_GLOBAL_PRIORITY_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyGlobalPriorityProperties");
    out << "\t\t" << "VkQueueFamilyGlobalPriorityProperties " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderingAreaInfo(std::ostream &out, const VkRenderingAreaInfo* structInfo, Decoded_VkRenderingAreaInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcolor_attachment_formats_values;
    std::string pcolor_attachment_formats_array = "NULL";
    if (structInfo->pColorAttachmentFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            pcolor_attachment_formats_values += util::ToString<VkFormat>(structInfo->pColorAttachmentFormats[idx]) + ", ";
        }
        pcolor_attachment_formats_array = "pColorAttachmentFormats_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkFormat " << pcolor_attachment_formats_array << "[] = {" << pcolor_attachment_formats_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pcolor_attachment_formats_array << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->depthAttachmentFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->stencilAttachmentFormat << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderingAreaInfo");
    out << "\t\t" << "VkRenderingAreaInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderingAttachmentLocationInfo(std::ostream &out, const VkRenderingAttachmentLocationInfo* structInfo, Decoded_VkRenderingAttachmentLocationInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcolor_attachment_locations_array = "NULL";
    if (structInfo->pColorAttachmentLocations != NULL) {
        pcolor_attachment_locations_array = "pColorAttachmentLocations_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pcolor_attachment_locations_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pColorAttachmentLocations, structInfo->colorAttachmentCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pcolor_attachment_locations_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderingAttachmentLocationInfo");
    out << "\t\t" << "VkRenderingAttachmentLocationInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderingInputAttachmentIndexInfo(std::ostream &out, const VkRenderingInputAttachmentIndexInfo* structInfo, Decoded_VkRenderingInputAttachmentIndexInfo* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcolor_attachment_input_indices_array = "NULL";
    if (structInfo->pColorAttachmentInputIndices != NULL) {
        pcolor_attachment_input_indices_array = "pColorAttachmentInputIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pcolor_attachment_input_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pColorAttachmentInputIndices, structInfo->colorAttachmentCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pcolor_attachment_input_indices_array << "," << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "renderingInputAttachmentIndexInfo");
    out << "\t\t" << "VkRenderingInputAttachmentIndexInfo " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubresourceHostMemcpySize(std::ostream &out, const VkSubresourceHostMemcpySize* structInfo, Decoded_VkSubresourceHostMemcpySize* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subresourceHostMemcpySize");
    out << "\t\t" << "VkSubresourceHostMemcpySize " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubresourceLayout2(std::ostream &out, const VkSubresourceLayout2* structInfo, Decoded_VkSubresourceLayout2* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string subresource_layout_info_var = GenerateStruct_VkSubresourceLayout(out,
                                                                                 &structInfo->subresourceLayout,
                                                                                 metaInfo->subresourceLayout,
                                                                                 consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << subresource_layout_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subresourceLayout2");
    out << "\t\t" << "VkSubresourceLayout2 " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVertexInputBindingDivisorDescription(std::ostream &out, const VkVertexInputBindingDivisorDescription* structInfo, Decoded_VkVertexInputBindingDivisorDescription* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->binding << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->divisor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "vertexInputBindingDivisorDescription");
    out << "\t\t" << "VkVertexInputBindingDivisorDescription " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceCapabilitiesKHR(std::ostream &out, const VkSurfaceCapabilitiesKHR* structInfo, Decoded_VkSurfaceCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string current_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->currentExtent,
                                                                    metaInfo->currentExtent,
                                                                    consumer);
    std::string min_image_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->minImageExtent,
                                                                      metaInfo->minImageExtent,
                                                                      consumer);
    std::string max_image_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->maxImageExtent,
                                                                      metaInfo->maxImageExtent,
                                                                      consumer);
    struct_body << "\t" << structInfo->minImageCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxImageCount << "," << std::endl;
    struct_body << "\t\t\t" << current_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << min_image_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_image_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxImageArrayLayers << "," << std::endl;
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagsKHR(" << structInfo->supportedTransforms << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->currentTransform << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkCompositeAlphaFlagsKHR(" << structInfo->supportedCompositeAlpha << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->supportedUsageFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceCapabilitiesKHR");
    out << "\t\t" << "VkSurfaceCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceFormatKHR(std::ostream &out, const VkSurfaceFormatKHR* structInfo, Decoded_VkSurfaceFormatKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkColorSpaceKHR(" << structInfo->colorSpace << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceFormatKHR");
    out << "\t\t" << "VkSurfaceFormatKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAcquireNextImageInfoKHR(std::ostream &out, const VkAcquireNextImageInfoKHR* structInfo, Decoded_VkAcquireNextImageInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->swapchain) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timeout << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->fence) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceMask << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "acquireNextImageInfoKHR");
    out << "\t\t" << "VkAcquireNextImageInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindImageMemorySwapchainInfoKHR(std::ostream &out, const VkBindImageMemorySwapchainInfoKHR* structInfo, Decoded_VkBindImageMemorySwapchainInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->swapchain) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindImageMemorySwapchainInfoKHR");
    out << "\t\t" << "VkBindImageMemorySwapchainInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupPresentCapabilitiesKHR(std::ostream &out, const VkDeviceGroupPresentCapabilitiesKHR* structInfo, Decoded_VkDeviceGroupPresentCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->presentMask[0]), VK_MAX_DEVICE_GROUP_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << "VkDeviceGroupPresentModeFlagsKHR(" << structInfo->modes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupPresentCapabilitiesKHR");
    out << "\t\t" << "VkDeviceGroupPresentCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupPresentInfoKHR(std::ostream &out, const VkDeviceGroupPresentInfoKHR* structInfo, Decoded_VkDeviceGroupPresentInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdevice_masks_array = "NULL";
    if (structInfo->pDeviceMasks != NULL) {
        pdevice_masks_array = "pDeviceMasks_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pdevice_masks_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceMasks, structInfo->swapchainCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->swapchainCount << "," << std::endl;
    struct_body << "\t\t\t" << pdevice_masks_array << "," << std::endl;
    struct_body << "\t\t\t" << "VkDeviceGroupPresentModeFlagBitsKHR(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupPresentInfoKHR");
    out << "\t\t" << "VkDeviceGroupPresentInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceGroupSwapchainCreateInfoKHR(std::ostream &out, const VkDeviceGroupSwapchainCreateInfoKHR* structInfo, Decoded_VkDeviceGroupSwapchainCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDeviceGroupPresentModeFlagsKHR(" << structInfo->modes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceGroupSwapchainCreateInfoKHR");
    out << "\t\t" << "VkDeviceGroupSwapchainCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageSwapchainCreateInfoKHR(std::ostream &out, const VkImageSwapchainCreateInfoKHR* structInfo, Decoded_VkImageSwapchainCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->swapchain) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageSwapchainCreateInfoKHR");
    out << "\t\t" << "VkImageSwapchainCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayModeCreateInfoKHR(std::ostream &out, const VkDisplayModeCreateInfoKHR* structInfo, Decoded_VkDisplayModeCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string parameters_info_var = GenerateStruct_VkDisplayModeParametersKHR(out,
                                                                                &structInfo->parameters,
                                                                                metaInfo->parameters,
                                                                                consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDisplayModeCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << parameters_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayModeCreateInfoKHR");
    out << "\t\t" << "VkDisplayModeCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayModeParametersKHR(std::ostream &out, const VkDisplayModeParametersKHR* structInfo, Decoded_VkDisplayModeParametersKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string visible_region_info_var = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->visibleRegion,
                                                                    metaInfo->visibleRegion,
                                                                    consumer);
    struct_body << "\t" << visible_region_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->refreshRate << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayModeParametersKHR");
    out << "\t\t" << "VkDisplayModeParametersKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayModePropertiesKHR(std::ostream &out, const VkDisplayModePropertiesKHR* structInfo, Decoded_VkDisplayModePropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string parameters_info_var = GenerateStruct_VkDisplayModeParametersKHR(out,
                                                                                &structInfo->parameters,
                                                                                metaInfo->parameters,
                                                                                consumer);
    struct_body << "\t" << consumer.GetHandle(metaInfo->displayMode) << "," << std::endl;
    struct_body << "\t\t\t" << parameters_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayModePropertiesKHR");
    out << "\t\t" << "VkDisplayModePropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPlaneCapabilitiesKHR(std::ostream &out, const VkDisplayPlaneCapabilitiesKHR* structInfo, Decoded_VkDisplayPlaneCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string min_src_position_info_var = GenerateStruct_VkOffset2D(out,
                                                                      &structInfo->minSrcPosition,
                                                                      metaInfo->minSrcPosition,
                                                                      consumer);
    std::string max_src_position_info_var = GenerateStruct_VkOffset2D(out,
                                                                      &structInfo->maxSrcPosition,
                                                                      metaInfo->maxSrcPosition,
                                                                      consumer);
    std::string min_src_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->minSrcExtent,
                                                                    metaInfo->minSrcExtent,
                                                                    consumer);
    std::string max_src_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->maxSrcExtent,
                                                                    metaInfo->maxSrcExtent,
                                                                    consumer);
    std::string min_dst_position_info_var = GenerateStruct_VkOffset2D(out,
                                                                      &structInfo->minDstPosition,
                                                                      metaInfo->minDstPosition,
                                                                      consumer);
    std::string max_dst_position_info_var = GenerateStruct_VkOffset2D(out,
                                                                      &structInfo->maxDstPosition,
                                                                      metaInfo->maxDstPosition,
                                                                      consumer);
    std::string min_dst_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->minDstExtent,
                                                                    metaInfo->minDstExtent,
                                                                    consumer);
    std::string max_dst_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->maxDstExtent,
                                                                    metaInfo->maxDstExtent,
                                                                    consumer);
    struct_body << "\t" << "VkDisplayPlaneAlphaFlagsKHR(" << structInfo->supportedAlpha << ")" << "," << std::endl;
    struct_body << "\t\t\t" << min_src_position_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_src_position_info_var << "," << std::endl;
    struct_body << "\t\t\t" << min_src_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_src_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << min_dst_position_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_dst_position_info_var << "," << std::endl;
    struct_body << "\t\t\t" << min_dst_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_dst_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPlaneCapabilitiesKHR");
    out << "\t\t" << "VkDisplayPlaneCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPlanePropertiesKHR(std::ostream &out, const VkDisplayPlanePropertiesKHR* structInfo, Decoded_VkDisplayPlanePropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << consumer.GetHandle(metaInfo->currentDisplay) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->currentStackIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPlanePropertiesKHR");
    out << "\t\t" << "VkDisplayPlanePropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPropertiesKHR(std::ostream &out, const VkDisplayPropertiesKHR* structInfo, Decoded_VkDisplayPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string physical_dimensions_info_var = GenerateStruct_VkExtent2D(out,
                                                                         &structInfo->physicalDimensions,
                                                                         metaInfo->physicalDimensions,
                                                                         consumer);
    std::string physical_resolution_info_var = GenerateStruct_VkExtent2D(out,
                                                                         &structInfo->physicalResolution,
                                                                         metaInfo->physicalResolution,
                                                                         consumer);
    struct_body << "\t" << consumer.GetHandle(metaInfo->display) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->displayName) << "," << std::endl;
    struct_body << "\t\t\t" << physical_dimensions_info_var << "," << std::endl;
    struct_body << "\t\t\t" << physical_resolution_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagsKHR(" << structInfo->supportedTransforms << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->planeReorderPossible << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->persistentContent << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPropertiesKHR");
    out << "\t\t" << "VkDisplayPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplaySurfaceCreateInfoKHR(std::ostream &out, const VkDisplaySurfaceCreateInfoKHR* structInfo, Decoded_VkDisplaySurfaceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string image_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                  &structInfo->imageExtent,
                                                                  metaInfo->imageExtent,
                                                                  consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDisplaySurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->displayMode) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->planeIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->planeStackIndex << "," << std::endl;
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->transform << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->globalAlpha << "," << std::endl;
    struct_body << "\t\t\t" << "VkDisplayPlaneAlphaFlagBitsKHR(" << structInfo->alphaMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << image_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displaySurfaceCreateInfoKHR");
    out << "\t\t" << "VkDisplaySurfaceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPresentInfoKHR(std::ostream &out, const VkDisplayPresentInfoKHR* structInfo, Decoded_VkDisplayPresentInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string src_rect_info_var = GenerateStruct_VkRect2D(out,
                                                            &structInfo->srcRect,
                                                            metaInfo->srcRect,
                                                            consumer);
    std::string dst_rect_info_var = GenerateStruct_VkRect2D(out,
                                                            &structInfo->dstRect,
                                                            metaInfo->dstRect,
                                                            consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << src_rect_info_var << "," << std::endl;
    struct_body << "\t\t\t" << dst_rect_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->persistent << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPresentInfoKHR");
    out << "\t\t" << "VkDisplayPresentInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkXlibSurfaceCreateInfoKHR(std::ostream &out, const VkXlibSurfaceCreateInfoKHR* structInfo, Decoded_VkXlibSurfaceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkXlibSurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<Display*>(" << structInfo->dpy << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->window << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "xlibSurfaceCreateInfoKHR");
    out << "\t\t" << "VkXlibSurfaceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    out << "\t\t" << "OverrideVkXlibSurfaceCreateInfoKHR(&" << variable_name << ", " << "appdata" << ");" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkXcbSurfaceCreateInfoKHR(std::ostream &out, const VkXcbSurfaceCreateInfoKHR* structInfo, Decoded_VkXcbSurfaceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkXcbSurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<xcb_connection_t*>(" << structInfo->connection << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->window << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "xcbSurfaceCreateInfoKHR");
    out << "\t\t" << "VkXcbSurfaceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    out << "\t\t" << "OverrideVkXcbSurfaceCreateInfoKHR(&" << variable_name << ", " << "appdata" << ");" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWaylandSurfaceCreateInfoKHR(std::ostream &out, const VkWaylandSurfaceCreateInfoKHR* structInfo, Decoded_VkWaylandSurfaceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkWaylandSurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<struct wl_display*>(" << structInfo->display << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<struct wl_surface*>(" << structInfo->surface << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "waylandSurfaceCreateInfoKHR");
    out << "\t\t" << "VkWaylandSurfaceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    out << "\t\t" << "OverrideVkWaylandSurfaceCreateInfoKHR(&" << variable_name << ", " << "appdata" << ");" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAndroidSurfaceCreateInfoKHR(std::ostream &out, const VkAndroidSurfaceCreateInfoKHR* structInfo, Decoded_VkAndroidSurfaceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAndroidSurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<struct ANativeWindow*>(" << structInfo->window << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "androidSurfaceCreateInfoKHR");
    out << "\t\t" << "VkAndroidSurfaceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    out << "\t\t" << "OverrideVkAndroidSurfaceCreateInfoKHR(&" << variable_name << ", " << "appdata" << ");" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWin32SurfaceCreateInfoKHR(std::ostream &out, const VkWin32SurfaceCreateInfoKHR* structInfo, Decoded_VkWin32SurfaceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkWin32SurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<HINSTANCE>(" << structInfo->hinstance << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<HWND>(" << structInfo->hwnd << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "win32SurfaceCreateInfoKHR");
    out << "\t\t" << "VkWin32SurfaceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    out << "\t\t" << "OverrideVkWin32SurfaceCreateInfoKHR(&" << variable_name << ", " << "appdata" << ");" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindVideoSessionMemoryInfoKHR(std::ostream &out, const VkBindVideoSessionMemoryInfoKHR* structInfo, Decoded_VkBindVideoSessionMemoryInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryBindIndex << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memorySize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindVideoSessionMemoryInfoKHR");
    out << "\t\t" << "VkBindVideoSessionMemoryInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVideoFormatInfoKHR(std::ostream &out, const VkPhysicalDeviceVideoFormatInfoKHR* structInfo, Decoded_VkPhysicalDeviceVideoFormatInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->imageUsage << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVideoFormatInfoKHR");
    out << "\t\t" << "VkPhysicalDeviceVideoFormatInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyQueryResultStatusPropertiesKHR(std::ostream &out, const VkQueueFamilyQueryResultStatusPropertiesKHR* structInfo, Decoded_VkQueueFamilyQueryResultStatusPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queryResultStatusSupport << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyQueryResultStatusPropertiesKHR");
    out << "\t\t" << "VkQueueFamilyQueryResultStatusPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyVideoPropertiesKHR(std::ostream &out, const VkQueueFamilyVideoPropertiesKHR* structInfo, Decoded_VkQueueFamilyVideoPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoCodecOperationFlagsKHR(" << structInfo->videoCodecOperations << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyVideoPropertiesKHR");
    out << "\t\t" << "VkQueueFamilyVideoPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoBeginCodingInfoKHR(std::ostream &out, const VkVideoBeginCodingInfoKHR* structInfo, Decoded_VkVideoBeginCodingInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string preference_slots_array = "NULL";
    if (structInfo->pReferenceSlots != NULL) {
        preference_slots_array = "pReferenceSlots_" + std::to_string(consumer.GetNextId());
        std::string preference_slots_names;
        for (uint32_t idx = 0; idx < structInfo->referenceSlotCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pReferenceSlots + idx != NULL) {
                variable_name = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                                           structInfo->pReferenceSlots + idx,
                                                                           metaInfo->pReferenceSlots->GetMetaStructPointer() + idx,
                                                                           consumer);
            }
            preference_slots_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVideoReferenceSlotInfoKHR " << preference_slots_array << "[] = {" << preference_slots_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoBeginCodingFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->videoSession) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->videoSessionParameters) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->referenceSlotCount << "," << std::endl;
    struct_body << "\t\t\t" << preference_slots_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoBeginCodingInfoKHR");
    out << "\t\t" << "VkVideoBeginCodingInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoCapabilitiesKHR(std::ostream &out, const VkVideoCapabilitiesKHR* structInfo, Decoded_VkVideoCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string picture_access_granularity_info_var = GenerateStruct_VkExtent2D(out,
                                                                                &structInfo->pictureAccessGranularity,
                                                                                metaInfo->pictureAccessGranularity,
                                                                                consumer);
    std::string min_coded_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->minCodedExtent,
                                                                      metaInfo->minCodedExtent,
                                                                      consumer);
    std::string max_coded_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->maxCodedExtent,
                                                                      metaInfo->maxCodedExtent,
                                                                      consumer);
    std::string std_header_version_info_var = GenerateStruct_VkExtensionProperties(out,
                                                                                   &structInfo->stdHeaderVersion,
                                                                                   metaInfo->stdHeaderVersion,
                                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoCapabilityFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minBitstreamBufferOffsetAlignment << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minBitstreamBufferSizeAlignment << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << picture_access_granularity_info_var << "," << std::endl;
    struct_body << "\t\t\t" << min_coded_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_coded_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDpbSlots << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxActiveReferencePictures << "," << std::endl;
    struct_body << "\t\t\t" << std_header_version_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoCapabilitiesKHR");
    out << "\t\t" << "VkVideoCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoCodingControlInfoKHR(std::ostream &out, const VkVideoCodingControlInfoKHR* structInfo, Decoded_VkVideoCodingControlInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoCodingControlFlagsKHR(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoCodingControlInfoKHR");
    out << "\t\t" << "VkVideoCodingControlInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEndCodingInfoKHR(std::ostream &out, const VkVideoEndCodingInfoKHR* structInfo, Decoded_VkVideoEndCodingInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEndCodingFlagsKHR(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEndCodingInfoKHR");
    out << "\t\t" << "VkVideoEndCodingInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoFormatPropertiesKHR(std::ostream &out, const VkVideoFormatPropertiesKHR* structInfo, Decoded_VkVideoFormatPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string component_mapping_info_var = GenerateStruct_VkComponentMapping(out,
                                                                               &structInfo->componentMapping,
                                                                               metaInfo->componentMapping,
                                                                               consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << component_mapping_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageCreateFlags(" << structInfo->imageCreateFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageType(" << structInfo->imageType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageTiling(" << structInfo->imageTiling << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->imageUsageFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoFormatPropertiesKHR");
    out << "\t\t" << "VkVideoFormatPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoPictureResourceInfoKHR(std::ostream &out, const VkVideoPictureResourceInfoKHR* structInfo, Decoded_VkVideoPictureResourceInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string coded_offset_info_var = GenerateStruct_VkOffset2D(out,
                                                                  &structInfo->codedOffset,
                                                                  metaInfo->codedOffset,
                                                                  consumer);
    std::string coded_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                  &structInfo->codedExtent,
                                                                  metaInfo->codedExtent,
                                                                  consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << coded_offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << coded_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->baseArrayLayer << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->imageViewBinding) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoPictureResourceInfoKHR");
    out << "\t\t" << "VkVideoPictureResourceInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoProfileInfoKHR(std::ostream &out, const VkVideoProfileInfoKHR* structInfo, Decoded_VkVideoProfileInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoCodecOperationFlagBitsKHR(" << structInfo->videoCodecOperation << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoChromaSubsamplingFlagsKHR(" << structInfo->chromaSubsampling << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoComponentBitDepthFlagsKHR(" << structInfo->lumaBitDepth << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoComponentBitDepthFlagsKHR(" << structInfo->chromaBitDepth << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoProfileInfoKHR");
    out << "\t\t" << "VkVideoProfileInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoProfileListInfoKHR(std::ostream &out, const VkVideoProfileListInfoKHR* structInfo, Decoded_VkVideoProfileListInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pprofiles_array = "NULL";
    if (structInfo->pProfiles != NULL) {
        pprofiles_array = "pProfiles_" + std::to_string(consumer.GetNextId());
        std::string pprofiles_names;
        for (uint32_t idx = 0; idx < structInfo->profileCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pProfiles + idx != NULL) {
                variable_name = GenerateStruct_VkVideoProfileInfoKHR(out,
                                                                     structInfo->pProfiles + idx,
                                                                     metaInfo->pProfiles->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            pprofiles_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVideoProfileInfoKHR " << pprofiles_array << "[] = {" << pprofiles_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->profileCount << "," << std::endl;
    struct_body << "\t\t\t" << pprofiles_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoProfileListInfoKHR");
    out << "\t\t" << "VkVideoProfileListInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoReferenceSlotInfoKHR(std::ostream &out, const VkVideoReferenceSlotInfoKHR* structInfo, Decoded_VkVideoReferenceSlotInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppicture_resource_struct = "NULL";
    if (structInfo->pPictureResource != NULL) {
        ppicture_resource_struct = GenerateStruct_VkVideoPictureResourceInfoKHR(out,
                                                                                structInfo->pPictureResource,
                                                                                metaInfo->pPictureResource->GetMetaStructPointer(),
                                                                                consumer);
        ppicture_resource_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->slotIndex << "," << std::endl;
    struct_body << "\t\t\t" << ppicture_resource_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoReferenceSlotInfoKHR");
    out << "\t\t" << "VkVideoReferenceSlotInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoSessionCreateInfoKHR(std::ostream &out, const VkVideoSessionCreateInfoKHR* structInfo, Decoded_VkVideoSessionCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pvideo_profile_struct = "NULL";
    if (structInfo->pVideoProfile != NULL) {
        pvideo_profile_struct = GenerateStruct_VkVideoProfileInfoKHR(out,
                                                                     structInfo->pVideoProfile,
                                                                     metaInfo->pVideoProfile->GetMetaStructPointer(),
                                                                     consumer);
        pvideo_profile_struct.insert(0, "&");
    }
    std::string max_coded_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->maxCodedExtent,
                                                                      metaInfo->maxCodedExtent,
                                                                      consumer);
    std::string pstd_header_version_struct = "NULL";
    if (structInfo->pStdHeaderVersion != NULL) {
        pstd_header_version_struct = GenerateStruct_VkExtensionProperties(out,
                                                                          structInfo->pStdHeaderVersion,
                                                                          metaInfo->pStdHeaderVersion->GetMetaStructPointer(),
                                                                          consumer);
        pstd_header_version_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueFamilyIndex << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoSessionCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pvideo_profile_struct << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->pictureFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << max_coded_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->referencePictureFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDpbSlots << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxActiveReferencePictures << "," << std::endl;
    struct_body << "\t\t\t" << pstd_header_version_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoSessionCreateInfoKHR");
    out << "\t\t" << "VkVideoSessionCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoSessionMemoryRequirementsKHR(std::ostream &out, const VkVideoSessionMemoryRequirementsKHR* structInfo, Decoded_VkVideoSessionMemoryRequirementsKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string memory_requirements_info_var = GenerateStruct_VkMemoryRequirements(out,
                                                                                   &structInfo->memoryRequirements,
                                                                                   metaInfo->memoryRequirements,
                                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryBindIndex << "," << std::endl;
    struct_body << "\t\t\t" << memory_requirements_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoSessionMemoryRequirementsKHR");
    out << "\t\t" << "VkVideoSessionMemoryRequirementsKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoSessionParametersCreateInfoKHR(std::ostream &out, const VkVideoSessionParametersCreateInfoKHR* structInfo, Decoded_VkVideoSessionParametersCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoSessionParametersCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->videoSessionParametersTemplate) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->videoSession) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoSessionParametersCreateInfoKHR");
    out << "\t\t" << "VkVideoSessionParametersCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoSessionParametersUpdateInfoKHR(std::ostream &out, const VkVideoSessionParametersUpdateInfoKHR* structInfo, Decoded_VkVideoSessionParametersUpdateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->updateSequenceCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoSessionParametersUpdateInfoKHR");
    out << "\t\t" << "VkVideoSessionParametersUpdateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeCapabilitiesKHR(std::ostream &out, const VkVideoDecodeCapabilitiesKHR* structInfo, Decoded_VkVideoDecodeCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoDecodeCapabilityFlagsKHR(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeCapabilitiesKHR");
    out << "\t\t" << "VkVideoDecodeCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeInfoKHR(std::ostream &out, const VkVideoDecodeInfoKHR* structInfo, Decoded_VkVideoDecodeInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string dst_picture_resource_info_var = GenerateStruct_VkVideoPictureResourceInfoKHR(out,
                                                                                             &structInfo->dstPictureResource,
                                                                                             metaInfo->dstPictureResource,
                                                                                             consumer);
    std::string psetup_reference_slot_struct = "NULL";
    if (structInfo->pSetupReferenceSlot != NULL) {
        psetup_reference_slot_struct = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                                                  structInfo->pSetupReferenceSlot,
                                                                                  metaInfo->pSetupReferenceSlot->GetMetaStructPointer(),
                                                                                  consumer);
        psetup_reference_slot_struct.insert(0, "&");
    }
    std::string preference_slots_array = "NULL";
    if (structInfo->pReferenceSlots != NULL) {
        preference_slots_array = "pReferenceSlots_" + std::to_string(consumer.GetNextId());
        std::string preference_slots_names;
        for (uint32_t idx = 0; idx < structInfo->referenceSlotCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pReferenceSlots + idx != NULL) {
                variable_name = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                                           structInfo->pReferenceSlots + idx,
                                                                           metaInfo->pReferenceSlots->GetMetaStructPointer() + idx,
                                                                           consumer);
            }
            preference_slots_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVideoReferenceSlotInfoKHR " << preference_slots_array << "[] = {" << preference_slots_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoDecodeFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcBuffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcBufferOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcBufferRange << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << dst_picture_resource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << psetup_reference_slot_struct << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->referenceSlotCount << "," << std::endl;
    struct_body << "\t\t\t" << preference_slots_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeInfoKHR");
    out << "\t\t" << "VkVideoDecodeInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeUsageInfoKHR(std::ostream &out, const VkVideoDecodeUsageInfoKHR* structInfo, Decoded_VkVideoDecodeUsageInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoDecodeUsageFlagsKHR(" << structInfo->videoUsageHints << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeUsageInfoKHR");
    out << "\t\t" << "VkVideoDecodeUsageInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264CapabilitiesKHR(std::ostream &out, const VkVideoEncodeH264CapabilitiesKHR* structInfo, Decoded_VkVideoEncodeH264CapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeH264CapabilityFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264LevelIdc(" << structInfo->maxLevelIdc << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSliceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPPictureL0ReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxBPictureL0ReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxL1ReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTemporalLayerCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->expectDyadicTemporalLayerPattern << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minQp << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxQp << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->prefersGopRemainingFrames << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->requiresGopRemainingFrames << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeH264StdFlagsKHR(" << structInfo->stdSyntaxFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264CapabilitiesKHR");
    out << "\t\t" << "VkVideoEncodeH264CapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264DpbSlotInfoKHR(std::ostream &out, const VkVideoEncodeH264DpbSlotInfoKHR* structInfo, Decoded_VkVideoEncodeH264DpbSlotInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_reference_info_struct = "NULL";
    if (structInfo->pStdReferenceInfo != NULL) {
        pstd_reference_info_struct = GenerateStruct_StdVideoEncodeH264ReferenceInfo(out,
                                                                                    structInfo->pStdReferenceInfo,
                                                                                    metaInfo->pStdReferenceInfo->GetMetaStructPointer(),
                                                                                    consumer);
        pstd_reference_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pstd_reference_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264DpbSlotInfoKHR");
    out << "\t\t" << "VkVideoEncodeH264DpbSlotInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264FrameSizeKHR(std::ostream &out, const VkVideoEncodeH264FrameSizeKHR* structInfo, Decoded_VkVideoEncodeH264FrameSizeKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->frameISize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->framePSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frameBSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264FrameSizeKHR");
    out << "\t\t" << "VkVideoEncodeH264FrameSizeKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264GopRemainingFrameInfoKHR(std::ostream &out, const VkVideoEncodeH264GopRemainingFrameInfoKHR* structInfo, Decoded_VkVideoEncodeH264GopRemainingFrameInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->useGopRemainingFrames << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->gopRemainingI << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->gopRemainingP << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->gopRemainingB << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264GopRemainingFrameInfoKHR");
    out << "\t\t" << "VkVideoEncodeH264GopRemainingFrameInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264NaluSliceInfoKHR(std::ostream &out, const VkVideoEncodeH264NaluSliceInfoKHR* structInfo, Decoded_VkVideoEncodeH264NaluSliceInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_slice_header_struct = "NULL";
    if (structInfo->pStdSliceHeader != NULL) {
        pstd_slice_header_struct = GenerateStruct_StdVideoEncodeH264SliceHeader(out,
                                                                                structInfo->pStdSliceHeader,
                                                                                metaInfo->pStdSliceHeader->GetMetaStructPointer(),
                                                                                consumer);
        pstd_slice_header_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->constantQp << "," << std::endl;
    struct_body << "\t\t\t" << pstd_slice_header_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264NaluSliceInfoKHR");
    out << "\t\t" << "VkVideoEncodeH264NaluSliceInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264PictureInfoKHR(std::ostream &out, const VkVideoEncodeH264PictureInfoKHR* structInfo, Decoded_VkVideoEncodeH264PictureInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pnalu_slice_entries_array = "NULL";
    if (structInfo->pNaluSliceEntries != NULL) {
        pnalu_slice_entries_array = "pNaluSliceEntries_" + std::to_string(consumer.GetNextId());
        std::string pnalu_slice_entries_names;
        for (uint32_t idx = 0; idx < structInfo->naluSliceEntryCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pNaluSliceEntries + idx != NULL) {
                variable_name = GenerateStruct_VkVideoEncodeH264NaluSliceInfoKHR(out,
                                                                                 structInfo->pNaluSliceEntries + idx,
                                                                                 metaInfo->pNaluSliceEntries->GetMetaStructPointer() + idx,
                                                                                 consumer);
            }
            pnalu_slice_entries_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVideoEncodeH264NaluSliceInfoKHR " << pnalu_slice_entries_array << "[] = {" << pnalu_slice_entries_names << "};" << std::endl;
    }
    std::string pstd_picture_info_struct = "NULL";
    if (structInfo->pStdPictureInfo != NULL) {
        pstd_picture_info_struct = GenerateStruct_StdVideoEncodeH264PictureInfo(out,
                                                                                structInfo->pStdPictureInfo,
                                                                                metaInfo->pStdPictureInfo->GetMetaStructPointer(),
                                                                                consumer);
        pstd_picture_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->naluSliceEntryCount << "," << std::endl;
    struct_body << "\t\t\t" << pnalu_slice_entries_array << "," << std::endl;
    struct_body << "\t\t\t" << pstd_picture_info_struct << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->generatePrefixNalu << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264PictureInfoKHR");
    out << "\t\t" << "VkVideoEncodeH264PictureInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264ProfileInfoKHR(std::ostream &out, const VkVideoEncodeH264ProfileInfoKHR* structInfo, Decoded_VkVideoEncodeH264ProfileInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264ProfileIdc(" << structInfo->stdProfileIdc << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264ProfileInfoKHR");
    out << "\t\t" << "VkVideoEncodeH264ProfileInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264QpKHR(std::ostream &out, const VkVideoEncodeH264QpKHR* structInfo, Decoded_VkVideoEncodeH264QpKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->qpI << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->qpP << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->qpB << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264QpKHR");
    out << "\t\t" << "VkVideoEncodeH264QpKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264QualityLevelPropertiesKHR(std::ostream &out, const VkVideoEncodeH264QualityLevelPropertiesKHR* structInfo, Decoded_VkVideoEncodeH264QualityLevelPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string preferred_constant_qp_info_var = GenerateStruct_VkVideoEncodeH264QpKHR(out,
                                                                                       &structInfo->preferredConstantQp,
                                                                                       metaInfo->preferredConstantQp,
                                                                                       consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeH264RateControlFlagsKHR(" << structInfo->preferredRateControlFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredGopFrameCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredIdrPeriod << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredConsecutiveBFrameCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredTemporalLayerCount << "," << std::endl;
    struct_body << "\t\t\t" << preferred_constant_qp_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredMaxL0ReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredMaxL1ReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredStdEntropyCodingModeFlag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264QualityLevelPropertiesKHR");
    out << "\t\t" << "VkVideoEncodeH264QualityLevelPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264RateControlInfoKHR(std::ostream &out, const VkVideoEncodeH264RateControlInfoKHR* structInfo, Decoded_VkVideoEncodeH264RateControlInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeH264RateControlFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->gopFrameCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->idrPeriod << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->consecutiveBFrameCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->temporalLayerCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264RateControlInfoKHR");
    out << "\t\t" << "VkVideoEncodeH264RateControlInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264RateControlLayerInfoKHR(std::ostream &out, const VkVideoEncodeH264RateControlLayerInfoKHR* structInfo, Decoded_VkVideoEncodeH264RateControlLayerInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string min_qp_info_var = GenerateStruct_VkVideoEncodeH264QpKHR(out,
                                                                        &structInfo->minQp,
                                                                        metaInfo->minQp,
                                                                        consumer);
    std::string max_qp_info_var = GenerateStruct_VkVideoEncodeH264QpKHR(out,
                                                                        &structInfo->maxQp,
                                                                        metaInfo->maxQp,
                                                                        consumer);
    std::string max_frame_size_info_var = GenerateStruct_VkVideoEncodeH264FrameSizeKHR(out,
                                                                                       &structInfo->maxFrameSize,
                                                                                       metaInfo->maxFrameSize,
                                                                                       consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->useMinQp << "," << std::endl;
    struct_body << "\t\t\t" << min_qp_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->useMaxQp << "," << std::endl;
    struct_body << "\t\t\t" << max_qp_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->useMaxFrameSize << "," << std::endl;
    struct_body << "\t\t\t" << max_frame_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264RateControlLayerInfoKHR");
    out << "\t\t" << "VkVideoEncodeH264RateControlLayerInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264SessionCreateInfoKHR(std::ostream &out, const VkVideoEncodeH264SessionCreateInfoKHR* structInfo, Decoded_VkVideoEncodeH264SessionCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->useMaxLevelIdc << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264LevelIdc(" << structInfo->maxLevelIdc << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264SessionCreateInfoKHR");
    out << "\t\t" << "VkVideoEncodeH264SessionCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264SessionParametersAddInfoKHR(std::ostream &out, const VkVideoEncodeH264SessionParametersAddInfoKHR* structInfo, Decoded_VkVideoEncodeH264SessionParametersAddInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_s_pss_array = "NULL";
    if (structInfo->pStdSPSs != NULL) {
        pstd_s_pss_array = "pStdSPSs_" + std::to_string(consumer.GetNextId());
        std::string pstd_s_pss_names;
        for (uint32_t idx = 0; idx < structInfo->stdSPSCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdSPSs + idx != NULL) {
                variable_name = GenerateStruct_StdVideoH264SequenceParameterSet(out,
                                                                                structInfo->pStdSPSs + idx,
                                                                                metaInfo->pStdSPSs->GetMetaStructPointer() + idx,
                                                                                consumer);
            }
            pstd_s_pss_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoH264SequenceParameterSet " << pstd_s_pss_array << "[] = {" << pstd_s_pss_names << "};" << std::endl;
    }
    std::string pstd_pp_ss_array = "NULL";
    if (structInfo->pStdPPSs != NULL) {
        pstd_pp_ss_array = "pStdPPSs_" + std::to_string(consumer.GetNextId());
        std::string pstd_pp_ss_names;
        for (uint32_t idx = 0; idx < structInfo->stdPPSCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdPPSs + idx != NULL) {
                variable_name = GenerateStruct_StdVideoH264PictureParameterSet(out,
                                                                               structInfo->pStdPPSs + idx,
                                                                               metaInfo->pStdPPSs->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pstd_pp_ss_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoH264PictureParameterSet " << pstd_pp_ss_array << "[] = {" << pstd_pp_ss_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stdSPSCount << "," << std::endl;
    struct_body << "\t\t\t" << pstd_s_pss_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stdPPSCount << "," << std::endl;
    struct_body << "\t\t\t" << pstd_pp_ss_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264SessionParametersAddInfoKHR");
    out << "\t\t" << "VkVideoEncodeH264SessionParametersAddInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264SessionParametersCreateInfoKHR(std::ostream &out, const VkVideoEncodeH264SessionParametersCreateInfoKHR* structInfo, Decoded_VkVideoEncodeH264SessionParametersCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pparameters_add_info_struct = "NULL";
    if (structInfo->pParametersAddInfo != NULL) {
        pparameters_add_info_struct = GenerateStruct_VkVideoEncodeH264SessionParametersAddInfoKHR(out,
                                                                                                  structInfo->pParametersAddInfo,
                                                                                                  metaInfo->pParametersAddInfo->GetMetaStructPointer(),
                                                                                                  consumer);
        pparameters_add_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxStdSPSCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxStdPPSCount << "," << std::endl;
    struct_body << "\t\t\t" << pparameters_add_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264SessionParametersCreateInfoKHR");
    out << "\t\t" << "VkVideoEncodeH264SessionParametersCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264SessionParametersFeedbackInfoKHR(std::ostream &out, const VkVideoEncodeH264SessionParametersFeedbackInfoKHR* structInfo, Decoded_VkVideoEncodeH264SessionParametersFeedbackInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hasStdSPSOverrides << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hasStdPPSOverrides << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264SessionParametersFeedbackInfoKHR");
    out << "\t\t" << "VkVideoEncodeH264SessionParametersFeedbackInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264SessionParametersGetInfoKHR(std::ostream &out, const VkVideoEncodeH264SessionParametersGetInfoKHR* structInfo, Decoded_VkVideoEncodeH264SessionParametersGetInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->writeStdSPS << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->writeStdPPS << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stdSPSId << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stdPPSId << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264SessionParametersGetInfoKHR");
    out << "\t\t" << "VkVideoEncodeH264SessionParametersGetInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH264CapabilitiesKHR(std::ostream &out, const VkVideoDecodeH264CapabilitiesKHR* structInfo, Decoded_VkVideoDecodeH264CapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string field_offset_granularity_info_var = GenerateStruct_VkOffset2D(out,
                                                                              &structInfo->fieldOffsetGranularity,
                                                                              metaInfo->fieldOffsetGranularity,
                                                                              consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264LevelIdc(" << structInfo->maxLevelIdc << ")" << "," << std::endl;
    struct_body << "\t\t\t" << field_offset_granularity_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH264CapabilitiesKHR");
    out << "\t\t" << "VkVideoDecodeH264CapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH264DpbSlotInfoKHR(std::ostream &out, const VkVideoDecodeH264DpbSlotInfoKHR* structInfo, Decoded_VkVideoDecodeH264DpbSlotInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_reference_info_struct = "NULL";
    if (structInfo->pStdReferenceInfo != NULL) {
        pstd_reference_info_struct = GenerateStruct_StdVideoDecodeH264ReferenceInfo(out,
                                                                                    structInfo->pStdReferenceInfo,
                                                                                    metaInfo->pStdReferenceInfo->GetMetaStructPointer(),
                                                                                    consumer);
        pstd_reference_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pstd_reference_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH264DpbSlotInfoKHR");
    out << "\t\t" << "VkVideoDecodeH264DpbSlotInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH264PictureInfoKHR(std::ostream &out, const VkVideoDecodeH264PictureInfoKHR* structInfo, Decoded_VkVideoDecodeH264PictureInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_picture_info_struct = "NULL";
    if (structInfo->pStdPictureInfo != NULL) {
        pstd_picture_info_struct = GenerateStruct_StdVideoDecodeH264PictureInfo(out,
                                                                                structInfo->pStdPictureInfo,
                                                                                metaInfo->pStdPictureInfo->GetMetaStructPointer(),
                                                                                consumer);
        pstd_picture_info_struct.insert(0, "&");
    }
    std::string pslice_offsets_array = "NULL";
    if (structInfo->pSliceOffsets != NULL) {
        pslice_offsets_array = "pSliceOffsets_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pslice_offsets_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pSliceOffsets, structInfo->sliceCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pstd_picture_info_struct << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sliceCount << "," << std::endl;
    struct_body << "\t\t\t" << pslice_offsets_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH264PictureInfoKHR");
    out << "\t\t" << "VkVideoDecodeH264PictureInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH264ProfileInfoKHR(std::ostream &out, const VkVideoDecodeH264ProfileInfoKHR* structInfo, Decoded_VkVideoDecodeH264ProfileInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoH264ProfileIdc(" << structInfo->stdProfileIdc << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoDecodeH264PictureLayoutFlagBitsKHR(" << structInfo->pictureLayout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH264ProfileInfoKHR");
    out << "\t\t" << "VkVideoDecodeH264ProfileInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH264SessionParametersAddInfoKHR(std::ostream &out, const VkVideoDecodeH264SessionParametersAddInfoKHR* structInfo, Decoded_VkVideoDecodeH264SessionParametersAddInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_s_pss_array = "NULL";
    if (structInfo->pStdSPSs != NULL) {
        pstd_s_pss_array = "pStdSPSs_" + std::to_string(consumer.GetNextId());
        std::string pstd_s_pss_names;
        for (uint32_t idx = 0; idx < structInfo->stdSPSCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdSPSs + idx != NULL) {
                variable_name = GenerateStruct_StdVideoH264SequenceParameterSet(out,
                                                                                structInfo->pStdSPSs + idx,
                                                                                metaInfo->pStdSPSs->GetMetaStructPointer() + idx,
                                                                                consumer);
            }
            pstd_s_pss_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoH264SequenceParameterSet " << pstd_s_pss_array << "[] = {" << pstd_s_pss_names << "};" << std::endl;
    }
    std::string pstd_pp_ss_array = "NULL";
    if (structInfo->pStdPPSs != NULL) {
        pstd_pp_ss_array = "pStdPPSs_" + std::to_string(consumer.GetNextId());
        std::string pstd_pp_ss_names;
        for (uint32_t idx = 0; idx < structInfo->stdPPSCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdPPSs + idx != NULL) {
                variable_name = GenerateStruct_StdVideoH264PictureParameterSet(out,
                                                                               structInfo->pStdPPSs + idx,
                                                                               metaInfo->pStdPPSs->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pstd_pp_ss_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoH264PictureParameterSet " << pstd_pp_ss_array << "[] = {" << pstd_pp_ss_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stdSPSCount << "," << std::endl;
    struct_body << "\t\t\t" << pstd_s_pss_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stdPPSCount << "," << std::endl;
    struct_body << "\t\t\t" << pstd_pp_ss_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH264SessionParametersAddInfoKHR");
    out << "\t\t" << "VkVideoDecodeH264SessionParametersAddInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeH264SessionParametersCreateInfoKHR(std::ostream &out, const VkVideoDecodeH264SessionParametersCreateInfoKHR* structInfo, Decoded_VkVideoDecodeH264SessionParametersCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pparameters_add_info_struct = "NULL";
    if (structInfo->pParametersAddInfo != NULL) {
        pparameters_add_info_struct = GenerateStruct_VkVideoDecodeH264SessionParametersAddInfoKHR(out,
                                                                                                  structInfo->pParametersAddInfo,
                                                                                                  metaInfo->pParametersAddInfo->GetMetaStructPointer(),
                                                                                                  consumer);
        pparameters_add_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxStdSPSCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxStdPPSCount << "," << std::endl;
    struct_body << "\t\t\t" << pparameters_add_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeH264SessionParametersCreateInfoKHR");
    out << "\t\t" << "VkVideoDecodeH264SessionParametersCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportMemoryWin32HandleInfoKHR(std::ostream &out, const VkExportMemoryWin32HandleInfoKHR* structInfo, Decoded_VkExportMemoryWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pAttributes << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dwAccess << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<LPCWSTR>(" << util::strings::convert_wstring_to_utf8(structInfo->name) << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportMemoryWin32HandleInfoKHR");
    out << "\t\t" << "VkExportMemoryWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportMemoryWin32HandleInfoKHR(std::ostream &out, const VkImportMemoryWin32HandleInfoKHR* structInfo, Decoded_VkImportMemoryWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<HANDLE>(" << structInfo->handle << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<LPCWSTR>(" << util::strings::convert_wstring_to_utf8(structInfo->name) << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importMemoryWin32HandleInfoKHR");
    out << "\t\t" << "VkImportMemoryWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryGetWin32HandleInfoKHR(std::ostream &out, const VkMemoryGetWin32HandleInfoKHR* structInfo, Decoded_VkMemoryGetWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryGetWin32HandleInfoKHR");
    out << "\t\t" << "VkMemoryGetWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryWin32HandlePropertiesKHR(std::ostream &out, const VkMemoryWin32HandlePropertiesKHR* structInfo, Decoded_VkMemoryWin32HandlePropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryTypeBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryWin32HandlePropertiesKHR");
    out << "\t\t" << "VkMemoryWin32HandlePropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportMemoryFdInfoKHR(std::ostream &out, const VkImportMemoryFdInfoKHR* structInfo, Decoded_VkImportMemoryFdInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fd << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importMemoryFdInfoKHR");
    out << "\t\t" << "VkImportMemoryFdInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryFdPropertiesKHR(std::ostream &out, const VkMemoryFdPropertiesKHR* structInfo, Decoded_VkMemoryFdPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryTypeBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryFdPropertiesKHR");
    out << "\t\t" << "VkMemoryFdPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryGetFdInfoKHR(std::ostream &out, const VkMemoryGetFdInfoKHR* structInfo, Decoded_VkMemoryGetFdInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryGetFdInfoKHR");
    out << "\t\t" << "VkMemoryGetFdInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWin32KeyedMutexAcquireReleaseInfoKHR(std::ostream &out, const VkWin32KeyedMutexAcquireReleaseInfoKHR* structInfo, Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pacquire_syncs_array = "NULL";
    if (metaInfo->pAcquireSyncs.GetPointer() != NULL && structInfo->acquireCount > 0) {
        pacquire_syncs_array = "pacquire_syncs_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DEVICE_MEMORY));
        std::string pacquire_syncs_values = toStringJoin(metaInfo->pAcquireSyncs.GetPointer(),
                                                         metaInfo->pAcquireSyncs.GetPointer() + structInfo->acquireCount,
                                                         [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                         ", ");
        if (structInfo->acquireCount == 1) {
            pacquire_syncs_array = "&" + pacquire_syncs_values;
        } else if (structInfo->acquireCount > 1) {
            out << "\t\t" << "VkDeviceMemory " << pacquire_syncs_array << "[] = {" << pacquire_syncs_values << "};" << std::endl;
        }
    }
    std::string pacquire_keys_array = "pacquire_keys_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->acquireCount > 0) {
        std::string pacquire_keys_values = toStringJoin(structInfo->pAcquireKeys,
                                                        structInfo->pAcquireKeys + structInfo->acquireCount,
                                                        [](uint64_t current) { return std::to_string(current); },
                                                        ", ");
        if (structInfo->acquireCount == 1) {
            pacquire_keys_array = "&" + pacquire_keys_values;
        } else if (structInfo->acquireCount > 1) {
            out << "\t\t" << "uint64_t " << pacquire_keys_array << "[] = {" << pacquire_keys_values << "};" << std::endl;
        }
    }
    std::string pacquire_timeouts_array = "NULL";
    if (structInfo->pAcquireTimeouts != NULL) {
        pacquire_timeouts_array = "pAcquireTimeouts_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pacquire_timeouts_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pAcquireTimeouts, structInfo->acquireCount) << ";" << std::endl;
    }
    std::string prelease_syncs_array = "NULL";
    if (metaInfo->pReleaseSyncs.GetPointer() != NULL && structInfo->releaseCount > 0) {
        prelease_syncs_array = "prelease_syncs_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DEVICE_MEMORY));
        std::string prelease_syncs_values = toStringJoin(metaInfo->pReleaseSyncs.GetPointer(),
                                                         metaInfo->pReleaseSyncs.GetPointer() + structInfo->releaseCount,
                                                         [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                         ", ");
        if (structInfo->releaseCount == 1) {
            prelease_syncs_array = "&" + prelease_syncs_values;
        } else if (structInfo->releaseCount > 1) {
            out << "\t\t" << "VkDeviceMemory " << prelease_syncs_array << "[] = {" << prelease_syncs_values << "};" << std::endl;
        }
    }
    std::string prelease_keys_array = "prelease_keys_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->releaseCount > 0) {
        std::string prelease_keys_values = toStringJoin(structInfo->pReleaseKeys,
                                                        structInfo->pReleaseKeys + structInfo->releaseCount,
                                                        [](uint64_t current) { return std::to_string(current); },
                                                        ", ");
        if (structInfo->releaseCount == 1) {
            prelease_keys_array = "&" + prelease_keys_values;
        } else if (structInfo->releaseCount > 1) {
            out << "\t\t" << "uint64_t " << prelease_keys_array << "[] = {" << prelease_keys_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->acquireCount << "," << std::endl;
    struct_body << "\t\t\t" << pacquire_syncs_array << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << pacquire_keys_array << " }" << "," << std::endl;
    struct_body << "\t\t\t" << pacquire_timeouts_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->releaseCount << "," << std::endl;
    struct_body << "\t\t\t" << prelease_syncs_array << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << prelease_keys_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "win32KeyedMutexAcquireReleaseInfoKHR");
    out << "\t\t" << "VkWin32KeyedMutexAcquireReleaseInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkD3D12FenceSubmitInfoKHR(std::ostream &out, const VkD3D12FenceSubmitInfoKHR* structInfo, Decoded_VkD3D12FenceSubmitInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pwait_semaphore_values_array = "pwait_semaphore_values_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->waitSemaphoreValuesCount > 0) {
        std::string pwait_semaphore_values_values = toStringJoin(structInfo->pWaitSemaphoreValues,
                                                                 structInfo->pWaitSemaphoreValues + structInfo->waitSemaphoreValuesCount,
                                                                 [](uint64_t current) { return std::to_string(current); },
                                                                 ", ");
        if (structInfo->waitSemaphoreValuesCount == 1) {
            pwait_semaphore_values_array = "&" + pwait_semaphore_values_values;
        } else if (structInfo->waitSemaphoreValuesCount > 1) {
            out << "\t\t" << "uint64_t " << pwait_semaphore_values_array << "[] = {" << pwait_semaphore_values_values << "};" << std::endl;
        }
    }
    std::string psignal_semaphore_values_array = "psignal_semaphore_values_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->signalSemaphoreValuesCount > 0) {
        std::string psignal_semaphore_values_values = toStringJoin(structInfo->pSignalSemaphoreValues,
                                                                   structInfo->pSignalSemaphoreValues + structInfo->signalSemaphoreValuesCount,
                                                                   [](uint64_t current) { return std::to_string(current); },
                                                                   ", ");
        if (structInfo->signalSemaphoreValuesCount == 1) {
            psignal_semaphore_values_array = "&" + psignal_semaphore_values_values;
        } else if (structInfo->signalSemaphoreValuesCount > 1) {
            out << "\t\t" << "uint64_t " << psignal_semaphore_values_array << "[] = {" << psignal_semaphore_values_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->waitSemaphoreValuesCount << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << pwait_semaphore_values_array << " }" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->signalSemaphoreValuesCount << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << psignal_semaphore_values_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "d3D12FenceSubmitInfoKHR");
    out << "\t\t" << "VkD3D12FenceSubmitInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportSemaphoreWin32HandleInfoKHR(std::ostream &out, const VkExportSemaphoreWin32HandleInfoKHR* structInfo, Decoded_VkExportSemaphoreWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pAttributes << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dwAccess << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<LPCWSTR>(" << util::strings::convert_wstring_to_utf8(structInfo->name) << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportSemaphoreWin32HandleInfoKHR");
    out << "\t\t" << "VkExportSemaphoreWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportSemaphoreWin32HandleInfoKHR(std::ostream &out, const VkImportSemaphoreWin32HandleInfoKHR* structInfo, Decoded_VkImportSemaphoreWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
    struct_body << "\t\t\t" << "VkSemaphoreImportFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<HANDLE>(" << structInfo->handle << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<LPCWSTR>(" << util::strings::convert_wstring_to_utf8(structInfo->name) << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importSemaphoreWin32HandleInfoKHR");
    out << "\t\t" << "VkImportSemaphoreWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreGetWin32HandleInfoKHR(std::ostream &out, const VkSemaphoreGetWin32HandleInfoKHR* structInfo, Decoded_VkSemaphoreGetWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreGetWin32HandleInfoKHR");
    out << "\t\t" << "VkSemaphoreGetWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportSemaphoreFdInfoKHR(std::ostream &out, const VkImportSemaphoreFdInfoKHR* structInfo, Decoded_VkImportSemaphoreFdInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
    struct_body << "\t\t\t" << "VkSemaphoreImportFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fd << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importSemaphoreFdInfoKHR");
    out << "\t\t" << "VkImportSemaphoreFdInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreGetFdInfoKHR(std::ostream &out, const VkSemaphoreGetFdInfoKHR* structInfo, Decoded_VkSemaphoreGetFdInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreGetFdInfoKHR");
    out << "\t\t" << "VkSemaphoreGetFdInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentRegionKHR(std::ostream &out, const VkPresentRegionKHR* structInfo, Decoded_VkPresentRegionKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string prectangles_array = "NULL";
    if (structInfo->pRectangles != NULL) {
        prectangles_array = "pRectangles_" + std::to_string(consumer.GetNextId());
        std::string prectangles_names;
        for (uint32_t idx = 0; idx < structInfo->rectangleCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRectangles + idx != NULL) {
                variable_name = GenerateStruct_VkRectLayerKHR(out,
                                                              structInfo->pRectangles + idx,
                                                              metaInfo->pRectangles->GetMetaStructPointer() + idx,
                                                              consumer);
            }
            prectangles_names += variable_name + ", ";
        }
        out << "\t\t" << "VkRectLayerKHR " << prectangles_array << "[] = {" << prectangles_names << "};" << std::endl;
    }
    struct_body << "\t" << structInfo->rectangleCount << "," << std::endl;
    struct_body << "\t\t\t" << prectangles_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentRegionKHR");
    out << "\t\t" << "VkPresentRegionKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentRegionsKHR(std::ostream &out, const VkPresentRegionsKHR* structInfo, Decoded_VkPresentRegionsKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->swapchainCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkPresentRegionKHR(out,
                                                                  structInfo->pRegions + idx,
                                                                  metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPresentRegionKHR " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->swapchainCount << "," << std::endl;
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentRegionsKHR");
    out << "\t\t" << "VkPresentRegionsKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRectLayerKHR(std::ostream &out, const VkRectLayerKHR* structInfo, Decoded_VkRectLayerKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string offset_info_var = GenerateStruct_VkOffset2D(out,
                                                            &structInfo->offset,
                                                            metaInfo->offset,
                                                            consumer);
    std::string extent_info_var = GenerateStruct_VkExtent2D(out,
                                                            &structInfo->extent,
                                                            metaInfo->extent,
                                                            consumer);
    struct_body << "\t" << offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->layer << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "rectLayerKHR");
    out << "\t\t" << "VkRectLayerKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSharedPresentSurfaceCapabilitiesKHR(std::ostream &out, const VkSharedPresentSurfaceCapabilitiesKHR* structInfo, Decoded_VkSharedPresentSurfaceCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->sharedPresentSupportedUsageFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sharedPresentSurfaceCapabilitiesKHR");
    out << "\t\t" << "VkSharedPresentSurfaceCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportFenceWin32HandleInfoKHR(std::ostream &out, const VkExportFenceWin32HandleInfoKHR* structInfo, Decoded_VkExportFenceWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pAttributes << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dwAccess << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<LPCWSTR>(" << util::strings::convert_wstring_to_utf8(structInfo->name) << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportFenceWin32HandleInfoKHR");
    out << "\t\t" << "VkExportFenceWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFenceGetWin32HandleInfoKHR(std::ostream &out, const VkFenceGetWin32HandleInfoKHR* structInfo, Decoded_VkFenceGetWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->fence) << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "fenceGetWin32HandleInfoKHR");
    out << "\t\t" << "VkFenceGetWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportFenceWin32HandleInfoKHR(std::ostream &out, const VkImportFenceWin32HandleInfoKHR* structInfo, Decoded_VkImportFenceWin32HandleInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->fence) << "," << std::endl;
    struct_body << "\t\t\t" << "VkFenceImportFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<HANDLE>(" << structInfo->handle << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<LPCWSTR>(" << util::strings::convert_wstring_to_utf8(structInfo->name) << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importFenceWin32HandleInfoKHR");
    out << "\t\t" << "VkImportFenceWin32HandleInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFenceGetFdInfoKHR(std::ostream &out, const VkFenceGetFdInfoKHR* structInfo, Decoded_VkFenceGetFdInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->fence) << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "fenceGetFdInfoKHR");
    out << "\t\t" << "VkFenceGetFdInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportFenceFdInfoKHR(std::ostream &out, const VkImportFenceFdInfoKHR* structInfo, Decoded_VkImportFenceFdInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->fence) << "," << std::endl;
    struct_body << "\t\t\t" << "VkFenceImportFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fd << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importFenceFdInfoKHR");
    out << "\t\t" << "VkImportFenceFdInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAcquireProfilingLockInfoKHR(std::ostream &out, const VkAcquireProfilingLockInfoKHR* structInfo, Decoded_VkAcquireProfilingLockInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAcquireProfilingLockFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timeout << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "acquireProfilingLockInfoKHR");
    out << "\t\t" << "VkAcquireProfilingLockInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceCounterDescriptionKHR(std::ostream &out, const VkPerformanceCounterDescriptionKHR* structInfo, Decoded_VkPerformanceCounterDescriptionKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPerformanceCounterDescriptionFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->name) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->category) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceCounterDescriptionKHR");
    out << "\t\t" << "VkPerformanceCounterDescriptionKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceCounterKHR(std::ostream &out, const VkPerformanceCounterKHR* structInfo, Decoded_VkPerformanceCounterKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPerformanceCounterUnitKHR(" << structInfo->unit << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPerformanceCounterScopeKHR(" << structInfo->scope << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPerformanceCounterStorageKHR(" << structInfo->storage << ")" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->uuid[0]), VK_UUID_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceCounterKHR");
    out << "\t\t" << "VkPerformanceCounterKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceQuerySubmitInfoKHR(std::ostream &out, const VkPerformanceQuerySubmitInfoKHR* structInfo, Decoded_VkPerformanceQuerySubmitInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->counterPassIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceQuerySubmitInfoKHR");
    out << "\t\t" << "VkPerformanceQuerySubmitInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePerformanceQueryFeaturesKHR(std::ostream &out, const VkPhysicalDevicePerformanceQueryFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePerformanceQueryFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->performanceCounterQueryPools << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->performanceCounterMultipleQueryPools << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePerformanceQueryFeaturesKHR");
    out << "\t\t" << "VkPhysicalDevicePerformanceQueryFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePerformanceQueryPropertiesKHR(std::ostream &out, const VkPhysicalDevicePerformanceQueryPropertiesKHR* structInfo, Decoded_VkPhysicalDevicePerformanceQueryPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->allowCommandBufferQueryCopies << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePerformanceQueryPropertiesKHR");
    out << "\t\t" << "VkPhysicalDevicePerformanceQueryPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueryPoolPerformanceCreateInfoKHR(std::ostream &out, const VkQueryPoolPerformanceCreateInfoKHR* structInfo, Decoded_VkQueryPoolPerformanceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcounter_indices_array = "NULL";
    if (structInfo->pCounterIndices != NULL) {
        pcounter_indices_array = "pCounterIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pcounter_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCounterIndices, structInfo->counterIndexCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueFamilyIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->counterIndexCount << "," << std::endl;
    struct_body << "\t\t\t" << pcounter_indices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queryPoolPerformanceCreateInfoKHR");
    out << "\t\t" << "VkQueryPoolPerformanceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSurfaceInfo2KHR(std::ostream &out, const VkPhysicalDeviceSurfaceInfo2KHR* structInfo, Decoded_VkPhysicalDeviceSurfaceInfo2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->surface) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSurfaceInfo2KHR");
    out << "\t\t" << "VkPhysicalDeviceSurfaceInfo2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceCapabilities2KHR(std::ostream &out, const VkSurfaceCapabilities2KHR* structInfo, Decoded_VkSurfaceCapabilities2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string surface_capabilities_info_var = GenerateStruct_VkSurfaceCapabilitiesKHR(out,
                                                                                        &structInfo->surfaceCapabilities,
                                                                                        metaInfo->surfaceCapabilities,
                                                                                        consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << surface_capabilities_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceCapabilities2KHR");
    out << "\t\t" << "VkSurfaceCapabilities2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceFormat2KHR(std::ostream &out, const VkSurfaceFormat2KHR* structInfo, Decoded_VkSurfaceFormat2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string surface_format_info_var = GenerateStruct_VkSurfaceFormatKHR(out,
                                                                            &structInfo->surfaceFormat,
                                                                            metaInfo->surfaceFormat,
                                                                            consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << surface_format_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceFormat2KHR");
    out << "\t\t" << "VkSurfaceFormat2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayModeProperties2KHR(std::ostream &out, const VkDisplayModeProperties2KHR* structInfo, Decoded_VkDisplayModeProperties2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string display_mode_properties_info_var = GenerateStruct_VkDisplayModePropertiesKHR(out,
                                                                                             &structInfo->displayModeProperties,
                                                                                             metaInfo->displayModeProperties,
                                                                                             consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << display_mode_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayModeProperties2KHR");
    out << "\t\t" << "VkDisplayModeProperties2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPlaneCapabilities2KHR(std::ostream &out, const VkDisplayPlaneCapabilities2KHR* structInfo, Decoded_VkDisplayPlaneCapabilities2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string capabilities_info_var = GenerateStruct_VkDisplayPlaneCapabilitiesKHR(out,
                                                                                     &structInfo->capabilities,
                                                                                     metaInfo->capabilities,
                                                                                     consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << capabilities_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPlaneCapabilities2KHR");
    out << "\t\t" << "VkDisplayPlaneCapabilities2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPlaneInfo2KHR(std::ostream &out, const VkDisplayPlaneInfo2KHR* structInfo, Decoded_VkDisplayPlaneInfo2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->mode) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->planeIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPlaneInfo2KHR");
    out << "\t\t" << "VkDisplayPlaneInfo2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPlaneProperties2KHR(std::ostream &out, const VkDisplayPlaneProperties2KHR* structInfo, Decoded_VkDisplayPlaneProperties2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string display_plane_properties_info_var = GenerateStruct_VkDisplayPlanePropertiesKHR(out,
                                                                                               &structInfo->displayPlaneProperties,
                                                                                               metaInfo->displayPlaneProperties,
                                                                                               consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << display_plane_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPlaneProperties2KHR");
    out << "\t\t" << "VkDisplayPlaneProperties2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayProperties2KHR(std::ostream &out, const VkDisplayProperties2KHR* structInfo, Decoded_VkDisplayProperties2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string display_properties_info_var = GenerateStruct_VkDisplayPropertiesKHR(out,
                                                                                    &structInfo->displayProperties,
                                                                                    metaInfo->displayProperties,
                                                                                    consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << display_properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayProperties2KHR");
    out << "\t\t" << "VkDisplayProperties2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderBfloat16FeaturesKHR(std::ostream &out, const VkPhysicalDeviceShaderBfloat16FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceShaderBfloat16FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBFloat16Type << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBFloat16DotProduct << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBFloat16CooperativeMatrix << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderBfloat16FeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceShaderBfloat16FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePortabilitySubsetFeaturesKHR(std::ostream &out, const VkPhysicalDevicePortabilitySubsetFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePortabilitySubsetFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->constantAlphaColorBlendFactors << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->events << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageViewFormatReinterpretation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageViewFormatSwizzle << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageView2DOn3DImage << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multisampleArrayImage << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->mutableComparisonSamplers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pointPolygons << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->samplerMipLodBias << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->separateStencilMaskRef << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSampleRateInterpolationFunctions << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tessellationIsolines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tessellationPointMode << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->triangleFans << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexAttributeAccessBeyondStride << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePortabilitySubsetFeaturesKHR");
    out << "\t\t" << "VkPhysicalDevicePortabilitySubsetFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePortabilitySubsetPropertiesKHR(std::ostream &out, const VkPhysicalDevicePortabilitySubsetPropertiesKHR* structInfo, Decoded_VkPhysicalDevicePortabilitySubsetPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minVertexInputBindingStrideAlignment << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePortabilitySubsetPropertiesKHR");
    out << "\t\t" << "VkPhysicalDevicePortabilitySubsetPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderClockFeaturesKHR(std::ostream &out, const VkPhysicalDeviceShaderClockFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceShaderClockFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSubgroupClock << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderDeviceClock << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderClockFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceShaderClockFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFragmentShadingRateAttachmentInfoKHR(std::ostream &out, const VkFragmentShadingRateAttachmentInfoKHR* structInfo, Decoded_VkFragmentShadingRateAttachmentInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pfragment_shading_rate_attachment_struct = "NULL";
    if (structInfo->pFragmentShadingRateAttachment != NULL) {
        pfragment_shading_rate_attachment_struct = GenerateStruct_VkAttachmentReference2(out,
                                                                                         structInfo->pFragmentShadingRateAttachment,
                                                                                         metaInfo->pFragmentShadingRateAttachment->GetMetaStructPointer(),
                                                                                         consumer);
        pfragment_shading_rate_attachment_struct.insert(0, "&");
    }
    std::string shading_rate_attachment_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                        &structInfo->shadingRateAttachmentTexelSize,
                                                                                        metaInfo->shadingRateAttachmentTexelSize,
                                                                                        consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pfragment_shading_rate_attachment_struct << "," << std::endl;
    struct_body << "\t\t\t" << shading_rate_attachment_texel_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "fragmentShadingRateAttachmentInfoKHR");
    out << "\t\t" << "VkFragmentShadingRateAttachmentInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(std::ostream &out, const VkPhysicalDeviceFragmentShadingRateFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRateFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineFragmentShadingRate << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primitiveFragmentShadingRate << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->attachmentFragmentShadingRate << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShadingRateFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceFragmentShadingRateFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRateKHR(std::ostream &out, const VkPhysicalDeviceFragmentShadingRateKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRateKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string fragment_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                   &structInfo->fragmentSize,
                                                                   metaInfo->fragmentSize,
                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->sampleCounts << ")" << "," << std::endl;
    struct_body << "\t\t\t" << fragment_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShadingRateKHR");
    out << "\t\t" << "VkPhysicalDeviceFragmentShadingRateKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(std::ostream &out, const VkPhysicalDeviceFragmentShadingRatePropertiesKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRatePropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string min_fragment_shading_rate_attachment_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                                     &structInfo->minFragmentShadingRateAttachmentTexelSize,
                                                                                                     metaInfo->minFragmentShadingRateAttachmentTexelSize,
                                                                                                     consumer);
    std::string max_fragment_shading_rate_attachment_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                                     &structInfo->maxFragmentShadingRateAttachmentTexelSize,
                                                                                                     metaInfo->maxFragmentShadingRateAttachmentTexelSize,
                                                                                                     consumer);
    std::string max_fragment_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                       &structInfo->maxFragmentSize,
                                                                       metaInfo->maxFragmentSize,
                                                                       consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << min_fragment_shading_rate_attachment_texel_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_fragment_shading_rate_attachment_texel_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxFragmentShadingRateAttachmentTexelSizeAspectRatio << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primitiveFragmentShadingRateWithMultipleViewports << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->layeredShadingRateAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateNonTrivialCombinerOps << "," << std::endl;
    struct_body << "\t\t\t" << max_fragment_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxFragmentSizeAspectRatio << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxFragmentShadingRateCoverageSamples << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->maxFragmentShadingRateRasterizationSamples << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateWithShaderDepthStencilWrites << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateWithSampleMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateWithShaderSampleMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateWithConservativeRasterization << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateWithFragmentShaderInterlock << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateWithCustomSampleLocations << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateStrictMultiplyCombiner << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShadingRatePropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceFragmentShadingRatePropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineFragmentShadingRateStateCreateInfoKHR(std::ostream &out, const VkPipelineFragmentShadingRateStateCreateInfoKHR* structInfo, Decoded_VkPipelineFragmentShadingRateStateCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string fragment_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                   &structInfo->fragmentSize,
                                                                   metaInfo->fragmentSize,
                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << fragment_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkFragmentShadingRateCombinerOpKHR*>(&structInfo->combinerOps[0]), 2) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineFragmentShadingRateStateCreateInfoKHR");
    out << "\t\t" << "VkPipelineFragmentShadingRateStateCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderingFragmentShadingRateAttachmentInfoKHR(std::ostream &out, const VkRenderingFragmentShadingRateAttachmentInfoKHR* structInfo, Decoded_VkRenderingFragmentShadingRateAttachmentInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string shading_rate_attachment_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                        &structInfo->shadingRateAttachmentTexelSize,
                                                                                        metaInfo->shadingRateAttachmentTexelSize,
                                                                                        consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->imageView) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->imageLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << shading_rate_attachment_texel_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderingFragmentShadingRateAttachmentInfoKHR");
    out << "\t\t" << "VkRenderingFragmentShadingRateAttachmentInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderQuadControlFeaturesKHR(std::ostream &out, const VkPhysicalDeviceShaderQuadControlFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceShaderQuadControlFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderQuadControl << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderQuadControlFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceShaderQuadControlFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceProtectedCapabilitiesKHR(std::ostream &out, const VkSurfaceProtectedCapabilitiesKHR* structInfo, Decoded_VkSurfaceProtectedCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->supportsProtected << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceProtectedCapabilitiesKHR");
    out << "\t\t" << "VkSurfaceProtectedCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePresentWaitFeaturesKHR(std::ostream &out, const VkPhysicalDevicePresentWaitFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePresentWaitFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentWait << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePresentWaitFeaturesKHR");
    out << "\t\t" << "VkPhysicalDevicePresentWaitFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(std::ostream &out, const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineExecutableInfo << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineExecutablePropertiesFeaturesKHR");
    out << "\t\t" << "VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineExecutableInfoKHR(std::ostream &out, const VkPipelineExecutableInfoKHR* structInfo, Decoded_VkPipelineExecutableInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipeline) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->executableIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineExecutableInfoKHR");
    out << "\t\t" << "VkPipelineExecutableInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineExecutableInternalRepresentationKHR(std::ostream &out, const VkPipelineExecutableInternalRepresentationKHR* structInfo, Decoded_VkPipelineExecutableInternalRepresentationKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->name) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->isText << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dataSize << "," << std::endl;
    out << "\t\t" << "// TODO: Support pData (output with array length value?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineExecutableInternalRepresentationKHR");
    out << "\t\t" << "VkPipelineExecutableInternalRepresentationKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineExecutablePropertiesKHR(std::ostream &out, const VkPipelineExecutablePropertiesKHR* structInfo, Decoded_VkPipelineExecutablePropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->stages << ")" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->name) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subgroupSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineExecutablePropertiesKHR");
    out << "\t\t" << "VkPipelineExecutablePropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineExecutableStatisticKHR(std::ostream &out, const VkPipelineExecutableStatisticKHR* structInfo, Decoded_VkPipelineExecutableStatisticKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->name) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineExecutableStatisticFormatKHR(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->value.b32 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineExecutableStatisticKHR");
    out << "\t\t" << "VkPipelineExecutableStatisticKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineInfoKHR(std::ostream &out, const VkPipelineInfoKHR* structInfo, Decoded_VkPipelineInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipeline) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineInfoKHR");
    out << "\t\t" << "VkPipelineInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineLibraryCreateInfoKHR(std::ostream &out, const VkPipelineLibraryCreateInfoKHR* structInfo, Decoded_VkPipelineLibraryCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string plibraries_array = "NULL";
    if (metaInfo->pLibraries.GetPointer() != NULL && structInfo->libraryCount > 0) {
        plibraries_array = "plibraries_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_PIPELINE));
        std::string plibraries_values = toStringJoin(metaInfo->pLibraries.GetPointer(),
                                                     metaInfo->pLibraries.GetPointer() + structInfo->libraryCount,
                                                     [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                     ", ");
        if (structInfo->libraryCount == 1) {
            plibraries_array = "&" + plibraries_values;
        } else if (structInfo->libraryCount > 1) {
            out << "\t\t" << "VkPipeline " << plibraries_array << "[] = {" << plibraries_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->libraryCount << "," << std::endl;
    struct_body << "\t\t\t" << plibraries_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineLibraryCreateInfoKHR");
    out << "\t\t" << "VkPipelineLibraryCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePresentIdFeaturesKHR(std::ostream &out, const VkPhysicalDevicePresentIdFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePresentIdFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentId << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePresentIdFeaturesKHR");
    out << "\t\t" << "VkPhysicalDevicePresentIdFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentIdKHR(std::ostream &out, const VkPresentIdKHR* structInfo, Decoded_VkPresentIdKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppresent_ids_array = "ppresent_ids_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->swapchainCount > 0) {
        std::string ppresent_ids_values = toStringJoin(structInfo->pPresentIds,
                                                       structInfo->pPresentIds + structInfo->swapchainCount,
                                                       [](uint64_t current) { return std::to_string(current); },
                                                       ", ");
        if (structInfo->swapchainCount == 1) {
            ppresent_ids_array = "&" + ppresent_ids_values;
        } else if (structInfo->swapchainCount > 1) {
            out << "\t\t" << "uint64_t " << ppresent_ids_array << "[] = {" << ppresent_ids_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->swapchainCount << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << ppresent_ids_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentIdKHR");
    out << "\t\t" << "VkPresentIdKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR(std::ostream &out, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* structInfo, Decoded_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pvideo_profile_struct = "NULL";
    if (structInfo->pVideoProfile != NULL) {
        pvideo_profile_struct = GenerateStruct_VkVideoProfileInfoKHR(out,
                                                                     structInfo->pVideoProfile,
                                                                     metaInfo->pVideoProfile->GetMetaStructPointer(),
                                                                     consumer);
        pvideo_profile_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pvideo_profile_struct << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->qualityLevel << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVideoEncodeQualityLevelInfoKHR");
    out << "\t\t" << "VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(std::ostream &out, const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* structInfo, Decoded_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeFeedbackFlagsKHR(" << structInfo->encodeFeedbackFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queryPoolVideoEncodeFeedbackCreateInfoKHR");
    out << "\t\t" << "VkQueryPoolVideoEncodeFeedbackCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeCapabilitiesKHR(std::ostream &out, const VkVideoEncodeCapabilitiesKHR* structInfo, Decoded_VkVideoEncodeCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string encode_input_picture_granularity_info_var = GenerateStruct_VkExtent2D(out,
                                                                                      &structInfo->encodeInputPictureGranularity,
                                                                                      metaInfo->encodeInputPictureGranularity,
                                                                                      consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeCapabilityFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeRateControlModeFlagsKHR(" << structInfo->rateControlModes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxRateControlLayers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxBitrate << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxQualityLevels << "," << std::endl;
    struct_body << "\t\t\t" << encode_input_picture_granularity_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeFeedbackFlagsKHR(" << structInfo->supportedEncodeFeedbackFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeCapabilitiesKHR");
    out << "\t\t" << "VkVideoEncodeCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeInfoKHR(std::ostream &out, const VkVideoEncodeInfoKHR* structInfo, Decoded_VkVideoEncodeInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string src_picture_resource_info_var = GenerateStruct_VkVideoPictureResourceInfoKHR(out,
                                                                                             &structInfo->srcPictureResource,
                                                                                             metaInfo->srcPictureResource,
                                                                                             consumer);
    std::string psetup_reference_slot_struct = "NULL";
    if (structInfo->pSetupReferenceSlot != NULL) {
        psetup_reference_slot_struct = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                                                  structInfo->pSetupReferenceSlot,
                                                                                  metaInfo->pSetupReferenceSlot->GetMetaStructPointer(),
                                                                                  consumer);
        psetup_reference_slot_struct.insert(0, "&");
    }
    std::string preference_slots_array = "NULL";
    if (structInfo->pReferenceSlots != NULL) {
        preference_slots_array = "pReferenceSlots_" + std::to_string(consumer.GetNextId());
        std::string preference_slots_names;
        for (uint32_t idx = 0; idx < structInfo->referenceSlotCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pReferenceSlots + idx != NULL) {
                variable_name = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                                           structInfo->pReferenceSlots + idx,
                                                                           metaInfo->pReferenceSlots->GetMetaStructPointer() + idx,
                                                                           consumer);
            }
            preference_slots_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVideoReferenceSlotInfoKHR " << preference_slots_array << "[] = {" << preference_slots_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstBuffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstBufferOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstBufferRange << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << src_picture_resource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << psetup_reference_slot_struct << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->referenceSlotCount << "," << std::endl;
    struct_body << "\t\t\t" << preference_slots_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->precedingExternallyEncodedBytes << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeInfoKHR");
    out << "\t\t" << "VkVideoEncodeInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeQualityLevelInfoKHR(std::ostream &out, const VkVideoEncodeQualityLevelInfoKHR* structInfo, Decoded_VkVideoEncodeQualityLevelInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->qualityLevel << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeQualityLevelInfoKHR");
    out << "\t\t" << "VkVideoEncodeQualityLevelInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeQualityLevelPropertiesKHR(std::ostream &out, const VkVideoEncodeQualityLevelPropertiesKHR* structInfo, Decoded_VkVideoEncodeQualityLevelPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeRateControlModeFlagBitsKHR(" << structInfo->preferredRateControlMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredRateControlLayerCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeQualityLevelPropertiesKHR");
    out << "\t\t" << "VkVideoEncodeQualityLevelPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeRateControlInfoKHR(std::ostream &out, const VkVideoEncodeRateControlInfoKHR* structInfo, Decoded_VkVideoEncodeRateControlInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string players_array = "NULL";
    if (structInfo->pLayers != NULL) {
        players_array = "pLayers_" + std::to_string(consumer.GetNextId());
        std::string players_names;
        for (uint32_t idx = 0; idx < structInfo->layerCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pLayers + idx != NULL) {
                variable_name = GenerateStruct_VkVideoEncodeRateControlLayerInfoKHR(out,
                                                                                    structInfo->pLayers + idx,
                                                                                    metaInfo->pLayers->GetMetaStructPointer() + idx,
                                                                                    consumer);
            }
            players_names += variable_name + ", ";
        }
        out << "\t\t" << "VkVideoEncodeRateControlLayerInfoKHR " << players_array << "[] = {" << players_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeRateControlFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeRateControlModeFlagBitsKHR(" << structInfo->rateControlMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->layerCount << "," << std::endl;
    struct_body << "\t\t\t" << players_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->virtualBufferSizeInMs << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->initialVirtualBufferSizeInMs << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeRateControlInfoKHR");
    out << "\t\t" << "VkVideoEncodeRateControlInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeRateControlLayerInfoKHR(std::ostream &out, const VkVideoEncodeRateControlLayerInfoKHR* structInfo, Decoded_VkVideoEncodeRateControlLayerInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->averageBitrate << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxBitrate << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frameRateNumerator << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frameRateDenominator << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeRateControlLayerInfoKHR");
    out << "\t\t" << "VkVideoEncodeRateControlLayerInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeSessionParametersFeedbackInfoKHR(std::ostream &out, const VkVideoEncodeSessionParametersFeedbackInfoKHR* structInfo, Decoded_VkVideoEncodeSessionParametersFeedbackInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hasOverrides << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeSessionParametersFeedbackInfoKHR");
    out << "\t\t" << "VkVideoEncodeSessionParametersFeedbackInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeSessionParametersGetInfoKHR(std::ostream &out, const VkVideoEncodeSessionParametersGetInfoKHR* structInfo, Decoded_VkVideoEncodeSessionParametersGetInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->videoSessionParameters) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeSessionParametersGetInfoKHR");
    out << "\t\t" << "VkVideoEncodeSessionParametersGetInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeUsageInfoKHR(std::ostream &out, const VkVideoEncodeUsageInfoKHR* structInfo, Decoded_VkVideoEncodeUsageInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeUsageFlagsKHR(" << structInfo->videoUsageHints << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeContentFlagsKHR(" << structInfo->videoContentHints << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeTuningModeKHR(" << structInfo->tuningMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeUsageInfoKHR");
    out << "\t\t" << "VkVideoEncodeUsageInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(std::ostream &out, const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShaderBarycentric << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShaderBarycentricFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(std::ostream &out, const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->triStripVertexOrderIndependentOfProvokingVertex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShaderBarycentricPropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(std::ostream &out, const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSubgroupUniformControlFlow << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(std::ostream &out, const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->workgroupMemoryExplicitLayout << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->workgroupMemoryExplicitLayoutScalarBlockLayout << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->workgroupMemoryExplicitLayout8BitAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->workgroupMemoryExplicitLayout16BitAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(std::ostream &out, const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rayTracingMaintenance1 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rayTracingPipelineTraceRaysIndirect2 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingMaintenance1FeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTraceRaysIndirectCommand2KHR(std::ostream &out, const VkTraceRaysIndirectCommand2KHR* structInfo, Decoded_VkTraceRaysIndirectCommand2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->raygenShaderRecordAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->raygenShaderRecordSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->missShaderBindingTableAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->missShaderBindingTableSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->missShaderBindingTableStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hitShaderBindingTableAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hitShaderBindingTableSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hitShaderBindingTableStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->callableShaderBindingTableAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->callableShaderBindingTableSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->callableShaderBindingTableStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->width << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->height << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depth << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "traceRaysIndirectCommand2KHR");
    out << "\t\t" << "VkTraceRaysIndirectCommand2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderUntypedPointersFeaturesKHR(std::ostream &out, const VkPhysicalDeviceShaderUntypedPointersFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceShaderUntypedPointersFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderUntypedPointers << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderUntypedPointersFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceShaderUntypedPointersFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR(std::ostream &out, const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderMaximalReconvergence << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderMaximalReconvergenceFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePresentId2FeaturesKHR(std::ostream &out, const VkPhysicalDevicePresentId2FeaturesKHR* structInfo, Decoded_VkPhysicalDevicePresentId2FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentId2 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePresentId2FeaturesKHR");
    out << "\t\t" << "VkPhysicalDevicePresentId2FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentId2KHR(std::ostream &out, const VkPresentId2KHR* structInfo, Decoded_VkPresentId2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppresent_ids_array = "ppresent_ids_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->swapchainCount > 0) {
        std::string ppresent_ids_values = toStringJoin(structInfo->pPresentIds,
                                                       structInfo->pPresentIds + structInfo->swapchainCount,
                                                       [](uint64_t current) { return std::to_string(current); },
                                                       ", ");
        if (structInfo->swapchainCount == 1) {
            ppresent_ids_array = "&" + ppresent_ids_values;
        } else if (structInfo->swapchainCount > 1) {
            out << "\t\t" << "uint64_t " << ppresent_ids_array << "[] = {" << ppresent_ids_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->swapchainCount << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << ppresent_ids_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentId2KHR");
    out << "\t\t" << "VkPresentId2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceCapabilitiesPresentId2KHR(std::ostream &out, const VkSurfaceCapabilitiesPresentId2KHR* structInfo, Decoded_VkSurfaceCapabilitiesPresentId2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentId2Supported << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceCapabilitiesPresentId2KHR");
    out << "\t\t" << "VkSurfaceCapabilitiesPresentId2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePresentWait2FeaturesKHR(std::ostream &out, const VkPhysicalDevicePresentWait2FeaturesKHR* structInfo, Decoded_VkPhysicalDevicePresentWait2FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentWait2 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePresentWait2FeaturesKHR");
    out << "\t\t" << "VkPhysicalDevicePresentWait2FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentWait2InfoKHR(std::ostream &out, const VkPresentWait2InfoKHR* structInfo, Decoded_VkPresentWait2InfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentId << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timeout << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentWait2InfoKHR");
    out << "\t\t" << "VkPresentWait2InfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceCapabilitiesPresentWait2KHR(std::ostream &out, const VkSurfaceCapabilitiesPresentWait2KHR* structInfo, Decoded_VkSurfaceCapabilitiesPresentWait2KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentWait2Supported << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceCapabilitiesPresentWait2KHR");
    out << "\t\t" << "VkSurfaceCapabilitiesPresentWait2KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(std::ostream &out, const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rayTracingPositionFetch << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingPositionFetchFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDevicePipelineBinaryInternalCacheControlKHR(std::ostream &out, const VkDevicePipelineBinaryInternalCacheControlKHR* structInfo, Decoded_VkDevicePipelineBinaryInternalCacheControlKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->disableInternalCache << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "devicePipelineBinaryInternalCacheControlKHR");
    out << "\t\t" << "VkDevicePipelineBinaryInternalCacheControlKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineBinaryFeaturesKHR(std::ostream &out, const VkPhysicalDevicePipelineBinaryFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePipelineBinaryFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineBinaries << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineBinaryFeaturesKHR");
    out << "\t\t" << "VkPhysicalDevicePipelineBinaryFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineBinaryPropertiesKHR(std::ostream &out, const VkPhysicalDevicePipelineBinaryPropertiesKHR* structInfo, Decoded_VkPhysicalDevicePipelineBinaryPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineBinaryInternalCache << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineBinaryInternalCacheControl << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineBinaryPrefersInternalCache << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineBinaryPrecompiledInternalCache << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineBinaryCompressedData << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineBinaryPropertiesKHR");
    out << "\t\t" << "VkPhysicalDevicePipelineBinaryPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineBinaryCreateInfoKHR(std::ostream &out, const VkPipelineBinaryCreateInfoKHR* structInfo, Decoded_VkPipelineBinaryCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pkeys_and_data_info_struct = "NULL";
    if (structInfo->pKeysAndDataInfo != NULL) {
        pkeys_and_data_info_struct = GenerateStruct_VkPipelineBinaryKeysAndDataKHR(out,
                                                                                   structInfo->pKeysAndDataInfo,
                                                                                   metaInfo->pKeysAndDataInfo->GetMetaStructPointer(),
                                                                                   consumer);
        pkeys_and_data_info_struct.insert(0, "&");
    }
    std::string ppipeline_create_info_struct = "NULL";
    if (structInfo->pPipelineCreateInfo != NULL) {
        ppipeline_create_info_struct = GenerateStruct_VkPipelineCreateInfoKHR(out,
                                                                              structInfo->pPipelineCreateInfo,
                                                                              metaInfo->pPipelineCreateInfo->GetMetaStructPointer(),
                                                                              consumer);
        ppipeline_create_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pkeys_and_data_info_struct << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipeline) << "," << std::endl;
    struct_body << "\t\t\t" << ppipeline_create_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineBinaryCreateInfoKHR");
    out << "\t\t" << "VkPipelineBinaryCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineBinaryDataInfoKHR(std::ostream &out, const VkPipelineBinaryDataInfoKHR* structInfo, Decoded_VkPipelineBinaryDataInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipelineBinary) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineBinaryDataInfoKHR");
    out << "\t\t" << "VkPipelineBinaryDataInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineBinaryDataKHR(std::ostream &out, const VkPipelineBinaryDataKHR* structInfo, Decoded_VkPipelineBinaryDataKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->dataSize << "," << std::endl;
    out << "\t\t" << "// TODO: Support pData (output with array length value?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineBinaryDataKHR");
    out << "\t\t" << "VkPipelineBinaryDataKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineBinaryHandlesInfoKHR(std::ostream &out, const VkPipelineBinaryHandlesInfoKHR* structInfo, Decoded_VkPipelineBinaryHandlesInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineBinaryCount << "," << std::endl;
    out << "\t\t" << "// TODO: Support pPipelineBinaries (output with array length value?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineBinaryHandlesInfoKHR");
    out << "\t\t" << "VkPipelineBinaryHandlesInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineBinaryInfoKHR(std::ostream &out, const VkPipelineBinaryInfoKHR* structInfo, Decoded_VkPipelineBinaryInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppipeline_binaries_array = "NULL";
    if (metaInfo->pPipelineBinaries.GetPointer() != NULL && structInfo->binaryCount > 0) {
        ppipeline_binaries_array = "ppipeline_binaries_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_PIPELINE_BINARY_KHR));
        std::string ppipeline_binaries_values = toStringJoin(metaInfo->pPipelineBinaries.GetPointer(),
                                                             metaInfo->pPipelineBinaries.GetPointer() + structInfo->binaryCount,
                                                             [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                             ", ");
        if (structInfo->binaryCount == 1) {
            ppipeline_binaries_array = "&" + ppipeline_binaries_values;
        } else if (structInfo->binaryCount > 1) {
            out << "\t\t" << "VkPipelineBinaryKHR " << ppipeline_binaries_array << "[] = {" << ppipeline_binaries_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->binaryCount << "," << std::endl;
    struct_body << "\t\t\t" << ppipeline_binaries_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineBinaryInfoKHR");
    out << "\t\t" << "VkPipelineBinaryInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineBinaryKeyKHR(std::ostream &out, const VkPipelineBinaryKeyKHR* structInfo, Decoded_VkPipelineBinaryKeyKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->keySize << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->key[0]), VK_MAX_PIPELINE_BINARY_KEY_SIZE_KHR) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineBinaryKeyKHR");
    out << "\t\t" << "VkPipelineBinaryKeyKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineBinaryKeysAndDataKHR(std::ostream &out, const VkPipelineBinaryKeysAndDataKHR* structInfo, Decoded_VkPipelineBinaryKeysAndDataKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string ppipeline_binary_keys_array = "NULL";
    if (structInfo->pPipelineBinaryKeys != NULL) {
        ppipeline_binary_keys_array = "pPipelineBinaryKeys_" + std::to_string(consumer.GetNextId());
        std::string ppipeline_binary_keys_names;
        for (uint32_t idx = 0; idx < structInfo->binaryCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPipelineBinaryKeys + idx != NULL) {
                variable_name = GenerateStruct_VkPipelineBinaryKeyKHR(out,
                                                                      structInfo->pPipelineBinaryKeys + idx,
                                                                      metaInfo->pPipelineBinaryKeys->GetMetaStructPointer() + idx,
                                                                      consumer);
            }
            ppipeline_binary_keys_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPipelineBinaryKeyKHR " << ppipeline_binary_keys_array << "[] = {" << ppipeline_binary_keys_names << "};" << std::endl;
    }
    std::string ppipeline_binary_data_array = "NULL";
    if (structInfo->pPipelineBinaryData != NULL) {
        ppipeline_binary_data_array = "pPipelineBinaryData_" + std::to_string(consumer.GetNextId());
        std::string ppipeline_binary_data_names;
        for (uint32_t idx = 0; idx < structInfo->binaryCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPipelineBinaryData + idx != NULL) {
                variable_name = GenerateStruct_VkPipelineBinaryDataKHR(out,
                                                                       structInfo->pPipelineBinaryData + idx,
                                                                       metaInfo->pPipelineBinaryData->GetMetaStructPointer() + idx,
                                                                       consumer);
            }
            ppipeline_binary_data_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPipelineBinaryDataKHR " << ppipeline_binary_data_array << "[] = {" << ppipeline_binary_data_names << "};" << std::endl;
    }
    struct_body << "\t" << structInfo->binaryCount << "," << std::endl;
    struct_body << "\t\t\t" << ppipeline_binary_keys_array << "," << std::endl;
    struct_body << "\t\t\t" << ppipeline_binary_data_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineBinaryKeysAndDataKHR");
    out << "\t\t" << "VkPipelineBinaryKeysAndDataKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCreateInfoKHR(std::ostream &out, const VkPipelineCreateInfoKHR* structInfo, Decoded_VkPipelineCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCreateInfoKHR");
    out << "\t\t" << "VkPipelineCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkReleaseCapturedPipelineDataInfoKHR(std::ostream &out, const VkReleaseCapturedPipelineDataInfoKHR* structInfo, Decoded_VkReleaseCapturedPipelineDataInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipeline) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "releaseCapturedPipelineDataInfoKHR");
    out << "\t\t" << "VkReleaseCapturedPipelineDataInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfacePresentModeCompatibilityKHR(std::ostream &out, const VkSurfacePresentModeCompatibilityKHR* structInfo, Decoded_VkSurfacePresentModeCompatibilityKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppresent_modes_array = "NULL";
    if (structInfo->pPresentModes != NULL) {
        std::string ppresent_modes_values;
        for (uint32_t idx = 0; idx < structInfo->presentModeCount; idx++) {
            ppresent_modes_values += util::ToString<VkPresentModeKHR>(structInfo->pPresentModes[idx]) + ", ";
        }
        ppresent_modes_array = "pPresentModes_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkPresentModeKHR " << ppresent_modes_array << "[] = {" << ppresent_modes_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentModeCount << "," << std::endl;
    struct_body << "\t\t\t" << ppresent_modes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfacePresentModeCompatibilityKHR");
    out << "\t\t" << "VkSurfacePresentModeCompatibilityKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfacePresentModeKHR(std::ostream &out, const VkSurfacePresentModeKHR* structInfo, Decoded_VkSurfacePresentModeKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPresentModeKHR(" << structInfo->presentMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfacePresentModeKHR");
    out << "\t\t" << "VkSurfacePresentModeKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfacePresentScalingCapabilitiesKHR(std::ostream &out, const VkSurfacePresentScalingCapabilitiesKHR* structInfo, Decoded_VkSurfacePresentScalingCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string min_scaled_image_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                             &structInfo->minScaledImageExtent,
                                                                             metaInfo->minScaledImageExtent,
                                                                             consumer);
    std::string max_scaled_image_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                             &structInfo->maxScaledImageExtent,
                                                                             metaInfo->maxScaledImageExtent,
                                                                             consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPresentScalingFlagsKHR(" << structInfo->supportedPresentScaling << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPresentGravityFlagsKHR(" << structInfo->supportedPresentGravityX << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPresentGravityFlagsKHR(" << structInfo->supportedPresentGravityY << ")" << "," << std::endl;
    struct_body << "\t\t\t" << min_scaled_image_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_scaled_image_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfacePresentScalingCapabilitiesKHR");
    out << "\t\t" << "VkSurfacePresentScalingCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR(std::ostream &out, const VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->swapchainMaintenance1 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSwapchainMaintenance1FeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceSwapchainMaintenance1FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkReleaseSwapchainImagesInfoKHR(std::ostream &out, const VkReleaseSwapchainImagesInfoKHR* structInfo, Decoded_VkReleaseSwapchainImagesInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pimage_indices_array = "NULL";
    if (structInfo->pImageIndices != NULL) {
        pimage_indices_array = "pImageIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pimage_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pImageIndices, structInfo->imageIndexCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->swapchain) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageIndexCount << "," << std::endl;
    struct_body << "\t\t\t" << pimage_indices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "releaseSwapchainImagesInfoKHR");
    out << "\t\t" << "VkReleaseSwapchainImagesInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainPresentFenceInfoKHR(std::ostream &out, const VkSwapchainPresentFenceInfoKHR* structInfo, Decoded_VkSwapchainPresentFenceInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pfences_array = "NULL";
    if (metaInfo->pFences.GetPointer() != NULL && structInfo->swapchainCount > 0) {
        pfences_array = "pfences_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_FENCE));
        std::string pfences_values = toStringJoin(metaInfo->pFences.GetPointer(),
                                                  metaInfo->pFences.GetPointer() + structInfo->swapchainCount,
                                                  [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                  ", ");
        if (structInfo->swapchainCount == 1) {
            pfences_array = "&" + pfences_values;
        } else if (structInfo->swapchainCount > 1) {
            out << "\t\t" << "VkFence " << pfences_array << "[] = {" << pfences_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->swapchainCount << "," << std::endl;
    struct_body << "\t\t\t" << pfences_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainPresentFenceInfoKHR");
    out << "\t\t" << "VkSwapchainPresentFenceInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainPresentModeInfoKHR(std::ostream &out, const VkSwapchainPresentModeInfoKHR* structInfo, Decoded_VkSwapchainPresentModeInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppresent_modes_values;
    std::string ppresent_modes_array = "NULL";
    if (structInfo->pPresentModes != NULL) {
        for (uint32_t idx = 0; idx < structInfo->swapchainCount; idx++) {
            ppresent_modes_values += util::ToString<VkPresentModeKHR>(structInfo->pPresentModes[idx]) + ", ";
        }
        ppresent_modes_array = "pPresentModes_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkPresentModeKHR " << ppresent_modes_array << "[] = {" << ppresent_modes_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->swapchainCount << "," << std::endl;
    struct_body << "\t\t\t" << ppresent_modes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainPresentModeInfoKHR");
    out << "\t\t" << "VkSwapchainPresentModeInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainPresentModesCreateInfoKHR(std::ostream &out, const VkSwapchainPresentModesCreateInfoKHR* structInfo, Decoded_VkSwapchainPresentModesCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppresent_modes_values;
    std::string ppresent_modes_array = "NULL";
    if (structInfo->pPresentModes != NULL) {
        for (uint32_t idx = 0; idx < structInfo->presentModeCount; idx++) {
            ppresent_modes_values += util::ToString<VkPresentModeKHR>(structInfo->pPresentModes[idx]) + ", ";
        }
        ppresent_modes_array = "pPresentModes_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkPresentModeKHR " << ppresent_modes_array << "[] = {" << ppresent_modes_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentModeCount << "," << std::endl;
    struct_body << "\t\t\t" << ppresent_modes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainPresentModesCreateInfoKHR");
    out << "\t\t" << "VkSwapchainPresentModesCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainPresentScalingCreateInfoKHR(std::ostream &out, const VkSwapchainPresentScalingCreateInfoKHR* structInfo, Decoded_VkSwapchainPresentScalingCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPresentScalingFlagsKHR(" << structInfo->scalingBehavior << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPresentGravityFlagsKHR(" << structInfo->presentGravityX << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPresentGravityFlagsKHR(" << structInfo->presentGravityY << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainPresentScalingCreateInfoKHR");
    out << "\t\t" << "VkSwapchainPresentScalingCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCooperativeMatrixPropertiesKHR(std::ostream &out, const VkCooperativeMatrixPropertiesKHR* structInfo, Decoded_VkCooperativeMatrixPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->MSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->NSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->KSize << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->AType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->BType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->CType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->ResultType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->saturatingAccumulation << "," << std::endl;
    struct_body << "\t\t\t" << "VkScopeKHR(" << structInfo->scope << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "cooperativeMatrixPropertiesKHR");
    out << "\t\t" << "VkCooperativeMatrixPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(std::ostream &out, const VkPhysicalDeviceCooperativeMatrixFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeMatrix << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeMatrixRobustBufferAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCooperativeMatrixFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceCooperativeMatrixFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(std::ostream &out, const VkPhysicalDeviceCooperativeMatrixPropertiesKHR* structInfo, Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->cooperativeMatrixSupportedStages << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCooperativeMatrixPropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceCooperativeMatrixPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR(std::ostream &out, const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->computeDerivativeGroupQuads << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->computeDerivativeGroupLinear << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceComputeShaderDerivativesFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR(std::ostream &out, const VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR* structInfo, Decoded_VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->meshAndTaskShaderDerivatives << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceComputeShaderDerivativesPropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceComputeShaderDerivativesPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeAV1CapabilitiesKHR(std::ostream &out, const VkVideoDecodeAV1CapabilitiesKHR* structInfo, Decoded_VkVideoDecodeAV1CapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1Level(" << structInfo->maxLevel << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeAV1CapabilitiesKHR");
    out << "\t\t" << "VkVideoDecodeAV1CapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeAV1DpbSlotInfoKHR(std::ostream &out, const VkVideoDecodeAV1DpbSlotInfoKHR* structInfo, Decoded_VkVideoDecodeAV1DpbSlotInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_reference_info_struct = "NULL";
    if (structInfo->pStdReferenceInfo != NULL) {
        pstd_reference_info_struct = GenerateStruct_StdVideoDecodeAV1ReferenceInfo(out,
                                                                                   structInfo->pStdReferenceInfo,
                                                                                   metaInfo->pStdReferenceInfo->GetMetaStructPointer(),
                                                                                   consumer);
        pstd_reference_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pstd_reference_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeAV1DpbSlotInfoKHR");
    out << "\t\t" << "VkVideoDecodeAV1DpbSlotInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeAV1PictureInfoKHR(std::ostream &out, const VkVideoDecodeAV1PictureInfoKHR* structInfo, Decoded_VkVideoDecodeAV1PictureInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_picture_info_struct = "NULL";
    if (structInfo->pStdPictureInfo != NULL) {
        pstd_picture_info_struct = GenerateStruct_StdVideoDecodeAV1PictureInfo(out,
                                                                               structInfo->pStdPictureInfo,
                                                                               metaInfo->pStdPictureInfo->GetMetaStructPointer(),
                                                                               consumer);
        pstd_picture_info_struct.insert(0, "&");
    }
    std::string ptile_offsets_array = "NULL";
    if (structInfo->pTileOffsets != NULL) {
        ptile_offsets_array = "pTileOffsets_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << ptile_offsets_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pTileOffsets, structInfo->tileCount) << ";" << std::endl;
    }
    std::string ptile_sizes_array = "NULL";
    if (structInfo->pTileSizes != NULL) {
        ptile_sizes_array = "pTileSizes_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << ptile_sizes_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pTileSizes, structInfo->tileCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pstd_picture_info_struct << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int32_t*>(&structInfo->referenceNameSlotIndices[0]), VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frameHeaderOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileCount << "," << std::endl;
    struct_body << "\t\t\t" << ptile_offsets_array << "," << std::endl;
    struct_body << "\t\t\t" << ptile_sizes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeAV1PictureInfoKHR");
    out << "\t\t" << "VkVideoDecodeAV1PictureInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeAV1ProfileInfoKHR(std::ostream &out, const VkVideoDecodeAV1ProfileInfoKHR* structInfo, Decoded_VkVideoDecodeAV1ProfileInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1Profile(" << structInfo->stdProfile << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->filmGrainSupport << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeAV1ProfileInfoKHR");
    out << "\t\t" << "VkVideoDecodeAV1ProfileInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeAV1SessionParametersCreateInfoKHR(std::ostream &out, const VkVideoDecodeAV1SessionParametersCreateInfoKHR* structInfo, Decoded_VkVideoDecodeAV1SessionParametersCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_sequence_header_struct = "NULL";
    if (structInfo->pStdSequenceHeader != NULL) {
        pstd_sequence_header_struct = GenerateStruct_StdVideoAV1SequenceHeader(out,
                                                                               structInfo->pStdSequenceHeader,
                                                                               metaInfo->pStdSequenceHeader->GetMetaStructPointer(),
                                                                               consumer);
        pstd_sequence_header_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pstd_sequence_header_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeAV1SessionParametersCreateInfoKHR");
    out << "\t\t" << "VkVideoDecodeAV1SessionParametersCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR(std::ostream &out, const VkPhysicalDeviceVideoEncodeAV1FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceVideoEncodeAV1FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->videoEncodeAV1 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVideoEncodeAV1FeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceVideoEncodeAV1FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeAV1CapabilitiesKHR(std::ostream &out, const VkVideoEncodeAV1CapabilitiesKHR* structInfo, Decoded_VkVideoEncodeAV1CapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string coded_picture_alignment_info_var = GenerateStruct_VkExtent2D(out,
                                                                             &structInfo->codedPictureAlignment,
                                                                             metaInfo->codedPictureAlignment,
                                                                             consumer);
    std::string max_tiles_info_var = GenerateStruct_VkExtent2D(out,
                                                               &structInfo->maxTiles,
                                                               metaInfo->maxTiles,
                                                               consumer);
    std::string min_tile_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                   &structInfo->minTileSize,
                                                                   metaInfo->minTileSize,
                                                                   consumer);
    std::string max_tile_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                   &structInfo->maxTileSize,
                                                                   metaInfo->maxTileSize,
                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeAV1CapabilityFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1Level(" << structInfo->maxLevel << ")" << "," << std::endl;
    struct_body << "\t\t\t" << coded_picture_alignment_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_tiles_info_var << "," << std::endl;
    struct_body << "\t\t\t" << min_tile_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_tile_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeAV1SuperblockSizeFlagsKHR(" << structInfo->superblockSizes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSingleReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->singleReferenceNameMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxUnidirectionalCompoundReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxUnidirectionalCompoundGroup1ReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->unidirectionalCompoundReferenceNameMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxBidirectionalCompoundReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxBidirectionalCompoundGroup1ReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxBidirectionalCompoundGroup2ReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bidirectionalCompoundReferenceNameMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTemporalLayerCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSpatialLayerCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxOperatingPoints << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minQIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxQIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->prefersGopRemainingFrames << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->requiresGopRemainingFrames << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeAV1StdFlagsKHR(" << structInfo->stdSyntaxFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeAV1CapabilitiesKHR");
    out << "\t\t" << "VkVideoEncodeAV1CapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeAV1DpbSlotInfoKHR(std::ostream &out, const VkVideoEncodeAV1DpbSlotInfoKHR* structInfo, Decoded_VkVideoEncodeAV1DpbSlotInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_reference_info_struct = "NULL";
    if (structInfo->pStdReferenceInfo != NULL) {
        pstd_reference_info_struct = GenerateStruct_StdVideoEncodeAV1ReferenceInfo(out,
                                                                                   structInfo->pStdReferenceInfo,
                                                                                   metaInfo->pStdReferenceInfo->GetMetaStructPointer(),
                                                                                   consumer);
        pstd_reference_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pstd_reference_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeAV1DpbSlotInfoKHR");
    out << "\t\t" << "VkVideoEncodeAV1DpbSlotInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeAV1FrameSizeKHR(std::ostream &out, const VkVideoEncodeAV1FrameSizeKHR* structInfo, Decoded_VkVideoEncodeAV1FrameSizeKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->intraFrameSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->predictiveFrameSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bipredictiveFrameSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeAV1FrameSizeKHR");
    out << "\t\t" << "VkVideoEncodeAV1FrameSizeKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeAV1GopRemainingFrameInfoKHR(std::ostream &out, const VkVideoEncodeAV1GopRemainingFrameInfoKHR* structInfo, Decoded_VkVideoEncodeAV1GopRemainingFrameInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->useGopRemainingFrames << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->gopRemainingIntra << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->gopRemainingPredictive << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->gopRemainingBipredictive << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeAV1GopRemainingFrameInfoKHR");
    out << "\t\t" << "VkVideoEncodeAV1GopRemainingFrameInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeAV1PictureInfoKHR(std::ostream &out, const VkVideoEncodeAV1PictureInfoKHR* structInfo, Decoded_VkVideoEncodeAV1PictureInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_picture_info_struct = "NULL";
    if (structInfo->pStdPictureInfo != NULL) {
        pstd_picture_info_struct = GenerateStruct_StdVideoEncodeAV1PictureInfo(out,
                                                                               structInfo->pStdPictureInfo,
                                                                               metaInfo->pStdPictureInfo->GetMetaStructPointer(),
                                                                               consumer);
        pstd_picture_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeAV1PredictionModeKHR(" << structInfo->predictionMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeAV1RateControlGroupKHR(" << structInfo->rateControlGroup << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->constantQIndex << "," << std::endl;
    struct_body << "\t\t\t" << pstd_picture_info_struct << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int32_t*>(&structInfo->referenceNameSlotIndices[0]), VK_MAX_VIDEO_AV1_REFERENCES_PER_FRAME_KHR) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primaryReferenceCdfOnly << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->generateObuExtensionHeader << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeAV1PictureInfoKHR");
    out << "\t\t" << "VkVideoEncodeAV1PictureInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeAV1ProfileInfoKHR(std::ostream &out, const VkVideoEncodeAV1ProfileInfoKHR* structInfo, Decoded_VkVideoEncodeAV1ProfileInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1Profile(" << structInfo->stdProfile << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeAV1ProfileInfoKHR");
    out << "\t\t" << "VkVideoEncodeAV1ProfileInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeAV1QIndexKHR(std::ostream &out, const VkVideoEncodeAV1QIndexKHR* structInfo, Decoded_VkVideoEncodeAV1QIndexKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->intraQIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->predictiveQIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bipredictiveQIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeAV1QIndexKHR");
    out << "\t\t" << "VkVideoEncodeAV1QIndexKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeAV1QualityLevelPropertiesKHR(std::ostream &out, const VkVideoEncodeAV1QualityLevelPropertiesKHR* structInfo, Decoded_VkVideoEncodeAV1QualityLevelPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string preferred_constant_q_index_info_var = GenerateStruct_VkVideoEncodeAV1QIndexKHR(out,
                                                                                               &structInfo->preferredConstantQIndex,
                                                                                               metaInfo->preferredConstantQIndex,
                                                                                               consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeAV1RateControlFlagsKHR(" << structInfo->preferredRateControlFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredGopFrameCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredKeyFramePeriod << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredConsecutiveBipredictiveFrameCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredTemporalLayerCount << "," << std::endl;
    struct_body << "\t\t\t" << preferred_constant_q_index_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredMaxSingleReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredSingleReferenceNameMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredMaxUnidirectionalCompoundReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredMaxUnidirectionalCompoundGroup1ReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredUnidirectionalCompoundReferenceNameMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredMaxBidirectionalCompoundReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredMaxBidirectionalCompoundGroup1ReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredMaxBidirectionalCompoundGroup2ReferenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferredBidirectionalCompoundReferenceNameMask << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeAV1QualityLevelPropertiesKHR");
    out << "\t\t" << "VkVideoEncodeAV1QualityLevelPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeAV1RateControlInfoKHR(std::ostream &out, const VkVideoEncodeAV1RateControlInfoKHR* structInfo, Decoded_VkVideoEncodeAV1RateControlInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeAV1RateControlFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->gopFrameCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->keyFramePeriod << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->consecutiveBipredictiveFrameCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->temporalLayerCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeAV1RateControlInfoKHR");
    out << "\t\t" << "VkVideoEncodeAV1RateControlInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeAV1RateControlLayerInfoKHR(std::ostream &out, const VkVideoEncodeAV1RateControlLayerInfoKHR* structInfo, Decoded_VkVideoEncodeAV1RateControlLayerInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string min_q_index_info_var = GenerateStruct_VkVideoEncodeAV1QIndexKHR(out,
                                                                                &structInfo->minQIndex,
                                                                                metaInfo->minQIndex,
                                                                                consumer);
    std::string max_q_index_info_var = GenerateStruct_VkVideoEncodeAV1QIndexKHR(out,
                                                                                &structInfo->maxQIndex,
                                                                                metaInfo->maxQIndex,
                                                                                consumer);
    std::string max_frame_size_info_var = GenerateStruct_VkVideoEncodeAV1FrameSizeKHR(out,
                                                                                      &structInfo->maxFrameSize,
                                                                                      metaInfo->maxFrameSize,
                                                                                      consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->useMinQIndex << "," << std::endl;
    struct_body << "\t\t\t" << min_q_index_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->useMaxQIndex << "," << std::endl;
    struct_body << "\t\t\t" << max_q_index_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->useMaxFrameSize << "," << std::endl;
    struct_body << "\t\t\t" << max_frame_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeAV1RateControlLayerInfoKHR");
    out << "\t\t" << "VkVideoEncodeAV1RateControlLayerInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeAV1SessionCreateInfoKHR(std::ostream &out, const VkVideoEncodeAV1SessionCreateInfoKHR* structInfo, Decoded_VkVideoEncodeAV1SessionCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->useMaxLevel << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoAV1Level(" << structInfo->maxLevel << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeAV1SessionCreateInfoKHR");
    out << "\t\t" << "VkVideoEncodeAV1SessionCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeAV1SessionParametersCreateInfoKHR(std::ostream &out, const VkVideoEncodeAV1SessionParametersCreateInfoKHR* structInfo, Decoded_VkVideoEncodeAV1SessionParametersCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_sequence_header_struct = "NULL";
    if (structInfo->pStdSequenceHeader != NULL) {
        pstd_sequence_header_struct = GenerateStruct_StdVideoAV1SequenceHeader(out,
                                                                               structInfo->pStdSequenceHeader,
                                                                               metaInfo->pStdSequenceHeader->GetMetaStructPointer(),
                                                                               consumer);
        pstd_sequence_header_struct.insert(0, "&");
    }
    std::string pstd_decoder_model_info_struct = "NULL";
    if (structInfo->pStdDecoderModelInfo != NULL) {
        pstd_decoder_model_info_struct = GenerateStruct_StdVideoEncodeAV1DecoderModelInfo(out,
                                                                                          structInfo->pStdDecoderModelInfo,
                                                                                          metaInfo->pStdDecoderModelInfo->GetMetaStructPointer(),
                                                                                          consumer);
        pstd_decoder_model_info_struct.insert(0, "&");
    }
    std::string pstd_operating_points_array = "NULL";
    if (structInfo->pStdOperatingPoints != NULL) {
        pstd_operating_points_array = "pStdOperatingPoints_" + std::to_string(consumer.GetNextId());
        std::string pstd_operating_points_names;
        for (uint32_t idx = 0; idx < structInfo->stdOperatingPointCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStdOperatingPoints + idx != NULL) {
                variable_name = GenerateStruct_StdVideoEncodeAV1OperatingPointInfo(out,
                                                                                   structInfo->pStdOperatingPoints + idx,
                                                                                   metaInfo->pStdOperatingPoints->GetMetaStructPointer() + idx,
                                                                                   consumer);
            }
            pstd_operating_points_names += variable_name + ", ";
        }
        out << "\t\t" << "StdVideoEncodeAV1OperatingPointInfo " << pstd_operating_points_array << "[] = {" << pstd_operating_points_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pstd_sequence_header_struct << "," << std::endl;
    struct_body << "\t\t\t" << pstd_decoder_model_info_struct << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stdOperatingPointCount << "," << std::endl;
    struct_body << "\t\t\t" << pstd_operating_points_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeAV1SessionParametersCreateInfoKHR");
    out << "\t\t" << "VkVideoEncodeAV1SessionParametersCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR(std::ostream &out, const VkPhysicalDeviceVideoDecodeVP9FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceVideoDecodeVP9FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->videoDecodeVP9 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVideoDecodeVP9FeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceVideoDecodeVP9FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeVP9CapabilitiesKHR(std::ostream &out, const VkVideoDecodeVP9CapabilitiesKHR* structInfo, Decoded_VkVideoDecodeVP9CapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoVP9Level(" << structInfo->maxLevel << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeVP9CapabilitiesKHR");
    out << "\t\t" << "VkVideoDecodeVP9CapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeVP9PictureInfoKHR(std::ostream &out, const VkVideoDecodeVP9PictureInfoKHR* structInfo, Decoded_VkVideoDecodeVP9PictureInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstd_picture_info_struct = "NULL";
    if (structInfo->pStdPictureInfo != NULL) {
        pstd_picture_info_struct = GenerateStruct_StdVideoDecodeVP9PictureInfo(out,
                                                                               structInfo->pStdPictureInfo,
                                                                               metaInfo->pStdPictureInfo->GetMetaStructPointer(),
                                                                               consumer);
        pstd_picture_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pstd_picture_info_struct << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int32_t*>(&structInfo->referenceNameSlotIndices[0]), VK_MAX_VIDEO_VP9_REFERENCES_PER_FRAME_KHR) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->uncompressedHeaderOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->compressedHeaderOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tilesOffset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeVP9PictureInfoKHR");
    out << "\t\t" << "VkVideoDecodeVP9PictureInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoDecodeVP9ProfileInfoKHR(std::ostream &out, const VkVideoDecodeVP9ProfileInfoKHR* structInfo, Decoded_VkVideoDecodeVP9ProfileInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "StdVideoVP9Profile(" << structInfo->stdProfile << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoDecodeVP9ProfileInfoKHR");
    out << "\t\t" << "VkVideoDecodeVP9ProfileInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVideoMaintenance1FeaturesKHR(std::ostream &out, const VkPhysicalDeviceVideoMaintenance1FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceVideoMaintenance1FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->videoMaintenance1 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVideoMaintenance1FeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceVideoMaintenance1FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoInlineQueryInfoKHR(std::ostream &out, const VkVideoInlineQueryInfoKHR* structInfo, Decoded_VkVideoInlineQueryInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->queryPool) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->firstQuery << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queryCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoInlineQueryInfoKHR");
    out << "\t\t" << "VkVideoInlineQueryInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentFeedbackLoopInfoEXT(std::ostream &out, const VkAttachmentFeedbackLoopInfoEXT* structInfo, Decoded_VkAttachmentFeedbackLoopInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->feedbackLoopEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentFeedbackLoopInfoEXT");
    out << "\t\t" << "VkAttachmentFeedbackLoopInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR(std::ostream &out, const VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->unifiedImageLayouts << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->unifiedImageLayoutsVideo << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceUnifiedImageLayoutsFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceUnifiedImageLayoutsFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCalibratedTimestampInfoKHR(std::ostream &out, const VkCalibratedTimestampInfoKHR* structInfo, Decoded_VkCalibratedTimestampInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkTimeDomainKHR(" << structInfo->timeDomain << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "calibratedTimestampInfoKHR");
    out << "\t\t" << "VkCalibratedTimestampInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindDescriptorBufferEmbeddedSamplersInfoEXT(std::ostream &out, const VkBindDescriptorBufferEmbeddedSamplersInfoEXT* structInfo, Decoded_VkBindDescriptorBufferEmbeddedSamplersInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->stageFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->layout) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->set << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindDescriptorBufferEmbeddedSamplersInfoEXT");
    out << "\t\t" << "VkBindDescriptorBufferEmbeddedSamplersInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSetDescriptorBufferOffsetsInfoEXT(std::ostream &out, const VkSetDescriptorBufferOffsetsInfoEXT* structInfo, Decoded_VkSetDescriptorBufferOffsetsInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pbuffer_indices_array = "NULL";
    if (structInfo->pBufferIndices != NULL) {
        pbuffer_indices_array = "pBufferIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pbuffer_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pBufferIndices, structInfo->setCount) << ";" << std::endl;
    }
    std::string poffsets_array = "poffsets_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->setCount > 0) {
        std::string poffsets_values = toStringJoin(structInfo->pOffsets,
                                                   structInfo->pOffsets + structInfo->setCount,
                                                   [](VkDeviceSize current) { return std::to_string(current); },
                                                   ", ");
        if (structInfo->setCount == 1) {
            poffsets_array = "&" + poffsets_values;
        } else if (structInfo->setCount > 1) {
            out << "\t\t" << "VkDeviceSize " << poffsets_array << "[] = {" << poffsets_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->stageFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->layout) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->firstSet << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->setCount << "," << std::endl;
    struct_body << "\t\t\t" << pbuffer_indices_array << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << poffsets_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "setDescriptorBufferOffsetsInfoEXT");
    out << "\t\t" << "VkSetDescriptorBufferOffsetsInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyMemoryIndirectCommandKHR(std::ostream &out, const VkCopyMemoryIndirectCommandKHR* structInfo, Decoded_VkCopyMemoryIndirectCommandKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->srcAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyMemoryIndirectCommandKHR");
    out << "\t\t" << "VkCopyMemoryIndirectCommandKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyMemoryIndirectInfoKHR(std::ostream &out, const VkCopyMemoryIndirectInfoKHR* structInfo, Decoded_VkCopyMemoryIndirectInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string copy_address_range_info_var = GenerateStruct_VkStridedDeviceAddressRangeKHR(out,
                                                                                            &structInfo->copyAddressRange,
                                                                                            metaInfo->copyAddressRange,
                                                                                            consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAddressCopyFlagsKHR(" << structInfo->srcCopyFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAddressCopyFlagsKHR(" << structInfo->dstCopyFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->copyCount << "," << std::endl;
    struct_body << "\t\t\t" << copy_address_range_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyMemoryIndirectInfoKHR");
    out << "\t\t" << "VkCopyMemoryIndirectInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyMemoryToImageIndirectCommandKHR(std::ostream &out, const VkCopyMemoryToImageIndirectCommandKHR* structInfo, Decoded_VkCopyMemoryToImageIndirectCommandKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string image_subresource_info_var = GenerateStruct_VkImageSubresourceLayers(out,
                                                                                     &structInfo->imageSubresource,
                                                                                     metaInfo->imageSubresource,
                                                                                     consumer);
    std::string image_offset_info_var = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->imageOffset,
                                                                  metaInfo->imageOffset,
                                                                  consumer);
    std::string image_extent_info_var = GenerateStruct_VkExtent3D(out,
                                                                  &structInfo->imageExtent,
                                                                  metaInfo->imageExtent,
                                                                  consumer);
    struct_body << "\t" << structInfo->srcAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferRowLength << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferImageHeight << "," << std::endl;
    struct_body << "\t\t\t" << image_subresource_info_var << "," << std::endl;
    struct_body << "\t\t\t" << image_offset_info_var << "," << std::endl;
    struct_body << "\t\t\t" << image_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyMemoryToImageIndirectCommandKHR");
    out << "\t\t" << "VkCopyMemoryToImageIndirectCommandKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyMemoryToImageIndirectInfoKHR(std::ostream &out, const VkCopyMemoryToImageIndirectInfoKHR* structInfo, Decoded_VkCopyMemoryToImageIndirectInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string copy_address_range_info_var = GenerateStruct_VkStridedDeviceAddressRangeKHR(out,
                                                                                            &structInfo->copyAddressRange,
                                                                                            metaInfo->copyAddressRange,
                                                                                            consumer);
    std::string pimage_subresources_array = "NULL";
    if (structInfo->pImageSubresources != NULL) {
        pimage_subresources_array = "pImageSubresources_" + std::to_string(consumer.GetNextId());
        std::string pimage_subresources_names;
        for (uint32_t idx = 0; idx < structInfo->copyCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pImageSubresources + idx != NULL) {
                variable_name = GenerateStruct_VkImageSubresourceLayers(out,
                                                                        structInfo->pImageSubresources + idx,
                                                                        metaInfo->pImageSubresources->GetMetaStructPointer() + idx,
                                                                        consumer);
            }
            pimage_subresources_names += variable_name + ", ";
        }
        out << "\t\t" << "VkImageSubresourceLayers " << pimage_subresources_array << "[] = {" << pimage_subresources_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAddressCopyFlagsKHR(" << structInfo->srcCopyFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->copyCount << "," << std::endl;
    struct_body << "\t\t\t" << copy_address_range_info_var << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstImage) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pimage_subresources_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyMemoryToImageIndirectInfoKHR");
    out << "\t\t" << "VkCopyMemoryToImageIndirectInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR(std::ostream &out, const VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indirectMemoryCopy << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indirectMemoryToImageCopy << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCopyMemoryIndirectFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceCopyMemoryIndirectFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR(std::ostream &out, const VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR* structInfo, Decoded_VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkQueueFlags(" << structInfo->supportedQueues << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCopyMemoryIndirectPropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceCopyMemoryIndirectPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkStridedDeviceAddressRangeKHR(std::ostream &out, const VkStridedDeviceAddressRangeKHR* structInfo, Decoded_VkStridedDeviceAddressRangeKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->address << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stride << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stridedDeviceAddressRangeKHR");
    out << "\t\t" << "VkStridedDeviceAddressRangeKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR(std::ostream &out, const VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->videoEncodeIntraRefresh << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVideoEncodeIntraRefreshFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceVideoEncodeIntraRefreshFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeIntraRefreshCapabilitiesKHR(std::ostream &out, const VkVideoEncodeIntraRefreshCapabilitiesKHR* structInfo, Decoded_VkVideoEncodeIntraRefreshCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeIntraRefreshModeFlagsKHR(" << structInfo->intraRefreshModes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxIntraRefreshCycleDuration << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxIntraRefreshActiveReferencePictures << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->partitionIndependentIntraRefreshRegions << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->nonRectangularIntraRefreshRegions << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeIntraRefreshCapabilitiesKHR");
    out << "\t\t" << "VkVideoEncodeIntraRefreshCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeIntraRefreshInfoKHR(std::ostream &out, const VkVideoEncodeIntraRefreshInfoKHR* structInfo, Decoded_VkVideoEncodeIntraRefreshInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->intraRefreshCycleDuration << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->intraRefreshIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeIntraRefreshInfoKHR");
    out << "\t\t" << "VkVideoEncodeIntraRefreshInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeSessionIntraRefreshCreateInfoKHR(std::ostream &out, const VkVideoEncodeSessionIntraRefreshCreateInfoKHR* structInfo, Decoded_VkVideoEncodeSessionIntraRefreshCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeIntraRefreshModeFlagBitsKHR(" << structInfo->intraRefreshMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeSessionIntraRefreshCreateInfoKHR");
    out << "\t\t" << "VkVideoEncodeSessionIntraRefreshCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoReferenceIntraRefreshInfoKHR(std::ostream &out, const VkVideoReferenceIntraRefreshInfoKHR* structInfo, Decoded_VkVideoReferenceIntraRefreshInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dirtyIntraRefreshRegions << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoReferenceIntraRefreshInfoKHR");
    out << "\t\t" << "VkVideoReferenceIntraRefreshInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR(std::ostream &out, const VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->videoEncodeQuantizationMap << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVideoEncodeQuantizationMapFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceVideoEncodeQuantizationMapFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR(std::ostream &out, const VkVideoEncodeAV1QuantizationMapCapabilitiesKHR* structInfo, Decoded_VkVideoEncodeAV1QuantizationMapCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minQIndexDelta << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxQIndexDelta << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeAV1QuantizationMapCapabilitiesKHR");
    out << "\t\t" << "VkVideoEncodeAV1QuantizationMapCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH264QuantizationMapCapabilitiesKHR(std::ostream &out, const VkVideoEncodeH264QuantizationMapCapabilitiesKHR* structInfo, Decoded_VkVideoEncodeH264QuantizationMapCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minQpDelta << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxQpDelta << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH264QuantizationMapCapabilitiesKHR");
    out << "\t\t" << "VkVideoEncodeH264QuantizationMapCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeH265QuantizationMapCapabilitiesKHR(std::ostream &out, const VkVideoEncodeH265QuantizationMapCapabilitiesKHR* structInfo, Decoded_VkVideoEncodeH265QuantizationMapCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minQpDelta << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxQpDelta << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeH265QuantizationMapCapabilitiesKHR");
    out << "\t\t" << "VkVideoEncodeH265QuantizationMapCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeQuantizationMapCapabilitiesKHR(std::ostream &out, const VkVideoEncodeQuantizationMapCapabilitiesKHR* structInfo, Decoded_VkVideoEncodeQuantizationMapCapabilitiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string max_quantization_map_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                                 &structInfo->maxQuantizationMapExtent,
                                                                                 metaInfo->maxQuantizationMapExtent,
                                                                                 consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << max_quantization_map_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeQuantizationMapCapabilitiesKHR");
    out << "\t\t" << "VkVideoEncodeQuantizationMapCapabilitiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeQuantizationMapInfoKHR(std::ostream &out, const VkVideoEncodeQuantizationMapInfoKHR* structInfo, Decoded_VkVideoEncodeQuantizationMapInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string quantization_map_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                             &structInfo->quantizationMapExtent,
                                                                             metaInfo->quantizationMapExtent,
                                                                             consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->quantizationMap) << "," << std::endl;
    struct_body << "\t\t\t" << quantization_map_extent_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeQuantizationMapInfoKHR");
    out << "\t\t" << "VkVideoEncodeQuantizationMapInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR(std::ostream &out, const VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR* structInfo, Decoded_VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string quantization_map_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                 &structInfo->quantizationMapTexelSize,
                                                                                 metaInfo->quantizationMapTexelSize,
                                                                                 consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << quantization_map_texel_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeQuantizationMapSessionParametersCreateInfoKHR");
    out << "\t\t" << "VkVideoEncodeQuantizationMapSessionParametersCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoFormatAV1QuantizationMapPropertiesKHR(std::ostream &out, const VkVideoFormatAV1QuantizationMapPropertiesKHR* structInfo, Decoded_VkVideoFormatAV1QuantizationMapPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeAV1SuperblockSizeFlagsKHR(" << structInfo->compatibleSuperblockSizes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoFormatAV1QuantizationMapPropertiesKHR");
    out << "\t\t" << "VkVideoFormatAV1QuantizationMapPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoFormatH265QuantizationMapPropertiesKHR(std::ostream &out, const VkVideoFormatH265QuantizationMapPropertiesKHR* structInfo, Decoded_VkVideoFormatH265QuantizationMapPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeH265CtbSizeFlagsKHR(" << structInfo->compatibleCtbSizes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoFormatH265QuantizationMapPropertiesKHR");
    out << "\t\t" << "VkVideoFormatH265QuantizationMapPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoFormatQuantizationMapPropertiesKHR(std::ostream &out, const VkVideoFormatQuantizationMapPropertiesKHR* structInfo, Decoded_VkVideoFormatQuantizationMapPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string quantization_map_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                 &structInfo->quantizationMapTexelSize,
                                                                                 metaInfo->quantizationMapTexelSize,
                                                                                 consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << quantization_map_texel_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoFormatQuantizationMapPropertiesKHR");
    out << "\t\t" << "VkVideoFormatQuantizationMapPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR(std::ostream &out, const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderRelaxedExtendedInstruction << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLayeredApiPropertiesKHR(std::ostream &out, const VkPhysicalDeviceLayeredApiPropertiesKHR* structInfo, Decoded_VkPhysicalDeviceLayeredApiPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vendorID << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceID << "," << std::endl;
    struct_body << "\t\t\t" << "VkPhysicalDeviceLayeredApiKHR(" << structInfo->layeredAPI << ")" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->deviceName) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLayeredApiPropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceLayeredApiPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLayeredApiPropertiesListKHR(std::ostream &out, const VkPhysicalDeviceLayeredApiPropertiesListKHR* structInfo, Decoded_VkPhysicalDeviceLayeredApiPropertiesListKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string playered_apis_array = "NULL";
    if (structInfo->pLayeredApis != NULL) {
        playered_apis_array = "pLayeredApis_" + std::to_string(consumer.GetNextId());
        std::string playered_apis_names;
        for (uint32_t idx = 0; idx < structInfo->layeredApiCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pLayeredApis + idx != NULL) {
                variable_name = GenerateStruct_VkPhysicalDeviceLayeredApiPropertiesKHR(out,
                                                                                       structInfo->pLayeredApis + idx,
                                                                                       metaInfo->pLayeredApis->GetMetaStructPointer() + idx,
                                                                                       consumer);
            }
            playered_apis_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPhysicalDeviceLayeredApiPropertiesKHR " << playered_apis_array << "[] = {" << playered_apis_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->layeredApiCount << "," << std::endl;
    struct_body << "\t\t\t" << playered_apis_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLayeredApiPropertiesListKHR");
    out << "\t\t" << "VkPhysicalDeviceLayeredApiPropertiesListKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR(std::ostream &out, const VkPhysicalDeviceLayeredApiVulkanPropertiesKHR* structInfo, Decoded_VkPhysicalDeviceLayeredApiVulkanPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string properties_info_var = GenerateStruct_VkPhysicalDeviceProperties2(out,
                                                                                 &structInfo->properties,
                                                                                 metaInfo->properties,
                                                                                 consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << properties_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLayeredApiVulkanPropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceLayeredApiVulkanPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance7FeaturesKHR(std::ostream &out, const VkPhysicalDeviceMaintenance7FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceMaintenance7FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maintenance7 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance7FeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceMaintenance7FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance7PropertiesKHR(std::ostream &out, const VkPhysicalDeviceMaintenance7PropertiesKHR* structInfo, Decoded_VkPhysicalDeviceMaintenance7PropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->robustFragmentShadingRateAttachmentAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->separateDepthStencilAttachmentAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetTotalUniformBuffersDynamic << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetTotalStorageBuffersDynamic << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetTotalBuffersDynamic << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindTotalUniformBuffersDynamic << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindTotalStorageBuffersDynamic << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindTotalBuffersDynamic << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance7PropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceMaintenance7PropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryBarrierAccessFlags3KHR(std::ostream &out, const VkMemoryBarrierAccessFlags3KHR* structInfo, Decoded_VkMemoryBarrierAccessFlags3KHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags3KHR(" << structInfo->srcAccessMask3 << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccessFlags3KHR(" << structInfo->dstAccessMask3 << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryBarrierAccessFlags3KHR");
    out << "\t\t" << "VkMemoryBarrierAccessFlags3KHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance8FeaturesKHR(std::ostream &out, const VkPhysicalDeviceMaintenance8FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceMaintenance8FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maintenance8 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance8FeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceMaintenance8FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderFmaFeaturesKHR(std::ostream &out, const VkPhysicalDeviceShaderFmaFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceShaderFmaFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderFmaFloat16 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderFmaFloat32 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderFmaFloat64 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderFmaFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceShaderFmaFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance9FeaturesKHR(std::ostream &out, const VkPhysicalDeviceMaintenance9FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceMaintenance9FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maintenance9 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance9FeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceMaintenance9FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance9PropertiesKHR(std::ostream &out, const VkPhysicalDeviceMaintenance9PropertiesKHR* structInfo, Decoded_VkPhysicalDeviceMaintenance9PropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->image2DViewOf3DSparse << "," << std::endl;
    struct_body << "\t\t\t" << "VkDefaultVertexAttributeValueKHR(" << structInfo->defaultVertexAttributeValue << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance9PropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceMaintenance9PropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyOwnershipTransferPropertiesKHR(std::ostream &out, const VkQueueFamilyOwnershipTransferPropertiesKHR* structInfo, Decoded_VkQueueFamilyOwnershipTransferPropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->optimalImageTransferToQueueFamilies << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyOwnershipTransferPropertiesKHR");
    out << "\t\t" << "VkQueueFamilyOwnershipTransferPropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR(std::ostream &out, const VkPhysicalDeviceDepthClampZeroOneFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceDepthClampZeroOneFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthClampZeroOne << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDepthClampZeroOneFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceDepthClampZeroOneFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRobustness2FeaturesKHR(std::ostream &out, const VkPhysicalDeviceRobustness2FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceRobustness2FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->robustBufferAccess2 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->robustImageAccess2 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->nullDescriptor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRobustness2FeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceRobustness2FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRobustness2PropertiesKHR(std::ostream &out, const VkPhysicalDeviceRobustness2PropertiesKHR* structInfo, Decoded_VkPhysicalDeviceRobustness2PropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->robustStorageBufferAccessSizeAlignment << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->robustUniformBufferAccessSizeAlignment << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRobustness2PropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceRobustness2PropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR(std::ostream &out, const VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentModeFifoLatestReady << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePresentModeFifoLatestReadyFeaturesKHR");
    out << "\t\t" << "VkPhysicalDevicePresentModeFifoLatestReadyFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance10FeaturesKHR(std::ostream &out, const VkPhysicalDeviceMaintenance10FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceMaintenance10FeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maintenance10 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance10FeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceMaintenance10FeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance10PropertiesKHR(std::ostream &out, const VkPhysicalDeviceMaintenance10PropertiesKHR* structInfo, Decoded_VkPhysicalDeviceMaintenance10PropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rgba4OpaqueBlackSwizzled << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->resolveSrgbFormatAppliesTransferFunction << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->resolveSrgbFormatSupportsTransferFunctionControl << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMaintenance10PropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceMaintenance10PropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderingAttachmentFlagsInfoKHR(std::ostream &out, const VkRenderingAttachmentFlagsInfoKHR* structInfo, Decoded_VkRenderingAttachmentFlagsInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkRenderingAttachmentFlagsKHR(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderingAttachmentFlagsInfoKHR");
    out << "\t\t" << "VkRenderingAttachmentFlagsInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderingEndInfoKHR(std::ostream &out, const VkRenderingEndInfoKHR* structInfo, Decoded_VkRenderingEndInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderingEndInfoKHR");
    out << "\t\t" << "VkRenderingEndInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkResolveImageModeInfoKHR(std::ostream &out, const VkResolveImageModeInfoKHR* structInfo, Decoded_VkResolveImageModeInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkResolveImageFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkResolveModeFlagBits(" << structInfo->resolveMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkResolveModeFlagBits(" << structInfo->stencilResolveMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "resolveImageModeInfoKHR");
    out << "\t\t" << "VkResolveImageModeInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugReportCallbackCreateInfoEXT(std::ostream &out, const VkDebugReportCallbackCreateInfoEXT* structInfo, Decoded_VkDebugReportCallbackCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDebugReportFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pfnCallback << "," << std::endl;
    out << "\t\t" << "// TODO: Support pUserData (non-struct output) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "debugReportCallbackCreateInfoEXT");
    out << "\t\t" << "VkDebugReportCallbackCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRasterizationStateRasterizationOrderAMD(std::ostream &out, const VkPipelineRasterizationStateRasterizationOrderAMD* structInfo, Decoded_VkPipelineRasterizationStateRasterizationOrderAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkRasterizationOrderAMD(" << structInfo->rasterizationOrder << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRasterizationStateRasterizationOrderAMD");
    out << "\t\t" << "VkPipelineRasterizationStateRasterizationOrderAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugMarkerMarkerInfoEXT(std::ostream &out, const VkDebugMarkerMarkerInfoEXT* structInfo, Decoded_VkDebugMarkerMarkerInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pMarkerName) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->color[0]), 4) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "debugMarkerMarkerInfoEXT");
    out << "\t\t" << "VkDebugMarkerMarkerInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugMarkerObjectNameInfoEXT(std::ostream &out, const VkDebugMarkerObjectNameInfoEXT* structInfo, Decoded_VkDebugMarkerObjectNameInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDebugReportObjectTypeEXT(" << structInfo->objectType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->object << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pObjectName) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "debugMarkerObjectNameInfoEXT");
    out << "\t\t" << "VkDebugMarkerObjectNameInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugMarkerObjectTagInfoEXT(std::ostream &out, const VkDebugMarkerObjectTagInfoEXT* structInfo, Decoded_VkDebugMarkerObjectTagInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ptag_array = "NULL";
    if (structInfo->pTag != NULL) {
        std::string ptag_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->tagSize; ++idx0) {
            ptag_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pTag)[idx0]) + ", ";
        }
        ptag_array = "pTag_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << ptag_array << "[] = {" << ptag_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDebugReportObjectTypeEXT(" << structInfo->objectType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->object << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tagName << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tagSize << "," << std::endl;
    struct_body << "\t\t\t" << ptag_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "debugMarkerObjectTagInfoEXT");
    out << "\t\t" << "VkDebugMarkerObjectTagInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDedicatedAllocationBufferCreateInfoNV(std::ostream &out, const VkDedicatedAllocationBufferCreateInfoNV* structInfo, Decoded_VkDedicatedAllocationBufferCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dedicatedAllocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dedicatedAllocationBufferCreateInfoNV");
    out << "\t\t" << "VkDedicatedAllocationBufferCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDedicatedAllocationImageCreateInfoNV(std::ostream &out, const VkDedicatedAllocationImageCreateInfoNV* structInfo, Decoded_VkDedicatedAllocationImageCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dedicatedAllocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dedicatedAllocationImageCreateInfoNV");
    out << "\t\t" << "VkDedicatedAllocationImageCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDedicatedAllocationMemoryAllocateInfoNV(std::ostream &out, const VkDedicatedAllocationMemoryAllocateInfoNV* structInfo, Decoded_VkDedicatedAllocationMemoryAllocateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->image) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dedicatedAllocationMemoryAllocateInfoNV");
    out << "\t\t" << "VkDedicatedAllocationMemoryAllocateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTransformFeedbackFeaturesEXT(std::ostream &out, const VkPhysicalDeviceTransformFeedbackFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->transformFeedback << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->geometryStreams << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTransformFeedbackFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceTransformFeedbackFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTransformFeedbackPropertiesEXT(std::ostream &out, const VkPhysicalDeviceTransformFeedbackPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTransformFeedbackStreams << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTransformFeedbackBuffers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTransformFeedbackBufferSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTransformFeedbackStreamDataSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTransformFeedbackBufferDataSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTransformFeedbackBufferDataStride << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->transformFeedbackQueries << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->transformFeedbackStreamsLinesTriangles << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->transformFeedbackRasterizationStreamSelect << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->transformFeedbackDraw << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTransformFeedbackPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceTransformFeedbackPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRasterizationStateStreamCreateInfoEXT(std::ostream &out, const VkPipelineRasterizationStateStreamCreateInfoEXT* structInfo, Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRasterizationStateStreamCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rasterizationStream << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRasterizationStateStreamCreateInfoEXT");
    out << "\t\t" << "VkPipelineRasterizationStateStreamCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewAddressPropertiesNVX(std::ostream &out, const VkImageViewAddressPropertiesNVX* structInfo, Decoded_VkImageViewAddressPropertiesNVX* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewAddressPropertiesNVX");
    out << "\t\t" << "VkImageViewAddressPropertiesNVX " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewHandleInfoNVX(std::ostream &out, const VkImageViewHandleInfoNVX* structInfo, Decoded_VkImageViewHandleInfoNVX* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->imageView) << "," << std::endl;
    struct_body << "\t\t\t" << "VkDescriptorType(" << structInfo->descriptorType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->sampler) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewHandleInfoNVX");
    out << "\t\t" << "VkImageViewHandleInfoNVX " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTextureLODGatherFormatPropertiesAMD(std::ostream &out, const VkTextureLODGatherFormatPropertiesAMD* structInfo, Decoded_VkTextureLODGatherFormatPropertiesAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->supportsTextureGatherLODBiasAMD << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "textureLODGatherFormatPropertiesAMD");
    out << "\t\t" << "VkTextureLODGatherFormatPropertiesAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkShaderResourceUsageAMD(std::ostream &out, const VkShaderResourceUsageAMD* structInfo, Decoded_VkShaderResourceUsageAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->numUsedVgprs << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->numUsedSgprs << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->ldsSizePerLocalWorkGroup << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->ldsUsageSizeInBytes << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->scratchMemUsageInBytes << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "shaderResourceUsageAMD");
    out << "\t\t" << "VkShaderResourceUsageAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkShaderStatisticsInfoAMD(std::ostream &out, const VkShaderStatisticsInfoAMD* structInfo, Decoded_VkShaderStatisticsInfoAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string resource_usage_info_var = GenerateStruct_VkShaderResourceUsageAMD(out,
                                                                                  &structInfo->resourceUsage,
                                                                                  metaInfo->resourceUsage,
                                                                                  consumer);
    struct_body << "\t" << "VkShaderStageFlags(" << structInfo->shaderStageMask << ")" << "," << std::endl;
    struct_body << "\t\t\t" << resource_usage_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->numPhysicalVgprs << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->numPhysicalSgprs << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->numAvailableVgprs << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->numAvailableSgprs << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->computeWorkGroupSize[0]), 3) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "shaderStatisticsInfoAMD");
    out << "\t\t" << "VkShaderStatisticsInfoAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkStreamDescriptorSurfaceCreateInfoGGP(std::ostream &out, const VkStreamDescriptorSurfaceCreateInfoGGP* structInfo, Decoded_VkStreamDescriptorSurfaceCreateInfoGGP* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkStreamDescriptorSurfaceCreateFlagsGGP(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->streamDescriptor << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "streamDescriptorSurfaceCreateInfoGGP");
    out << "\t\t" << "VkStreamDescriptorSurfaceCreateInfoGGP " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCornerSampledImageFeaturesNV(std::ostream &out, const VkPhysicalDeviceCornerSampledImageFeaturesNV* structInfo, Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cornerSampledImage << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCornerSampledImageFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceCornerSampledImageFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalImageFormatPropertiesNV(std::ostream &out, const VkExternalImageFormatPropertiesNV* structInfo, Decoded_VkExternalImageFormatPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string image_format_properties_info_var = GenerateStruct_VkImageFormatProperties(out,
                                                                                          &structInfo->imageFormatProperties,
                                                                                          metaInfo->imageFormatProperties,
                                                                                          consumer);
    struct_body << "\t" << image_format_properties_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryFeatureFlagsNV(" << structInfo->externalMemoryFeatures << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->exportFromImportedHandleTypes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->compatibleHandleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalImageFormatPropertiesNV");
    out << "\t\t" << "VkExternalImageFormatPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportMemoryAllocateInfoNV(std::ostream &out, const VkExportMemoryAllocateInfoNV* structInfo, Decoded_VkExportMemoryAllocateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->handleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportMemoryAllocateInfoNV");
    out << "\t\t" << "VkExportMemoryAllocateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalMemoryImageCreateInfoNV(std::ostream &out, const VkExternalMemoryImageCreateInfoNV* structInfo, Decoded_VkExternalMemoryImageCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->handleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalMemoryImageCreateInfoNV");
    out << "\t\t" << "VkExternalMemoryImageCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExportMemoryWin32HandleInfoNV(std::ostream &out, const VkExportMemoryWin32HandleInfoNV* structInfo, Decoded_VkExportMemoryWin32HandleInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pAttributes << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dwAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "exportMemoryWin32HandleInfoNV");
    out << "\t\t" << "VkExportMemoryWin32HandleInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportMemoryWin32HandleInfoNV(std::ostream &out, const VkImportMemoryWin32HandleInfoNV* structInfo, Decoded_VkImportMemoryWin32HandleInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->handleType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<HANDLE>(" << structInfo->handle << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importMemoryWin32HandleInfoNV");
    out << "\t\t" << "VkImportMemoryWin32HandleInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWin32KeyedMutexAcquireReleaseInfoNV(std::ostream &out, const VkWin32KeyedMutexAcquireReleaseInfoNV* structInfo, Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pacquire_syncs_array = "NULL";
    if (metaInfo->pAcquireSyncs.GetPointer() != NULL && structInfo->acquireCount > 0) {
        pacquire_syncs_array = "pacquire_syncs_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DEVICE_MEMORY));
        std::string pacquire_syncs_values = toStringJoin(metaInfo->pAcquireSyncs.GetPointer(),
                                                         metaInfo->pAcquireSyncs.GetPointer() + structInfo->acquireCount,
                                                         [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                         ", ");
        if (structInfo->acquireCount == 1) {
            pacquire_syncs_array = "&" + pacquire_syncs_values;
        } else if (structInfo->acquireCount > 1) {
            out << "\t\t" << "VkDeviceMemory " << pacquire_syncs_array << "[] = {" << pacquire_syncs_values << "};" << std::endl;
        }
    }
    std::string pacquire_keys_array = "pacquire_keys_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->acquireCount > 0) {
        std::string pacquire_keys_values = toStringJoin(structInfo->pAcquireKeys,
                                                        structInfo->pAcquireKeys + structInfo->acquireCount,
                                                        [](uint64_t current) { return std::to_string(current); },
                                                        ", ");
        if (structInfo->acquireCount == 1) {
            pacquire_keys_array = "&" + pacquire_keys_values;
        } else if (structInfo->acquireCount > 1) {
            out << "\t\t" << "uint64_t " << pacquire_keys_array << "[] = {" << pacquire_keys_values << "};" << std::endl;
        }
    }
    std::string pacquire_timeout_milliseconds_array = "NULL";
    if (structInfo->pAcquireTimeoutMilliseconds != NULL) {
        pacquire_timeout_milliseconds_array = "pAcquireTimeoutMilliseconds_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pacquire_timeout_milliseconds_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pAcquireTimeoutMilliseconds, structInfo->acquireCount) << ";" << std::endl;
    }
    std::string prelease_syncs_array = "NULL";
    if (metaInfo->pReleaseSyncs.GetPointer() != NULL && structInfo->releaseCount > 0) {
        prelease_syncs_array = "prelease_syncs_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DEVICE_MEMORY));
        std::string prelease_syncs_values = toStringJoin(metaInfo->pReleaseSyncs.GetPointer(),
                                                         metaInfo->pReleaseSyncs.GetPointer() + structInfo->releaseCount,
                                                         [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                         ", ");
        if (structInfo->releaseCount == 1) {
            prelease_syncs_array = "&" + prelease_syncs_values;
        } else if (structInfo->releaseCount > 1) {
            out << "\t\t" << "VkDeviceMemory " << prelease_syncs_array << "[] = {" << prelease_syncs_values << "};" << std::endl;
        }
    }
    std::string prelease_keys_array = "prelease_keys_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->releaseCount > 0) {
        std::string prelease_keys_values = toStringJoin(structInfo->pReleaseKeys,
                                                        structInfo->pReleaseKeys + structInfo->releaseCount,
                                                        [](uint64_t current) { return std::to_string(current); },
                                                        ", ");
        if (structInfo->releaseCount == 1) {
            prelease_keys_array = "&" + prelease_keys_values;
        } else if (structInfo->releaseCount > 1) {
            out << "\t\t" << "uint64_t " << prelease_keys_array << "[] = {" << prelease_keys_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->acquireCount << "," << std::endl;
    struct_body << "\t\t\t" << pacquire_syncs_array << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << pacquire_keys_array << " }" << "," << std::endl;
    struct_body << "\t\t\t" << pacquire_timeout_milliseconds_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->releaseCount << "," << std::endl;
    struct_body << "\t\t\t" << prelease_syncs_array << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << prelease_keys_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "win32KeyedMutexAcquireReleaseInfoNV");
    out << "\t\t" << "VkWin32KeyedMutexAcquireReleaseInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkValidationFlagsEXT(std::ostream &out, const VkValidationFlagsEXT* structInfo, Decoded_VkValidationFlagsEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdisabled_validation_checks_values;
    std::string pdisabled_validation_checks_array = "NULL";
    if (structInfo->pDisabledValidationChecks != NULL) {
        for (uint32_t idx = 0; idx < structInfo->disabledValidationCheckCount; idx++) {
            pdisabled_validation_checks_values += util::ToString<VkValidationCheckEXT>(structInfo->pDisabledValidationChecks[idx]) + ", ";
        }
        pdisabled_validation_checks_array = "pDisabledValidationChecks_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkValidationCheckEXT " << pdisabled_validation_checks_array << "[] = {" << pdisabled_validation_checks_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->disabledValidationCheckCount << "," << std::endl;
    struct_body << "\t\t\t" << pdisabled_validation_checks_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "validationFlagsEXT");
    out << "\t\t" << "VkValidationFlagsEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkViSurfaceCreateInfoNN(std::ostream &out, const VkViSurfaceCreateInfoNN* structInfo, Decoded_VkViSurfaceCreateInfoNN* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkViSurfaceCreateFlagsNN(" << structInfo->flags << ")" << "," << std::endl;
    out << "\t\t" << "// TODO: Support window (non-struct output) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "viSurfaceCreateInfoNN");
    out << "\t\t" << "VkViSurfaceCreateInfoNN " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewASTCDecodeModeEXT(std::ostream &out, const VkImageViewASTCDecodeModeEXT* structInfo, Decoded_VkImageViewASTCDecodeModeEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->decodeMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewASTCDecodeModeEXT");
    out << "\t\t" << "VkImageViewASTCDecodeModeEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceASTCDecodeFeaturesEXT(std::ostream &out, const VkPhysicalDeviceASTCDecodeFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->decodeModeSharedExponent << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceASTCDecodeFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceASTCDecodeFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferInheritanceConditionalRenderingInfoEXT(std::ostream &out, const VkCommandBufferInheritanceConditionalRenderingInfoEXT* structInfo, Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->conditionalRenderingEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferInheritanceConditionalRenderingInfoEXT");
    out << "\t\t" << "VkCommandBufferInheritanceConditionalRenderingInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkConditionalRenderingBeginInfoEXT(std::ostream &out, const VkConditionalRenderingBeginInfoEXT* structInfo, Decoded_VkConditionalRenderingBeginInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkConditionalRenderingFlagsEXT(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "conditionalRenderingBeginInfoEXT");
    out << "\t\t" << "VkConditionalRenderingBeginInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceConditionalRenderingFeaturesEXT(std::ostream &out, const VkPhysicalDeviceConditionalRenderingFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->conditionalRendering << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->inheritedConditionalRendering << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceConditionalRenderingFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceConditionalRenderingFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportWScalingStateCreateInfoNV(std::ostream &out, const VkPipelineViewportWScalingStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportWScalingStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pviewport_w_scalings_array = "NULL";
    if (structInfo->pViewportWScalings != NULL) {
        pviewport_w_scalings_array = "pViewportWScalings_" + std::to_string(consumer.GetNextId());
        std::string pviewport_w_scalings_names;
        for (uint32_t idx = 0; idx < structInfo->viewportCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pViewportWScalings + idx != NULL) {
                variable_name = GenerateStruct_VkViewportWScalingNV(out,
                                                                    structInfo->pViewportWScalings + idx,
                                                                    metaInfo->pViewportWScalings->GetMetaStructPointer() + idx,
                                                                    consumer);
            }
            pviewport_w_scalings_names += variable_name + ", ";
        }
        out << "\t\t" << "VkViewportWScalingNV " << pviewport_w_scalings_array << "[] = {" << pviewport_w_scalings_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewportWScalingEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewportCount << "," << std::endl;
    struct_body << "\t\t\t" << pviewport_w_scalings_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportWScalingStateCreateInfoNV");
    out << "\t\t" << "VkPipelineViewportWScalingStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkViewportWScalingNV(std::ostream &out, const VkViewportWScalingNV* structInfo, Decoded_VkViewportWScalingNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->xcoeff << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->ycoeff << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "viewportWScalingNV");
    out << "\t\t" << "VkViewportWScalingNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceCapabilities2EXT(std::ostream &out, const VkSurfaceCapabilities2EXT* structInfo, Decoded_VkSurfaceCapabilities2EXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string current_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->currentExtent,
                                                                    metaInfo->currentExtent,
                                                                    consumer);
    std::string min_image_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->minImageExtent,
                                                                      metaInfo->minImageExtent,
                                                                      consumer);
    std::string max_image_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->maxImageExtent,
                                                                      metaInfo->maxImageExtent,
                                                                      consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minImageCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxImageCount << "," << std::endl;
    struct_body << "\t\t\t" << current_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << min_image_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_image_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxImageArrayLayers << "," << std::endl;
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagsKHR(" << structInfo->supportedTransforms << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->currentTransform << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkCompositeAlphaFlagsKHR(" << structInfo->supportedCompositeAlpha << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->supportedUsageFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSurfaceCounterFlagsEXT(" << structInfo->supportedSurfaceCounters << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceCapabilities2EXT");
    out << "\t\t" << "VkSurfaceCapabilities2EXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceEventInfoEXT(std::ostream &out, const VkDeviceEventInfoEXT* structInfo, Decoded_VkDeviceEventInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDeviceEventTypeEXT(" << structInfo->deviceEvent << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceEventInfoEXT");
    out << "\t\t" << "VkDeviceEventInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayEventInfoEXT(std::ostream &out, const VkDisplayEventInfoEXT* structInfo, Decoded_VkDisplayEventInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDisplayEventTypeEXT(" << structInfo->displayEvent << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayEventInfoEXT");
    out << "\t\t" << "VkDisplayEventInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayPowerInfoEXT(std::ostream &out, const VkDisplayPowerInfoEXT* structInfo, Decoded_VkDisplayPowerInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDisplayPowerStateEXT(" << structInfo->powerState << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayPowerInfoEXT");
    out << "\t\t" << "VkDisplayPowerInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainCounterCreateInfoEXT(std::ostream &out, const VkSwapchainCounterCreateInfoEXT* structInfo, Decoded_VkSwapchainCounterCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSurfaceCounterFlagsEXT(" << structInfo->surfaceCounters << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainCounterCreateInfoEXT");
    out << "\t\t" << "VkSwapchainCounterCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPastPresentationTimingGOOGLE(std::ostream &out, const VkPastPresentationTimingGOOGLE* structInfo, Decoded_VkPastPresentationTimingGOOGLE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->presentID << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->desiredPresentTime << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->actualPresentTime << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->earliestPresentTime << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentMargin << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pastPresentationTimingGOOGLE");
    out << "\t\t" << "VkPastPresentationTimingGOOGLE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentTimeGOOGLE(std::ostream &out, const VkPresentTimeGOOGLE* structInfo, Decoded_VkPresentTimeGOOGLE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->presentID << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->desiredPresentTime << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentTimeGOOGLE");
    out << "\t\t" << "VkPresentTimeGOOGLE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentTimesInfoGOOGLE(std::ostream &out, const VkPresentTimesInfoGOOGLE* structInfo, Decoded_VkPresentTimesInfoGOOGLE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ptimes_array = "NULL";
    if (structInfo->pTimes != NULL) {
        ptimes_array = "pTimes_" + std::to_string(consumer.GetNextId());
        std::string ptimes_names;
        for (uint32_t idx = 0; idx < structInfo->swapchainCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pTimes + idx != NULL) {
                variable_name = GenerateStruct_VkPresentTimeGOOGLE(out,
                                                                   structInfo->pTimes + idx,
                                                                   metaInfo->pTimes->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            ptimes_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPresentTimeGOOGLE " << ptimes_array << "[] = {" << ptimes_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->swapchainCount << "," << std::endl;
    struct_body << "\t\t\t" << ptimes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentTimesInfoGOOGLE");
    out << "\t\t" << "VkPresentTimesInfoGOOGLE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRefreshCycleDurationGOOGLE(std::ostream &out, const VkRefreshCycleDurationGOOGLE* structInfo, Decoded_VkRefreshCycleDurationGOOGLE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->refreshDuration << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "refreshCycleDurationGOOGLE");
    out << "\t\t" << "VkRefreshCycleDurationGOOGLE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMultiviewPerViewAttributesInfoNVX(std::ostream &out, const VkMultiviewPerViewAttributesInfoNVX* structInfo, Decoded_VkMultiviewPerViewAttributesInfoNVX* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->perViewAttributes << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->perViewAttributesPositionXOnly << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "multiviewPerViewAttributesInfoNVX");
    out << "\t\t" << "VkMultiviewPerViewAttributesInfoNVX " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(std::ostream &out, const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* structInfo, Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->perViewPositionAllComponents << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultiviewPerViewAttributesPropertiesNVX");
    out << "\t\t" << "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportSwizzleStateCreateInfoNV(std::ostream &out, const VkPipelineViewportSwizzleStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportSwizzleStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pviewport_swizzles_array = "NULL";
    if (structInfo->pViewportSwizzles != NULL) {
        pviewport_swizzles_array = "pViewportSwizzles_" + std::to_string(consumer.GetNextId());
        std::string pviewport_swizzles_names;
        for (uint32_t idx = 0; idx < structInfo->viewportCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pViewportSwizzles + idx != NULL) {
                variable_name = GenerateStruct_VkViewportSwizzleNV(out,
                                                                   structInfo->pViewportSwizzles + idx,
                                                                   metaInfo->pViewportSwizzles->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            pviewport_swizzles_names += variable_name + ", ";
        }
        out << "\t\t" << "VkViewportSwizzleNV " << pviewport_swizzles_array << "[] = {" << pviewport_swizzles_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineViewportSwizzleStateCreateFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewportCount << "," << std::endl;
    struct_body << "\t\t\t" << pviewport_swizzles_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportSwizzleStateCreateInfoNV");
    out << "\t\t" << "VkPipelineViewportSwizzleStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkViewportSwizzleNV(std::ostream &out, const VkViewportSwizzleNV* structInfo, Decoded_VkViewportSwizzleNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkViewportCoordinateSwizzleNV(" << structInfo->x << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkViewportCoordinateSwizzleNV(" << structInfo->y << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkViewportCoordinateSwizzleNV(" << structInfo->z << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkViewportCoordinateSwizzleNV(" << structInfo->w << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "viewportSwizzleNV");
    out << "\t\t" << "VkViewportSwizzleNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDiscardRectanglePropertiesEXT(std::ostream &out, const VkPhysicalDeviceDiscardRectanglePropertiesEXT* structInfo, Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDiscardRectangles << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDiscardRectanglePropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceDiscardRectanglePropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineDiscardRectangleStateCreateInfoEXT(std::ostream &out, const VkPipelineDiscardRectangleStateCreateInfoEXT* structInfo, Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdiscard_rectangles_array = "NULL";
    if (structInfo->pDiscardRectangles != NULL) {
        pdiscard_rectangles_array = "pDiscardRectangles_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkRect2D " << pdiscard_rectangles_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDiscardRectangles, structInfo->discardRectangleCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineDiscardRectangleStateCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkDiscardRectangleModeEXT(" << structInfo->discardRectangleMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->discardRectangleCount << "," << std::endl;
    struct_body << "\t\t\t" << pdiscard_rectangles_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineDiscardRectangleStateCreateInfoEXT");
    out << "\t\t" << "VkPipelineDiscardRectangleStateCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(std::ostream &out, const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primitiveOverestimationSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxExtraPrimitiveOverestimationSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extraPrimitiveOverestimationSizeGranularity << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primitiveUnderestimation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->conservativePointAndLineRasterization << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->degenerateTrianglesRasterized << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->degenerateLinesRasterized << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fullyCoveredFragmentShaderInputVariable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->conservativeRasterizationPostDepthCoverage << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceConservativeRasterizationPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceConservativeRasterizationPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRasterizationConservativeStateCreateInfoEXT(std::ostream &out, const VkPipelineRasterizationConservativeStateCreateInfoEXT* structInfo, Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRasterizationConservativeStateCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkConservativeRasterizationModeEXT(" << structInfo->conservativeRasterizationMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extraPrimitiveOverestimationSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRasterizationConservativeStateCreateInfoEXT");
    out << "\t\t" << "VkPipelineRasterizationConservativeStateCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDepthClipEnableFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDepthClipEnableFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthClipEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDepthClipEnableFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceDepthClipEnableFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRasterizationDepthClipStateCreateInfoEXT(std::ostream &out, const VkPipelineRasterizationDepthClipStateCreateInfoEXT* structInfo, Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineRasterizationDepthClipStateCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthClipEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRasterizationDepthClipStateCreateInfoEXT");
    out << "\t\t" << "VkPipelineRasterizationDepthClipStateCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkHdrMetadataEXT(std::ostream &out, const VkHdrMetadataEXT* structInfo, Decoded_VkHdrMetadataEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string display_primary_red_info_var = GenerateStruct_VkXYColorEXT(out,
                                                                           &structInfo->displayPrimaryRed,
                                                                           metaInfo->displayPrimaryRed,
                                                                           consumer);
    std::string display_primary_green_info_var = GenerateStruct_VkXYColorEXT(out,
                                                                             &structInfo->displayPrimaryGreen,
                                                                             metaInfo->displayPrimaryGreen,
                                                                             consumer);
    std::string display_primary_blue_info_var = GenerateStruct_VkXYColorEXT(out,
                                                                            &structInfo->displayPrimaryBlue,
                                                                            metaInfo->displayPrimaryBlue,
                                                                            consumer);
    std::string white_point_info_var = GenerateStruct_VkXYColorEXT(out,
                                                                   &structInfo->whitePoint,
                                                                   metaInfo->whitePoint,
                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << display_primary_red_info_var << "," << std::endl;
    struct_body << "\t\t\t" << display_primary_green_info_var << "," << std::endl;
    struct_body << "\t\t\t" << display_primary_blue_info_var << "," << std::endl;
    struct_body << "\t\t\t" << white_point_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxLuminance << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minLuminance << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxContentLightLevel << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxFrameAverageLightLevel << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "hdrMetadataEXT");
    out << "\t\t" << "VkHdrMetadataEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkXYColorEXT(std::ostream &out, const VkXYColorEXT* structInfo, Decoded_VkXYColorEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->x << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->y << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "xYColorEXT");
    out << "\t\t" << "VkXYColorEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG(std::ostream &out, const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* structInfo, Decoded_VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->relaxedLineRasterization << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRelaxedLineRasterizationFeaturesIMG");
    out << "\t\t" << "VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIOSSurfaceCreateInfoMVK(std::ostream &out, const VkIOSSurfaceCreateInfoMVK* structInfo, Decoded_VkIOSSurfaceCreateInfoMVK* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkIOSSurfaceCreateFlagsMVK(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pView << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "iOSSurfaceCreateInfoMVK");
    out << "\t\t" << "VkIOSSurfaceCreateInfoMVK " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMacOSSurfaceCreateInfoMVK(std::ostream &out, const VkMacOSSurfaceCreateInfoMVK* structInfo, Decoded_VkMacOSSurfaceCreateInfoMVK* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkMacOSSurfaceCreateFlagsMVK(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pView << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "macOSSurfaceCreateInfoMVK");
    out << "\t\t" << "VkMacOSSurfaceCreateInfoMVK " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugUtilsLabelEXT(std::ostream &out, const VkDebugUtilsLabelEXT* structInfo, Decoded_VkDebugUtilsLabelEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pLabelName) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->color[0]), 4) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "debugUtilsLabelEXT");
    out << "\t\t" << "VkDebugUtilsLabelEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugUtilsMessengerCallbackDataEXT(std::ostream &out, const VkDebugUtilsMessengerCallbackDataEXT* structInfo, Decoded_VkDebugUtilsMessengerCallbackDataEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pqueue_labels_array = "NULL";
    if (structInfo->pQueueLabels != NULL) {
        pqueue_labels_array = "pQueueLabels_" + std::to_string(consumer.GetNextId());
        std::string pqueue_labels_names;
        for (uint32_t idx = 0; idx < structInfo->queueLabelCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pQueueLabels + idx != NULL) {
                variable_name = GenerateStruct_VkDebugUtilsLabelEXT(out,
                                                                    structInfo->pQueueLabels + idx,
                                                                    metaInfo->pQueueLabels->GetMetaStructPointer() + idx,
                                                                    consumer);
            }
            pqueue_labels_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDebugUtilsLabelEXT " << pqueue_labels_array << "[] = {" << pqueue_labels_names << "};" << std::endl;
    }
    std::string pcmd_buf_labels_array = "NULL";
    if (structInfo->pCmdBufLabels != NULL) {
        pcmd_buf_labels_array = "pCmdBufLabels_" + std::to_string(consumer.GetNextId());
        std::string pcmd_buf_labels_names;
        for (uint32_t idx = 0; idx < structInfo->cmdBufLabelCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pCmdBufLabels + idx != NULL) {
                variable_name = GenerateStruct_VkDebugUtilsLabelEXT(out,
                                                                    structInfo->pCmdBufLabels + idx,
                                                                    metaInfo->pCmdBufLabels->GetMetaStructPointer() + idx,
                                                                    consumer);
            }
            pcmd_buf_labels_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDebugUtilsLabelEXT " << pcmd_buf_labels_array << "[] = {" << pcmd_buf_labels_names << "};" << std::endl;
    }
    std::string pobjects_array = "NULL";
    if (structInfo->pObjects != NULL) {
        pobjects_array = "pObjects_" + std::to_string(consumer.GetNextId());
        std::string pobjects_names;
        for (uint32_t idx = 0; idx < structInfo->objectCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pObjects + idx != NULL) {
                variable_name = GenerateStruct_VkDebugUtilsObjectNameInfoEXT(out,
                                                                             structInfo->pObjects + idx,
                                                                             metaInfo->pObjects->GetMetaStructPointer() + idx,
                                                                             consumer);
            }
            pobjects_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDebugUtilsObjectNameInfoEXT " << pobjects_array << "[] = {" << pobjects_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDebugUtilsMessengerCallbackDataFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pMessageIdName) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->messageIdNumber << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pMessage) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueLabelCount << "," << std::endl;
    struct_body << "\t\t\t" << pqueue_labels_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cmdBufLabelCount << "," << std::endl;
    struct_body << "\t\t\t" << pcmd_buf_labels_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->objectCount << "," << std::endl;
    struct_body << "\t\t\t" << pobjects_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "debugUtilsMessengerCallbackDataEXT");
    out << "\t\t" << "VkDebugUtilsMessengerCallbackDataEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugUtilsObjectNameInfoEXT(std::ostream &out, const VkDebugUtilsObjectNameInfoEXT* structInfo, Decoded_VkDebugUtilsObjectNameInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkObjectType(" << structInfo->objectType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->objectHandle << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pObjectName) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "debugUtilsObjectNameInfoEXT");
    out << "\t\t" << "VkDebugUtilsObjectNameInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDebugUtilsObjectTagInfoEXT(std::ostream &out, const VkDebugUtilsObjectTagInfoEXT* structInfo, Decoded_VkDebugUtilsObjectTagInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ptag_array = "NULL";
    if (structInfo->pTag != NULL) {
        std::string ptag_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->tagSize; ++idx0) {
            ptag_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pTag)[idx0]) + ", ";
        }
        ptag_array = "pTag_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << ptag_array << "[] = {" << ptag_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkObjectType(" << structInfo->objectType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->objectHandle << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tagName << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tagSize << "," << std::endl;
    struct_body << "\t\t\t" << ptag_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "debugUtilsObjectTagInfoEXT");
    out << "\t\t" << "VkDebugUtilsObjectTagInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAndroidHardwareBufferFormatProperties2ANDROID(std::ostream &out, const VkAndroidHardwareBufferFormatProperties2ANDROID* structInfo, Decoded_VkAndroidHardwareBufferFormatProperties2ANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string sampler_ycbcr_conversion_components_info_var = GenerateStruct_VkComponentMapping(out,
                                                                                                 &structInfo->samplerYcbcrConversionComponents,
                                                                                                 metaInfo->samplerYcbcrConversionComponents,
                                                                                                 consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->externalFormat << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormatFeatureFlags2(" << structInfo->formatFeatures << ")" << "," << std::endl;
    struct_body << "\t\t\t" << sampler_ycbcr_conversion_components_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "VkSamplerYcbcrModelConversion(" << structInfo->suggestedYcbcrModel << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSamplerYcbcrRange(" << structInfo->suggestedYcbcrRange << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->suggestedXChromaOffset << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->suggestedYChromaOffset << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "androidHardwareBufferFormatProperties2ANDROID");
    out << "\t\t" << "VkAndroidHardwareBufferFormatProperties2ANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAndroidHardwareBufferFormatPropertiesANDROID(std::ostream &out, const VkAndroidHardwareBufferFormatPropertiesANDROID* structInfo, Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string sampler_ycbcr_conversion_components_info_var = GenerateStruct_VkComponentMapping(out,
                                                                                                 &structInfo->samplerYcbcrConversionComponents,
                                                                                                 metaInfo->samplerYcbcrConversionComponents,
                                                                                                 consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->externalFormat << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormatFeatureFlags(" << structInfo->formatFeatures << ")" << "," << std::endl;
    struct_body << "\t\t\t" << sampler_ycbcr_conversion_components_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "VkSamplerYcbcrModelConversion(" << structInfo->suggestedYcbcrModel << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSamplerYcbcrRange(" << structInfo->suggestedYcbcrRange << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->suggestedXChromaOffset << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->suggestedYChromaOffset << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "androidHardwareBufferFormatPropertiesANDROID");
    out << "\t\t" << "VkAndroidHardwareBufferFormatPropertiesANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAndroidHardwareBufferPropertiesANDROID(std::ostream &out, const VkAndroidHardwareBufferPropertiesANDROID* structInfo, Decoded_VkAndroidHardwareBufferPropertiesANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->allocationSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryTypeBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "androidHardwareBufferPropertiesANDROID");
    out << "\t\t" << "VkAndroidHardwareBufferPropertiesANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAndroidHardwareBufferUsageANDROID(std::ostream &out, const VkAndroidHardwareBufferUsageANDROID* structInfo, Decoded_VkAndroidHardwareBufferUsageANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->androidHardwareBufferUsage << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "androidHardwareBufferUsageANDROID");
    out << "\t\t" << "VkAndroidHardwareBufferUsageANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalFormatANDROID(std::ostream &out, const VkExternalFormatANDROID* structInfo, Decoded_VkExternalFormatANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->externalFormat << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalFormatANDROID");
    out << "\t\t" << "VkExternalFormatANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryGetAndroidHardwareBufferInfoANDROID(std::ostream &out, const VkMemoryGetAndroidHardwareBufferInfoANDROID* structInfo, Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryGetAndroidHardwareBufferInfoANDROID");
    out << "\t\t" << "VkMemoryGetAndroidHardwareBufferInfoANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentSampleCountInfoAMD(std::ostream &out, const VkAttachmentSampleCountInfoAMD* structInfo, Decoded_VkAttachmentSampleCountInfoAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcolor_attachment_samples_values;
    std::string pcolor_attachment_samples_array = "NULL";
    if (structInfo->pColorAttachmentSamples != NULL) {
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            pcolor_attachment_samples_values += util::ToString<VkSampleCountFlagBits>(structInfo->pColorAttachmentSamples[idx]) + ", ";
        }
        pcolor_attachment_samples_array = "pColorAttachmentSamples_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkSampleCountFlagBits " << pcolor_attachment_samples_array << "[] = {" << pcolor_attachment_samples_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pcolor_attachment_samples_array << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->depthStencilAttachmentSamples << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentSampleCountInfoAMD");
    out << "\t\t" << "VkAttachmentSampleCountInfoAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAttachmentSampleLocationsEXT(std::ostream &out, const VkAttachmentSampleLocationsEXT* structInfo, Decoded_VkAttachmentSampleLocationsEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string sample_locations_info_info_var = GenerateStruct_VkSampleLocationsInfoEXT(out,
                                                                                         &structInfo->sampleLocationsInfo,
                                                                                         metaInfo->sampleLocationsInfo,
                                                                                         consumer);
    struct_body << "\t" << structInfo->attachmentIndex << "," << std::endl;
    struct_body << "\t\t\t" << sample_locations_info_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "attachmentSampleLocationsEXT");
    out << "\t\t" << "VkAttachmentSampleLocationsEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMultisamplePropertiesEXT(std::ostream &out, const VkMultisamplePropertiesEXT* structInfo, Decoded_VkMultisamplePropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string max_sample_location_grid_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                   &structInfo->maxSampleLocationGridSize,
                                                                                   metaInfo->maxSampleLocationGridSize,
                                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << max_sample_location_grid_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "multisamplePropertiesEXT");
    out << "\t\t" << "VkMultisamplePropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSampleLocationsPropertiesEXT(std::ostream &out, const VkPhysicalDeviceSampleLocationsPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string max_sample_location_grid_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                   &structInfo->maxSampleLocationGridSize,
                                                                                   metaInfo->maxSampleLocationGridSize,
                                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->sampleLocationSampleCounts << ")" << "," << std::endl;
    struct_body << "\t\t\t" << max_sample_location_grid_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->sampleLocationCoordinateRange[0]), 2) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sampleLocationSubPixelBits << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->variableSampleLocations << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSampleLocationsPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceSampleLocationsPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineSampleLocationsStateCreateInfoEXT(std::ostream &out, const VkPipelineSampleLocationsStateCreateInfoEXT* structInfo, Decoded_VkPipelineSampleLocationsStateCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string sample_locations_info_info_var = GenerateStruct_VkSampleLocationsInfoEXT(out,
                                                                                         &structInfo->sampleLocationsInfo,
                                                                                         metaInfo->sampleLocationsInfo,
                                                                                         consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sampleLocationsEnable << "," << std::endl;
    struct_body << "\t\t\t" << sample_locations_info_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineSampleLocationsStateCreateInfoEXT");
    out << "\t\t" << "VkPipelineSampleLocationsStateCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassSampleLocationsBeginInfoEXT(std::ostream &out, const VkRenderPassSampleLocationsBeginInfoEXT* structInfo, Decoded_VkRenderPassSampleLocationsBeginInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pattachment_initial_sample_locations_array = "NULL";
    if (structInfo->pAttachmentInitialSampleLocations != NULL) {
        pattachment_initial_sample_locations_array = "pAttachmentInitialSampleLocations_" + std::to_string(consumer.GetNextId());
        std::string pattachment_initial_sample_locations_names;
        for (uint32_t idx = 0; idx < structInfo->attachmentInitialSampleLocationsCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pAttachmentInitialSampleLocations + idx != NULL) {
                variable_name = GenerateStruct_VkAttachmentSampleLocationsEXT(out,
                                                                              structInfo->pAttachmentInitialSampleLocations + idx,
                                                                              metaInfo->pAttachmentInitialSampleLocations->GetMetaStructPointer() + idx,
                                                                              consumer);
            }
            pattachment_initial_sample_locations_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAttachmentSampleLocationsEXT " << pattachment_initial_sample_locations_array << "[] = {" << pattachment_initial_sample_locations_names << "};" << std::endl;
    }
    std::string ppost_subpass_sample_locations_array = "NULL";
    if (structInfo->pPostSubpassSampleLocations != NULL) {
        ppost_subpass_sample_locations_array = "pPostSubpassSampleLocations_" + std::to_string(consumer.GetNextId());
        std::string ppost_subpass_sample_locations_names;
        for (uint32_t idx = 0; idx < structInfo->postSubpassSampleLocationsCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPostSubpassSampleLocations + idx != NULL) {
                variable_name = GenerateStruct_VkSubpassSampleLocationsEXT(out,
                                                                           structInfo->pPostSubpassSampleLocations + idx,
                                                                           metaInfo->pPostSubpassSampleLocations->GetMetaStructPointer() + idx,
                                                                           consumer);
            }
            ppost_subpass_sample_locations_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSubpassSampleLocationsEXT " << ppost_subpass_sample_locations_array << "[] = {" << ppost_subpass_sample_locations_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->attachmentInitialSampleLocationsCount << "," << std::endl;
    struct_body << "\t\t\t" << pattachment_initial_sample_locations_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->postSubpassSampleLocationsCount << "," << std::endl;
    struct_body << "\t\t\t" << ppost_subpass_sample_locations_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassSampleLocationsBeginInfoEXT");
    out << "\t\t" << "VkRenderPassSampleLocationsBeginInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSampleLocationEXT(std::ostream &out, const VkSampleLocationEXT* structInfo, Decoded_VkSampleLocationEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->x << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->y << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sampleLocationEXT");
    out << "\t\t" << "VkSampleLocationEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSampleLocationsInfoEXT(std::ostream &out, const VkSampleLocationsInfoEXT* structInfo, Decoded_VkSampleLocationsInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string sample_location_grid_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                               &structInfo->sampleLocationGridSize,
                                                                               metaInfo->sampleLocationGridSize,
                                                                               consumer);
    std::string psample_locations_array = "NULL";
    if (structInfo->pSampleLocations != NULL) {
        psample_locations_array = "pSampleLocations_" + std::to_string(consumer.GetNextId());
        std::string psample_locations_names;
        for (uint32_t idx = 0; idx < structInfo->sampleLocationsCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pSampleLocations + idx != NULL) {
                variable_name = GenerateStruct_VkSampleLocationEXT(out,
                                                                   structInfo->pSampleLocations + idx,
                                                                   metaInfo->pSampleLocations->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            psample_locations_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSampleLocationEXT " << psample_locations_array << "[] = {" << psample_locations_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->sampleLocationsPerPixel << ")" << "," << std::endl;
    struct_body << "\t\t\t" << sample_location_grid_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sampleLocationsCount << "," << std::endl;
    struct_body << "\t\t\t" << psample_locations_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sampleLocationsInfoEXT");
    out << "\t\t" << "VkSampleLocationsInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassSampleLocationsEXT(std::ostream &out, const VkSubpassSampleLocationsEXT* structInfo, Decoded_VkSubpassSampleLocationsEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string sample_locations_info_info_var = GenerateStruct_VkSampleLocationsInfoEXT(out,
                                                                                         &structInfo->sampleLocationsInfo,
                                                                                         metaInfo->sampleLocationsInfo,
                                                                                         consumer);
    struct_body << "\t" << structInfo->subpassIndex << "," << std::endl;
    struct_body << "\t\t\t" << sample_locations_info_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassSampleLocationsEXT");
    out << "\t\t" << "VkSubpassSampleLocationsEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(std::ostream &out, const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->advancedBlendCoherentOperations << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceBlendOperationAdvancedFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(std::ostream &out, const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->advancedBlendMaxColorAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->advancedBlendIndependentBlend << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->advancedBlendNonPremultipliedSrcColor << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->advancedBlendNonPremultipliedDstColor << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->advancedBlendCorrelatedOverlap << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->advancedBlendAllOperations << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceBlendOperationAdvancedPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineColorBlendAdvancedStateCreateInfoEXT(std::ostream &out, const VkPipelineColorBlendAdvancedStateCreateInfoEXT* structInfo, Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcPremultiplied << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstPremultiplied << "," << std::endl;
    struct_body << "\t\t\t" << "VkBlendOverlapEXT(" << structInfo->blendOverlap << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineColorBlendAdvancedStateCreateInfoEXT");
    out << "\t\t" << "VkPipelineColorBlendAdvancedStateCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCoverageToColorStateCreateInfoNV(std::ostream &out, const VkPipelineCoverageToColorStateCreateInfoNV* structInfo, Decoded_VkPipelineCoverageToColorStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineCoverageToColorStateCreateFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->coverageToColorEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->coverageToColorLocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCoverageToColorStateCreateInfoNV");
    out << "\t\t" << "VkPipelineCoverageToColorStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCoverageModulationStateCreateInfoNV(std::ostream &out, const VkPipelineCoverageModulationStateCreateInfoNV* structInfo, Decoded_VkPipelineCoverageModulationStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcoverage_modulation_table_array = "NULL";
    if (structInfo->pCoverageModulationTable != NULL) {
        pcoverage_modulation_table_array = "pCoverageModulationTable_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "float " << pcoverage_modulation_table_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCoverageModulationTable, structInfo->coverageModulationTableCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineCoverageModulationStateCreateFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkCoverageModulationModeNV(" << structInfo->coverageModulationMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->coverageModulationTableEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->coverageModulationTableCount << "," << std::endl;
    struct_body << "\t\t\t" << pcoverage_modulation_table_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCoverageModulationStateCreateInfoNV");
    out << "\t\t" << "VkPipelineCoverageModulationStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(std::ostream &out, const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* structInfo, Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSMBuiltins << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderSMBuiltinsFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceShaderSMBuiltinsFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(std::ostream &out, const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* structInfo, Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSMCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderWarpsPerSM << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderSMBuiltinsPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceShaderSMBuiltinsPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrmFormatModifierProperties2EXT(std::ostream &out, const VkDrmFormatModifierProperties2EXT* structInfo, Decoded_VkDrmFormatModifierProperties2EXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->drmFormatModifier << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->drmFormatModifierPlaneCount << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormatFeatureFlags2(" << structInfo->drmFormatModifierTilingFeatures << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drmFormatModifierProperties2EXT");
    out << "\t\t" << "VkDrmFormatModifierProperties2EXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrmFormatModifierPropertiesEXT(std::ostream &out, const VkDrmFormatModifierPropertiesEXT* structInfo, Decoded_VkDrmFormatModifierPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->drmFormatModifier << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->drmFormatModifierPlaneCount << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormatFeatureFlags(" << structInfo->drmFormatModifierTilingFeatures << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drmFormatModifierPropertiesEXT");
    out << "\t\t" << "VkDrmFormatModifierPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrmFormatModifierPropertiesList2EXT(std::ostream &out, const VkDrmFormatModifierPropertiesList2EXT* structInfo, Decoded_VkDrmFormatModifierPropertiesList2EXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdrm_format_modifier_properties_array = "NULL";
    if (structInfo->pDrmFormatModifierProperties != NULL) {
        pdrm_format_modifier_properties_array = "pDrmFormatModifierProperties_" + std::to_string(consumer.GetNextId());
        std::string pdrm_format_modifier_properties_names;
        for (uint32_t idx = 0; idx < structInfo->drmFormatModifierCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pDrmFormatModifierProperties + idx != NULL) {
                variable_name = GenerateStruct_VkDrmFormatModifierProperties2EXT(out,
                                                                                 structInfo->pDrmFormatModifierProperties + idx,
                                                                                 metaInfo->pDrmFormatModifierProperties->GetMetaStructPointer() + idx,
                                                                                 consumer);
            }
            pdrm_format_modifier_properties_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDrmFormatModifierProperties2EXT " << pdrm_format_modifier_properties_array << "[] = {" << pdrm_format_modifier_properties_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->drmFormatModifierCount << "," << std::endl;
    struct_body << "\t\t\t" << pdrm_format_modifier_properties_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drmFormatModifierPropertiesList2EXT");
    out << "\t\t" << "VkDrmFormatModifierPropertiesList2EXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrmFormatModifierPropertiesListEXT(std::ostream &out, const VkDrmFormatModifierPropertiesListEXT* structInfo, Decoded_VkDrmFormatModifierPropertiesListEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdrm_format_modifier_properties_array = "NULL";
    if (structInfo->pDrmFormatModifierProperties != NULL) {
        pdrm_format_modifier_properties_array = "pDrmFormatModifierProperties_" + std::to_string(consumer.GetNextId());
        std::string pdrm_format_modifier_properties_names;
        for (uint32_t idx = 0; idx < structInfo->drmFormatModifierCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pDrmFormatModifierProperties + idx != NULL) {
                variable_name = GenerateStruct_VkDrmFormatModifierPropertiesEXT(out,
                                                                                structInfo->pDrmFormatModifierProperties + idx,
                                                                                metaInfo->pDrmFormatModifierProperties->GetMetaStructPointer() + idx,
                                                                                consumer);
            }
            pdrm_format_modifier_properties_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDrmFormatModifierPropertiesEXT " << pdrm_format_modifier_properties_array << "[] = {" << pdrm_format_modifier_properties_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->drmFormatModifierCount << "," << std::endl;
    struct_body << "\t\t\t" << pdrm_format_modifier_properties_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drmFormatModifierPropertiesListEXT");
    out << "\t\t" << "VkDrmFormatModifierPropertiesListEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageDrmFormatModifierExplicitCreateInfoEXT(std::ostream &out, const VkImageDrmFormatModifierExplicitCreateInfoEXT* structInfo, Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pplane_layouts_array = "NULL";
    if (structInfo->pPlaneLayouts != NULL) {
        pplane_layouts_array = "pPlaneLayouts_" + std::to_string(consumer.GetNextId());
        std::string pplane_layouts_names;
        for (uint32_t idx = 0; idx < structInfo->drmFormatModifierPlaneCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPlaneLayouts + idx != NULL) {
                variable_name = GenerateStruct_VkSubresourceLayout(out,
                                                                   structInfo->pPlaneLayouts + idx,
                                                                   metaInfo->pPlaneLayouts->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            pplane_layouts_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSubresourceLayout " << pplane_layouts_array << "[] = {" << pplane_layouts_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->drmFormatModifier << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->drmFormatModifierPlaneCount << "," << std::endl;
    struct_body << "\t\t\t" << pplane_layouts_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageDrmFormatModifierExplicitCreateInfoEXT");
    out << "\t\t" << "VkImageDrmFormatModifierExplicitCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageDrmFormatModifierListCreateInfoEXT(std::ostream &out, const VkImageDrmFormatModifierListCreateInfoEXT* structInfo, Decoded_VkImageDrmFormatModifierListCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdrm_format_modifiers_array = "pdrm_format_modifiers_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->drmFormatModifierCount > 0) {
        std::string pdrm_format_modifiers_values = toStringJoin(structInfo->pDrmFormatModifiers,
                                                                structInfo->pDrmFormatModifiers + structInfo->drmFormatModifierCount,
                                                                [](uint64_t current) { return std::to_string(current); },
                                                                ", ");
        if (structInfo->drmFormatModifierCount == 1) {
            pdrm_format_modifiers_array = "&" + pdrm_format_modifiers_values;
        } else if (structInfo->drmFormatModifierCount > 1) {
            out << "\t\t" << "uint64_t " << pdrm_format_modifiers_array << "[] = {" << pdrm_format_modifiers_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->drmFormatModifierCount << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << pdrm_format_modifiers_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageDrmFormatModifierListCreateInfoEXT");
    out << "\t\t" << "VkImageDrmFormatModifierListCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageDrmFormatModifierPropertiesEXT(std::ostream &out, const VkImageDrmFormatModifierPropertiesEXT* structInfo, Decoded_VkImageDrmFormatModifierPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->drmFormatModifier << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageDrmFormatModifierPropertiesEXT");
    out << "\t\t" << "VkImageDrmFormatModifierPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(std::ostream &out, const VkPhysicalDeviceImageDrmFormatModifierInfoEXT* structInfo, Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pqueue_family_indices_array = "NULL";
    if (structInfo->pQueueFamilyIndices != NULL) {
        pqueue_family_indices_array = "pQueueFamilyIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pqueue_family_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pQueueFamilyIndices, structInfo->queueFamilyIndexCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->drmFormatModifier << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSharingMode(" << structInfo->sharingMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueFamilyIndexCount << "," << std::endl;
    struct_body << "\t\t\t" << pqueue_family_indices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageDrmFormatModifierInfoEXT");
    out << "\t\t" << "VkPhysicalDeviceImageDrmFormatModifierInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkShaderModuleValidationCacheCreateInfoEXT(std::ostream &out, const VkShaderModuleValidationCacheCreateInfoEXT* structInfo, Decoded_VkShaderModuleValidationCacheCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->validationCache) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "shaderModuleValidationCacheCreateInfoEXT");
    out << "\t\t" << "VkShaderModuleValidationCacheCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkValidationCacheCreateInfoEXT(std::ostream &out, const VkValidationCacheCreateInfoEXT* structInfo, Decoded_VkValidationCacheCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pinitial_data_array = "NULL";
    if (structInfo->pInitialData != NULL) {
        std::string pinitial_data_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->initialDataSize; ++idx0) {
            pinitial_data_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pInitialData)[idx0]) + ", ";
        }
        pinitial_data_array = "pInitialData_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pinitial_data_array << "[] = {" << pinitial_data_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkValidationCacheCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->initialDataSize << "," << std::endl;
    struct_body << "\t\t\t" << pinitial_data_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "validationCacheCreateInfoEXT");
    out << "\t\t" << "VkValidationCacheCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCoarseSampleLocationNV(std::ostream &out, const VkCoarseSampleLocationNV* structInfo, Decoded_VkCoarseSampleLocationNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->pixelX << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pixelY << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sample << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "coarseSampleLocationNV");
    out << "\t\t" << "VkCoarseSampleLocationNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCoarseSampleOrderCustomNV(std::ostream &out, const VkCoarseSampleOrderCustomNV* structInfo, Decoded_VkCoarseSampleOrderCustomNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string psample_locations_array = "NULL";
    if (structInfo->pSampleLocations != NULL) {
        psample_locations_array = "pSampleLocations_" + std::to_string(consumer.GetNextId());
        std::string psample_locations_names;
        for (uint32_t idx = 0; idx < structInfo->sampleLocationCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pSampleLocations + idx != NULL) {
                variable_name = GenerateStruct_VkCoarseSampleLocationNV(out,
                                                                        structInfo->pSampleLocations + idx,
                                                                        metaInfo->pSampleLocations->GetMetaStructPointer() + idx,
                                                                        consumer);
            }
            psample_locations_names += variable_name + ", ";
        }
        out << "\t\t" << "VkCoarseSampleLocationNV " << psample_locations_array << "[] = {" << psample_locations_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkShadingRatePaletteEntryNV(" << structInfo->shadingRate << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sampleCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sampleLocationCount << "," << std::endl;
    struct_body << "\t\t\t" << psample_locations_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "coarseSampleOrderCustomNV");
    out << "\t\t" << "VkCoarseSampleOrderCustomNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShadingRateImageFeaturesNV(std::ostream &out, const VkPhysicalDeviceShadingRateImageFeaturesNV* structInfo, Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shadingRateImage << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shadingRateCoarseSampleOrder << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShadingRateImageFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceShadingRateImageFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShadingRateImagePropertiesNV(std::ostream &out, const VkPhysicalDeviceShadingRateImagePropertiesNV* structInfo, Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string shading_rate_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                             &structInfo->shadingRateTexelSize,
                                                                             metaInfo->shadingRateTexelSize,
                                                                             consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << shading_rate_texel_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shadingRatePaletteSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shadingRateMaxCoarseSamples << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShadingRateImagePropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceShadingRateImagePropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(std::ostream &out, const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcustom_sample_orders_array = "NULL";
    if (structInfo->pCustomSampleOrders != NULL) {
        pcustom_sample_orders_array = "pCustomSampleOrders_" + std::to_string(consumer.GetNextId());
        std::string pcustom_sample_orders_names;
        for (uint32_t idx = 0; idx < structInfo->customSampleOrderCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pCustomSampleOrders + idx != NULL) {
                variable_name = GenerateStruct_VkCoarseSampleOrderCustomNV(out,
                                                                           structInfo->pCustomSampleOrders + idx,
                                                                           metaInfo->pCustomSampleOrders->GetMetaStructPointer() + idx,
                                                                           consumer);
            }
            pcustom_sample_orders_names += variable_name + ", ";
        }
        out << "\t\t" << "VkCoarseSampleOrderCustomNV " << pcustom_sample_orders_array << "[] = {" << pcustom_sample_orders_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkCoarseSampleOrderTypeNV(" << structInfo->sampleOrderType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->customSampleOrderCount << "," << std::endl;
    struct_body << "\t\t\t" << pcustom_sample_orders_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportCoarseSampleOrderStateCreateInfoNV");
    out << "\t\t" << "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportShadingRateImageStateCreateInfoNV(std::ostream &out, const VkPipelineViewportShadingRateImageStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pshading_rate_palettes_array = "NULL";
    if (structInfo->pShadingRatePalettes != NULL) {
        pshading_rate_palettes_array = "pShadingRatePalettes_" + std::to_string(consumer.GetNextId());
        std::string pshading_rate_palettes_names;
        for (uint32_t idx = 0; idx < structInfo->viewportCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pShadingRatePalettes + idx != NULL) {
                variable_name = GenerateStruct_VkShadingRatePaletteNV(out,
                                                                      structInfo->pShadingRatePalettes + idx,
                                                                      metaInfo->pShadingRatePalettes->GetMetaStructPointer() + idx,
                                                                      consumer);
            }
            pshading_rate_palettes_names += variable_name + ", ";
        }
        out << "\t\t" << "VkShadingRatePaletteNV " << pshading_rate_palettes_array << "[] = {" << pshading_rate_palettes_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shadingRateImageEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewportCount << "," << std::endl;
    struct_body << "\t\t\t" << pshading_rate_palettes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportShadingRateImageStateCreateInfoNV");
    out << "\t\t" << "VkPipelineViewportShadingRateImageStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkShadingRatePaletteNV(std::ostream &out, const VkShadingRatePaletteNV* structInfo, Decoded_VkShadingRatePaletteNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pshading_rate_palette_entries_values;
    std::string pshading_rate_palette_entries_array = "NULL";
    if (structInfo->pShadingRatePaletteEntries != NULL) {
        for (uint32_t idx = 0; idx < structInfo->shadingRatePaletteEntryCount; idx++) {
            pshading_rate_palette_entries_values += util::ToString<VkShadingRatePaletteEntryNV>(structInfo->pShadingRatePaletteEntries[idx]) + ", ";
        }
        pshading_rate_palette_entries_array = "pShadingRatePaletteEntries_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkShadingRatePaletteEntryNV " << pshading_rate_palette_entries_array << "[] = {" << pshading_rate_palette_entries_values << "};" << std::endl;
    }
    struct_body << "\t" << structInfo->shadingRatePaletteEntryCount << "," << std::endl;
    struct_body << "\t\t\t" << pshading_rate_palette_entries_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "shadingRatePaletteNV");
    out << "\t\t" << "VkShadingRatePaletteNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAabbPositionsKHR(std::ostream &out, const VkAabbPositionsKHR* structInfo, Decoded_VkAabbPositionsKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->minX << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minY << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minZ << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxX << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxY << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxZ << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "aabbPositionsKHR");
    out << "\t\t" << "VkAabbPositionsKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureCreateInfoNV(std::ostream &out, const VkAccelerationStructureCreateInfoNV* structInfo, Decoded_VkAccelerationStructureCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string info_info_var = GenerateStruct_VkAccelerationStructureInfoNV(out,
                                                                             &structInfo->info,
                                                                             metaInfo->info,
                                                                             consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->compactedSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << info_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureCreateInfoNV");
    out << "\t\t" << "VkAccelerationStructureCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureInfoNV(std::ostream &out, const VkAccelerationStructureInfoNV* structInfo, Decoded_VkAccelerationStructureInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pgeometries_array = "NULL";
    if (structInfo->pGeometries != NULL) {
        pgeometries_array = "pGeometries_" + std::to_string(consumer.GetNextId());
        std::string pgeometries_names;
        for (uint32_t idx = 0; idx < structInfo->geometryCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pGeometries + idx != NULL) {
                variable_name = GenerateStruct_VkGeometryNV(out,
                                                            structInfo->pGeometries + idx,
                                                            metaInfo->pGeometries->GetMetaStructPointer() + idx,
                                                            consumer);
            }
            pgeometries_names += variable_name + ", ";
        }
        out << "\t\t" << "VkGeometryNV " << pgeometries_array << "[] = {" << pgeometries_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccelerationStructureTypeNV(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBuildAccelerationStructureFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->geometryCount << "," << std::endl;
    struct_body << "\t\t\t" << pgeometries_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureInfoNV");
    out << "\t\t" << "VkAccelerationStructureInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureInstanceKHR(std::ostream &out, const VkAccelerationStructureInstanceKHR* structInfo, Decoded_VkAccelerationStructureInstanceKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string transform_info_var = GenerateStruct_VkTransformMatrixKHR(out,
                                                                         &structInfo->transform,
                                                                         metaInfo->transform,
                                                                         consumer);
    struct_body << "\t" << transform_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceCustomIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->mask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceShaderBindingTableRecordOffset << "," << std::endl;
    struct_body << "\t\t\t" << "VkGeometryInstanceFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->accelerationStructureReference << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureInstanceKHR");
    out << "\t\t" << "VkAccelerationStructureInstanceKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureMemoryRequirementsInfoNV(std::ostream &out, const VkAccelerationStructureMemoryRequirementsInfoNV* structInfo, Decoded_VkAccelerationStructureMemoryRequirementsInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccelerationStructureMemoryRequirementsTypeNV(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->accelerationStructure) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureMemoryRequirementsInfoNV");
    out << "\t\t" << "VkAccelerationStructureMemoryRequirementsInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindAccelerationStructureMemoryInfoNV(std::ostream &out, const VkBindAccelerationStructureMemoryInfoNV* structInfo, Decoded_VkBindAccelerationStructureMemoryInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdevice_indices_array = "NULL";
    if (structInfo->pDeviceIndices != NULL) {
        pdevice_indices_array = "pDeviceIndices_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pdevice_indices_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceIndices, structInfo->deviceIndexCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->accelerationStructure) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceIndexCount << "," << std::endl;
    struct_body << "\t\t\t" << pdevice_indices_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindAccelerationStructureMemoryInfoNV");
    out << "\t\t" << "VkBindAccelerationStructureMemoryInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeometryAABBNV(std::ostream &out, const VkGeometryAABBNV* structInfo, Decoded_VkGeometryAABBNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->aabbData) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->numAABBs << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stride << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "geometryAABBNV");
    out << "\t\t" << "VkGeometryAABBNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeometryDataNV(std::ostream &out, const VkGeometryDataNV* structInfo, Decoded_VkGeometryDataNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string triangles_info_var = GenerateStruct_VkGeometryTrianglesNV(out,
                                                                          &structInfo->triangles,
                                                                          metaInfo->triangles,
                                                                          consumer);
    std::string aabbs_info_var = GenerateStruct_VkGeometryAABBNV(out,
                                                                 &structInfo->aabbs,
                                                                 metaInfo->aabbs,
                                                                 consumer);
    struct_body << "\t" << triangles_info_var << "," << std::endl;
    struct_body << "\t\t\t" << aabbs_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "geometryDataNV");
    out << "\t\t" << "VkGeometryDataNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeometryNV(std::ostream &out, const VkGeometryNV* structInfo, Decoded_VkGeometryNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string geometry_info_var = GenerateStruct_VkGeometryDataNV(out,
                                                                    &structInfo->geometry,
                                                                    metaInfo->geometry,
                                                                    consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkGeometryTypeKHR(" << structInfo->geometryType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << geometry_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "VkGeometryFlagsKHR(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "geometryNV");
    out << "\t\t" << "VkGeometryNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeometryTrianglesNV(std::ostream &out, const VkGeometryTrianglesNV* structInfo, Decoded_VkGeometryTrianglesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->vertexData) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->vertexFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->indexData) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexCount << "," << std::endl;
    struct_body << "\t\t\t" << "VkIndexType(" << structInfo->indexType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->transformData) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->transformOffset << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "geometryTrianglesNV");
    out << "\t\t" << "VkGeometryTrianglesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingPropertiesNV(std::ostream &out, const VkPhysicalDeviceRayTracingPropertiesNV* structInfo, Decoded_VkPhysicalDeviceRayTracingPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderGroupHandleSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxRecursionDepth << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxShaderGroupStride << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderGroupBaseAlignment << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxGeometryCount << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxInstanceCount << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTriangleCount << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetAccelerationStructures << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceRayTracingPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRayTracingPipelineCreateInfoNV(std::ostream &out, const VkRayTracingPipelineCreateInfoNV* structInfo, Decoded_VkRayTracingPipelineCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstages_array = "NULL";
    if (structInfo->pStages != NULL) {
        pstages_array = "pStages_" + std::to_string(consumer.GetNextId());
        std::string pstages_names;
        for (uint32_t idx = 0; idx < structInfo->stageCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStages + idx != NULL) {
                variable_name = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                                               structInfo->pStages + idx,
                                                                               metaInfo->pStages->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pstages_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPipelineShaderStageCreateInfo " << pstages_array << "[] = {" << pstages_names << "};" << std::endl;
    }
    std::string pgroups_array = "NULL";
    if (structInfo->pGroups != NULL) {
        pgroups_array = "pGroups_" + std::to_string(consumer.GetNextId());
        std::string pgroups_names;
        for (uint32_t idx = 0; idx < structInfo->groupCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pGroups + idx != NULL) {
                variable_name = GenerateStruct_VkRayTracingShaderGroupCreateInfoNV(out,
                                                                                   structInfo->pGroups + idx,
                                                                                   metaInfo->pGroups->GetMetaStructPointer() + idx,
                                                                                   consumer);
            }
            pgroups_names += variable_name + ", ";
        }
        out << "\t\t" << "VkRayTracingShaderGroupCreateInfoNV " << pgroups_array << "[] = {" << pgroups_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stageCount << "," << std::endl;
    struct_body << "\t\t\t" << pstages_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->groupCount << "," << std::endl;
    struct_body << "\t\t\t" << pgroups_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxRecursionDepth << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->layout) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->basePipelineHandle) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->basePipelineIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "rayTracingPipelineCreateInfoNV");
    out << "\t\t" << "VkRayTracingPipelineCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRayTracingShaderGroupCreateInfoNV(std::ostream &out, const VkRayTracingShaderGroupCreateInfoNV* structInfo, Decoded_VkRayTracingShaderGroupCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkRayTracingShaderGroupTypeKHR(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->generalShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->closestHitShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->anyHitShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->intersectionShader << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "rayTracingShaderGroupCreateInfoNV");
    out << "\t\t" << "VkRayTracingShaderGroupCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTransformMatrixKHR(std::ostream &out, const VkTransformMatrixKHR* structInfo, Decoded_VkTransformMatrixKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->matrix[0][0]), 3) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "transformMatrixKHR");
    out << "\t\t" << "VkTransformMatrixKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWriteDescriptorSetAccelerationStructureNV(std::ostream &out, const VkWriteDescriptorSetAccelerationStructureNV* structInfo, Decoded_VkWriteDescriptorSetAccelerationStructureNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pacceleration_structures_array = "NULL";
    if (metaInfo->pAccelerationStructures.GetPointer() != NULL && structInfo->accelerationStructureCount > 0) {
        pacceleration_structures_array = "pacceleration_structures_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV));
        std::string pacceleration_structures_values = toStringJoin(metaInfo->pAccelerationStructures.GetPointer(),
                                                                   metaInfo->pAccelerationStructures.GetPointer() + structInfo->accelerationStructureCount,
                                                                   [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                                   ", ");
        if (structInfo->accelerationStructureCount == 1) {
            pacceleration_structures_array = "&" + pacceleration_structures_values;
        } else if (structInfo->accelerationStructureCount > 1) {
            out << "\t\t" << "VkAccelerationStructureNV " << pacceleration_structures_array << "[] = {" << pacceleration_structures_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->accelerationStructureCount << "," << std::endl;
    struct_body << "\t\t\t" << pacceleration_structures_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "writeDescriptorSetAccelerationStructureNV");
    out << "\t\t" << "VkWriteDescriptorSetAccelerationStructureNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(std::ostream &out, const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* structInfo, Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->representativeFragmentTest << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRepresentativeFragmentTestFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(std::ostream &out, const VkPipelineRepresentativeFragmentTestStateCreateInfoNV* structInfo, Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->representativeFragmentTestEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRepresentativeFragmentTestStateCreateInfoNV");
    out << "\t\t" << "VkPipelineRepresentativeFragmentTestStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFilterCubicImageViewImageFormatPropertiesEXT(std::ostream &out, const VkFilterCubicImageViewImageFormatPropertiesEXT* structInfo, Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->filterCubic << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->filterCubicMinmax << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "filterCubicImageViewImageFormatPropertiesEXT");
    out << "\t\t" << "VkFilterCubicImageViewImageFormatPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageViewImageFormatInfoEXT(std::ostream &out, const VkPhysicalDeviceImageViewImageFormatInfoEXT* structInfo, Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageViewType(" << structInfo->imageViewType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageViewImageFormatInfoEXT");
    out << "\t\t" << "VkPhysicalDeviceImageViewImageFormatInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryHostPointerPropertiesEXT(std::ostream &out, const VkMemoryHostPointerPropertiesEXT* structInfo, Decoded_VkMemoryHostPointerPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryTypeBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryHostPointerPropertiesEXT");
    out << "\t\t" << "VkMemoryHostPointerPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(std::ostream &out, const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minImportedHostPointerAlignment << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalMemoryHostPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceExternalMemoryHostPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCompilerControlCreateInfoAMD(std::ostream &out, const VkPipelineCompilerControlCreateInfoAMD* structInfo, Decoded_VkPipelineCompilerControlCreateInfoAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineCompilerControlFlagsAMD(" << structInfo->compilerControlFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCompilerControlCreateInfoAMD");
    out << "\t\t" << "VkPipelineCompilerControlCreateInfoAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCorePropertiesAMD(std::ostream &out, const VkPhysicalDeviceShaderCorePropertiesAMD* structInfo, Decoded_VkPhysicalDeviceShaderCorePropertiesAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderEngineCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderArraysPerEngineCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->computeUnitsPerShaderArray << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->simdPerComputeUnit << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->wavefrontsPerSimd << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->wavefrontSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sgprsPerSimd << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minSgprAllocation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSgprAllocation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sgprAllocationGranularity << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vgprsPerSimd << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minVgprAllocation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxVgprAllocation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vgprAllocationGranularity << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderCorePropertiesAMD");
    out << "\t\t" << "VkPhysicalDeviceShaderCorePropertiesAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceMemoryOverallocationCreateInfoAMD(std::ostream &out, const VkDeviceMemoryOverallocationCreateInfoAMD* structInfo, Decoded_VkDeviceMemoryOverallocationCreateInfoAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkMemoryOverallocationBehaviorAMD(" << structInfo->overallocationBehavior << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceMemoryOverallocationCreateInfoAMD");
    out << "\t\t" << "VkDeviceMemoryOverallocationCreateInfoAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(std::ostream &out, const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxVertexAttribDivisor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVertexAttributeDivisorPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentFrameTokenGGP(std::ostream &out, const VkPresentFrameTokenGGP* structInfo, Decoded_VkPresentFrameTokenGGP* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frameToken << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentFrameTokenGGP");
    out << "\t\t" << "VkPresentFrameTokenGGP " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrawMeshTasksIndirectCommandNV(std::ostream &out, const VkDrawMeshTasksIndirectCommandNV* structInfo, Decoded_VkDrawMeshTasksIndirectCommandNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->taskCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->firstTask << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drawMeshTasksIndirectCommandNV");
    out << "\t\t" << "VkDrawMeshTasksIndirectCommandNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMeshShaderFeaturesNV(std::ostream &out, const VkPhysicalDeviceMeshShaderFeaturesNV* structInfo, Decoded_VkPhysicalDeviceMeshShaderFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->taskShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->meshShader << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMeshShaderFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceMeshShaderFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMeshShaderPropertiesNV(std::ostream &out, const VkPhysicalDeviceMeshShaderPropertiesNV* structInfo, Decoded_VkPhysicalDeviceMeshShaderPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDrawMeshTasksCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTaskWorkGroupInvocations << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxTaskWorkGroupSize[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTaskTotalMemorySize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTaskOutputCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshWorkGroupInvocations << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxMeshWorkGroupSize[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshTotalMemorySize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshOutputVertices << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshOutputPrimitives << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshMultiviewViewCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->meshOutputPerVertexGranularity << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->meshOutputPerPrimitiveGranularity << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMeshShaderPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceMeshShaderPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderImageFootprintFeaturesNV(std::ostream &out, const VkPhysicalDeviceShaderImageFootprintFeaturesNV* structInfo, Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageFootprint << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderImageFootprintFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceShaderImageFootprintFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExclusiveScissorFeaturesNV(std::ostream &out, const VkPhysicalDeviceExclusiveScissorFeaturesNV* structInfo, Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->exclusiveScissor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExclusiveScissorFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceExclusiveScissorFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportExclusiveScissorStateCreateInfoNV(std::ostream &out, const VkPipelineViewportExclusiveScissorStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pexclusive_scissors_array = "NULL";
    if (structInfo->pExclusiveScissors != NULL) {
        pexclusive_scissors_array = "pExclusiveScissors_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkRect2D " << pexclusive_scissors_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pExclusiveScissors, structInfo->exclusiveScissorCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->exclusiveScissorCount << "," << std::endl;
    struct_body << "\t\t\t" << pexclusive_scissors_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportExclusiveScissorStateCreateInfoNV");
    out << "\t\t" << "VkPipelineViewportExclusiveScissorStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCheckpointData2NV(std::ostream &out, const VkCheckpointData2NV* structInfo, Decoded_VkCheckpointData2NV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->stage << ")" << "," << std::endl;
    out << "\t\t" << "// TODO: Support pCheckpointMarker (non-struct output) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "checkpointData2NV");
    out << "\t\t" << "VkCheckpointData2NV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCheckpointDataNV(std::ostream &out, const VkCheckpointDataNV* structInfo, Decoded_VkCheckpointDataNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlagBits(" << structInfo->stage << ")" << "," << std::endl;
    out << "\t\t" << "// TODO: Support pCheckpointMarker (non-struct output) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "checkpointDataNV");
    out << "\t\t" << "VkCheckpointDataNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyCheckpointProperties2NV(std::ostream &out, const VkQueueFamilyCheckpointProperties2NV* structInfo, Decoded_VkQueueFamilyCheckpointProperties2NV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlags2(" << structInfo->checkpointExecutionStageMask << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyCheckpointProperties2NV");
    out << "\t\t" << "VkQueueFamilyCheckpointProperties2NV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyCheckpointPropertiesNV(std::ostream &out, const VkQueueFamilyCheckpointPropertiesNV* structInfo, Decoded_VkQueueFamilyCheckpointPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineStageFlags(" << structInfo->checkpointExecutionStageMask << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyCheckpointPropertiesNV");
    out << "\t\t" << "VkQueueFamilyCheckpointPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPastPresentationTimingEXT(std::ostream &out, const VkPastPresentationTimingEXT* structInfo, Decoded_VkPastPresentationTimingEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppresent_stages_array = "NULL";
    if (structInfo->pPresentStages != NULL) {
        ppresent_stages_array = "pPresentStages_" + std::to_string(consumer.GetNextId());
        std::string ppresent_stages_names;
        for (uint32_t idx = 0; idx < structInfo->presentStageCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPresentStages + idx != NULL) {
                variable_name = GenerateStruct_VkPresentStageTimeEXT(out,
                                                                     structInfo->pPresentStages + idx,
                                                                     metaInfo->pPresentStages->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            ppresent_stages_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPresentStageTimeEXT " << ppresent_stages_array << "[] = {" << ppresent_stages_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentId << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->targetTime << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentStageCount << "," << std::endl;
    struct_body << "\t\t\t" << ppresent_stages_array << "," << std::endl;
    struct_body << "\t\t\t" << "VkTimeDomainKHR(" << structInfo->timeDomain << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timeDomainId << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reportComplete << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pastPresentationTimingEXT");
    out << "\t\t" << "VkPastPresentationTimingEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPastPresentationTimingInfoEXT(std::ostream &out, const VkPastPresentationTimingInfoEXT* structInfo, Decoded_VkPastPresentationTimingInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPastPresentationTimingFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->swapchain) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pastPresentationTimingInfoEXT");
    out << "\t\t" << "VkPastPresentationTimingInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPastPresentationTimingPropertiesEXT(std::ostream &out, const VkPastPresentationTimingPropertiesEXT* structInfo, Decoded_VkPastPresentationTimingPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppresentation_timings_array = "NULL";
    if (structInfo->pPresentationTimings != NULL) {
        ppresentation_timings_array = "pPresentationTimings_" + std::to_string(consumer.GetNextId());
        std::string ppresentation_timings_names;
        for (uint32_t idx = 0; idx < structInfo->presentationTimingCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPresentationTimings + idx != NULL) {
                variable_name = GenerateStruct_VkPastPresentationTimingEXT(out,
                                                                           structInfo->pPresentationTimings + idx,
                                                                           metaInfo->pPresentationTimings->GetMetaStructPointer() + idx,
                                                                           consumer);
            }
            ppresentation_timings_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPastPresentationTimingEXT " << ppresentation_timings_array << "[] = {" << ppresentation_timings_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timingPropertiesCounter << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timeDomainsCounter << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentationTimingCount << "," << std::endl;
    struct_body << "\t\t\t" << ppresentation_timings_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pastPresentationTimingPropertiesEXT");
    out << "\t\t" << "VkPastPresentationTimingPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePresentTimingFeaturesEXT(std::ostream &out, const VkPhysicalDevicePresentTimingFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePresentTimingFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentTiming << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentAtAbsoluteTime << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentAtRelativeTime << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePresentTimingFeaturesEXT");
    out << "\t\t" << "VkPhysicalDevicePresentTimingFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentStageTimeEXT(std::ostream &out, const VkPresentStageTimeEXT* structInfo, Decoded_VkPresentStageTimeEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkPresentStageFlagsEXT(" << structInfo->stage << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->time << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentStageTimeEXT");
    out << "\t\t" << "VkPresentStageTimeEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentTimingInfoEXT(std::ostream &out, const VkPresentTimingInfoEXT* structInfo, Decoded_VkPresentTimingInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPresentTimingInfoFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->targetTime << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timeDomainId << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPresentStageFlagsEXT(" << structInfo->presentStageQueries << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPresentStageFlagsEXT(" << structInfo->targetTimeDomainPresentStage << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentTimingInfoEXT");
    out << "\t\t" << "VkPresentTimingInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentTimingSurfaceCapabilitiesEXT(std::ostream &out, const VkPresentTimingSurfaceCapabilitiesEXT* structInfo, Decoded_VkPresentTimingSurfaceCapabilitiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentTimingSupported << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentAtAbsoluteTimeSupported << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentAtRelativeTimeSupported << "," << std::endl;
    struct_body << "\t\t\t" << "VkPresentStageFlagsEXT(" << structInfo->presentStageQueries << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentTimingSurfaceCapabilitiesEXT");
    out << "\t\t" << "VkPresentTimingSurfaceCapabilitiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPresentTimingsInfoEXT(std::ostream &out, const VkPresentTimingsInfoEXT* structInfo, Decoded_VkPresentTimingsInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ptiming_infos_array = "NULL";
    if (structInfo->pTimingInfos != NULL) {
        ptiming_infos_array = "pTimingInfos_" + std::to_string(consumer.GetNextId());
        std::string ptiming_infos_names;
        for (uint32_t idx = 0; idx < structInfo->swapchainCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pTimingInfos + idx != NULL) {
                variable_name = GenerateStruct_VkPresentTimingInfoEXT(out,
                                                                      structInfo->pTimingInfos + idx,
                                                                      metaInfo->pTimingInfos->GetMetaStructPointer() + idx,
                                                                      consumer);
            }
            ptiming_infos_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPresentTimingInfoEXT " << ptiming_infos_array << "[] = {" << ptiming_infos_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->swapchainCount << "," << std::endl;
    struct_body << "\t\t\t" << ptiming_infos_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "presentTimingsInfoEXT");
    out << "\t\t" << "VkPresentTimingsInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainCalibratedTimestampInfoEXT(std::ostream &out, const VkSwapchainCalibratedTimestampInfoEXT* structInfo, Decoded_VkSwapchainCalibratedTimestampInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->swapchain) << "," << std::endl;
    struct_body << "\t\t\t" << "VkPresentStageFlagsEXT(" << structInfo->presentStage << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timeDomainId << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainCalibratedTimestampInfoEXT");
    out << "\t\t" << "VkSwapchainCalibratedTimestampInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainTimeDomainPropertiesEXT(std::ostream &out, const VkSwapchainTimeDomainPropertiesEXT* structInfo, Decoded_VkSwapchainTimeDomainPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ptime_domains_array = "NULL";
    if (structInfo->pTimeDomains != NULL) {
        std::string ptime_domains_values;
        for (uint32_t idx = 0; idx < structInfo->timeDomainCount; idx++) {
            ptime_domains_values += util::ToString<VkTimeDomainKHR>(structInfo->pTimeDomains[idx]) + ", ";
        }
        ptime_domains_array = "pTimeDomains_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkTimeDomainKHR " << ptime_domains_array << "[] = {" << ptime_domains_values << "};" << std::endl;
    }
    std::string ptime_domain_ids_array = "ptime_domain_ids_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->timeDomainCount > 0) {
        std::string ptime_domain_ids_values = toStringJoin(structInfo->pTimeDomainIds,
                                                           structInfo->pTimeDomainIds + structInfo->timeDomainCount,
                                                           [](uint64_t current) { return std::to_string(current); },
                                                           ", ");
        if (structInfo->timeDomainCount == 1) {
            ptime_domain_ids_array = "&" + ptime_domain_ids_values;
        } else if (structInfo->timeDomainCount > 1) {
            out << "\t\t" << "uint64_t " << ptime_domain_ids_array << "[] = {" << ptime_domain_ids_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timeDomainCount << "," << std::endl;
    struct_body << "\t\t\t" << ptime_domains_array << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << ptime_domain_ids_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainTimeDomainPropertiesEXT");
    out << "\t\t" << "VkSwapchainTimeDomainPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainTimingPropertiesEXT(std::ostream &out, const VkSwapchainTimingPropertiesEXT* structInfo, Decoded_VkSwapchainTimingPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->refreshDuration << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->refreshInterval << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainTimingPropertiesEXT");
    out << "\t\t" << "VkSwapchainTimingPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(std::ostream &out, const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* structInfo, Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderIntegerFunctions2 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderIntegerFunctions2FeaturesINTEL");
    out << "\t\t" << "VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkInitializePerformanceApiInfoINTEL(std::ostream &out, const VkInitializePerformanceApiInfoINTEL* structInfo, Decoded_VkInitializePerformanceApiInfoINTEL* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    out << "\t\t" << "// TODO: Support pUserData (non-struct output) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "initializePerformanceApiInfoINTEL");
    out << "\t\t" << "VkInitializePerformanceApiInfoINTEL " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceConfigurationAcquireInfoINTEL(std::ostream &out, const VkPerformanceConfigurationAcquireInfoINTEL* structInfo, Decoded_VkPerformanceConfigurationAcquireInfoINTEL* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPerformanceConfigurationTypeINTEL(" << structInfo->type << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceConfigurationAcquireInfoINTEL");
    out << "\t\t" << "VkPerformanceConfigurationAcquireInfoINTEL " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceMarkerInfoINTEL(std::ostream &out, const VkPerformanceMarkerInfoINTEL* structInfo, Decoded_VkPerformanceMarkerInfoINTEL* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->marker << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceMarkerInfoINTEL");
    out << "\t\t" << "VkPerformanceMarkerInfoINTEL " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceOverrideInfoINTEL(std::ostream &out, const VkPerformanceOverrideInfoINTEL* structInfo, Decoded_VkPerformanceOverrideInfoINTEL* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPerformanceOverrideTypeINTEL(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->parameter << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceOverrideInfoINTEL");
    out << "\t\t" << "VkPerformanceOverrideInfoINTEL " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceStreamMarkerInfoINTEL(std::ostream &out, const VkPerformanceStreamMarkerInfoINTEL* structInfo, Decoded_VkPerformanceStreamMarkerInfoINTEL* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->marker << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceStreamMarkerInfoINTEL");
    out << "\t\t" << "VkPerformanceStreamMarkerInfoINTEL " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueryPoolPerformanceQueryCreateInfoINTEL(std::ostream &out, const VkQueryPoolPerformanceQueryCreateInfoINTEL* structInfo, Decoded_VkQueryPoolPerformanceQueryCreateInfoINTEL* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkQueryPoolSamplingModeINTEL(" << structInfo->performanceCountersSampling << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queryPoolPerformanceQueryCreateInfoINTEL");
    out << "\t\t" << "VkQueryPoolPerformanceQueryCreateInfoINTEL " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePCIBusInfoPropertiesEXT(std::ostream &out, const VkPhysicalDevicePCIBusInfoPropertiesEXT* structInfo, Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pciDomain << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pciBus << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pciDevice << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pciFunction << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePCIBusInfoPropertiesEXT");
    out << "\t\t" << "VkPhysicalDevicePCIBusInfoPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayNativeHdrSurfaceCapabilitiesAMD(std::ostream &out, const VkDisplayNativeHdrSurfaceCapabilitiesAMD* structInfo, Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->localDimmingSupport << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayNativeHdrSurfaceCapabilitiesAMD");
    out << "\t\t" << "VkDisplayNativeHdrSurfaceCapabilitiesAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainDisplayNativeHdrCreateInfoAMD(std::ostream &out, const VkSwapchainDisplayNativeHdrCreateInfoAMD* structInfo, Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->localDimmingEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainDisplayNativeHdrCreateInfoAMD");
    out << "\t\t" << "VkSwapchainDisplayNativeHdrCreateInfoAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImagePipeSurfaceCreateInfoFUCHSIA(std::ostream &out, const VkImagePipeSurfaceCreateInfoFUCHSIA* structInfo, Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImagePipeSurfaceCreateFlagsFUCHSIA(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imagePipeHandle << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imagePipeSurfaceCreateInfoFUCHSIA");
    out << "\t\t" << "VkImagePipeSurfaceCreateInfoFUCHSIA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMetalSurfaceCreateInfoEXT(std::ostream &out, const VkMetalSurfaceCreateInfoEXT* structInfo, Decoded_VkMetalSurfaceCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkMetalSurfaceCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<const CAMetalLayer*>(" << structInfo->pLayer << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "metalSurfaceCreateInfoEXT");
    out << "\t\t" << "VkMetalSurfaceCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    out << "\t\t" << "OverrideVkMetalSurfaceCreateInfoEXT(&" << variable_name << ", " << "appdata" << ");" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(std::ostream &out, const VkPhysicalDeviceFragmentDensityMapFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentDensityMap << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentDensityMapDynamic << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentDensityMapNonSubsampledImages << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentDensityMapFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceFragmentDensityMapFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(std::ostream &out, const VkPhysicalDeviceFragmentDensityMapPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string min_fragment_density_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                     &structInfo->minFragmentDensityTexelSize,
                                                                                     metaInfo->minFragmentDensityTexelSize,
                                                                                     consumer);
    std::string max_fragment_density_texel_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                     &structInfo->maxFragmentDensityTexelSize,
                                                                                     metaInfo->maxFragmentDensityTexelSize,
                                                                                     consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << min_fragment_density_texel_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_fragment_density_texel_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentDensityInvocations << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentDensityMapPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceFragmentDensityMapPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassFragmentDensityMapCreateInfoEXT(std::ostream &out, const VkRenderPassFragmentDensityMapCreateInfoEXT* structInfo, Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string fragment_density_map_attachment_info_var = GenerateStruct_VkAttachmentReference(out,
                                                                                                &structInfo->fragmentDensityMapAttachment,
                                                                                                metaInfo->fragmentDensityMapAttachment,
                                                                                                consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << fragment_density_map_attachment_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassFragmentDensityMapCreateInfoEXT");
    out << "\t\t" << "VkRenderPassFragmentDensityMapCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderingFragmentDensityMapAttachmentInfoEXT(std::ostream &out, const VkRenderingFragmentDensityMapAttachmentInfoEXT* structInfo, Decoded_VkRenderingFragmentDensityMapAttachmentInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->imageView) << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageLayout(" << structInfo->imageLayout << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderingFragmentDensityMapAttachmentInfoEXT");
    out << "\t\t" << "VkRenderingFragmentDensityMapAttachmentInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCoreProperties2AMD(std::ostream &out, const VkPhysicalDeviceShaderCoreProperties2AMD* structInfo, Decoded_VkPhysicalDeviceShaderCoreProperties2AMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderCorePropertiesFlagsAMD(" << structInfo->shaderCoreFeatures << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->activeComputeUnitCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderCoreProperties2AMD");
    out << "\t\t" << "VkPhysicalDeviceShaderCoreProperties2AMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCoherentMemoryFeaturesAMD(std::ostream &out, const VkPhysicalDeviceCoherentMemoryFeaturesAMD* structInfo, Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceCoherentMemory << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCoherentMemoryFeaturesAMD");
    out << "\t\t" << "VkPhysicalDeviceCoherentMemoryFeaturesAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderImageInt64Atomics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sparseImageInt64Atomics << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderImageAtomicInt64FeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMemoryBudgetPropertiesEXT(std::ostream &out, const VkPhysicalDeviceMemoryBudgetPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string heap_budget_array = "heap_budget_array_" + std::to_string(consumer.GetNextId());
    if (VK_MAX_MEMORY_HEAPS > 0) {
        std::string heap_budget_values = toStringJoin(structInfo->heapBudget,
                                                      structInfo->heapBudget + VK_MAX_MEMORY_HEAPS,
                                                      [](VkDeviceSize current) { return std::to_string(current); },
                                                      ", ");
        if (VK_MAX_MEMORY_HEAPS == 1) {
            heap_budget_array = "&" + heap_budget_values;
        } else if (VK_MAX_MEMORY_HEAPS > 1) {
            out << "\t\t" << "VkDeviceSize " << heap_budget_array << "[] = {" << heap_budget_values << "};" << std::endl;
        }
    }
    std::string heap_usage_array = "heap_usage_array_" + std::to_string(consumer.GetNextId());
    if (VK_MAX_MEMORY_HEAPS > 0) {
        std::string heap_usage_values = toStringJoin(structInfo->heapUsage,
                                                     structInfo->heapUsage + VK_MAX_MEMORY_HEAPS,
                                                     [](VkDeviceSize current) { return std::to_string(current); },
                                                     ", ");
        if (VK_MAX_MEMORY_HEAPS == 1) {
            heap_usage_array = "&" + heap_usage_values;
        } else if (VK_MAX_MEMORY_HEAPS > 1) {
            out << "\t\t" << "VkDeviceSize " << heap_usage_array << "[] = {" << heap_usage_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << heap_budget_array << " }" << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << heap_usage_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMemoryBudgetPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceMemoryBudgetPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryPriorityAllocateInfoEXT(std::ostream &out, const VkMemoryPriorityAllocateInfoEXT* structInfo, Decoded_VkMemoryPriorityAllocateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->priority << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryPriorityAllocateInfoEXT");
    out << "\t\t" << "VkMemoryPriorityAllocateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMemoryPriorityFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMemoryPriorityFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryPriority << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMemoryPriorityFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceMemoryPriorityFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(std::ostream &out, const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dedicatedAllocationImageAliasing << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDedicatedAllocationImageAliasingFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBufferDeviceAddressCreateInfoEXT(std::ostream &out, const VkBufferDeviceAddressCreateInfoEXT* structInfo, Decoded_VkBufferDeviceAddressCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceAddress << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bufferDeviceAddressCreateInfoEXT");
    out << "\t\t" << "VkBufferDeviceAddressCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(std::ostream &out, const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddressCaptureReplay << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferDeviceAddressMultiDevice << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceBufferDeviceAddressFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkValidationFeaturesEXT(std::ostream &out, const VkValidationFeaturesEXT* structInfo, Decoded_VkValidationFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string penabled_validation_features_values;
    std::string penabled_validation_features_array = "NULL";
    if (structInfo->pEnabledValidationFeatures != NULL) {
        for (uint32_t idx = 0; idx < structInfo->enabledValidationFeatureCount; idx++) {
            penabled_validation_features_values += util::ToString<VkValidationFeatureEnableEXT>(structInfo->pEnabledValidationFeatures[idx]) + ", ";
        }
        penabled_validation_features_array = "pEnabledValidationFeatures_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkValidationFeatureEnableEXT " << penabled_validation_features_array << "[] = {" << penabled_validation_features_values << "};" << std::endl;
    }
    std::string pdisabled_validation_features_values;
    std::string pdisabled_validation_features_array = "NULL";
    if (structInfo->pDisabledValidationFeatures != NULL) {
        for (uint32_t idx = 0; idx < structInfo->disabledValidationFeatureCount; idx++) {
            pdisabled_validation_features_values += util::ToString<VkValidationFeatureDisableEXT>(structInfo->pDisabledValidationFeatures[idx]) + ", ";
        }
        pdisabled_validation_features_array = "pDisabledValidationFeatures_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkValidationFeatureDisableEXT " << pdisabled_validation_features_array << "[] = {" << pdisabled_validation_features_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enabledValidationFeatureCount << "," << std::endl;
    struct_body << "\t\t\t" << penabled_validation_features_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->disabledValidationFeatureCount << "," << std::endl;
    struct_body << "\t\t\t" << pdisabled_validation_features_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "validationFeaturesEXT");
    out << "\t\t" << "VkValidationFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCooperativeMatrixPropertiesNV(std::ostream &out, const VkCooperativeMatrixPropertiesNV* structInfo, Decoded_VkCooperativeMatrixPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->MSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->NSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->KSize << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeNV(" << structInfo->AType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeNV(" << structInfo->BType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeNV(" << structInfo->CType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeNV(" << structInfo->DType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkScopeNV(" << structInfo->scope << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "cooperativeMatrixPropertiesNV");
    out << "\t\t" << "VkCooperativeMatrixPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeMatrixFeaturesNV(std::ostream &out, const VkPhysicalDeviceCooperativeMatrixFeaturesNV* structInfo, Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeMatrix << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeMatrixRobustBufferAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCooperativeMatrixFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceCooperativeMatrixFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeMatrixPropertiesNV(std::ostream &out, const VkPhysicalDeviceCooperativeMatrixPropertiesNV* structInfo, Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->cooperativeMatrixSupportedStages << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCooperativeMatrixPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceCooperativeMatrixPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFramebufferMixedSamplesCombinationNV(std::ostream &out, const VkFramebufferMixedSamplesCombinationNV* structInfo, Decoded_VkFramebufferMixedSamplesCombinationNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkCoverageReductionModeNV(" << structInfo->coverageReductionMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->rasterizationSamples << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->depthStencilSamples << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlags(" << structInfo->colorSamples << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "framebufferMixedSamplesCombinationNV");
    out << "\t\t" << "VkFramebufferMixedSamplesCombinationNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCoverageReductionModeFeaturesNV(std::ostream &out, const VkPhysicalDeviceCoverageReductionModeFeaturesNV* structInfo, Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->coverageReductionMode << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCoverageReductionModeFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceCoverageReductionModeFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCoverageReductionStateCreateInfoNV(std::ostream &out, const VkPipelineCoverageReductionStateCreateInfoNV* structInfo, Decoded_VkPipelineCoverageReductionStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineCoverageReductionStateCreateFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkCoverageReductionModeNV(" << structInfo->coverageReductionMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCoverageReductionStateCreateInfoNV");
    out << "\t\t" << "VkPipelineCoverageReductionStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(std::ostream &out, const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShaderSampleInterlock << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShaderPixelInterlock << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShaderShadingRateInterlock << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShaderInterlockFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(std::ostream &out, const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->ycbcrImageArrays << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceYcbcrImageArraysFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceProvokingVertexFeaturesEXT(std::ostream &out, const VkPhysicalDeviceProvokingVertexFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceProvokingVertexFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->provokingVertexLast << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->transformFeedbackPreservesProvokingVertex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceProvokingVertexFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceProvokingVertexFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceProvokingVertexPropertiesEXT(std::ostream &out, const VkPhysicalDeviceProvokingVertexPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceProvokingVertexPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->provokingVertexModePerPipeline << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->transformFeedbackPreservesTriangleFanProvokingVertex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceProvokingVertexPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceProvokingVertexPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(std::ostream &out, const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* structInfo, Decoded_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkProvokingVertexModeEXT(" << structInfo->provokingVertexMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineRasterizationProvokingVertexStateCreateInfoEXT");
    out << "\t\t" << "VkPipelineRasterizationProvokingVertexStateCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceCapabilitiesFullScreenExclusiveEXT(std::ostream &out, const VkSurfaceCapabilitiesFullScreenExclusiveEXT* structInfo, Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fullScreenExclusiveSupported << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceCapabilitiesFullScreenExclusiveEXT");
    out << "\t\t" << "VkSurfaceCapabilitiesFullScreenExclusiveEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceFullScreenExclusiveInfoEXT(std::ostream &out, const VkSurfaceFullScreenExclusiveInfoEXT* structInfo, Decoded_VkSurfaceFullScreenExclusiveInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFullScreenExclusiveEXT(" << structInfo->fullScreenExclusive << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceFullScreenExclusiveInfoEXT");
    out << "\t\t" << "VkSurfaceFullScreenExclusiveInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceFullScreenExclusiveWin32InfoEXT(std::ostream &out, const VkSurfaceFullScreenExclusiveWin32InfoEXT* structInfo, Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<HMONITOR>(" << structInfo->hmonitor << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceFullScreenExclusiveWin32InfoEXT");
    out << "\t\t" << "VkSurfaceFullScreenExclusiveWin32InfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkHeadlessSurfaceCreateInfoEXT(std::ostream &out, const VkHeadlessSurfaceCreateInfoEXT* structInfo, Decoded_VkHeadlessSurfaceCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkHeadlessSurfaceCreateFlagsEXT(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "headlessSurfaceCreateInfoEXT");
    out << "\t\t" << "VkHeadlessSurfaceCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat32Atomics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat32AtomicAdd << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat64Atomics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat64AtomicAdd << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat32Atomics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat32AtomicAdd << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat64Atomics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat64AtomicAdd << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderImageFloat32Atomics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderImageFloat32AtomicAdd << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sparseImageFloat32Atomics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sparseImageFloat32AtomicAdd << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderAtomicFloatFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(std::ostream &out, const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExtendedDynamicStateFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceExtendedDynamicStateFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryMapPlacedInfoEXT(std::ostream &out, const VkMemoryMapPlacedInfoEXT* structInfo, Decoded_VkMemoryMapPlacedInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    out << "\t\t" << "// TODO: Support pPlacedAddress (non-struct output) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "memoryMapPlacedInfoEXT");
    out << "\t\t" << "VkMemoryMapPlacedInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMapMemoryPlacedFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryMapPlaced << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryMapRangePlaced << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryUnmapReserve << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMapMemoryPlacedFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceMapMemoryPlacedFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT(std::ostream &out, const VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceMapMemoryPlacedPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minPlacedMemoryMapAlignment << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMapMemoryPlacedPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceMapMemoryPlacedPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat16Atomics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat16AtomicAdd << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat16AtomicMinMax << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat32AtomicMinMax << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBufferFloat64AtomicMinMax << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat16Atomics << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat16AtomicAdd << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat16AtomicMinMax << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat32AtomicMinMax << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderSharedFloat64AtomicMinMax << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderImageFloat32AtomicMinMax << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sparseImageFloat32AtomicMinMax << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderAtomicFloat2FeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindIndexBufferIndirectCommandNV(std::ostream &out, const VkBindIndexBufferIndirectCommandNV* structInfo, Decoded_VkBindIndexBufferIndirectCommandNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->bufferAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "," << std::endl;
    struct_body << "\t\t\t" << "VkIndexType(" << structInfo->indexType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindIndexBufferIndirectCommandNV");
    out << "\t\t" << "VkBindIndexBufferIndirectCommandNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindShaderGroupIndirectCommandNV(std::ostream &out, const VkBindShaderGroupIndirectCommandNV* structInfo, Decoded_VkBindShaderGroupIndirectCommandNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->groupIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindShaderGroupIndirectCommandNV");
    out << "\t\t" << "VkBindShaderGroupIndirectCommandNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindVertexBufferIndirectCommandNV(std::ostream &out, const VkBindVertexBufferIndirectCommandNV* structInfo, Decoded_VkBindVertexBufferIndirectCommandNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->bufferAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stride << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindVertexBufferIndirectCommandNV");
    out << "\t\t" << "VkBindVertexBufferIndirectCommandNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeneratedCommandsInfoNV(std::ostream &out, const VkGeneratedCommandsInfoNV* structInfo, Decoded_VkGeneratedCommandsInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstreams_array = "NULL";
    if (structInfo->pStreams != NULL) {
        pstreams_array = "pStreams_" + std::to_string(consumer.GetNextId());
        std::string pstreams_names;
        for (uint32_t idx = 0; idx < structInfo->streamCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStreams + idx != NULL) {
                variable_name = GenerateStruct_VkIndirectCommandsStreamNV(out,
                                                                          structInfo->pStreams + idx,
                                                                          metaInfo->pStreams->GetMetaStructPointer() + idx,
                                                                          consumer);
            }
            pstreams_names += variable_name + ", ";
        }
        out << "\t\t" << "VkIndirectCommandsStreamNV " << pstreams_array << "[] = {" << pstreams_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipeline) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->indirectCommandsLayout) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->streamCount << "," << std::endl;
    struct_body << "\t\t\t" << pstreams_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sequencesCount << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->preprocessBuffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preprocessOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preprocessSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->sequencesCountBuffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sequencesCountOffset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->sequencesIndexBuffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sequencesIndexOffset << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "generatedCommandsInfoNV");
    out << "\t\t" << "VkGeneratedCommandsInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeneratedCommandsMemoryRequirementsInfoNV(std::ostream &out, const VkGeneratedCommandsMemoryRequirementsInfoNV* structInfo, Decoded_VkGeneratedCommandsMemoryRequirementsInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipeline) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->indirectCommandsLayout) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSequencesCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "generatedCommandsMemoryRequirementsInfoNV");
    out << "\t\t" << "VkGeneratedCommandsMemoryRequirementsInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGraphicsPipelineShaderGroupsCreateInfoNV(std::ostream &out, const VkGraphicsPipelineShaderGroupsCreateInfoNV* structInfo, Decoded_VkGraphicsPipelineShaderGroupsCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pgroups_array = "NULL";
    if (structInfo->pGroups != NULL) {
        pgroups_array = "pGroups_" + std::to_string(consumer.GetNextId());
        std::string pgroups_names;
        for (uint32_t idx = 0; idx < structInfo->groupCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pGroups + idx != NULL) {
                variable_name = GenerateStruct_VkGraphicsShaderGroupCreateInfoNV(out,
                                                                                 structInfo->pGroups + idx,
                                                                                 metaInfo->pGroups->GetMetaStructPointer() + idx,
                                                                                 consumer);
            }
            pgroups_names += variable_name + ", ";
        }
        out << "\t\t" << "VkGraphicsShaderGroupCreateInfoNV " << pgroups_array << "[] = {" << pgroups_names << "};" << std::endl;
    }
    std::string ppipelines_array = "NULL";
    if (metaInfo->pPipelines.GetPointer() != NULL && structInfo->pipelineCount > 0) {
        ppipelines_array = "ppipelines_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_PIPELINE));
        std::string ppipelines_values = toStringJoin(metaInfo->pPipelines.GetPointer(),
                                                     metaInfo->pPipelines.GetPointer() + structInfo->pipelineCount,
                                                     [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                     ", ");
        if (structInfo->pipelineCount == 1) {
            ppipelines_array = "&" + ppipelines_values;
        } else if (structInfo->pipelineCount > 1) {
            out << "\t\t" << "VkPipeline " << ppipelines_array << "[] = {" << ppipelines_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->groupCount << "," << std::endl;
    struct_body << "\t\t\t" << pgroups_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineCount << "," << std::endl;
    struct_body << "\t\t\t" << ppipelines_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "graphicsPipelineShaderGroupsCreateInfoNV");
    out << "\t\t" << "VkGraphicsPipelineShaderGroupsCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGraphicsShaderGroupCreateInfoNV(std::ostream &out, const VkGraphicsShaderGroupCreateInfoNV* structInfo, Decoded_VkGraphicsShaderGroupCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstages_array = "NULL";
    if (structInfo->pStages != NULL) {
        pstages_array = "pStages_" + std::to_string(consumer.GetNextId());
        std::string pstages_names;
        for (uint32_t idx = 0; idx < structInfo->stageCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStages + idx != NULL) {
                variable_name = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                                               structInfo->pStages + idx,
                                                                               metaInfo->pStages->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pstages_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPipelineShaderStageCreateInfo " << pstages_array << "[] = {" << pstages_names << "};" << std::endl;
    }
    std::string pvertex_input_state_struct = "NULL";
    if (structInfo->pVertexInputState != NULL) {
        pvertex_input_state_struct = GenerateStruct_VkPipelineVertexInputStateCreateInfo(out,
                                                                                         structInfo->pVertexInputState,
                                                                                         metaInfo->pVertexInputState->GetMetaStructPointer(),
                                                                                         consumer);
        pvertex_input_state_struct.insert(0, "&");
    }
    std::string ptessellation_state_struct = "NULL";
    if (structInfo->pTessellationState != NULL) {
        ptessellation_state_struct = GenerateStruct_VkPipelineTessellationStateCreateInfo(out,
                                                                                          structInfo->pTessellationState,
                                                                                          metaInfo->pTessellationState->GetMetaStructPointer(),
                                                                                          consumer);
        ptessellation_state_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stageCount << "," << std::endl;
    struct_body << "\t\t\t" << pstages_array << "," << std::endl;
    struct_body << "\t\t\t" << pvertex_input_state_struct << "," << std::endl;
    struct_body << "\t\t\t" << ptessellation_state_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "graphicsShaderGroupCreateInfoNV");
    out << "\t\t" << "VkGraphicsShaderGroupCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIndirectCommandsLayoutCreateInfoNV(std::ostream &out, const VkIndirectCommandsLayoutCreateInfoNV* structInfo, Decoded_VkIndirectCommandsLayoutCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ptokens_array = "NULL";
    if (structInfo->pTokens != NULL) {
        ptokens_array = "pTokens_" + std::to_string(consumer.GetNextId());
        std::string ptokens_names;
        for (uint32_t idx = 0; idx < structInfo->tokenCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pTokens + idx != NULL) {
                variable_name = GenerateStruct_VkIndirectCommandsLayoutTokenNV(out,
                                                                               structInfo->pTokens + idx,
                                                                               metaInfo->pTokens->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            ptokens_names += variable_name + ", ";
        }
        out << "\t\t" << "VkIndirectCommandsLayoutTokenNV " << ptokens_array << "[] = {" << ptokens_names << "};" << std::endl;
    }
    std::string pstream_strides_array = "NULL";
    if (structInfo->pStreamStrides != NULL) {
        pstream_strides_array = "pStreamStrides_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pstream_strides_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pStreamStrides, structInfo->streamCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkIndirectCommandsLayoutUsageFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tokenCount << "," << std::endl;
    struct_body << "\t\t\t" << ptokens_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->streamCount << "," << std::endl;
    struct_body << "\t\t\t" << pstream_strides_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "indirectCommandsLayoutCreateInfoNV");
    out << "\t\t" << "VkIndirectCommandsLayoutCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIndirectCommandsLayoutTokenNV(std::ostream &out, const VkIndirectCommandsLayoutTokenNV* structInfo, Decoded_VkIndirectCommandsLayoutTokenNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pindex_types_values;
    std::string pindex_types_array = "NULL";
    if (structInfo->pIndexTypes != NULL) {
        for (uint32_t idx = 0; idx < structInfo->indexTypeCount; idx++) {
            pindex_types_values += util::ToString<VkIndexType>(structInfo->pIndexTypes[idx]) + ", ";
        }
        pindex_types_array = "pIndexTypes_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkIndexType " << pindex_types_array << "[] = {" << pindex_types_values << "};" << std::endl;
    }
    std::string pindex_type_values_array = "NULL";
    if (structInfo->pIndexTypeValues != NULL) {
        pindex_type_values_array = "pIndexTypeValues_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint32_t " << pindex_type_values_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pIndexTypeValues, structInfo->indexTypeCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkIndirectCommandsTokenTypeNV(" << structInfo->tokenType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stream << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexBindingUnit << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexDynamicStride << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pushconstantPipelineLayout) << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->pushconstantShaderStageFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pushconstantOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pushconstantSize << "," << std::endl;
    struct_body << "\t\t\t" << "VkIndirectStateFlagsNV(" << structInfo->indirectStateFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexTypeCount << "," << std::endl;
    struct_body << "\t\t\t" << pindex_types_array << "," << std::endl;
    struct_body << "\t\t\t" << pindex_type_values_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "indirectCommandsLayoutTokenNV");
    out << "\t\t" << "VkIndirectCommandsLayoutTokenNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIndirectCommandsStreamNV(std::ostream &out, const VkIndirectCommandsStreamNV* structInfo, Decoded_VkIndirectCommandsStreamNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "indirectCommandsStreamNV");
    out << "\t\t" << "VkIndirectCommandsStreamNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(std::ostream &out, const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceGeneratedCommands << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDeviceGeneratedCommandsFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(std::ostream &out, const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* structInfo, Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxGraphicsShaderGroupCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxIndirectSequenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxIndirectCommandsTokenCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxIndirectCommandsStreamCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxIndirectCommandsTokenOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxIndirectCommandsStreamStride << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minSequencesCountBufferOffsetAlignment << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minSequencesIndexBufferOffsetAlignment << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minIndirectCommandsBufferOffsetAlignment << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDeviceGeneratedCommandsPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSetStateFlagsIndirectCommandNV(std::ostream &out, const VkSetStateFlagsIndirectCommandNV* structInfo, Decoded_VkSetStateFlagsIndirectCommandNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->data << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "setStateFlagsIndirectCommandNV");
    out << "\t\t" << "VkSetStateFlagsIndirectCommandNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferInheritanceViewportScissorInfoNV(std::ostream &out, const VkCommandBufferInheritanceViewportScissorInfoNV* structInfo, Decoded_VkCommandBufferInheritanceViewportScissorInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pviewport_depths_struct = "NULL";
    if (structInfo->pViewportDepths != NULL) {
        pviewport_depths_struct = GenerateStruct_VkViewport(out,
                                                            structInfo->pViewportDepths,
                                                            metaInfo->pViewportDepths->GetMetaStructPointer(),
                                                            consumer);
        pviewport_depths_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewportScissor2D << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->viewportDepthCount << "," << std::endl;
    struct_body << "\t\t\t" << pviewport_depths_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferInheritanceViewportScissorInfoNV");
    out << "\t\t" << "VkCommandBufferInheritanceViewportScissorInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceInheritedViewportScissorFeaturesNV(std::ostream &out, const VkPhysicalDeviceInheritedViewportScissorFeaturesNV* structInfo, Decoded_VkPhysicalDeviceInheritedViewportScissorFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->inheritedViewportScissor2D << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceInheritedViewportScissorFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceInheritedViewportScissorFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(std::ostream &out, const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->texelBufferAlignment << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTexelBufferAlignmentFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(std::ostream &out, const VkCommandBufferInheritanceRenderPassTransformInfoQCOM* structInfo, Decoded_VkCommandBufferInheritanceRenderPassTransformInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string render_area_info_var = GenerateStruct_VkRect2D(out,
                                                               &structInfo->renderArea,
                                                               metaInfo->renderArea,
                                                               consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->transform << ")" << "," << std::endl;
    struct_body << "\t\t\t" << render_area_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "commandBufferInheritanceRenderPassTransformInfoQCOM");
    out << "\t\t" << "VkCommandBufferInheritanceRenderPassTransformInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassTransformBeginInfoQCOM(std::ostream &out, const VkRenderPassTransformBeginInfoQCOM* structInfo, Decoded_VkRenderPassTransformBeginInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->transform << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassTransformBeginInfoQCOM");
    out << "\t\t" << "VkRenderPassTransformBeginInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDepthBiasInfoEXT(std::ostream &out, const VkDepthBiasInfoEXT* structInfo, Decoded_VkDepthBiasInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthBiasConstantFactor << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthBiasClamp << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthBiasSlopeFactor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "depthBiasInfoEXT");
    out << "\t\t" << "VkDepthBiasInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDepthBiasRepresentationInfoEXT(std::ostream &out, const VkDepthBiasRepresentationInfoEXT* structInfo, Decoded_VkDepthBiasRepresentationInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDepthBiasRepresentationEXT(" << structInfo->depthBiasRepresentation << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthBiasExact << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "depthBiasRepresentationInfoEXT");
    out << "\t\t" << "VkDepthBiasRepresentationInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDepthBiasControlFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDepthBiasControlFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDepthBiasControlFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthBiasControl << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->leastRepresentableValueForceUnormRepresentation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->floatRepresentation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthBiasExact << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDepthBiasControlFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceDepthBiasControlFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceDeviceMemoryReportCreateInfoEXT(std::ostream &out, const VkDeviceDeviceMemoryReportCreateInfoEXT* structInfo, Decoded_VkDeviceDeviceMemoryReportCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDeviceMemoryReportFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pfnUserCallback << "," << std::endl;
    out << "\t\t" << "// TODO: Support pUserData (non-struct output) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "deviceDeviceMemoryReportCreateInfoEXT");
    out << "\t\t" << "VkDeviceDeviceMemoryReportCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceMemoryReportCallbackDataEXT(std::ostream &out, const VkDeviceMemoryReportCallbackDataEXT* structInfo, Decoded_VkDeviceMemoryReportCallbackDataEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDeviceMemoryReportFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkDeviceMemoryReportEventTypeEXT(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryObjectId << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkObjectType(" << structInfo->objectType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->objectHandle << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->heapIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceMemoryReportCallbackDataEXT");
    out << "\t\t" << "VkDeviceMemoryReportCallbackDataEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceMemoryReport << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDeviceMemoryReportFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceDeviceMemoryReportFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCustomBorderColorFeaturesEXT(std::ostream &out, const VkPhysicalDeviceCustomBorderColorFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceCustomBorderColorFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->customBorderColors << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->customBorderColorWithoutFormat << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCustomBorderColorFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceCustomBorderColorFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCustomBorderColorPropertiesEXT(std::ostream &out, const VkPhysicalDeviceCustomBorderColorPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceCustomBorderColorPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxCustomBorderColorSamplers << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCustomBorderColorPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceCustomBorderColorPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerCustomBorderColorCreateInfoEXT(std::ostream &out, const VkSamplerCustomBorderColorCreateInfoEXT* structInfo, Decoded_VkSamplerCustomBorderColorCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(structInfo->customBorderColor) << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerCustomBorderColorCreateInfoEXT");
    out << "\t\t" << "VkSamplerCustomBorderColorCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePresentBarrierFeaturesNV(std::ostream &out, const VkPhysicalDevicePresentBarrierFeaturesNV* structInfo, Decoded_VkPhysicalDevicePresentBarrierFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentBarrier << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePresentBarrierFeaturesNV");
    out << "\t\t" << "VkPhysicalDevicePresentBarrierFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSurfaceCapabilitiesPresentBarrierNV(std::ostream &out, const VkSurfaceCapabilitiesPresentBarrierNV* structInfo, Decoded_VkSurfaceCapabilitiesPresentBarrierNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentBarrierSupported << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "surfaceCapabilitiesPresentBarrierNV");
    out << "\t\t" << "VkSurfaceCapabilitiesPresentBarrierNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainPresentBarrierCreateInfoNV(std::ostream &out, const VkSwapchainPresentBarrierCreateInfoNV* structInfo, Decoded_VkSwapchainPresentBarrierCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentBarrierEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainPresentBarrierCreateInfoNV");
    out << "\t\t" << "VkSwapchainPresentBarrierCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceDiagnosticsConfigCreateInfoNV(std::ostream &out, const VkDeviceDiagnosticsConfigCreateInfoNV* structInfo, Decoded_VkDeviceDiagnosticsConfigCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDeviceDiagnosticsConfigFlagsNV(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceDiagnosticsConfigCreateInfoNV");
    out << "\t\t" << "VkDeviceDiagnosticsConfigCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(std::ostream &out, const VkPhysicalDeviceDiagnosticsConfigFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDiagnosticsConfigFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->diagnosticsConfig << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDiagnosticsConfigFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceDiagnosticsConfigFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDispatchTileInfoQCOM(std::ostream &out, const VkDispatchTileInfoQCOM* structInfo, Decoded_VkDispatchTileInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dispatchTileInfoQCOM");
    out << "\t\t" << "VkDispatchTileInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerTileBeginInfoQCOM(std::ostream &out, const VkPerTileBeginInfoQCOM* structInfo, Decoded_VkPerTileBeginInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "perTileBeginInfoQCOM");
    out << "\t\t" << "VkPerTileBeginInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerTileEndInfoQCOM(std::ostream &out, const VkPerTileEndInfoQCOM* structInfo, Decoded_VkPerTileEndInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "perTileEndInfoQCOM");
    out << "\t\t" << "VkPerTileEndInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTileShadingFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceTileShadingFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceTileShadingFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileShading << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileShadingFragmentStage << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileShadingColorAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileShadingDepthAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileShadingStencilAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileShadingInputAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileShadingSampledAttachments << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileShadingPerTileDraw << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileShadingPerTileDispatch << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileShadingDispatchTile << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileShadingApron << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileShadingAnisotropicApron << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileShadingAtomicOps << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileShadingImageProcessing << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTileShadingFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceTileShadingFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTileShadingPropertiesQCOM(std::ostream &out, const VkPhysicalDeviceTileShadingPropertiesQCOM* structInfo, Decoded_VkPhysicalDeviceTileShadingPropertiesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string tile_granularity_info_var = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->tileGranularity,
                                                                      metaInfo->tileGranularity,
                                                                      consumer);
    std::string max_tile_shading_rate_info_var = GenerateStruct_VkExtent2D(out,
                                                                           &structInfo->maxTileShadingRate,
                                                                           metaInfo->maxTileShadingRate,
                                                                           consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxApronSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preferNonCoherent << "," << std::endl;
    struct_body << "\t\t\t" << tile_granularity_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_tile_shading_rate_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTileShadingPropertiesQCOM");
    out << "\t\t" << "VkPhysicalDeviceTileShadingPropertiesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassTileShadingCreateInfoQCOM(std::ostream &out, const VkRenderPassTileShadingCreateInfoQCOM* structInfo, Decoded_VkRenderPassTileShadingCreateInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string tile_apron_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                     &structInfo->tileApronSize,
                                                                     metaInfo->tileApronSize,
                                                                     consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkTileShadingRenderPassFlagsQCOM(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << tile_apron_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassTileShadingCreateInfoQCOM");
    out << "\t\t" << "VkRenderPassTileShadingCreateInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueryLowLatencySupportNV(std::ostream &out, const VkQueryLowLatencySupportNV* structInfo, Decoded_VkQueryLowLatencySupportNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    out << "\t\t" << "// TODO: Support pQueriedLowLatencyData (non-struct output) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "queryLowLatencySupportNV");
    out << "\t\t" << "VkQueryLowLatencySupportNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGraphicsPipelineLibraryCreateInfoEXT(std::ostream &out, const VkGraphicsPipelineLibraryCreateInfoEXT* structInfo, Decoded_VkGraphicsPipelineLibraryCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkGraphicsPipelineLibraryFlagsEXT(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "graphicsPipelineLibraryCreateInfoEXT");
    out << "\t\t" << "VkGraphicsPipelineLibraryCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(std::ostream &out, const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->graphicsPipelineLibrary << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceGraphicsPipelineLibraryFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(std::ostream &out, const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->graphicsPipelineLibraryFastLinking << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->graphicsPipelineLibraryIndependentInterpolationDecoration << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceGraphicsPipelineLibraryPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(std::ostream &out, const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* structInfo, Decoded_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderEarlyAndLateFragmentTests << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD");
    out << "\t\t" << "VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(std::ostream &out, const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentShadingRateEnums << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->supersampleFragmentShadingRates << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->noInvocationFragmentShadingRates << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShadingRateEnumsFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(std::ostream &out, const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->maxFragmentShadingRateInvocationCount << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentShadingRateEnumsPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(std::ostream &out, const VkPipelineFragmentShadingRateEnumStateCreateInfoNV* structInfo, Decoded_VkPipelineFragmentShadingRateEnumStateCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFragmentShadingRateTypeNV(" << structInfo->shadingRateType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFragmentShadingRateNV(" << structInfo->shadingRate << ")" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkFragmentShadingRateCombinerOpKHR*>(&structInfo->combinerOps[0]), 2) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineFragmentShadingRateEnumStateCreateInfoNV");
    out << "\t\t" << "VkPipelineFragmentShadingRateEnumStateCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureGeometryMotionTrianglesDataNV(std::ostream &out, const VkAccelerationStructureGeometryMotionTrianglesDataNV* structInfo, Decoded_VkAccelerationStructureGeometryMotionTrianglesDataNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexData.deviceAddress << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureGeometryMotionTrianglesDataNV");
    out << "\t\t" << "VkAccelerationStructureGeometryMotionTrianglesDataNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureMatrixMotionInstanceNV(std::ostream &out, const VkAccelerationStructureMatrixMotionInstanceNV* structInfo, Decoded_VkAccelerationStructureMatrixMotionInstanceNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string transform_t0_info_var = GenerateStruct_VkTransformMatrixKHR(out,
                                                                            &structInfo->transformT0,
                                                                            metaInfo->transformT0,
                                                                            consumer);
    std::string transform_t1_info_var = GenerateStruct_VkTransformMatrixKHR(out,
                                                                            &structInfo->transformT1,
                                                                            metaInfo->transformT1,
                                                                            consumer);
    struct_body << "\t" << transform_t0_info_var << "," << std::endl;
    struct_body << "\t\t\t" << transform_t1_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceCustomIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->mask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceShaderBindingTableRecordOffset << "," << std::endl;
    struct_body << "\t\t\t" << "VkGeometryInstanceFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->accelerationStructureReference << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureMatrixMotionInstanceNV");
    out << "\t\t" << "VkAccelerationStructureMatrixMotionInstanceNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureMotionInfoNV(std::ostream &out, const VkAccelerationStructureMotionInfoNV* structInfo, Decoded_VkAccelerationStructureMotionInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxInstances << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccelerationStructureMotionInfoFlagsNV(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureMotionInfoNV");
    out << "\t\t" << "VkAccelerationStructureMotionInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureSRTMotionInstanceNV(std::ostream &out, const VkAccelerationStructureSRTMotionInstanceNV* structInfo, Decoded_VkAccelerationStructureSRTMotionInstanceNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string transform_t0_info_var = GenerateStruct_VkSRTDataNV(out,
                                                                   &structInfo->transformT0,
                                                                   metaInfo->transformT0,
                                                                   consumer);
    std::string transform_t1_info_var = GenerateStruct_VkSRTDataNV(out,
                                                                   &structInfo->transformT1,
                                                                   metaInfo->transformT1,
                                                                   consumer);
    struct_body << "\t" << transform_t0_info_var << "," << std::endl;
    struct_body << "\t\t\t" << transform_t1_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceCustomIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->mask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceShaderBindingTableRecordOffset << "," << std::endl;
    struct_body << "\t\t\t" << "VkGeometryInstanceFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->accelerationStructureReference << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureSRTMotionInstanceNV");
    out << "\t\t" << "VkAccelerationStructureSRTMotionInstanceNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(std::ostream &out, const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* structInfo, Decoded_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rayTracingMotionBlur << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rayTracingMotionBlurPipelineTraceRaysIndirect << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingMotionBlurFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceRayTracingMotionBlurFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSRTDataNV(std::ostream &out, const VkSRTDataNV* structInfo, Decoded_VkSRTDataNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->sx << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->a << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->b << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pvx << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sy << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->c << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pvy << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sz << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pvz << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->qx << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->qy << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->qz << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->qw << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tx << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->ty << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tz << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "sRTDataNV");
    out << "\t\t" << "VkSRTDataNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(std::ostream &out, const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->ycbcr2plane444Formats << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceYcbcr2Plane444FormatsFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(std::ostream &out, const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentDensityMapDeferred << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentDensityMap2FeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceFragmentDensityMap2FeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(std::ostream &out, const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subsampledLoads << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subsampledCoarseReconstructionEarlyAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSubsampledArrayLayers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetSubsampledSamplers << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentDensityMap2PropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceFragmentDensityMap2PropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyCommandTransformInfoQCOM(std::ostream &out, const VkCopyCommandTransformInfoQCOM* structInfo, Decoded_VkCopyCommandTransformInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->transform << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyCommandTransformInfoQCOM");
    out << "\t\t" << "VkCopyCommandTransformInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageCompressionControlEXT(std::ostream &out, const VkImageCompressionControlEXT* structInfo, Decoded_VkImageCompressionControlEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pfixed_rate_flags_array = "NULL";
    if (structInfo->pFixedRateFlags != NULL) {
        std::string pfixed_rate_flags_values;
        for (uint32_t idx = 0; idx < structInfo->compressionControlPlaneCount; idx++) {
            pfixed_rate_flags_values += util::ToString<VkImageCompressionFixedRateFlagsEXT>(structInfo->pFixedRateFlags[idx]) + ", ";
        }
        pfixed_rate_flags_array = "pFixedRateFlags_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkImageCompressionFixedRateFlagsEXT " << pfixed_rate_flags_array << "[] = {" << pfixed_rate_flags_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageCompressionFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->compressionControlPlaneCount << "," << std::endl;
    struct_body << "\t\t\t" << pfixed_rate_flags_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageCompressionControlEXT");
    out << "\t\t" << "VkImageCompressionControlEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageCompressionPropertiesEXT(std::ostream &out, const VkImageCompressionPropertiesEXT* structInfo, Decoded_VkImageCompressionPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageCompressionFlagsEXT(" << structInfo->imageCompressionFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageCompressionFixedRateFlagsEXT(" << structInfo->imageCompressionFixedRateFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageCompressionPropertiesEXT");
    out << "\t\t" << "VkImageCompressionPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageCompressionControlFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImageCompressionControlFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImageCompressionControlFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageCompressionControl << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageCompressionControlFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceImageCompressionControlFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(std::ostream &out, const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->attachmentFeedbackLoopLayout << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevice4444FormatsFeaturesEXT(std::ostream &out, const VkPhysicalDevice4444FormatsFeaturesEXT* structInfo, Decoded_VkPhysicalDevice4444FormatsFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->formatA4R4G4B4 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->formatA4B4G4R4 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevice4444FormatsFeaturesEXT");
    out << "\t\t" << "VkPhysicalDevice4444FormatsFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceFaultAddressInfoEXT(std::ostream &out, const VkDeviceFaultAddressInfoEXT* structInfo, Decoded_VkDeviceFaultAddressInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkDeviceFaultAddressTypeEXT(" << structInfo->addressType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reportedAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->addressPrecision << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceFaultAddressInfoEXT");
    out << "\t\t" << "VkDeviceFaultAddressInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceFaultCountsEXT(std::ostream &out, const VkDeviceFaultCountsEXT* structInfo, Decoded_VkDeviceFaultCountsEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->addressInfoCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vendorInfoCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vendorBinarySize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceFaultCountsEXT");
    out << "\t\t" << "VkDeviceFaultCountsEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceFaultInfoEXT(std::ostream &out, const VkDeviceFaultInfoEXT* structInfo, Decoded_VkDeviceFaultInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string paddress_infos_name = "NULL";
    if (structInfo->pAddressInfos != NULL) {
        paddress_infos_name = GenerateStruct_VkDeviceFaultAddressInfoEXT(out,
                                                                         structInfo->pAddressInfos,
                                                                         metaInfo->pAddressInfos->GetMetaStructPointer(),
                                                                         consumer);
        paddress_infos_name.insert(0, "&");
    }
    std::string pvendor_infos_name = "NULL";
    if (structInfo->pVendorInfos != NULL) {
        pvendor_infos_name = GenerateStruct_VkDeviceFaultVendorInfoEXT(out,
                                                                       structInfo->pVendorInfos,
                                                                       metaInfo->pVendorInfos->GetMetaStructPointer(),
                                                                       consumer);
        pvendor_infos_name.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << "," << std::endl;
    struct_body << "\t\t\t" << paddress_infos_name << "," << std::endl;
    struct_body << "\t\t\t" << pvendor_infos_name << "," << std::endl;
    out << "\t\t" << "// TODO: Support pVendorBinaryData (non-struct output) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "deviceFaultInfoEXT");
    out << "\t\t" << "VkDeviceFaultInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceFaultVendorBinaryHeaderVersionOneEXT(std::ostream &out, const VkDeviceFaultVendorBinaryHeaderVersionOneEXT* structInfo, Decoded_VkDeviceFaultVendorBinaryHeaderVersionOneEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->headerSize << "," << std::endl;
    struct_body << "\t\t\t" << "VkDeviceFaultVendorBinaryHeaderVersionEXT(" << structInfo->headerVersion << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vendorID << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceID << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->driverVersion << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->pipelineCacheUUID[0]), VK_UUID_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->applicationNameOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->applicationVersion << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->engineNameOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->engineVersion << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->apiVersion << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceFaultVendorBinaryHeaderVersionOneEXT");
    out << "\t\t" << "VkDeviceFaultVendorBinaryHeaderVersionOneEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceFaultVendorInfoEXT(std::ostream &out, const VkDeviceFaultVendorInfoEXT* structInfo, Decoded_VkDeviceFaultVendorInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vendorFaultCode << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vendorFaultData << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceFaultVendorInfoEXT");
    out << "\t\t" << "VkDeviceFaultVendorInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFaultFeaturesEXT(std::ostream &out, const VkPhysicalDeviceFaultFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFaultFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceFault << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceFaultVendorBinary << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFaultFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceFaultFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(std::ostream &out, const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rasterizationOrderColorAttachmentAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rasterizationOrderDepthAttachmentAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rasterizationOrderStencilAttachmentAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(std::ostream &out, const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->formatRgba10x6WithoutYCbCrSampler << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRGBA10X6FormatsFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDirectFBSurfaceCreateInfoEXT(std::ostream &out, const VkDirectFBSurfaceCreateInfoEXT* structInfo, Decoded_VkDirectFBSurfaceCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDirectFBSurfaceCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<IDirectFB*>(" << structInfo->dfb << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<IDirectFBSurface*>(" << structInfo->surface << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "directFBSurfaceCreateInfoEXT");
    out << "\t\t" << "VkDirectFBSurfaceCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMutableDescriptorTypeCreateInfoEXT(std::ostream &out, const VkMutableDescriptorTypeCreateInfoEXT* structInfo, Decoded_VkMutableDescriptorTypeCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pmutable_descriptor_type_lists_array = "NULL";
    if (structInfo->pMutableDescriptorTypeLists != NULL) {
        pmutable_descriptor_type_lists_array = "pMutableDescriptorTypeLists_" + std::to_string(consumer.GetNextId());
        std::string pmutable_descriptor_type_lists_names;
        for (uint32_t idx = 0; idx < structInfo->mutableDescriptorTypeListCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pMutableDescriptorTypeLists + idx != NULL) {
                variable_name = GenerateStruct_VkMutableDescriptorTypeListEXT(out,
                                                                              structInfo->pMutableDescriptorTypeLists + idx,
                                                                              metaInfo->pMutableDescriptorTypeLists->GetMetaStructPointer() + idx,
                                                                              consumer);
            }
            pmutable_descriptor_type_lists_names += variable_name + ", ";
        }
        out << "\t\t" << "VkMutableDescriptorTypeListEXT " << pmutable_descriptor_type_lists_array << "[] = {" << pmutable_descriptor_type_lists_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->mutableDescriptorTypeListCount << "," << std::endl;
    struct_body << "\t\t\t" << pmutable_descriptor_type_lists_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "mutableDescriptorTypeCreateInfoEXT");
    out << "\t\t" << "VkMutableDescriptorTypeCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMutableDescriptorTypeListEXT(std::ostream &out, const VkMutableDescriptorTypeListEXT* structInfo, Decoded_VkMutableDescriptorTypeListEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pdescriptor_types_values;
    std::string pdescriptor_types_array = "NULL";
    if (structInfo->pDescriptorTypes != NULL) {
        for (uint32_t idx = 0; idx < structInfo->descriptorTypeCount; idx++) {
            pdescriptor_types_values += util::ToString<VkDescriptorType>(structInfo->pDescriptorTypes[idx]) + ", ";
        }
        pdescriptor_types_array = "pDescriptorTypes_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkDescriptorType " << pdescriptor_types_array << "[] = {" << pdescriptor_types_values << "};" << std::endl;
    }
    struct_body << "\t" << structInfo->descriptorTypeCount << "," << std::endl;
    struct_body << "\t\t\t" << pdescriptor_types_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "mutableDescriptorTypeListEXT");
    out << "\t\t" << "VkMutableDescriptorTypeListEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->mutableDescriptorType << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMutableDescriptorTypeFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(std::ostream &out, const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexInputDynamicState << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVertexInputDynamicStateFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVertexInputAttributeDescription2EXT(std::ostream &out, const VkVertexInputAttributeDescription2EXT* structInfo, Decoded_VkVertexInputAttributeDescription2EXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->location << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->binding << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "vertexInputAttributeDescription2EXT");
    out << "\t\t" << "VkVertexInputAttributeDescription2EXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVertexInputBindingDescription2EXT(std::ostream &out, const VkVertexInputBindingDescription2EXT* structInfo, Decoded_VkVertexInputBindingDescription2EXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->binding << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stride << "," << std::endl;
    struct_body << "\t\t\t" << "VkVertexInputRate(" << structInfo->inputRate << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->divisor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "vertexInputBindingDescription2EXT");
    out << "\t\t" << "VkVertexInputBindingDescription2EXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDrmPropertiesEXT(std::ostream &out, const VkPhysicalDeviceDrmPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceDrmPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hasPrimary << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hasRender << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primaryMajor << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primaryMinor << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->renderMajor << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->renderMinor << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDrmPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceDrmPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceAddressBindingCallbackDataEXT(std::ostream &out, const VkDeviceAddressBindingCallbackDataEXT* structInfo, Decoded_VkDeviceAddressBindingCallbackDataEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDeviceAddressBindingFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->baseAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkDeviceAddressBindingTypeEXT(" << structInfo->bindingType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceAddressBindingCallbackDataEXT");
    out << "\t\t" << "VkDeviceAddressBindingCallbackDataEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceAddressBindingReportFeaturesEXT(std::ostream &out, const VkPhysicalDeviceAddressBindingReportFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceAddressBindingReportFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->reportAddressBinding << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceAddressBindingReportFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceAddressBindingReportFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDepthClipControlFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDepthClipControlFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDepthClipControlFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthClipControl << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDepthClipControlFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceDepthClipControlFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportDepthClipControlCreateInfoEXT(std::ostream &out, const VkPipelineViewportDepthClipControlCreateInfoEXT* structInfo, Decoded_VkPipelineViewportDepthClipControlCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->negativeOneToOne << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportDepthClipControlCreateInfoEXT");
    out << "\t\t" << "VkPipelineViewportDepthClipControlCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(std::ostream &out, const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primitiveTopologyListRestart << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primitiveTopologyPatchListRestart << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePrimitiveTopologyListRestartFeaturesEXT");
    out << "\t\t" << "VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportMemoryZirconHandleInfoFUCHSIA(std::ostream &out, const VkImportMemoryZirconHandleInfoFUCHSIA* structInfo, Decoded_VkImportMemoryZirconHandleInfoFUCHSIA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->handle << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importMemoryZirconHandleInfoFUCHSIA");
    out << "\t\t" << "VkImportMemoryZirconHandleInfoFUCHSIA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryGetZirconHandleInfoFUCHSIA(std::ostream &out, const VkMemoryGetZirconHandleInfoFUCHSIA* structInfo, Decoded_VkMemoryGetZirconHandleInfoFUCHSIA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryGetZirconHandleInfoFUCHSIA");
    out << "\t\t" << "VkMemoryGetZirconHandleInfoFUCHSIA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryZirconHandlePropertiesFUCHSIA(std::ostream &out, const VkMemoryZirconHandlePropertiesFUCHSIA* structInfo, Decoded_VkMemoryZirconHandlePropertiesFUCHSIA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryTypeBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryZirconHandlePropertiesFUCHSIA");
    out << "\t\t" << "VkMemoryZirconHandlePropertiesFUCHSIA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportSemaphoreZirconHandleInfoFUCHSIA(std::ostream &out, const VkImportSemaphoreZirconHandleInfoFUCHSIA* structInfo, Decoded_VkImportSemaphoreZirconHandleInfoFUCHSIA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
    struct_body << "\t\t\t" << "VkSemaphoreImportFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->zirconHandle << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "importSemaphoreZirconHandleInfoFUCHSIA");
    out << "\t\t" << "VkImportSemaphoreZirconHandleInfoFUCHSIA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSemaphoreGetZirconHandleInfoFUCHSIA(std::ostream &out, const VkSemaphoreGetZirconHandleInfoFUCHSIA* structInfo, Decoded_VkSemaphoreGetZirconHandleInfoFUCHSIA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->semaphore) << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "semaphoreGetZirconHandleInfoFUCHSIA");
    out << "\t\t" << "VkSemaphoreGetZirconHandleInfoFUCHSIA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(std::ostream &out, const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* structInfo, Decoded_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->invocationMask << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceInvocationMaskFeaturesHUAWEI");
    out << "\t\t" << "VkPhysicalDeviceInvocationMaskFeaturesHUAWEI " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryGetRemoteAddressInfoNV(std::ostream &out, const VkMemoryGetRemoteAddressInfoNV* structInfo, Decoded_VkMemoryGetRemoteAddressInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryGetRemoteAddressInfoNV");
    out << "\t\t" << "VkMemoryGetRemoteAddressInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(std::ostream &out, const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* structInfo, Decoded_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->externalMemoryRDMA << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalMemoryRDMAFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceExternalMemoryRDMAFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkFrameBoundaryEXT(std::ostream &out, const VkFrameBoundaryEXT* structInfo, Decoded_VkFrameBoundaryEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pimages_array = "NULL";
    if (metaInfo->pImages.GetPointer() != NULL && structInfo->imageCount > 0) {
        pimages_array = "pimages_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_IMAGE));
        std::string pimages_values = toStringJoin(metaInfo->pImages.GetPointer(),
                                                  metaInfo->pImages.GetPointer() + structInfo->imageCount,
                                                  [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                  ", ");
        if (structInfo->imageCount == 1) {
            pimages_array = "&" + pimages_values;
        } else if (structInfo->imageCount > 1) {
            out << "\t\t" << "VkImage " << pimages_array << "[] = {" << pimages_values << "};" << std::endl;
        }
    }
    std::string pbuffers_array = "NULL";
    if (metaInfo->pBuffers.GetPointer() != NULL && structInfo->bufferCount > 0) {
        pbuffers_array = "pbuffers_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_BUFFER));
        std::string pbuffers_values = toStringJoin(metaInfo->pBuffers.GetPointer(),
                                                   metaInfo->pBuffers.GetPointer() + structInfo->bufferCount,
                                                   [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                   ", ");
        if (structInfo->bufferCount == 1) {
            pbuffers_array = "&" + pbuffers_values;
        } else if (structInfo->bufferCount > 1) {
            out << "\t\t" << "VkBuffer " << pbuffers_array << "[] = {" << pbuffers_values << "};" << std::endl;
        }
    }
    std::string ptag_array = "NULL";
    if (structInfo->pTag != NULL) {
        std::string ptag_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->tagSize; ++idx0) {
            ptag_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pTag)[idx0]) + ", ";
        }
        ptag_array = "pTag_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << ptag_array << "[] = {" << ptag_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFrameBoundaryFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frameID << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageCount << "," << std::endl;
    struct_body << "\t\t\t" << pimages_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bufferCount << "," << std::endl;
    struct_body << "\t\t\t" << pbuffers_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tagName << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tagSize << "," << std::endl;
    struct_body << "\t\t\t" << ptag_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "frameBoundaryEXT");
    out << "\t\t" << "VkFrameBoundaryEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFrameBoundaryFeaturesEXT(std::ostream &out, const VkPhysicalDeviceFrameBoundaryFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFrameBoundaryFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frameBoundary << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFrameBoundaryFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceFrameBoundaryFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMultisampledRenderToSingleSampledInfoEXT(std::ostream &out, const VkMultisampledRenderToSingleSampledInfoEXT* structInfo, Decoded_VkMultisampledRenderToSingleSampledInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multisampledRenderToSingleSampledEnable << "," << std::endl;
    struct_body << "\t\t\t" << "VkSampleCountFlagBits(" << structInfo->rasterizationSamples << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "multisampledRenderToSingleSampledInfoEXT");
    out << "\t\t" << "VkMultisampledRenderToSingleSampledInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multisampledRenderToSingleSampled << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultisampledRenderToSingleSampledFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSubpassResolvePerformanceQueryEXT(std::ostream &out, const VkSubpassResolvePerformanceQueryEXT* structInfo, Decoded_VkSubpassResolvePerformanceQueryEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->optimal << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "subpassResolvePerformanceQueryEXT");
    out << "\t\t" << "VkSubpassResolvePerformanceQueryEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(std::ostream &out, const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState2 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState2LogicOp << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState2PatchControlPoints << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExtendedDynamicState2FeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceExtendedDynamicState2FeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkScreenSurfaceCreateInfoQNX(std::ostream &out, const VkScreenSurfaceCreateInfoQNX* structInfo, Decoded_VkScreenSurfaceCreateInfoQNX* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkScreenSurfaceCreateFlagsQNX(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<struct _screen_context*>(" << structInfo->context << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "reinterpret_cast<struct _screen_window*>(" << structInfo->window << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "screenSurfaceCreateInfoQNX");
    out << "\t\t" << "VkScreenSurfaceCreateInfoQNX " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceColorWriteEnableFeaturesEXT(std::ostream &out, const VkPhysicalDeviceColorWriteEnableFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceColorWriteEnableFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->colorWriteEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceColorWriteEnableFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceColorWriteEnableFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineColorWriteCreateInfoEXT(std::ostream &out, const VkPipelineColorWriteCreateInfoEXT* structInfo, Decoded_VkPipelineColorWriteCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcolor_write_enables_array = "NULL";
    if (structInfo->pColorWriteEnables != NULL) {
        std::string pcolor_write_enables_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->attachmentCount; ++idx0) {
            pcolor_write_enables_values += std::to_string(structInfo->pColorWriteEnables[idx0]) + ", ";
        }
        pcolor_write_enables_array = "pColorWriteEnables_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkBool32 " << pcolor_write_enables_array << "[] = {" << pcolor_write_enables_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->attachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pcolor_write_enables_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineColorWriteCreateInfoEXT");
    out << "\t\t" << "VkPipelineColorWriteCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(std::ostream &out, const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primitivesGeneratedQuery << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primitivesGeneratedQueryWithRasterizerDiscard << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primitivesGeneratedQueryWithNonZeroStreams << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePrimitivesGeneratedQueryFeaturesEXT");
    out << "\t\t" << "VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE(std::ostream &out, const VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE* structInfo, Decoded_VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->videoEncodeRgbConversion << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVideoEncodeRgbConversionFeaturesVALVE");
    out << "\t\t" << "VkPhysicalDeviceVideoEncodeRgbConversionFeaturesVALVE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeProfileRgbConversionInfoVALVE(std::ostream &out, const VkVideoEncodeProfileRgbConversionInfoVALVE* structInfo, Decoded_VkVideoEncodeProfileRgbConversionInfoVALVE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->performEncodeRgbConversion << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeProfileRgbConversionInfoVALVE");
    out << "\t\t" << "VkVideoEncodeProfileRgbConversionInfoVALVE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeRgbConversionCapabilitiesVALVE(std::ostream &out, const VkVideoEncodeRgbConversionCapabilitiesVALVE* structInfo, Decoded_VkVideoEncodeRgbConversionCapabilitiesVALVE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeRgbModelConversionFlagsVALVE(" << structInfo->rgbModels << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeRgbRangeCompressionFlagsVALVE(" << structInfo->rgbRanges << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeRgbChromaOffsetFlagsVALVE(" << structInfo->xChromaOffsets << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeRgbChromaOffsetFlagsVALVE(" << structInfo->yChromaOffsets << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeRgbConversionCapabilitiesVALVE");
    out << "\t\t" << "VkVideoEncodeRgbConversionCapabilitiesVALVE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkVideoEncodeSessionRgbConversionCreateInfoVALVE(std::ostream &out, const VkVideoEncodeSessionRgbConversionCreateInfoVALVE* structInfo, Decoded_VkVideoEncodeSessionRgbConversionCreateInfoVALVE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeRgbModelConversionFlagBitsVALVE(" << structInfo->rgbModel << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeRgbRangeCompressionFlagBitsVALVE(" << structInfo->rgbRange << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeRgbChromaOffsetFlagBitsVALVE(" << structInfo->xChromaOffset << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkVideoEncodeRgbChromaOffsetFlagBitsVALVE(" << structInfo->yChromaOffset << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "videoEncodeSessionRgbConversionCreateInfoVALVE");
    out << "\t\t" << "VkVideoEncodeSessionRgbConversionCreateInfoVALVE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewMinLodCreateInfoEXT(std::ostream &out, const VkImageViewMinLodCreateInfoEXT* structInfo, Decoded_VkImageViewMinLodCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minLod << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewMinLodCreateInfoEXT");
    out << "\t\t" << "VkImageViewMinLodCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageViewMinLodFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImageViewMinLodFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImageViewMinLodFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minLod << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageViewMinLodFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceImageViewMinLodFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMultiDrawIndexedInfoEXT(std::ostream &out, const VkMultiDrawIndexedInfoEXT* structInfo, Decoded_VkMultiDrawIndexedInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->firstIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexOffset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "multiDrawIndexedInfoEXT");
    out << "\t\t" << "VkMultiDrawIndexedInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMultiDrawInfoEXT(std::ostream &out, const VkMultiDrawInfoEXT* structInfo, Decoded_VkMultiDrawInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->firstVertex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "multiDrawInfoEXT");
    out << "\t\t" << "VkMultiDrawInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultiDrawFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMultiDrawFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMultiDrawFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multiDraw << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultiDrawFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceMultiDrawFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultiDrawPropertiesEXT(std::ostream &out, const VkPhysicalDeviceMultiDrawPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceMultiDrawPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMultiDrawCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultiDrawPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceMultiDrawPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->image2DViewOf3D << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sampler2DViewOf3D << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImage2DViewOf3DFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceImage2DViewOf3DFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderTileImageFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderTileImageFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderTileImageFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderTileImageColorReadAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderTileImageDepthReadAccess << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderTileImageStencilReadAccess << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderTileImageFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderTileImageFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderTileImagePropertiesEXT(std::ostream &out, const VkPhysicalDeviceShaderTileImagePropertiesEXT* structInfo, Decoded_VkPhysicalDeviceShaderTileImagePropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderTileImageCoherentReadAccelerated << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderTileImageReadSampleFromPixelRateInvocation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderTileImageReadFromHelperInvocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderTileImagePropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderTileImagePropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureTrianglesOpacityMicromapEXT(std::ostream &out, const VkAccelerationStructureTrianglesOpacityMicromapEXT* structInfo, Decoded_VkAccelerationStructureTrianglesOpacityMicromapEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pusage_counts_array = "NULL";
    if (structInfo->pUsageCounts != NULL) {
        pusage_counts_array = "pUsageCounts_" + std::to_string(consumer.GetNextId());
        std::string pusage_counts_names;
        for (uint32_t idx = 0; idx < structInfo->usageCountsCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pUsageCounts + idx != NULL) {
                variable_name = GenerateStruct_VkMicromapUsageEXT(out,
                                                                  structInfo->pUsageCounts + idx,
                                                                  metaInfo->pUsageCounts->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pusage_counts_names += variable_name + ", ";
        }
        out << "\t\t" << "VkMicromapUsageEXT " << pusage_counts_array << "[] = {" << pusage_counts_names << "};" << std::endl;
    }
    std::string pp_usage_counts_array = "NULL";
    if (structInfo->ppUsageCounts != NULL) {
        pp_usage_counts_array = "ppUsageCounts_" + std::to_string(consumer.GetNextId());
        std::string pp_usage_counts_names;
        for (uint32_t idx0 = 0; idx0 < structInfo->usageCountsCount; ++idx0) {
            for (uint32_t idx1 = 0; idx1 < 1; ++idx1) {
                std::string variable_name = "NULL";
                variable_name = GenerateStruct_VkMicromapUsageEXT(out,
                                                                  &(structInfo->ppUsageCounts[idx0][idx1]),
                                                                  &(metaInfo->ppUsageCounts->GetMetaStructPointer()[idx0][idx1]),
                                                                  consumer);
                pp_usage_counts_names += variable_name + ", ";
            }
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkIndexType(" << structInfo->indexType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexBuffer.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->baseTriangle << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->usageCountsCount << "," << std::endl;
    struct_body << "\t\t\t" << pusage_counts_array << "," << std::endl;
    struct_body << "\t\t\t" << pp_usage_counts_array << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->micromap) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureTrianglesOpacityMicromapEXT");
    out << "\t\t" << "VkAccelerationStructureTrianglesOpacityMicromapEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyMemoryToMicromapInfoEXT(std::ostream &out, const VkCopyMemoryToMicromapInfoEXT* structInfo, Decoded_VkCopyMemoryToMicromapInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->src.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dst) << "," << std::endl;
    struct_body << "\t\t\t" << "VkCopyMicromapModeEXT(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyMemoryToMicromapInfoEXT");
    out << "\t\t" << "VkCopyMemoryToMicromapInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyMicromapInfoEXT(std::ostream &out, const VkCopyMicromapInfoEXT* structInfo, Decoded_VkCopyMicromapInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->src) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dst) << "," << std::endl;
    struct_body << "\t\t\t" << "VkCopyMicromapModeEXT(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyMicromapInfoEXT");
    out << "\t\t" << "VkCopyMicromapInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyMicromapToMemoryInfoEXT(std::ostream &out, const VkCopyMicromapToMemoryInfoEXT* structInfo, Decoded_VkCopyMicromapToMemoryInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->src) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dst.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << "VkCopyMicromapModeEXT(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyMicromapToMemoryInfoEXT");
    out << "\t\t" << "VkCopyMicromapToMemoryInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMicromapBuildInfoEXT(std::ostream &out, const VkMicromapBuildInfoEXT* structInfo, Decoded_VkMicromapBuildInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pusage_counts_array = "NULL";
    if (structInfo->pUsageCounts != NULL) {
        pusage_counts_array = "pUsageCounts_" + std::to_string(consumer.GetNextId());
        std::string pusage_counts_names;
        for (uint32_t idx = 0; idx < structInfo->usageCountsCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pUsageCounts + idx != NULL) {
                variable_name = GenerateStruct_VkMicromapUsageEXT(out,
                                                                  structInfo->pUsageCounts + idx,
                                                                  metaInfo->pUsageCounts->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pusage_counts_names += variable_name + ", ";
        }
        out << "\t\t" << "VkMicromapUsageEXT " << pusage_counts_array << "[] = {" << pusage_counts_names << "};" << std::endl;
    }
    std::string pp_usage_counts_array = "NULL";
    if (structInfo->ppUsageCounts != NULL) {
        pp_usage_counts_array = "ppUsageCounts_" + std::to_string(consumer.GetNextId());
        std::string pp_usage_counts_names;
        for (uint32_t idx0 = 0; idx0 < structInfo->usageCountsCount; ++idx0) {
            for (uint32_t idx1 = 0; idx1 < 1; ++idx1) {
                std::string variable_name = "NULL";
                variable_name = GenerateStruct_VkMicromapUsageEXT(out,
                                                                  &(structInfo->ppUsageCounts[idx0][idx1]),
                                                                  &(metaInfo->ppUsageCounts->GetMetaStructPointer()[idx0][idx1]),
                                                                  consumer);
                pp_usage_counts_names += variable_name + ", ";
            }
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkMicromapTypeEXT(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBuildMicromapFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBuildMicromapModeEXT(" << structInfo->mode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstMicromap) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->usageCountsCount << "," << std::endl;
    struct_body << "\t\t\t" << pusage_counts_array << "," << std::endl;
    struct_body << "\t\t\t" << pp_usage_counts_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->data.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->scratchData.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->triangleArray.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->triangleArrayStride << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "micromapBuildInfoEXT");
    out << "\t\t" << "VkMicromapBuildInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMicromapBuildSizesInfoEXT(std::ostream &out, const VkMicromapBuildSizesInfoEXT* structInfo, Decoded_VkMicromapBuildSizesInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->micromapSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->buildScratchSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->discardable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "micromapBuildSizesInfoEXT");
    out << "\t\t" << "VkMicromapBuildSizesInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMicromapCreateInfoEXT(std::ostream &out, const VkMicromapCreateInfoEXT* structInfo, Decoded_VkMicromapCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkMicromapCreateFlagsEXT(" << structInfo->createFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkMicromapTypeEXT(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceAddress << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "micromapCreateInfoEXT");
    out << "\t\t" << "VkMicromapCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMicromapTriangleEXT(std::ostream &out, const VkMicromapTriangleEXT* structInfo, Decoded_VkMicromapTriangleEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->dataOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subdivisionLevel << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->format << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "micromapTriangleEXT");
    out << "\t\t" << "VkMicromapTriangleEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMicromapUsageEXT(std::ostream &out, const VkMicromapUsageEXT* structInfo, Decoded_VkMicromapUsageEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->count << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subdivisionLevel << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->format << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "micromapUsageEXT");
    out << "\t\t" << "VkMicromapUsageEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMicromapVersionInfoEXT(std::ostream &out, const VkMicromapVersionInfoEXT* structInfo, Decoded_VkMicromapVersionInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pversion_data_array = "NULL";
    std::string pversion_data_values;
    for (uint32_t idx0 = 0; idx0 < 2*VK_UUID_SIZE; ++idx0) {
        pversion_data_values += std::to_string(structInfo->pVersionData[idx0]) + ", ";
    }
    pversion_data_array = "pVersionData_" + std::to_string(consumer.GetNextId());
    out << "\t\t" << "uint8_t " << pversion_data_array << "[] = {" << pversion_data_values << "};" << std::endl;
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pversion_data_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "micromapVersionInfoEXT");
    out << "\t\t" << "VkMicromapVersionInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceOpacityMicromapFeaturesEXT(std::ostream &out, const VkPhysicalDeviceOpacityMicromapFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceOpacityMicromapFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->micromap << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->micromapCaptureReplay << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->micromapHostCommands << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceOpacityMicromapFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceOpacityMicromapFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceOpacityMicromapPropertiesEXT(std::ostream &out, const VkPhysicalDeviceOpacityMicromapPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceOpacityMicromapPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxOpacity2StateSubdivisionLevel << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxOpacity4StateSubdivisionLevel << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceOpacityMicromapPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceOpacityMicromapPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureTrianglesDisplacementMicromapNV(std::ostream &out, const VkAccelerationStructureTrianglesDisplacementMicromapNV* structInfo, Decoded_VkAccelerationStructureTrianglesDisplacementMicromapNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pusage_counts_array = "NULL";
    if (structInfo->pUsageCounts != NULL) {
        pusage_counts_array = "pUsageCounts_" + std::to_string(consumer.GetNextId());
        std::string pusage_counts_names;
        for (uint32_t idx = 0; idx < structInfo->usageCountsCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pUsageCounts + idx != NULL) {
                variable_name = GenerateStruct_VkMicromapUsageEXT(out,
                                                                  structInfo->pUsageCounts + idx,
                                                                  metaInfo->pUsageCounts->GetMetaStructPointer() + idx,
                                                                  consumer);
            }
            pusage_counts_names += variable_name + ", ";
        }
        out << "\t\t" << "VkMicromapUsageEXT " << pusage_counts_array << "[] = {" << pusage_counts_names << "};" << std::endl;
    }
    std::string pp_usage_counts_array = "NULL";
    if (structInfo->ppUsageCounts != NULL) {
        pp_usage_counts_array = "ppUsageCounts_" + std::to_string(consumer.GetNextId());
        std::string pp_usage_counts_names;
        for (uint32_t idx0 = 0; idx0 < structInfo->usageCountsCount; ++idx0) {
            for (uint32_t idx1 = 0; idx1 < 1; ++idx1) {
                std::string variable_name = "NULL";
                variable_name = GenerateStruct_VkMicromapUsageEXT(out,
                                                                  &(structInfo->ppUsageCounts[idx0][idx1]),
                                                                  &(metaInfo->ppUsageCounts->GetMetaStructPointer()[idx0][idx1]),
                                                                  consumer);
                pp_usage_counts_names += variable_name + ", ";
            }
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->displacementBiasAndScaleFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->displacementVectorFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->displacementBiasAndScaleBuffer.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->displacementBiasAndScaleStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->displacementVectorBuffer.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->displacementVectorStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->displacedMicromapPrimitiveFlags.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->displacedMicromapPrimitiveFlagsStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkIndexType(" << structInfo->indexType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexBuffer.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->baseTriangle << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->usageCountsCount << "," << std::endl;
    struct_body << "\t\t\t" << pusage_counts_array << "," << std::endl;
    struct_body << "\t\t\t" << pp_usage_counts_array << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->micromap) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureTrianglesDisplacementMicromapNV");
    out << "\t\t" << "VkAccelerationStructureTrianglesDisplacementMicromapNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDisplacementMicromapFeaturesNV(std::ostream &out, const VkPhysicalDeviceDisplacementMicromapFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDisplacementMicromapFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->displacementMicromap << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDisplacementMicromapFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceDisplacementMicromapFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDisplacementMicromapPropertiesNV(std::ostream &out, const VkPhysicalDeviceDisplacementMicromapPropertiesNV* structInfo, Decoded_VkPhysicalDeviceDisplacementMicromapPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDisplacementMicromapSubdivisionLevel << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDisplacementMicromapPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceDisplacementMicromapPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(std::ostream &out, const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* structInfo, Decoded_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->clustercullingShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multiviewClusterCullingShader << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceClusterCullingShaderFeaturesHUAWEI");
    out << "\t\t" << "VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(std::ostream &out, const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* structInfo, Decoded_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxWorkGroupCount[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxWorkGroupSize[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxOutputClusterCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indirectBufferOffsetAlignment << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceClusterCullingShaderPropertiesHUAWEI");
    out << "\t\t" << "VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI(std::ostream &out, const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* structInfo, Decoded_VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->clusterShadingRate << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceClusterCullingShaderVrsFeaturesHUAWEI");
    out << "\t\t" << "VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(std::ostream &out, const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->borderColorSwizzle << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->borderColorSwizzleFromImage << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceBorderColorSwizzleFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceBorderColorSwizzleFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerBorderColorComponentMappingCreateInfoEXT(std::ostream &out, const VkSamplerBorderColorComponentMappingCreateInfoEXT* structInfo, Decoded_VkSamplerBorderColorComponentMappingCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string components_info_var = GenerateStruct_VkComponentMapping(out,
                                                                        &structInfo->components,
                                                                        metaInfo->components,
                                                                        consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << components_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srgb << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerBorderColorComponentMappingCreateInfoEXT");
    out << "\t\t" << "VkSamplerBorderColorComponentMappingCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(std::ostream &out, const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pageableDeviceLocalMemory << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePageableDeviceLocalMemoryFeaturesEXT");
    out << "\t\t" << "VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCorePropertiesARM(std::ostream &out, const VkPhysicalDeviceShaderCorePropertiesARM* structInfo, Decoded_VkPhysicalDeviceShaderCorePropertiesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pixelRate << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->texelRate << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fmaRate << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderCorePropertiesARM");
    out << "\t\t" << "VkPhysicalDeviceShaderCorePropertiesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDeviceQueueShaderCoreControlCreateInfoARM(std::ostream &out, const VkDeviceQueueShaderCoreControlCreateInfoARM* structInfo, Decoded_VkDeviceQueueShaderCoreControlCreateInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderCoreCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "deviceQueueShaderCoreControlCreateInfoARM");
    out << "\t\t" << "VkDeviceQueueShaderCoreControlCreateInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSchedulingControlsFeaturesARM(std::ostream &out, const VkPhysicalDeviceSchedulingControlsFeaturesARM* structInfo, Decoded_VkPhysicalDeviceSchedulingControlsFeaturesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->schedulingControls << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSchedulingControlsFeaturesARM");
    out << "\t\t" << "VkPhysicalDeviceSchedulingControlsFeaturesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSchedulingControlsPropertiesARM(std::ostream &out, const VkPhysicalDeviceSchedulingControlsPropertiesARM* structInfo, Decoded_VkPhysicalDeviceSchedulingControlsPropertiesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPhysicalDeviceSchedulingControlsFlagsARM(" << structInfo->schedulingControlsFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSchedulingControlsPropertiesARM");
    out << "\t\t" << "VkPhysicalDeviceSchedulingControlsPropertiesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewSlicedCreateInfoEXT(std::ostream &out, const VkImageViewSlicedCreateInfoEXT* structInfo, Decoded_VkImageViewSlicedCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sliceOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sliceCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewSlicedCreateInfoEXT");
    out << "\t\t" << "VkImageViewSlicedCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageSlicedViewOf3D << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageSlicedViewOf3DFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetBindingReferenceVALVE(std::ostream &out, const VkDescriptorSetBindingReferenceVALVE* structInfo, Decoded_VkDescriptorSetBindingReferenceVALVE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->descriptorSetLayout) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->binding << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetBindingReferenceVALVE");
    out << "\t\t" << "VkDescriptorSetBindingReferenceVALVE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDescriptorSetLayoutHostMappingInfoVALVE(std::ostream &out, const VkDescriptorSetLayoutHostMappingInfoVALVE* structInfo, Decoded_VkDescriptorSetLayoutHostMappingInfoVALVE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "descriptorSetLayoutHostMappingInfoVALVE");
    out << "\t\t" << "VkDescriptorSetLayoutHostMappingInfoVALVE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(std::ostream &out, const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* structInfo, Decoded_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorSetHostMapping << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDescriptorSetHostMappingFeaturesVALVE");
    out << "\t\t" << "VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(std::ostream &out, const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->nonSeamlessCubeMap << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceNonSeamlessCubeMapFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRenderPassStripedFeaturesARM(std::ostream &out, const VkPhysicalDeviceRenderPassStripedFeaturesARM* structInfo, Decoded_VkPhysicalDeviceRenderPassStripedFeaturesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->renderPassStriped << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRenderPassStripedFeaturesARM");
    out << "\t\t" << "VkPhysicalDeviceRenderPassStripedFeaturesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRenderPassStripedPropertiesARM(std::ostream &out, const VkPhysicalDeviceRenderPassStripedPropertiesARM* structInfo, Decoded_VkPhysicalDeviceRenderPassStripedPropertiesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string render_pass_stripe_granularity_info_var = GenerateStruct_VkExtent2D(out,
                                                                                    &structInfo->renderPassStripeGranularity,
                                                                                    metaInfo->renderPassStripeGranularity,
                                                                                    consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << render_pass_stripe_granularity_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxRenderPassStripes << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRenderPassStripedPropertiesARM");
    out << "\t\t" << "VkPhysicalDeviceRenderPassStripedPropertiesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassStripeBeginInfoARM(std::ostream &out, const VkRenderPassStripeBeginInfoARM* structInfo, Decoded_VkRenderPassStripeBeginInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstripe_infos_array = "NULL";
    if (structInfo->pStripeInfos != NULL) {
        pstripe_infos_array = "pStripeInfos_" + std::to_string(consumer.GetNextId());
        std::string pstripe_infos_names;
        for (uint32_t idx = 0; idx < structInfo->stripeInfoCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStripeInfos + idx != NULL) {
                variable_name = GenerateStruct_VkRenderPassStripeInfoARM(out,
                                                                         structInfo->pStripeInfos + idx,
                                                                         metaInfo->pStripeInfos->GetMetaStructPointer() + idx,
                                                                         consumer);
            }
            pstripe_infos_names += variable_name + ", ";
        }
        out << "\t\t" << "VkRenderPassStripeInfoARM " << pstripe_infos_array << "[] = {" << pstripe_infos_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stripeInfoCount << "," << std::endl;
    struct_body << "\t\t\t" << pstripe_infos_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassStripeBeginInfoARM");
    out << "\t\t" << "VkRenderPassStripeBeginInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassStripeInfoARM(std::ostream &out, const VkRenderPassStripeInfoARM* structInfo, Decoded_VkRenderPassStripeInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string stripe_area_info_var = GenerateStruct_VkRect2D(out,
                                                               &structInfo->stripeArea,
                                                               metaInfo->stripeArea,
                                                               consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << stripe_area_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassStripeInfoARM");
    out << "\t\t" << "VkRenderPassStripeInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassStripeSubmitInfoARM(std::ostream &out, const VkRenderPassStripeSubmitInfoARM* structInfo, Decoded_VkRenderPassStripeSubmitInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstripe_semaphore_infos_array = "NULL";
    if (structInfo->pStripeSemaphoreInfos != NULL) {
        pstripe_semaphore_infos_array = "pStripeSemaphoreInfos_" + std::to_string(consumer.GetNextId());
        std::string pstripe_semaphore_infos_names;
        for (uint32_t idx = 0; idx < structInfo->stripeSemaphoreInfoCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStripeSemaphoreInfos + idx != NULL) {
                variable_name = GenerateStruct_VkSemaphoreSubmitInfo(out,
                                                                     structInfo->pStripeSemaphoreInfos + idx,
                                                                     metaInfo->pStripeSemaphoreInfos->GetMetaStructPointer() + idx,
                                                                     consumer);
            }
            pstripe_semaphore_infos_names += variable_name + ", ";
        }
        out << "\t\t" << "VkSemaphoreSubmitInfo " << pstripe_semaphore_infos_array << "[] = {" << pstripe_semaphore_infos_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stripeSemaphoreInfoCount << "," << std::endl;
    struct_body << "\t\t\t" << pstripe_semaphore_infos_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassStripeSubmitInfoARM");
    out << "\t\t" << "VkRenderPassStripeSubmitInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT(std::ostream &out, const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentDensityMapOffset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentDensityMapOffsetFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceFragmentDensityMapOffsetFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT(std::ostream &out, const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string fragment_density_offset_granularity_info_var = GenerateStruct_VkExtent2D(out,
                                                                                         &structInfo->fragmentDensityOffsetGranularity,
                                                                                         metaInfo->fragmentDensityOffsetGranularity,
                                                                                         consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << fragment_density_offset_granularity_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentDensityMapOffsetPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceFragmentDensityMapOffsetPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassFragmentDensityMapOffsetEndInfoEXT(std::ostream &out, const VkRenderPassFragmentDensityMapOffsetEndInfoEXT* structInfo, Decoded_VkRenderPassFragmentDensityMapOffsetEndInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pfragment_density_offsets_array = "NULL";
    if (structInfo->pFragmentDensityOffsets != NULL) {
        pfragment_density_offsets_array = "pFragmentDensityOffsets_" + std::to_string(consumer.GetNextId());
        std::string pfragment_density_offsets_names;
        for (uint32_t idx = 0; idx < structInfo->fragmentDensityOffsetCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pFragmentDensityOffsets + idx != NULL) {
                variable_name = GenerateStruct_VkOffset2D(out,
                                                          structInfo->pFragmentDensityOffsets + idx,
                                                          metaInfo->pFragmentDensityOffsets->GetMetaStructPointer() + idx,
                                                          consumer);
            }
            pfragment_density_offsets_names += variable_name + ", ";
        }
        out << "\t\t" << "VkOffset2D " << pfragment_density_offsets_array << "[] = {" << pfragment_density_offsets_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentDensityOffsetCount << "," << std::endl;
    struct_body << "\t\t\t" << pfragment_density_offsets_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassFragmentDensityMapOffsetEndInfoEXT");
    out << "\t\t" << "VkRenderPassFragmentDensityMapOffsetEndInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindPipelineIndirectCommandNV(std::ostream &out, const VkBindPipelineIndirectCommandNV* structInfo, Decoded_VkBindPipelineIndirectCommandNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->pipelineAddress << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindPipelineIndirectCommandNV");
    out << "\t\t" << "VkBindPipelineIndirectCommandNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkComputePipelineIndirectBufferInfoNV(std::ostream &out, const VkComputePipelineIndirectBufferInfoNV* structInfo, Decoded_VkComputePipelineIndirectBufferInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineDeviceAddressCaptureReplay << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "computePipelineIndirectBufferInfoNV");
    out << "\t\t" << "VkComputePipelineIndirectBufferInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV(std::ostream &out, const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceGeneratedCompute << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceGeneratedComputePipelines << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceGeneratedComputeCaptureReplay << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDeviceGeneratedCommandsComputeFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineIndirectDeviceAddressInfoNV(std::ostream &out, const VkPipelineIndirectDeviceAddressInfoNV* structInfo, Decoded_VkPipelineIndirectDeviceAddressInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipeline) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineIndirectDeviceAddressInfoNV");
    out << "\t\t" << "VkPipelineIndirectDeviceAddressInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureGeometryLinearSweptSpheresDataNV(std::ostream &out, const VkAccelerationStructureGeometryLinearSweptSpheresDataNV* structInfo, Decoded_VkAccelerationStructureGeometryLinearSweptSpheresDataNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->vertexFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexData.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->radiusFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->radiusData.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->radiusStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkIndexType(" << structInfo->indexType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexData.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkRayTracingLssIndexingModeNV(" << structInfo->indexingMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkRayTracingLssPrimitiveEndCapsModeNV(" << structInfo->endCapsMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureGeometryLinearSweptSpheresDataNV");
    out << "\t\t" << "VkAccelerationStructureGeometryLinearSweptSpheresDataNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureGeometrySpheresDataNV(std::ostream &out, const VkAccelerationStructureGeometrySpheresDataNV* structInfo, Decoded_VkAccelerationStructureGeometrySpheresDataNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->vertexFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexData.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->radiusFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->radiusData.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->radiusStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkIndexType(" << structInfo->indexType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexData.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexStride << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureGeometrySpheresDataNV");
    out << "\t\t" << "VkAccelerationStructureGeometrySpheresDataNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV(std::ostream &out, const VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV* structInfo, Decoded_VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->spheres << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->linearSweptSpheres << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingLinearSweptSpheresFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceRayTracingLinearSweptSpheresFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLinearColorAttachmentFeaturesNV(std::ostream &out, const VkPhysicalDeviceLinearColorAttachmentFeaturesNV* structInfo, Decoded_VkPhysicalDeviceLinearColorAttachmentFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->linearColorAttachment << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLinearColorAttachmentFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceLinearColorAttachmentFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageCompressionControlSwapchain << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageCompressionControlSwapchainFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageViewSampleWeightCreateInfoQCOM(std::ostream &out, const VkImageViewSampleWeightCreateInfoQCOM* structInfo, Decoded_VkImageViewSampleWeightCreateInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string filter_center_info_var = GenerateStruct_VkOffset2D(out,
                                                                   &structInfo->filterCenter,
                                                                   metaInfo->filterCenter,
                                                                   consumer);
    std::string filter_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                 &structInfo->filterSize,
                                                                 metaInfo->filterSize,
                                                                 consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << filter_center_info_var << "," << std::endl;
    struct_body << "\t\t\t" << filter_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->numPhases << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageViewSampleWeightCreateInfoQCOM");
    out << "\t\t" << "VkImageViewSampleWeightCreateInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageProcessingFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceImageProcessingFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceImageProcessingFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->textureSampleWeighted << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->textureBoxFilter << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->textureBlockMatch << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageProcessingFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceImageProcessingFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageProcessingPropertiesQCOM(std::ostream &out, const VkPhysicalDeviceImageProcessingPropertiesQCOM* structInfo, Decoded_VkPhysicalDeviceImageProcessingPropertiesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string max_weight_filter_dimension_info_var = GenerateStruct_VkExtent2D(out,
                                                                                 &structInfo->maxWeightFilterDimension,
                                                                                 metaInfo->maxWeightFilterDimension,
                                                                                 consumer);
    std::string max_block_match_region_info_var = GenerateStruct_VkExtent2D(out,
                                                                            &structInfo->maxBlockMatchRegion,
                                                                            metaInfo->maxBlockMatchRegion,
                                                                            consumer);
    std::string max_box_filter_block_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                               &structInfo->maxBoxFilterBlockSize,
                                                                               metaInfo->maxBoxFilterBlockSize,
                                                                               consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxWeightFilterPhases << "," << std::endl;
    struct_body << "\t\t\t" << max_weight_filter_dimension_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_block_match_region_info_var << "," << std::endl;
    struct_body << "\t\t\t" << max_box_filter_block_size_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageProcessingPropertiesQCOM");
    out << "\t\t" << "VkPhysicalDeviceImageProcessingPropertiesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(std::ostream &out, const VkPhysicalDeviceNestedCommandBufferFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceNestedCommandBufferFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->nestedCommandBuffer << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->nestedCommandBufferRendering << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->nestedCommandBufferSimultaneousUse << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceNestedCommandBufferFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceNestedCommandBufferFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(std::ostream &out, const VkPhysicalDeviceNestedCommandBufferPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceNestedCommandBufferPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxCommandBufferNestingLevel << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceNestedCommandBufferPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceNestedCommandBufferPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkExternalMemoryAcquireUnmodifiedEXT(std::ostream &out, const VkExternalMemoryAcquireUnmodifiedEXT* structInfo, Decoded_VkExternalMemoryAcquireUnmodifiedEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->acquireUnmodifiedMemory << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "externalMemoryAcquireUnmodifiedEXT");
    out << "\t\t" << "VkExternalMemoryAcquireUnmodifiedEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkColorBlendAdvancedEXT(std::ostream &out, const VkColorBlendAdvancedEXT* structInfo, Decoded_VkColorBlendAdvancedEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkBlendOp(" << structInfo->advancedBlendOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcPremultiplied << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstPremultiplied << "," << std::endl;
    struct_body << "\t\t\t" << "VkBlendOverlapEXT(" << structInfo->blendOverlap << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->clampResults << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "colorBlendAdvancedEXT");
    out << "\t\t" << "VkColorBlendAdvancedEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkColorBlendEquationEXT(std::ostream &out, const VkColorBlendEquationEXT* structInfo, Decoded_VkColorBlendEquationEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkBlendFactor(" << structInfo->srcColorBlendFactor << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBlendFactor(" << structInfo->dstColorBlendFactor << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBlendOp(" << structInfo->colorBlendOp << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBlendFactor(" << structInfo->srcAlphaBlendFactor << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBlendFactor(" << structInfo->dstAlphaBlendFactor << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBlendOp(" << structInfo->alphaBlendOp << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "colorBlendEquationEXT");
    out << "\t\t" << "VkColorBlendEquationEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(std::ostream &out, const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3TessellationDomainOrigin << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3DepthClampEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3PolygonMode << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3RasterizationSamples << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3SampleMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3AlphaToCoverageEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3AlphaToOneEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3LogicOpEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ColorBlendEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ColorBlendEquation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ColorWriteMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3RasterizationStream << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ConservativeRasterizationMode << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ExtraPrimitiveOverestimationSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3DepthClipEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3SampleLocationsEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ColorBlendAdvanced << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ProvokingVertexMode << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3LineRasterizationMode << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3LineStippleEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3DepthClipNegativeOneToOne << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ViewportWScalingEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ViewportSwizzle << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3CoverageToColorEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3CoverageToColorLocation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3CoverageModulationMode << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3CoverageModulationTableEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3CoverageModulationTable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3CoverageReductionMode << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3RepresentativeFragmentTestEnable << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedDynamicState3ShadingRateImageEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExtendedDynamicState3FeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceExtendedDynamicState3FeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(std::ostream &out, const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* structInfo, Decoded_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dynamicPrimitiveTopologyUnrestricted << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExtendedDynamicState3PropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceExtendedDynamicState3PropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(std::ostream &out, const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->subpassMergeFeedback << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceSubpassMergeFeedbackFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassCreationControlEXT(std::ostream &out, const VkRenderPassCreationControlEXT* structInfo, Decoded_VkRenderPassCreationControlEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->disallowMerging << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassCreationControlEXT");
    out << "\t\t" << "VkRenderPassCreationControlEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassCreationFeedbackCreateInfoEXT(std::ostream &out, const VkRenderPassCreationFeedbackCreateInfoEXT* structInfo, Decoded_VkRenderPassCreationFeedbackCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string prender_pass_feedback_name = "NULL";
    if (structInfo->pRenderPassFeedback != NULL) {
        prender_pass_feedback_name = GenerateStruct_VkRenderPassCreationFeedbackInfoEXT(out,
                                                                                        structInfo->pRenderPassFeedback,
                                                                                        metaInfo->pRenderPassFeedback->GetMetaStructPointer(),
                                                                                        consumer);
        prender_pass_feedback_name.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << prender_pass_feedback_name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassCreationFeedbackCreateInfoEXT");
    out << "\t\t" << "VkRenderPassCreationFeedbackCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassCreationFeedbackInfoEXT(std::ostream &out, const VkRenderPassCreationFeedbackInfoEXT* structInfo, Decoded_VkRenderPassCreationFeedbackInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->postMergeSubpassCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassCreationFeedbackInfoEXT");
    out << "\t\t" << "VkRenderPassCreationFeedbackInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassSubpassFeedbackCreateInfoEXT(std::ostream &out, const VkRenderPassSubpassFeedbackCreateInfoEXT* structInfo, Decoded_VkRenderPassSubpassFeedbackCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string psubpass_feedback_name = "NULL";
    if (structInfo->pSubpassFeedback != NULL) {
        psubpass_feedback_name = GenerateStruct_VkRenderPassSubpassFeedbackInfoEXT(out,
                                                                                   structInfo->pSubpassFeedback,
                                                                                   metaInfo->pSubpassFeedback->GetMetaStructPointer(),
                                                                                   consumer);
        psubpass_feedback_name.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << psubpass_feedback_name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassSubpassFeedbackCreateInfoEXT");
    out << "\t\t" << "VkRenderPassSubpassFeedbackCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassSubpassFeedbackInfoEXT(std::ostream &out, const VkRenderPassSubpassFeedbackInfoEXT* structInfo, Decoded_VkRenderPassSubpassFeedbackInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkSubpassMergeStatusEXT(" << structInfo->subpassMergeStatus << ")" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->description) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->postMergeIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassSubpassFeedbackInfoEXT");
    out << "\t\t" << "VkRenderPassSubpassFeedbackInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDirectDriverLoadingInfoLUNARG(std::ostream &out, const VkDirectDriverLoadingInfoLUNARG* structInfo, Decoded_VkDirectDriverLoadingInfoLUNARG* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDirectDriverLoadingFlagsLUNARG(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pfnGetInstanceProcAddr << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "directDriverLoadingInfoLUNARG");
    out << "\t\t" << "VkDirectDriverLoadingInfoLUNARG " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDirectDriverLoadingListLUNARG(std::ostream &out, const VkDirectDriverLoadingListLUNARG* structInfo, Decoded_VkDirectDriverLoadingListLUNARG* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdrivers_array = "NULL";
    if (structInfo->pDrivers != NULL) {
        pdrivers_array = "pDrivers_" + std::to_string(consumer.GetNextId());
        std::string pdrivers_names;
        for (uint32_t idx = 0; idx < structInfo->driverCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pDrivers + idx != NULL) {
                variable_name = GenerateStruct_VkDirectDriverLoadingInfoLUNARG(out,
                                                                               structInfo->pDrivers + idx,
                                                                               metaInfo->pDrivers->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pdrivers_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDirectDriverLoadingInfoLUNARG " << pdrivers_array << "[] = {" << pdrivers_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDirectDriverLoadingModeLUNARG(" << structInfo->mode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->driverCount << "," << std::endl;
    struct_body << "\t\t\t" << pdrivers_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "directDriverLoadingListLUNARG");
    out << "\t\t" << "VkDirectDriverLoadingListLUNARG " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderModuleIdentifier << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderModuleIdentifierFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(std::ostream &out, const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->shaderModuleIdentifierAlgorithmUUID[0]), VK_UUID_SIZE) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderModuleIdentifierPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(std::ostream &out, const VkPipelineShaderStageModuleIdentifierCreateInfoEXT* structInfo, Decoded_VkPipelineShaderStageModuleIdentifierCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pidentifier_array = "NULL";
    if (structInfo->pIdentifier != NULL) {
        std::string pidentifier_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->identifierSize; ++idx0) {
            pidentifier_values += std::to_string(structInfo->pIdentifier[idx0]) + ", ";
        }
        pidentifier_array = "pIdentifier_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pidentifier_array << "[] = {" << pidentifier_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->identifierSize << "," << std::endl;
    struct_body << "\t\t\t" << pidentifier_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineShaderStageModuleIdentifierCreateInfoEXT");
    out << "\t\t" << "VkPipelineShaderStageModuleIdentifierCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkShaderModuleIdentifierEXT(std::ostream &out, const VkShaderModuleIdentifierEXT* structInfo, Decoded_VkShaderModuleIdentifierEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->identifierSize << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->identifier[0]), VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "shaderModuleIdentifierEXT");
    out << "\t\t" << "VkShaderModuleIdentifierEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOpticalFlowExecuteInfoNV(std::ostream &out, const VkOpticalFlowExecuteInfoNV* structInfo, Decoded_VkOpticalFlowExecuteInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkRect2D " << pregions_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pRegions, structInfo->regionCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkOpticalFlowExecuteFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "opticalFlowExecuteInfoNV");
    out << "\t\t" << "VkOpticalFlowExecuteInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOpticalFlowImageFormatInfoNV(std::ostream &out, const VkOpticalFlowImageFormatInfoNV* structInfo, Decoded_VkOpticalFlowImageFormatInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkOpticalFlowUsageFlagsNV(" << structInfo->usage << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "opticalFlowImageFormatInfoNV");
    out << "\t\t" << "VkOpticalFlowImageFormatInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOpticalFlowImageFormatPropertiesNV(std::ostream &out, const VkOpticalFlowImageFormatPropertiesNV* structInfo, Decoded_VkOpticalFlowImageFormatPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->format << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "opticalFlowImageFormatPropertiesNV");
    out << "\t\t" << "VkOpticalFlowImageFormatPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOpticalFlowSessionCreateInfoNV(std::ostream &out, const VkOpticalFlowSessionCreateInfoNV* structInfo, Decoded_VkOpticalFlowSessionCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->width << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->height << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->imageFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->flowVectorFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->costFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkOpticalFlowGridSizeFlagsNV(" << structInfo->outputGridSize << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkOpticalFlowGridSizeFlagsNV(" << structInfo->hintGridSize << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkOpticalFlowPerformanceLevelNV(" << structInfo->performanceLevel << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkOpticalFlowSessionCreateFlagsNV(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "opticalFlowSessionCreateInfoNV");
    out << "\t\t" << "VkOpticalFlowSessionCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOpticalFlowSessionCreatePrivateDataInfoNV(std::ostream &out, const VkOpticalFlowSessionCreatePrivateDataInfoNV* structInfo, Decoded_VkOpticalFlowSessionCreatePrivateDataInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->id << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pPrivateData << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "opticalFlowSessionCreatePrivateDataInfoNV");
    out << "\t\t" << "VkOpticalFlowSessionCreatePrivateDataInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceOpticalFlowFeaturesNV(std::ostream &out, const VkPhysicalDeviceOpticalFlowFeaturesNV* structInfo, Decoded_VkPhysicalDeviceOpticalFlowFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->opticalFlow << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceOpticalFlowFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceOpticalFlowFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceOpticalFlowPropertiesNV(std::ostream &out, const VkPhysicalDeviceOpticalFlowPropertiesNV* structInfo, Decoded_VkPhysicalDeviceOpticalFlowPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkOpticalFlowGridSizeFlagsNV(" << structInfo->supportedOutputGridSizes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkOpticalFlowGridSizeFlagsNV(" << structInfo->supportedHintGridSizes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hintSupported << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->costSupported << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->bidirectionalFlowSupported << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->globalFlowSupported << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minWidth << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minHeight << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxWidth << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxHeight << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxNumRegionsOfInterest << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceOpticalFlowPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceOpticalFlowPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLegacyDitheringFeaturesEXT(std::ostream &out, const VkPhysicalDeviceLegacyDitheringFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceLegacyDitheringFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->legacyDithering << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLegacyDitheringFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceLegacyDitheringFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAndroidHardwareBufferFormatResolvePropertiesANDROID(std::ostream &out, const VkAndroidHardwareBufferFormatResolvePropertiesANDROID* structInfo, Decoded_VkAndroidHardwareBufferFormatResolvePropertiesANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->colorAttachmentFormat << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "androidHardwareBufferFormatResolvePropertiesANDROID");
    out << "\t\t" << "VkAndroidHardwareBufferFormatResolvePropertiesANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(std::ostream &out, const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* structInfo, Decoded_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->externalFormatResolve << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalFormatResolveFeaturesANDROID");
    out << "\t\t" << "VkPhysicalDeviceExternalFormatResolveFeaturesANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(std::ostream &out, const VkPhysicalDeviceExternalFormatResolvePropertiesANDROID* structInfo, Decoded_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->nullColorAttachmentWithExternalFormatResolve << "," << std::endl;
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->externalFormatResolveChromaOffsetX << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkChromaLocation(" << structInfo->externalFormatResolveChromaOffsetY << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExternalFormatResolvePropertiesANDROID");
    out << "\t\t" << "VkPhysicalDeviceExternalFormatResolvePropertiesANDROID " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAntiLagDataAMD(std::ostream &out, const VkAntiLagDataAMD* structInfo, Decoded_VkAntiLagDataAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppresentation_info_struct = "NULL";
    if (structInfo->pPresentationInfo != NULL) {
        ppresentation_info_struct = GenerateStruct_VkAntiLagPresentationInfoAMD(out,
                                                                                structInfo->pPresentationInfo,
                                                                                metaInfo->pPresentationInfo->GetMetaStructPointer(),
                                                                                consumer);
        ppresentation_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAntiLagModeAMD(" << structInfo->mode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxFPS << "," << std::endl;
    struct_body << "\t\t\t" << ppresentation_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "antiLagDataAMD");
    out << "\t\t" << "VkAntiLagDataAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAntiLagPresentationInfoAMD(std::ostream &out, const VkAntiLagPresentationInfoAMD* structInfo, Decoded_VkAntiLagPresentationInfoAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAntiLagStageAMD(" << structInfo->stage << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->frameIndex << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "antiLagPresentationInfoAMD");
    out << "\t\t" << "VkAntiLagPresentationInfoAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceAntiLagFeaturesAMD(std::ostream &out, const VkPhysicalDeviceAntiLagFeaturesAMD* structInfo, Decoded_VkPhysicalDeviceAntiLagFeaturesAMD* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->antiLag << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceAntiLagFeaturesAMD");
    out << "\t\t" << "VkPhysicalDeviceAntiLagFeaturesAMD " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDepthClampRangeEXT(std::ostream &out, const VkDepthClampRangeEXT* structInfo, Decoded_VkDepthClampRangeEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->minDepthClamp << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDepthClamp << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "depthClampRangeEXT");
    out << "\t\t" << "VkDepthClampRangeEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderObjectFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderObjectFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderObjectFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderObject << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderObjectFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderObjectFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderObjectPropertiesEXT(std::ostream &out, const VkPhysicalDeviceShaderObjectPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceShaderObjectPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->shaderBinaryUUID[0]), VK_UUID_SIZE) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderBinaryVersion << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderObjectPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderObjectPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkShaderCreateInfoEXT(std::ostream &out, const VkShaderCreateInfoEXT* structInfo, Decoded_VkShaderCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcode_array = "NULL";
    if (structInfo->pCode != NULL) {
        std::string pcode_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->codeSize; ++idx0) {
            pcode_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pCode)[idx0]) + ", ";
        }
        pcode_array = "pCode_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pcode_array << "[] = {" << pcode_values << "};" << std::endl;
    }
    std::string pset_layouts_array = "NULL";
    if (metaInfo->pSetLayouts.GetPointer() != NULL && structInfo->setLayoutCount > 0) {
        pset_layouts_array = "pset_layouts_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT));
        std::string pset_layouts_values = toStringJoin(metaInfo->pSetLayouts.GetPointer(),
                                                       metaInfo->pSetLayouts.GetPointer() + structInfo->setLayoutCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->setLayoutCount == 1) {
            pset_layouts_array = "&" + pset_layouts_values;
        } else if (structInfo->setLayoutCount > 1) {
            out << "\t\t" << "VkDescriptorSetLayout " << pset_layouts_array << "[] = {" << pset_layouts_values << "};" << std::endl;
        }
    }
    std::string ppush_constant_ranges_array = "NULL";
    if (structInfo->pPushConstantRanges != NULL) {
        ppush_constant_ranges_array = "pPushConstantRanges_" + std::to_string(consumer.GetNextId());
        std::string ppush_constant_ranges_names;
        for (uint32_t idx = 0; idx < structInfo->pushConstantRangeCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPushConstantRanges + idx != NULL) {
                variable_name = GenerateStruct_VkPushConstantRange(out,
                                                                   structInfo->pPushConstantRanges + idx,
                                                                   metaInfo->pPushConstantRanges->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            ppush_constant_ranges_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPushConstantRange " << ppush_constant_ranges_array << "[] = {" << ppush_constant_ranges_names << "};" << std::endl;
    }
    std::string pspecialization_info_struct = "NULL";
    if (structInfo->pSpecializationInfo != NULL) {
        pspecialization_info_struct = GenerateStruct_VkSpecializationInfo(out,
                                                                          structInfo->pSpecializationInfo,
                                                                          metaInfo->pSpecializationInfo->GetMetaStructPointer(),
                                                                          consumer);
        pspecialization_info_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlagBits(" << structInfo->stage << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->nextStage << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderCodeTypeEXT(" << structInfo->codeType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->codeSize << "," << std::endl;
    struct_body << "\t\t\t" << pcode_array << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pName) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->setLayoutCount << "," << std::endl;
    struct_body << "\t\t\t" << pset_layouts_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pushConstantRangeCount << "," << std::endl;
    struct_body << "\t\t\t" << ppush_constant_ranges_array << "," << std::endl;
    struct_body << "\t\t\t" << pspecialization_info_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "shaderCreateInfoEXT");
    out << "\t\t" << "VkShaderCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTilePropertiesFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceTilePropertiesFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceTilePropertiesFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileProperties << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTilePropertiesFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceTilePropertiesFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTilePropertiesQCOM(std::ostream &out, const VkTilePropertiesQCOM* structInfo, Decoded_VkTilePropertiesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string tile_size_info_var = GenerateStruct_VkExtent3D(out,
                                                               &structInfo->tileSize,
                                                               metaInfo->tileSize,
                                                               consumer);
    std::string apron_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                &structInfo->apronSize,
                                                                metaInfo->apronSize,
                                                                consumer);
    std::string origin_info_var = GenerateStruct_VkOffset2D(out,
                                                            &structInfo->origin,
                                                            metaInfo->origin,
                                                            consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << tile_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << apron_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << origin_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "tilePropertiesQCOM");
    out << "\t\t" << "VkTilePropertiesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAmigoProfilingSubmitInfoSEC(std::ostream &out, const VkAmigoProfilingSubmitInfoSEC* structInfo, Decoded_VkAmigoProfilingSubmitInfoSEC* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->firstDrawTimestamp << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->swapBufferTimestamp << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "amigoProfilingSubmitInfoSEC");
    out << "\t\t" << "VkAmigoProfilingSubmitInfoSEC " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceAmigoProfilingFeaturesSEC(std::ostream &out, const VkPhysicalDeviceAmigoProfilingFeaturesSEC* structInfo, Decoded_VkPhysicalDeviceAmigoProfilingFeaturesSEC* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->amigoProfiling << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceAmigoProfilingFeaturesSEC");
    out << "\t\t" << "VkPhysicalDeviceAmigoProfilingFeaturesSEC " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multiviewPerViewViewports << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultiviewPerViewViewportsFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(std::ostream &out, const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* structInfo, Decoded_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rayTracingInvocationReorder << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingInvocationReorderFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(std::ostream &out, const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* structInfo, Decoded_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkRayTracingInvocationReorderModeEXT(" << structInfo->rayTracingInvocationReorderReorderingHint << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingInvocationReorderPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkConvertCooperativeVectorMatrixInfoNV(std::ostream &out, const VkConvertCooperativeVectorMatrixInfoNV* structInfo, Decoded_VkConvertCooperativeVectorMatrixInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcData.deviceAddress << "," << std::endl;
    out << "\t\t" << "// TODO: Support pDstSize (non-struct output) argument." << std::endl;
    struct_body << "\t\t\t" << structInfo->dstData.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->srcComponentType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->dstComponentType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->numRows << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->numColumns << "," << std::endl;
    struct_body << "\t\t\t" << "VkCooperativeVectorMatrixLayoutNV(" << structInfo->srcLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcStride << "," << std::endl;
    struct_body << "\t\t\t" << "VkCooperativeVectorMatrixLayoutNV(" << structInfo->dstLayout << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstStride << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "convertCooperativeVectorMatrixInfoNV");
    out << "\t\t" << "VkConvertCooperativeVectorMatrixInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCooperativeVectorPropertiesNV(std::ostream &out, const VkCooperativeVectorPropertiesNV* structInfo, Decoded_VkCooperativeVectorPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->inputType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->inputInterpretation << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->matrixInterpretation << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->biasInterpretation << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->resultType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->transpose << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "cooperativeVectorPropertiesNV");
    out << "\t\t" << "VkCooperativeVectorPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeVectorFeaturesNV(std::ostream &out, const VkPhysicalDeviceCooperativeVectorFeaturesNV* structInfo, Decoded_VkPhysicalDeviceCooperativeVectorFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeVector << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeVectorTraining << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCooperativeVectorFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceCooperativeVectorFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeVectorPropertiesNV(std::ostream &out, const VkPhysicalDeviceCooperativeVectorPropertiesNV* structInfo, Decoded_VkPhysicalDeviceCooperativeVectorPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->cooperativeVectorSupportedStages << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeVectorTrainingFloat16Accumulation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeVectorTrainingFloat32Accumulation << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxCooperativeVectorComponents << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCooperativeVectorPropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceCooperativeVectorPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV(std::ostream &out, const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* structInfo, Decoded_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedSparseAddressSpace << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExtendedSparseAddressSpaceFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV(std::ostream &out, const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* structInfo, Decoded_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->extendedSparseAddressSpaceSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkImageUsageFlags(" << structInfo->extendedSparseImageUsageFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBufferUsageFlags(" << structInfo->extendedSparseBufferUsageFlags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceExtendedSparseAddressSpacePropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT(std::ostream &out, const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->legacyVertexAttributes << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLegacyVertexAttributesFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT(std::ostream &out, const VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->nativeUnalignedPerformance << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLegacyVertexAttributesPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceLegacyVertexAttributesPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkLayerSettingsCreateInfoEXT(std::ostream &out, const VkLayerSettingsCreateInfoEXT* structInfo, Decoded_VkLayerSettingsCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string psettings_array = "NULL";
    if (structInfo->pSettings != NULL) {
        psettings_array = "pSettings_" + std::to_string(consumer.GetNextId());
        std::string psettings_names;
        for (uint32_t idx = 0; idx < structInfo->settingCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pSettings + idx != NULL) {
                variable_name = GenerateStruct_VkLayerSettingEXT(out,
                                                                 structInfo->pSettings + idx,
                                                                 metaInfo->pSettings->GetMetaStructPointer() + idx,
                                                                 consumer);
            }
            psettings_names += variable_name + ", ";
        }
        out << "\t\t" << "VkLayerSettingEXT " << psettings_array << "[] = {" << psettings_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->settingCount << "," << std::endl;
    struct_body << "\t\t\t" << psettings_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "layerSettingsCreateInfoEXT");
    out << "\t\t" << "VkLayerSettingsCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM(std::ostream &out, const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* structInfo, Decoded_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderCoreBuiltins << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderCoreBuiltinsFeaturesARM");
    out << "\t\t" << "VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM(std::ostream &out, const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* structInfo, Decoded_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderCoreMask << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderCoreCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderWarpsPerCore << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderCoreBuiltinsPropertiesARM");
    out << "\t\t" << "VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(std::ostream &out, const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineLibraryGroupHandles << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineLibraryGroupHandlesFeaturesEXT");
    out << "\t\t" << "VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dynamicRenderingUnusedAttachments << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGetLatencyMarkerInfoNV(std::ostream &out, const VkGetLatencyMarkerInfoNV* structInfo, Decoded_VkGetLatencyMarkerInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ptimings_array = "NULL";
    if (structInfo->pTimings != NULL) {
        ptimings_array = "pTimings_" + std::to_string(consumer.GetNextId());
        std::string ptimings_names;
        for (uint32_t idx = 0; idx < structInfo->timingCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pTimings + idx != NULL) {
                variable_name = GenerateStruct_VkLatencyTimingsFrameReportNV(out,
                                                                             structInfo->pTimings + idx,
                                                                             metaInfo->pTimings->GetMetaStructPointer() + idx,
                                                                             consumer);
            }
            ptimings_names += variable_name + ", ";
        }
        out << "\t\t" << "VkLatencyTimingsFrameReportNV " << ptimings_array << "[] = {" << ptimings_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->timingCount << "," << std::endl;
    struct_body << "\t\t\t" << ptimings_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "getLatencyMarkerInfoNV");
    out << "\t\t" << "VkGetLatencyMarkerInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkLatencySleepInfoNV(std::ostream &out, const VkLatencySleepInfoNV* structInfo, Decoded_VkLatencySleepInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->signalSemaphore) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->value << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "latencySleepInfoNV");
    out << "\t\t" << "VkLatencySleepInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkLatencySleepModeInfoNV(std::ostream &out, const VkLatencySleepModeInfoNV* structInfo, Decoded_VkLatencySleepModeInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->lowLatencyMode << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->lowLatencyBoost << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minimumIntervalUs << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "latencySleepModeInfoNV");
    out << "\t\t" << "VkLatencySleepModeInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkLatencySubmissionPresentIdNV(std::ostream &out, const VkLatencySubmissionPresentIdNV* structInfo, Decoded_VkLatencySubmissionPresentIdNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentID << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "latencySubmissionPresentIdNV");
    out << "\t\t" << "VkLatencySubmissionPresentIdNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkLatencySurfaceCapabilitiesNV(std::ostream &out, const VkLatencySurfaceCapabilitiesNV* structInfo, Decoded_VkLatencySurfaceCapabilitiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ppresent_modes_array = "NULL";
    if (structInfo->pPresentModes != NULL) {
        std::string ppresent_modes_values;
        for (uint32_t idx = 0; idx < structInfo->presentModeCount; idx++) {
            ppresent_modes_values += util::ToString<VkPresentModeKHR>(structInfo->pPresentModes[idx]) + ", ";
        }
        ppresent_modes_array = "pPresentModes_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkPresentModeKHR " << ppresent_modes_array << "[] = {" << ppresent_modes_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentModeCount << "," << std::endl;
    struct_body << "\t\t\t" << ppresent_modes_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "latencySurfaceCapabilitiesNV");
    out << "\t\t" << "VkLatencySurfaceCapabilitiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkLatencyTimingsFrameReportNV(std::ostream &out, const VkLatencyTimingsFrameReportNV* structInfo, Decoded_VkLatencyTimingsFrameReportNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentID << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->inputSampleTimeUs << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->simStartTimeUs << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->simEndTimeUs << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->renderSubmitStartTimeUs << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->renderSubmitEndTimeUs << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentStartTimeUs << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentEndTimeUs << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->driverStartTimeUs << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->driverEndTimeUs << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->osRenderQueueStartTimeUs << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->osRenderQueueEndTimeUs << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->gpuRenderStartTimeUs << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->gpuRenderEndTimeUs << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "latencyTimingsFrameReportNV");
    out << "\t\t" << "VkLatencyTimingsFrameReportNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkOutOfBandQueueTypeInfoNV(std::ostream &out, const VkOutOfBandQueueTypeInfoNV* structInfo, Decoded_VkOutOfBandQueueTypeInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkOutOfBandQueueTypeNV(" << structInfo->queueType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "outOfBandQueueTypeInfoNV");
    out << "\t\t" << "VkOutOfBandQueueTypeInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSetLatencyMarkerInfoNV(std::ostream &out, const VkSetLatencyMarkerInfoNV* structInfo, Decoded_VkSetLatencyMarkerInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentID << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkLatencyMarkerNV(" << structInfo->marker << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "setLatencyMarkerInfoNV");
    out << "\t\t" << "VkSetLatencyMarkerInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSwapchainLatencyCreateInfoNV(std::ostream &out, const VkSwapchainLatencyCreateInfoNV* structInfo, Decoded_VkSwapchainLatencyCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->latencyModeEnable << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "swapchainLatencyCreateInfoNV");
    out << "\t\t" << "VkSwapchainLatencyCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindDataGraphPipelineSessionMemoryInfoARM(std::ostream &out, const VkBindDataGraphPipelineSessionMemoryInfoARM* structInfo, Decoded_VkBindDataGraphPipelineSessionMemoryInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->session) << "," << std::endl;
    struct_body << "\t\t\t" << "VkDataGraphPipelineSessionBindPointARM(" << structInfo->bindPoint << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->objectIndex << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryOffset << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindDataGraphPipelineSessionMemoryInfoARM");
    out << "\t\t" << "VkBindDataGraphPipelineSessionMemoryInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelineCompilerControlCreateInfoARM(std::ostream &out, const VkDataGraphPipelineCompilerControlCreateInfoARM* structInfo, Decoded_VkDataGraphPipelineCompilerControlCreateInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pVendorOptions) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelineCompilerControlCreateInfoARM");
    out << "\t\t" << "VkDataGraphPipelineCompilerControlCreateInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelineConstantARM(std::ostream &out, const VkDataGraphPipelineConstantARM* structInfo, Decoded_VkDataGraphPipelineConstantARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->id << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pConstantData << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelineConstantARM");
    out << "\t\t" << "VkDataGraphPipelineConstantARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM(std::ostream &out, const VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM* structInfo, Decoded_VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dimension << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->zeroCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->groupSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM");
    out << "\t\t" << "VkDataGraphPipelineConstantTensorSemiStructuredSparsityInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelineCreateInfoARM(std::ostream &out, const VkDataGraphPipelineCreateInfoARM* structInfo, Decoded_VkDataGraphPipelineCreateInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string presource_infos_array = "NULL";
    if (structInfo->pResourceInfos != NULL) {
        presource_infos_array = "pResourceInfos_" + std::to_string(consumer.GetNextId());
        std::string presource_infos_names;
        for (uint32_t idx = 0; idx < structInfo->resourceInfoCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pResourceInfos + idx != NULL) {
                variable_name = GenerateStruct_VkDataGraphPipelineResourceInfoARM(out,
                                                                                  structInfo->pResourceInfos + idx,
                                                                                  metaInfo->pResourceInfos->GetMetaStructPointer() + idx,
                                                                                  consumer);
            }
            presource_infos_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDataGraphPipelineResourceInfoARM " << presource_infos_array << "[] = {" << presource_infos_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineCreateFlags2KHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->layout) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->resourceInfoCount << "," << std::endl;
    struct_body << "\t\t\t" << presource_infos_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelineCreateInfoARM");
    out << "\t\t" << "VkDataGraphPipelineCreateInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelineDispatchInfoARM(std::ostream &out, const VkDataGraphPipelineDispatchInfoARM* structInfo, Decoded_VkDataGraphPipelineDispatchInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDataGraphPipelineDispatchFlagsARM(" << structInfo->flags << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelineDispatchInfoARM");
    out << "\t\t" << "VkDataGraphPipelineDispatchInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelineIdentifierCreateInfoARM(std::ostream &out, const VkDataGraphPipelineIdentifierCreateInfoARM* structInfo, Decoded_VkDataGraphPipelineIdentifierCreateInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pidentifier_array = "NULL";
    if (structInfo->pIdentifier != NULL) {
        std::string pidentifier_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->identifierSize; ++idx0) {
            pidentifier_values += std::to_string(structInfo->pIdentifier[idx0]) + ", ";
        }
        pidentifier_array = "pIdentifier_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pidentifier_array << "[] = {" << pidentifier_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->identifierSize << "," << std::endl;
    struct_body << "\t\t\t" << pidentifier_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelineIdentifierCreateInfoARM");
    out << "\t\t" << "VkDataGraphPipelineIdentifierCreateInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelineInfoARM(std::ostream &out, const VkDataGraphPipelineInfoARM* structInfo, Decoded_VkDataGraphPipelineInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dataGraphPipeline) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelineInfoARM");
    out << "\t\t" << "VkDataGraphPipelineInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelinePropertyQueryResultARM(std::ostream &out, const VkDataGraphPipelinePropertyQueryResultARM* structInfo, Decoded_VkDataGraphPipelinePropertyQueryResultARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDataGraphPipelinePropertyARM(" << structInfo->property << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->isText << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dataSize << "," << std::endl;
    out << "\t\t" << "// TODO: Support pData (output with array length value?) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelinePropertyQueryResultARM");
    out << "\t\t" << "VkDataGraphPipelinePropertyQueryResultARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelineResourceInfoARM(std::ostream &out, const VkDataGraphPipelineResourceInfoARM* structInfo, Decoded_VkDataGraphPipelineResourceInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorSet << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->binding << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->arrayElement << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelineResourceInfoARM");
    out << "\t\t" << "VkDataGraphPipelineResourceInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelineSessionBindPointRequirementARM(std::ostream &out, const VkDataGraphPipelineSessionBindPointRequirementARM* structInfo, Decoded_VkDataGraphPipelineSessionBindPointRequirementARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDataGraphPipelineSessionBindPointARM(" << structInfo->bindPoint << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkDataGraphPipelineSessionBindPointTypeARM(" << structInfo->bindPointType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->numObjects << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelineSessionBindPointRequirementARM");
    out << "\t\t" << "VkDataGraphPipelineSessionBindPointRequirementARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelineSessionBindPointRequirementsInfoARM(std::ostream &out, const VkDataGraphPipelineSessionBindPointRequirementsInfoARM* structInfo, Decoded_VkDataGraphPipelineSessionBindPointRequirementsInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->session) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelineSessionBindPointRequirementsInfoARM");
    out << "\t\t" << "VkDataGraphPipelineSessionBindPointRequirementsInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelineSessionCreateInfoARM(std::ostream &out, const VkDataGraphPipelineSessionCreateInfoARM* structInfo, Decoded_VkDataGraphPipelineSessionCreateInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDataGraphPipelineSessionCreateFlagsARM(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dataGraphPipeline) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelineSessionCreateInfoARM");
    out << "\t\t" << "VkDataGraphPipelineSessionCreateInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelineSessionMemoryRequirementsInfoARM(std::ostream &out, const VkDataGraphPipelineSessionMemoryRequirementsInfoARM* structInfo, Decoded_VkDataGraphPipelineSessionMemoryRequirementsInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->session) << "," << std::endl;
    struct_body << "\t\t\t" << "VkDataGraphPipelineSessionBindPointARM(" << structInfo->bindPoint << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->objectIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelineSessionMemoryRequirementsInfoARM");
    out << "\t\t" << "VkDataGraphPipelineSessionMemoryRequirementsInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelineShaderModuleCreateInfoARM(std::ostream &out, const VkDataGraphPipelineShaderModuleCreateInfoARM* structInfo, Decoded_VkDataGraphPipelineShaderModuleCreateInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pspecialization_info_struct = "NULL";
    if (structInfo->pSpecializationInfo != NULL) {
        pspecialization_info_struct = GenerateStruct_VkSpecializationInfo(out,
                                                                          structInfo->pSpecializationInfo,
                                                                          metaInfo->pSpecializationInfo->GetMetaStructPointer(),
                                                                          consumer);
        pspecialization_info_struct.insert(0, "&");
    }
    std::string pconstants_array = "NULL";
    if (structInfo->pConstants != NULL) {
        pconstants_array = "pConstants_" + std::to_string(consumer.GetNextId());
        std::string pconstants_names;
        for (uint32_t idx = 0; idx < structInfo->constantCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pConstants + idx != NULL) {
                variable_name = GenerateStruct_VkDataGraphPipelineConstantARM(out,
                                                                              structInfo->pConstants + idx,
                                                                              metaInfo->pConstants->GetMetaStructPointer() + idx,
                                                                              consumer);
            }
            pconstants_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDataGraphPipelineConstantARM " << pconstants_array << "[] = {" << pconstants_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->module) << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->pName) << "," << std::endl;
    struct_body << "\t\t\t" << pspecialization_info_struct << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->constantCount << "," << std::endl;
    struct_body << "\t\t\t" << pconstants_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelineShaderModuleCreateInfoARM");
    out << "\t\t" << "VkDataGraphPipelineShaderModuleCreateInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphProcessingEngineCreateInfoARM(std::ostream &out, const VkDataGraphProcessingEngineCreateInfoARM* structInfo, Decoded_VkDataGraphProcessingEngineCreateInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pprocessing_engines_array = "NULL";
    if (structInfo->pProcessingEngines != NULL) {
        pprocessing_engines_array = "pProcessingEngines_" + std::to_string(consumer.GetNextId());
        std::string pprocessing_engines_names;
        for (uint32_t idx = 0; idx < structInfo->processingEngineCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pProcessingEngines + idx != NULL) {
                variable_name = GenerateStruct_VkPhysicalDeviceDataGraphProcessingEngineARM(out,
                                                                                            structInfo->pProcessingEngines + idx,
                                                                                            metaInfo->pProcessingEngines->GetMetaStructPointer() + idx,
                                                                                            consumer);
            }
            pprocessing_engines_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPhysicalDeviceDataGraphProcessingEngineARM " << pprocessing_engines_array << "[] = {" << pprocessing_engines_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->processingEngineCount << "," << std::endl;
    struct_body << "\t\t\t" << pprocessing_engines_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphProcessingEngineCreateInfoARM");
    out << "\t\t" << "VkDataGraphProcessingEngineCreateInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDataGraphFeaturesARM(std::ostream &out, const VkPhysicalDeviceDataGraphFeaturesARM* structInfo, Decoded_VkPhysicalDeviceDataGraphFeaturesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dataGraph << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dataGraphUpdateAfterBind << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dataGraphSpecializationConstants << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dataGraphDescriptorBuffer << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dataGraphShaderModule << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDataGraphFeaturesARM");
    out << "\t\t" << "VkPhysicalDeviceDataGraphFeaturesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDataGraphOperationSupportARM(std::ostream &out, const VkPhysicalDeviceDataGraphOperationSupportARM* structInfo, Decoded_VkPhysicalDeviceDataGraphOperationSupportARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkPhysicalDeviceDataGraphOperationTypeARM(" << structInfo->operationType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->name) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->version << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDataGraphOperationSupportARM");
    out << "\t\t" << "VkPhysicalDeviceDataGraphOperationSupportARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDataGraphProcessingEngineARM(std::ostream &out, const VkPhysicalDeviceDataGraphProcessingEngineARM* structInfo, Decoded_VkPhysicalDeviceDataGraphProcessingEngineARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkPhysicalDeviceDataGraphProcessingEngineTypeARM(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->isForeign << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDataGraphProcessingEngineARM");
    out << "\t\t" << "VkPhysicalDeviceDataGraphProcessingEngineARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM(std::ostream &out, const VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM* structInfo, Decoded_VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueFamilyIndex << "," << std::endl;
    struct_body << "\t\t\t" << "VkPhysicalDeviceDataGraphProcessingEngineTypeARM(" << structInfo->engineType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM");
    out << "\t\t" << "VkPhysicalDeviceQueueFamilyDataGraphProcessingEngineInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyDataGraphProcessingEnginePropertiesARM(std::ostream &out, const VkQueueFamilyDataGraphProcessingEnginePropertiesARM* structInfo, Decoded_VkQueueFamilyDataGraphProcessingEnginePropertiesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalSemaphoreHandleTypeFlags(" << structInfo->foreignSemaphoreHandleTypes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->foreignMemoryHandleTypes << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyDataGraphProcessingEnginePropertiesARM");
    out << "\t\t" << "VkQueueFamilyDataGraphProcessingEnginePropertiesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkQueueFamilyDataGraphPropertiesARM(std::ostream &out, const VkQueueFamilyDataGraphPropertiesARM* structInfo, Decoded_VkQueueFamilyDataGraphPropertiesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string engine_info_var = GenerateStruct_VkPhysicalDeviceDataGraphProcessingEngineARM(out,
                                                                                              &structInfo->engine,
                                                                                              metaInfo->engine,
                                                                                              consumer);
    std::string operation_info_var = GenerateStruct_VkPhysicalDeviceDataGraphOperationSupportARM(out,
                                                                                                 &structInfo->operation,
                                                                                                 metaInfo->operation,
                                                                                                 consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << engine_info_var << "," << std::endl;
    struct_body << "\t\t\t" << operation_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "queueFamilyDataGraphPropertiesARM");
    out << "\t\t" << "VkQueueFamilyDataGraphPropertiesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(std::ostream &out, const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* structInfo, Decoded_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pper_view_render_areas_array = "NULL";
    if (structInfo->pPerViewRenderAreas != NULL) {
        pper_view_render_areas_array = "pPerViewRenderAreas_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkRect2D " << pper_view_render_areas_array << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pPerViewRenderAreas, structInfo->perViewRenderAreaCount) << ";" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->perViewRenderAreaCount << "," << std::endl;
    struct_body << "\t\t\t" << pper_view_render_areas_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "multiviewPerViewRenderAreasRenderPassBeginInfoQCOM");
    out << "\t\t" << "VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multiviewPerViewRenderAreas << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePerStageDescriptorSetFeaturesNV(std::ostream &out, const VkPhysicalDevicePerStageDescriptorSetFeaturesNV* structInfo, Decoded_VkPhysicalDevicePerStageDescriptorSetFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->perStageDescriptorSet << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dynamicPipelineLayout << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePerStageDescriptorSetFeaturesNV");
    out << "\t\t" << "VkPhysicalDevicePerStageDescriptorSetFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageProcessing2FeaturesQCOM(std::ostream &out, const VkPhysicalDeviceImageProcessing2FeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceImageProcessing2FeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->textureBlockMatch2 << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageProcessing2FeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceImageProcessing2FeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageProcessing2PropertiesQCOM(std::ostream &out, const VkPhysicalDeviceImageProcessing2PropertiesQCOM* structInfo, Decoded_VkPhysicalDeviceImageProcessing2PropertiesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string max_block_match_window_info_var = GenerateStruct_VkExtent2D(out,
                                                                            &structInfo->maxBlockMatchWindow,
                                                                            metaInfo->maxBlockMatchWindow,
                                                                            consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << max_block_match_window_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageProcessing2PropertiesQCOM");
    out << "\t\t" << "VkPhysicalDeviceImageProcessing2PropertiesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerBlockMatchWindowCreateInfoQCOM(std::ostream &out, const VkSamplerBlockMatchWindowCreateInfoQCOM* structInfo, Decoded_VkSamplerBlockMatchWindowCreateInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string window_extent_info_var = GenerateStruct_VkExtent2D(out,
                                                                   &structInfo->windowExtent,
                                                                   metaInfo->windowExtent,
                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << window_extent_info_var << "," << std::endl;
    struct_body << "\t\t\t" << "VkBlockMatchWindowCompareModeQCOM(" << structInfo->windowCompareMode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerBlockMatchWindowCreateInfoQCOM");
    out << "\t\t" << "VkSamplerBlockMatchWindowCreateInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBlitImageCubicWeightsInfoQCOM(std::ostream &out, const VkBlitImageCubicWeightsInfoQCOM* structInfo, Decoded_VkBlitImageCubicWeightsInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkCubicFilterWeightsQCOM(" << structInfo->cubicWeights << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "blitImageCubicWeightsInfoQCOM");
    out << "\t\t" << "VkBlitImageCubicWeightsInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCubicWeightsFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceCubicWeightsFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceCubicWeightsFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->selectableCubicWeights << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCubicWeightsFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceCubicWeightsFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerCubicWeightsCreateInfoQCOM(std::ostream &out, const VkSamplerCubicWeightsCreateInfoQCOM* structInfo, Decoded_VkSamplerCubicWeightsCreateInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkCubicFilterWeightsQCOM(" << structInfo->cubicWeights << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerCubicWeightsCreateInfoQCOM");
    out << "\t\t" << "VkSamplerCubicWeightsCreateInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->ycbcrDegamma << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceYcbcrDegammaFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceYcbcrDegammaFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM(std::ostream &out, const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* structInfo, Decoded_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enableYDegamma << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enableCbCrDegamma << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "samplerYcbcrConversionYcbcrDegammaCreateInfoQCOM");
    out << "\t\t" << "VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCubicClampFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceCubicClampFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceCubicClampFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cubicRangeClamp << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCubicClampFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceCubicClampFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(std::ostream &out, const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->attachmentFeedbackLoopDynamicState << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceLayeredDriverPropertiesMSFT(std::ostream &out, const VkPhysicalDeviceLayeredDriverPropertiesMSFT* structInfo, Decoded_VkPhysicalDeviceLayeredDriverPropertiesMSFT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkLayeredDriverUnderlyingApiMSFT(" << structInfo->underlyingAPI << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceLayeredDriverPropertiesMSFT");
    out << "\t\t" << "VkPhysicalDeviceLayeredDriverPropertiesMSFT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV(std::ostream &out, const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorPoolOverallocation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDescriptorPoolOverallocationFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTileMemoryHeapFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceTileMemoryHeapFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceTileMemoryHeapFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileMemoryHeap << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTileMemoryHeapFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceTileMemoryHeapFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceTileMemoryHeapPropertiesQCOM(std::ostream &out, const VkPhysicalDeviceTileMemoryHeapPropertiesQCOM* structInfo, Decoded_VkPhysicalDeviceTileMemoryHeapPropertiesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->queueSubmitBoundary << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tileBufferTransfers << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceTileMemoryHeapPropertiesQCOM");
    out << "\t\t" << "VkPhysicalDeviceTileMemoryHeapPropertiesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTileMemoryBindInfoQCOM(std::ostream &out, const VkTileMemoryBindInfoQCOM* structInfo, Decoded_VkTileMemoryBindInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "tileMemoryBindInfoQCOM");
    out << "\t\t" << "VkTileMemoryBindInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTileMemoryRequirementsQCOM(std::ostream &out, const VkTileMemoryRequirementsQCOM* structInfo, Decoded_VkTileMemoryRequirementsQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->alignment << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "tileMemoryRequirementsQCOM");
    out << "\t\t" << "VkTileMemoryRequirementsQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTileMemorySizeInfoQCOM(std::ostream &out, const VkTileMemorySizeInfoQCOM* structInfo, Decoded_VkTileMemorySizeInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "tileMemorySizeInfoQCOM");
    out << "\t\t" << "VkTileMemorySizeInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDecompressMemoryInfoEXT(std::ostream &out, const VkDecompressMemoryInfoEXT* structInfo, Decoded_VkDecompressMemoryInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pregions_array = "NULL";
    if (structInfo->pRegions != NULL) {
        pregions_array = "pRegions_" + std::to_string(consumer.GetNextId());
        std::string pregions_names;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                variable_name = GenerateStruct_VkDecompressMemoryRegionEXT(out,
                                                                           structInfo->pRegions + idx,
                                                                           metaInfo->pRegions->GetMetaStructPointer() + idx,
                                                                           consumer);
            }
            pregions_names += variable_name + ", ";
        }
        out << "\t\t" << "VkDecompressMemoryRegionEXT " << pregions_array << "[] = {" << pregions_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkMemoryDecompressionMethodFlagsEXT(" << structInfo->decompressionMethod << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->regionCount << "," << std::endl;
    struct_body << "\t\t\t" << pregions_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "decompressMemoryInfoEXT");
    out << "\t\t" << "VkDecompressMemoryInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDecompressMemoryRegionEXT(std::ostream &out, const VkDecompressMemoryRegionEXT* structInfo, Decoded_VkDecompressMemoryRegionEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->srcAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->compressedSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->decompressedSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "decompressMemoryRegionEXT");
    out << "\t\t" << "VkDecompressMemoryRegionEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMemoryDecompressionFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMemoryDecompressionFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMemoryDecompressionFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryDecompression << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMemoryDecompressionFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceMemoryDecompressionFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMemoryDecompressionPropertiesEXT(std::ostream &out, const VkPhysicalDeviceMemoryDecompressionPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceMemoryDecompressionPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkMemoryDecompressionMethodFlagsEXT(" << structInfo->decompressionMethods << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDecompressionIndirectCount << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMemoryDecompressionPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceMemoryDecompressionPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplayModeStereoPropertiesNV(std::ostream &out, const VkDisplayModeStereoPropertiesNV* structInfo, Decoded_VkDisplayModeStereoPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hdmi3DSupported << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displayModeStereoPropertiesNV");
    out << "\t\t" << "VkDisplayModeStereoPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDisplaySurfaceStereoCreateInfoNV(std::ostream &out, const VkDisplaySurfaceStereoCreateInfoNV* structInfo, Decoded_VkDisplaySurfaceStereoCreateInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDisplaySurfaceStereoTypeNV(" << structInfo->stereoType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "displaySurfaceStereoCreateInfoNV");
    out << "\t\t" << "VkDisplaySurfaceStereoCreateInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRawAccessChainsFeaturesNV(std::ostream &out, const VkPhysicalDeviceRawAccessChainsFeaturesNV* structInfo, Decoded_VkPhysicalDeviceRawAccessChainsFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderRawAccessChains << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRawAccessChainsFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceRawAccessChainsFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV(std::ostream &out, const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV* structInfo, Decoded_VkPhysicalDeviceCommandBufferInheritanceFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->commandBufferInheritance << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCommandBufferInheritanceFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceCommandBufferInheritanceFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV(std::ostream &out, const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* structInfo, Decoded_VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderFloat16VectorAtomics << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderAtomicFloat16VectorFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderReplicatedComposites << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderReplicatedCompositesFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderFloat8FeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderFloat8FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderFloat8FeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderFloat8 << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderFloat8CooperativeMatrix << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderFloat8FeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderFloat8FeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingValidationFeaturesNV(std::ostream &out, const VkPhysicalDeviceRayTracingValidationFeaturesNV* structInfo, Decoded_VkPhysicalDeviceRayTracingValidationFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rayTracingValidation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingValidationFeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceRayTracingValidationFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureBuildSizesInfoKHR(std::ostream &out, const VkAccelerationStructureBuildSizesInfoKHR* structInfo, Decoded_VkAccelerationStructureBuildSizesInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->accelerationStructureSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->updateScratchSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->buildScratchSize << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureBuildSizesInfoKHR");
    out << "\t\t" << "VkAccelerationStructureBuildSizesInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBuildPartitionedAccelerationStructureIndirectCommandNV(std::ostream &out, const VkBuildPartitionedAccelerationStructureIndirectCommandNV* structInfo, Decoded_VkBuildPartitionedAccelerationStructureIndirectCommandNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string arg_data_info_var = GenerateStruct_VkStridedDeviceAddressNV(out,
                                                                            &structInfo->argData,
                                                                            metaInfo->argData,
                                                                            consumer);
    struct_body << "\t" << "VkPartitionedAccelerationStructureOpTypeNV(" << structInfo->opType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->argCount << "," << std::endl;
    struct_body << "\t\t\t" << arg_data_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "buildPartitionedAccelerationStructureIndirectCommandNV");
    out << "\t\t" << "VkBuildPartitionedAccelerationStructureIndirectCommandNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBuildPartitionedAccelerationStructureInfoNV(std::ostream &out, const VkBuildPartitionedAccelerationStructureInfoNV* structInfo, Decoded_VkBuildPartitionedAccelerationStructureInfoNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string input_info_var = GenerateStruct_VkPartitionedAccelerationStructureInstancesInputNV(out,
                                                                                                   &structInfo->input,
                                                                                                   metaInfo->input,
                                                                                                   consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << input_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcAccelerationStructureData << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dstAccelerationStructureData << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->scratchData << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcInfos << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->srcInfosCount << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "buildPartitionedAccelerationStructureInfoNV");
    out << "\t\t" << "VkBuildPartitionedAccelerationStructureInfoNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPartitionedAccelerationStructureFlagsNV(std::ostream &out, const VkPartitionedAccelerationStructureFlagsNV* structInfo, Decoded_VkPartitionedAccelerationStructureFlagsNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->enablePartitionTranslation << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "partitionedAccelerationStructureFlagsNV");
    out << "\t\t" << "VkPartitionedAccelerationStructureFlagsNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPartitionedAccelerationStructureInstancesInputNV(std::ostream &out, const VkPartitionedAccelerationStructureInstancesInputNV* structInfo, Decoded_VkPartitionedAccelerationStructureInstancesInputNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkBuildAccelerationStructureFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxInstancePerPartitionCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->partitionCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxInstanceInGlobalPartitionCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "partitionedAccelerationStructureInstancesInputNV");
    out << "\t\t" << "VkPartitionedAccelerationStructureInstancesInputNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPartitionedAccelerationStructureUpdateInstanceDataNV(std::ostream &out, const VkPartitionedAccelerationStructureUpdateInstanceDataNV* structInfo, Decoded_VkPartitionedAccelerationStructureUpdateInstanceDataNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->instanceIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceContributionToHitGroupIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->accelerationStructure << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "partitionedAccelerationStructureUpdateInstanceDataNV");
    out << "\t\t" << "VkPartitionedAccelerationStructureUpdateInstanceDataNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPartitionedAccelerationStructureWriteInstanceDataNV(std::ostream &out, const VkPartitionedAccelerationStructureWriteInstanceDataNV* structInfo, Decoded_VkPartitionedAccelerationStructureWriteInstanceDataNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string transform_info_var = GenerateStruct_VkTransformMatrixKHR(out,
                                                                         &structInfo->transform,
                                                                         metaInfo->transform,
                                                                         consumer);
    struct_body << "\t" << transform_info_var << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->explicitAABB[0]), 6) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceID << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceMask << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceContributionToHitGroupIndex << "," << std::endl;
    struct_body << "\t\t\t" << "VkPartitionedAccelerationStructureInstanceFlagsNV(" << structInfo->instanceFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->instanceIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->partitionIndex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->accelerationStructure << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "partitionedAccelerationStructureWriteInstanceDataNV");
    out << "\t\t" << "VkPartitionedAccelerationStructureWriteInstanceDataNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPartitionedAccelerationStructureWritePartitionTranslationDataNV(std::ostream &out, const VkPartitionedAccelerationStructureWritePartitionTranslationDataNV* structInfo, Decoded_VkPartitionedAccelerationStructureWritePartitionTranslationDataNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->partitionIndex << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->partitionTranslation[0]), 3) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "partitionedAccelerationStructureWritePartitionTranslationDataNV");
    out << "\t\t" << "VkPartitionedAccelerationStructureWritePartitionTranslationDataNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV(std::ostream &out, const VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV* structInfo, Decoded_VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->partitionedAccelerationStructure << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePartitionedAccelerationStructureFeaturesNV");
    out << "\t\t" << "VkPhysicalDevicePartitionedAccelerationStructureFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV(std::ostream &out, const VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV* structInfo, Decoded_VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPartitionCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePartitionedAccelerationStructurePropertiesNV");
    out << "\t\t" << "VkPhysicalDevicePartitionedAccelerationStructurePropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkStridedDeviceAddressNV(std::ostream &out, const VkStridedDeviceAddressNV* structInfo, Decoded_VkStridedDeviceAddressNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->startAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->strideInBytes << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stridedDeviceAddressNV");
    out << "\t\t" << "VkStridedDeviceAddressNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWriteDescriptorSetPartitionedAccelerationStructureNV(std::ostream &out, const VkWriteDescriptorSetPartitionedAccelerationStructureNV* structInfo, Decoded_VkWriteDescriptorSetPartitionedAccelerationStructureNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pacceleration_structures_array = "pacceleration_structures_array_" + std::to_string(consumer.GetNextId());
    if (structInfo->accelerationStructureCount > 0) {
        std::string pacceleration_structures_values = toStringJoin(structInfo->pAccelerationStructures,
                                                                   structInfo->pAccelerationStructures + structInfo->accelerationStructureCount,
                                                                   [](VkDeviceAddress current) { return std::to_string(current); },
                                                                   ", ");
        if (structInfo->accelerationStructureCount == 1) {
            pacceleration_structures_array = "&" + pacceleration_structures_values;
        } else if (structInfo->accelerationStructureCount > 1) {
            out << "\t\t" << "VkDeviceAddress " << pacceleration_structures_array << "[] = {" << pacceleration_structures_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->accelerationStructureCount << "," << std::endl;
    struct_body << "\t\t\t" << "{ *" << pacceleration_structures_array << " }" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "writeDescriptorSetPartitionedAccelerationStructureNV");
    out << "\t\t" << "VkWriteDescriptorSetPartitionedAccelerationStructureNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindIndexBufferIndirectCommandEXT(std::ostream &out, const VkBindIndexBufferIndirectCommandEXT* structInfo, Decoded_VkBindIndexBufferIndirectCommandEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->bufferAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "," << std::endl;
    struct_body << "\t\t\t" << "VkIndexType(" << structInfo->indexType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindIndexBufferIndirectCommandEXT");
    out << "\t\t" << "VkBindIndexBufferIndirectCommandEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBindVertexBufferIndirectCommandEXT(std::ostream &out, const VkBindVertexBufferIndirectCommandEXT* structInfo, Decoded_VkBindVertexBufferIndirectCommandEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->bufferAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stride << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "bindVertexBufferIndirectCommandEXT");
    out << "\t\t" << "VkBindVertexBufferIndirectCommandEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrawIndirectCountIndirectCommandEXT(std::ostream &out, const VkDrawIndirectCountIndirectCommandEXT* structInfo, Decoded_VkDrawIndirectCountIndirectCommandEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->bufferAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stride << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->commandCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drawIndirectCountIndirectCommandEXT");
    out << "\t\t" << "VkDrawIndirectCountIndirectCommandEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeneratedCommandsInfoEXT(std::ostream &out, const VkGeneratedCommandsInfoEXT* structInfo, Decoded_VkGeneratedCommandsInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->shaderStages << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->indirectExecutionSet) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->indirectCommandsLayout) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indirectAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indirectAddressSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preprocessAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->preprocessSize << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSequenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->sequenceCountAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDrawCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "generatedCommandsInfoEXT");
    out << "\t\t" << "VkGeneratedCommandsInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeneratedCommandsMemoryRequirementsInfoEXT(std::ostream &out, const VkGeneratedCommandsMemoryRequirementsInfoEXT* structInfo, Decoded_VkGeneratedCommandsMemoryRequirementsInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->indirectExecutionSet) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->indirectCommandsLayout) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxSequenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDrawCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "generatedCommandsMemoryRequirementsInfoEXT");
    out << "\t\t" << "VkGeneratedCommandsMemoryRequirementsInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeneratedCommandsPipelineInfoEXT(std::ostream &out, const VkGeneratedCommandsPipelineInfoEXT* structInfo, Decoded_VkGeneratedCommandsPipelineInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipeline) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "generatedCommandsPipelineInfoEXT");
    out << "\t\t" << "VkGeneratedCommandsPipelineInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkGeneratedCommandsShaderInfoEXT(std::ostream &out, const VkGeneratedCommandsShaderInfoEXT* structInfo, Decoded_VkGeneratedCommandsShaderInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pshaders_array = "NULL";
    if (metaInfo->pShaders.GetPointer() != NULL && structInfo->shaderCount > 0) {
        pshaders_array = "pshaders_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_SHADER_EXT));
        std::string pshaders_values = toStringJoin(metaInfo->pShaders.GetPointer(),
                                                   metaInfo->pShaders.GetPointer() + structInfo->shaderCount,
                                                   [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                   ", ");
        if (structInfo->shaderCount == 1) {
            pshaders_array = "&" + pshaders_values;
        } else if (structInfo->shaderCount > 1) {
            out << "\t\t" << "VkShaderEXT " << pshaders_array << "[] = {" << pshaders_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderCount << "," << std::endl;
    struct_body << "\t\t\t" << pshaders_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "generatedCommandsShaderInfoEXT");
    out << "\t\t" << "VkGeneratedCommandsShaderInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIndirectCommandsExecutionSetTokenEXT(std::ostream &out, const VkIndirectCommandsExecutionSetTokenEXT* structInfo, Decoded_VkIndirectCommandsExecutionSetTokenEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkIndirectExecutionSetInfoTypeEXT(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->shaderStages << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "indirectCommandsExecutionSetTokenEXT");
    out << "\t\t" << "VkIndirectCommandsExecutionSetTokenEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIndirectCommandsIndexBufferTokenEXT(std::ostream &out, const VkIndirectCommandsIndexBufferTokenEXT* structInfo, Decoded_VkIndirectCommandsIndexBufferTokenEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << "VkIndirectCommandsInputModeFlagBitsEXT(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "indirectCommandsIndexBufferTokenEXT");
    out << "\t\t" << "VkIndirectCommandsIndexBufferTokenEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIndirectCommandsLayoutCreateInfoEXT(std::ostream &out, const VkIndirectCommandsLayoutCreateInfoEXT* structInfo, Decoded_VkIndirectCommandsLayoutCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string ptokens_array = "NULL";
    if (structInfo->pTokens != NULL) {
        ptokens_array = "pTokens_" + std::to_string(consumer.GetNextId());
        std::string ptokens_names;
        for (uint32_t idx = 0; idx < structInfo->tokenCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pTokens + idx != NULL) {
                variable_name = GenerateStruct_VkIndirectCommandsLayoutTokenEXT(out,
                                                                                structInfo->pTokens + idx,
                                                                                metaInfo->pTokens->GetMetaStructPointer() + idx,
                                                                                consumer);
            }
            ptokens_names += variable_name + ", ";
        }
        out << "\t\t" << "VkIndirectCommandsLayoutTokenEXT " << ptokens_array << "[] = {" << ptokens_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkIndirectCommandsLayoutUsageFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->shaderStages << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indirectStride << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipelineLayout) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->tokenCount << "," << std::endl;
    struct_body << "\t\t\t" << ptokens_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "indirectCommandsLayoutCreateInfoEXT");
    out << "\t\t" << "VkIndirectCommandsLayoutCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIndirectCommandsPushConstantTokenEXT(std::ostream &out, const VkIndirectCommandsPushConstantTokenEXT* structInfo, Decoded_VkIndirectCommandsPushConstantTokenEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string update_range_info_var = GenerateStruct_VkPushConstantRange(out,
                                                                           &structInfo->updateRange,
                                                                           metaInfo->updateRange,
                                                                           consumer);
    struct_body << "\t" << update_range_info_var << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "indirectCommandsPushConstantTokenEXT");
    out << "\t\t" << "VkIndirectCommandsPushConstantTokenEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIndirectCommandsVertexBufferTokenEXT(std::ostream &out, const VkIndirectCommandsVertexBufferTokenEXT* structInfo, Decoded_VkIndirectCommandsVertexBufferTokenEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->vertexBindingUnit << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "indirectCommandsVertexBufferTokenEXT");
    out << "\t\t" << "VkIndirectCommandsVertexBufferTokenEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIndirectExecutionSetPipelineInfoEXT(std::ostream &out, const VkIndirectExecutionSetPipelineInfoEXT* structInfo, Decoded_VkIndirectExecutionSetPipelineInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->initialPipeline) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPipelineCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "indirectExecutionSetPipelineInfoEXT");
    out << "\t\t" << "VkIndirectExecutionSetPipelineInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIndirectExecutionSetShaderInfoEXT(std::ostream &out, const VkIndirectExecutionSetShaderInfoEXT* structInfo, Decoded_VkIndirectExecutionSetShaderInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pinitial_shaders_array = "NULL";
    if (metaInfo->pInitialShaders.GetPointer() != NULL && structInfo->shaderCount > 0) {
        pinitial_shaders_array = "pinitial_shaders_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_SHADER_EXT));
        std::string pinitial_shaders_values = toStringJoin(metaInfo->pInitialShaders.GetPointer(),
                                                           metaInfo->pInitialShaders.GetPointer() + structInfo->shaderCount,
                                                           [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                           ", ");
        if (structInfo->shaderCount == 1) {
            pinitial_shaders_array = "&" + pinitial_shaders_values;
        } else if (structInfo->shaderCount > 1) {
            out << "\t\t" << "VkShaderEXT " << pinitial_shaders_array << "[] = {" << pinitial_shaders_values << "};" << std::endl;
        }
    }
    std::string pset_layout_infos_array = "NULL";
    if (structInfo->pSetLayoutInfos != NULL) {
        pset_layout_infos_array = "pSetLayoutInfos_" + std::to_string(consumer.GetNextId());
        std::string pset_layout_infos_names;
        for (uint32_t idx = 0; idx < structInfo->shaderCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pSetLayoutInfos + idx != NULL) {
                variable_name = GenerateStruct_VkIndirectExecutionSetShaderLayoutInfoEXT(out,
                                                                                         structInfo->pSetLayoutInfos + idx,
                                                                                         metaInfo->pSetLayoutInfos->GetMetaStructPointer() + idx,
                                                                                         consumer);
            }
            pset_layout_infos_names += variable_name + ", ";
        }
        out << "\t\t" << "VkIndirectExecutionSetShaderLayoutInfoEXT " << pset_layout_infos_array << "[] = {" << pset_layout_infos_names << "};" << std::endl;
    }
    std::string ppush_constant_ranges_array = "NULL";
    if (structInfo->pPushConstantRanges != NULL) {
        ppush_constant_ranges_array = "pPushConstantRanges_" + std::to_string(consumer.GetNextId());
        std::string ppush_constant_ranges_names;
        for (uint32_t idx = 0; idx < structInfo->pushConstantRangeCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pPushConstantRanges + idx != NULL) {
                variable_name = GenerateStruct_VkPushConstantRange(out,
                                                                   structInfo->pPushConstantRanges + idx,
                                                                   metaInfo->pPushConstantRanges->GetMetaStructPointer() + idx,
                                                                   consumer);
            }
            ppush_constant_ranges_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPushConstantRange " << ppush_constant_ranges_array << "[] = {" << ppush_constant_ranges_names << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderCount << "," << std::endl;
    struct_body << "\t\t\t" << pinitial_shaders_array << "," << std::endl;
    struct_body << "\t\t\t" << pset_layout_infos_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxShaderCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pushConstantRangeCount << "," << std::endl;
    struct_body << "\t\t\t" << ppush_constant_ranges_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "indirectExecutionSetShaderInfoEXT");
    out << "\t\t" << "VkIndirectExecutionSetShaderInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkIndirectExecutionSetShaderLayoutInfoEXT(std::ostream &out, const VkIndirectExecutionSetShaderLayoutInfoEXT* structInfo, Decoded_VkIndirectExecutionSetShaderLayoutInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pset_layouts_array = "NULL";
    if (metaInfo->pSetLayouts.GetPointer() != NULL && structInfo->setLayoutCount > 0) {
        pset_layouts_array = "pset_layouts_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT));
        std::string pset_layouts_values = toStringJoin(metaInfo->pSetLayouts.GetPointer(),
                                                       metaInfo->pSetLayouts.GetPointer() + structInfo->setLayoutCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->setLayoutCount == 1) {
            pset_layouts_array = "&" + pset_layouts_values;
        } else if (structInfo->setLayoutCount > 1) {
            out << "\t\t" << "VkDescriptorSetLayout " << pset_layouts_array << "[] = {" << pset_layouts_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->setLayoutCount << "," << std::endl;
    struct_body << "\t\t\t" << pset_layouts_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "indirectExecutionSetShaderLayoutInfoEXT");
    out << "\t\t" << "VkIndirectExecutionSetShaderLayoutInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceGeneratedCommands << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dynamicGeneratedPipelineLayout << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDeviceGeneratedCommandsFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT(std::ostream &out, const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxIndirectPipelineCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxIndirectShaderObjectCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxIndirectSequenceCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxIndirectCommandsTokenCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxIndirectCommandsTokenOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxIndirectCommandsIndirectStride << "," << std::endl;
    struct_body << "\t\t\t" << "VkIndirectCommandsInputModeFlagsEXT(" << structInfo->supportedIndirectCommandsInputModes << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->supportedIndirectCommandsShaderStages << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->supportedIndirectCommandsShaderStagesPipelineBinding << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkShaderStageFlags(" << structInfo->supportedIndirectCommandsShaderStagesShaderBinding << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceGeneratedCommandsTransformFeedback << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceGeneratedCommandsMultiDrawIndirectCount << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDeviceGeneratedCommandsPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceDeviceGeneratedCommandsPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWriteIndirectExecutionSetPipelineEXT(std::ostream &out, const VkWriteIndirectExecutionSetPipelineEXT* structInfo, Decoded_VkWriteIndirectExecutionSetPipelineEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->index << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->pipeline) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "writeIndirectExecutionSetPipelineEXT");
    out << "\t\t" << "VkWriteIndirectExecutionSetPipelineEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWriteIndirectExecutionSetShaderEXT(std::ostream &out, const VkWriteIndirectExecutionSetShaderEXT* structInfo, Decoded_VkWriteIndirectExecutionSetShaderEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->index << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->shader) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "writeIndirectExecutionSetShaderEXT");
    out << "\t\t" << "VkWriteIndirectExecutionSetShaderEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImageAlignmentControlCreateInfoMESA(std::ostream &out, const VkImageAlignmentControlCreateInfoMESA* structInfo, Decoded_VkImageAlignmentControlCreateInfoMESA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maximumRequestedAlignment << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "imageAlignmentControlCreateInfoMESA");
    out << "\t\t" << "VkImageAlignmentControlCreateInfoMESA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageAlignmentControlFeaturesMESA(std::ostream &out, const VkPhysicalDeviceImageAlignmentControlFeaturesMESA* structInfo, Decoded_VkPhysicalDeviceImageAlignmentControlFeaturesMESA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->imageAlignmentControl << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageAlignmentControlFeaturesMESA");
    out << "\t\t" << "VkPhysicalDeviceImageAlignmentControlFeaturesMESA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceImageAlignmentControlPropertiesMESA(std::ostream &out, const VkPhysicalDeviceImageAlignmentControlPropertiesMESA* structInfo, Decoded_VkPhysicalDeviceImageAlignmentControlPropertiesMESA* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->supportedImageAlignmentMask << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceImageAlignmentControlPropertiesMESA");
    out << "\t\t" << "VkPhysicalDeviceImageAlignmentControlPropertiesMESA " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT(std::ostream &out, const VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rayTracingInvocationReorder << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingInvocationReorderFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceRayTracingInvocationReorderFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT(std::ostream &out, const VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkRayTracingInvocationReorderModeEXT(" << structInfo->rayTracingInvocationReorderReorderingHint << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxShaderBindingTableRecordIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingInvocationReorderPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceRayTracingInvocationReorderPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDepthClampControlFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDepthClampControlFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDepthClampControlFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depthClampControl << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDepthClampControlFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceDepthClampControlFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineViewportDepthClampControlCreateInfoEXT(std::ostream &out, const VkPipelineViewportDepthClampControlCreateInfoEXT* structInfo, Decoded_VkPipelineViewportDepthClampControlCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdepth_clamp_range_struct = "NULL";
    if (structInfo->pDepthClampRange != NULL) {
        pdepth_clamp_range_struct = GenerateStruct_VkDepthClampRangeEXT(out,
                                                                        structInfo->pDepthClampRange,
                                                                        metaInfo->pDepthClampRange->GetMetaStructPointer(),
                                                                        consumer);
        pdepth_clamp_range_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkDepthClampModeEXT(" << structInfo->depthClampMode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pdepth_clamp_range_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineViewportDepthClampControlCreateInfoEXT");
    out << "\t\t" << "VkPipelineViewportDepthClampControlCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkHdrVividDynamicMetadataHUAWEI(std::ostream &out, const VkHdrVividDynamicMetadataHUAWEI* structInfo, Decoded_VkHdrVividDynamicMetadataHUAWEI* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pdynamic_metadata_array = "NULL";
    if (structInfo->pDynamicMetadata != NULL) {
        std::string pdynamic_metadata_values;
        for (uint32_t idx0 = 0; idx0 < structInfo->dynamicMetadataSize; ++idx0) {
            pdynamic_metadata_values += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pDynamicMetadata)[idx0]) + ", ";
        }
        pdynamic_metadata_array = "pDynamicMetadata_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "uint8_t " << pdynamic_metadata_array << "[] = {" << pdynamic_metadata_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dynamicMetadataSize << "," << std::endl;
    struct_body << "\t\t\t" << pdynamic_metadata_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "hdrVividDynamicMetadataHUAWEI");
    out << "\t\t" << "VkHdrVividDynamicMetadataHUAWEI " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceHdrVividFeaturesHUAWEI(std::ostream &out, const VkPhysicalDeviceHdrVividFeaturesHUAWEI* structInfo, Decoded_VkPhysicalDeviceHdrVividFeaturesHUAWEI* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->hdrVivid << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceHdrVividFeaturesHUAWEI");
    out << "\t\t" << "VkPhysicalDeviceHdrVividFeaturesHUAWEI " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCooperativeMatrixFlexibleDimensionsPropertiesNV(std::ostream &out, const VkCooperativeMatrixFlexibleDimensionsPropertiesNV* structInfo, Decoded_VkCooperativeMatrixFlexibleDimensionsPropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->MGranularity << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->NGranularity << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->KGranularity << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->AType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->BType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->CType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkComponentTypeKHR(" << structInfo->ResultType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->saturatingAccumulation << "," << std::endl;
    struct_body << "\t\t\t" << "VkScopeKHR(" << structInfo->scope << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->workgroupInvocations << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "cooperativeMatrixFlexibleDimensionsPropertiesNV");
    out << "\t\t" << "VkCooperativeMatrixFlexibleDimensionsPropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeMatrix2FeaturesNV(std::ostream &out, const VkPhysicalDeviceCooperativeMatrix2FeaturesNV* structInfo, Decoded_VkPhysicalDeviceCooperativeMatrix2FeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeMatrixWorkgroupScope << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeMatrixFlexibleDimensions << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeMatrixReductions << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeMatrixConversions << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeMatrixPerElementOperations << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeMatrixTensorAddressing << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeMatrixBlockLoads << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCooperativeMatrix2FeaturesNV");
    out << "\t\t" << "VkPhysicalDeviceCooperativeMatrix2FeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeMatrix2PropertiesNV(std::ostream &out, const VkPhysicalDeviceCooperativeMatrix2PropertiesNV* structInfo, Decoded_VkPhysicalDeviceCooperativeMatrix2PropertiesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeMatrixWorkgroupScopeMaxWorkgroupSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeMatrixFlexibleDimensionsMaxDimension << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cooperativeMatrixWorkgroupScopeReservedSharedMemory << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCooperativeMatrix2PropertiesNV");
    out << "\t\t" << "VkPhysicalDeviceCooperativeMatrix2PropertiesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM(std::ostream &out, const VkPhysicalDevicePipelineOpacityMicromapFeaturesARM* structInfo, Decoded_VkPhysicalDevicePipelineOpacityMicromapFeaturesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineOpacityMicromap << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineOpacityMicromapFeaturesARM");
    out << "\t\t" << "VkPhysicalDevicePipelineOpacityMicromapFeaturesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkImportMemoryMetalHandleInfoEXT(std::ostream &out, const VkImportMemoryMetalHandleInfoEXT* structInfo, Decoded_VkImportMemoryMetalHandleInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
    out << "\t\t" << "// TODO: Support handle (non-struct output) argument." << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "importMemoryMetalHandleInfoEXT");
    out << "\t\t" << "VkImportMemoryMetalHandleInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryGetMetalHandleInfoEXT(std::ostream &out, const VkMemoryGetMetalHandleInfoEXT* structInfo, Decoded_VkMemoryGetMetalHandleInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->memory) << "," << std::endl;
    struct_body << "\t\t\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryGetMetalHandleInfoEXT");
    out << "\t\t" << "VkMemoryGetMetalHandleInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkMemoryMetalHandlePropertiesEXT(std::ostream &out, const VkMemoryMetalHandlePropertiesEXT* structInfo, Decoded_VkMemoryMetalHandlePropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->memoryTypeBits << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "memoryMetalHandlePropertiesEXT");
    out << "\t\t" << "VkMemoryMetalHandlePropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceCounterARM(std::ostream &out, const VkPerformanceCounterARM* structInfo, Decoded_VkPerformanceCounterARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->counterID << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceCounterARM");
    out << "\t\t" << "VkPerformanceCounterARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPerformanceCounterDescriptionARM(std::ostream &out, const VkPerformanceCounterDescriptionARM* structInfo, Decoded_VkPerformanceCounterDescriptionARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPerformanceCounterDescriptionFlagsARM(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::ToEscape(structInfo->name) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "performanceCounterDescriptionARM");
    out << "\t\t" << "VkPerformanceCounterDescriptionARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePerformanceCountersByRegionFeaturesARM(std::ostream &out, const VkPhysicalDevicePerformanceCountersByRegionFeaturesARM* structInfo, Decoded_VkPhysicalDevicePerformanceCountersByRegionFeaturesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->performanceCountersByRegion << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePerformanceCountersByRegionFeaturesARM");
    out << "\t\t" << "VkPhysicalDevicePerformanceCountersByRegionFeaturesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePerformanceCountersByRegionPropertiesARM(std::ostream &out, const VkPhysicalDevicePerformanceCountersByRegionPropertiesARM* structInfo, Decoded_VkPhysicalDevicePerformanceCountersByRegionPropertiesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string performance_counter_region_size_info_var = GenerateStruct_VkExtent2D(out,
                                                                                     &structInfo->performanceCounterRegionSize,
                                                                                     metaInfo->performanceCounterRegionSize,
                                                                                     consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerRegionPerformanceCounters << "," << std::endl;
    struct_body << "\t\t\t" << performance_counter_region_size_info_var << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rowStrideAlignment << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->regionAlignment << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->identityTransformOrder << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePerformanceCountersByRegionPropertiesARM");
    out << "\t\t" << "VkPhysicalDevicePerformanceCountersByRegionPropertiesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRenderPassPerformanceCountersByRegionBeginInfoARM(std::ostream &out, const VkRenderPassPerformanceCountersByRegionBeginInfoARM* structInfo, Decoded_VkRenderPassPerformanceCountersByRegionBeginInfoARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->counterAddressCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pCounterAddresses << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->serializeRegions << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->counterIndexCount << "," << std::endl;
    std::string variable_name = consumer.AddStruct(struct_body, "renderPassPerformanceCountersByRegionBeginInfoARM");
    out << "\t\t" << "VkRenderPassPerformanceCountersByRegionBeginInfoARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT(std::ostream &out, const VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexAttributeRobustness << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceVertexAttributeRobustnessFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceVertexAttributeRobustnessFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFormatPackFeaturesARM(std::ostream &out, const VkPhysicalDeviceFormatPackFeaturesARM* structInfo, Decoded_VkPhysicalDeviceFormatPackFeaturesARM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->formatPack << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFormatPackFeaturesARM");
    out << "\t\t" << "VkPhysicalDeviceFormatPackFeaturesARM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE(std::ostream &out, const VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->fragmentDensityMapLayered << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentDensityMapLayeredFeaturesVALVE");
    out << "\t\t" << "VkPhysicalDeviceFragmentDensityMapLayeredFeaturesVALVE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE(std::ostream &out, const VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxFragmentDensityMapLayers << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceFragmentDensityMapLayeredPropertiesVALVE");
    out << "\t\t" << "VkPhysicalDeviceFragmentDensityMapLayeredPropertiesVALVE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE(std::ostream &out, const VkPipelineFragmentDensityMapLayeredCreateInfoVALVE* structInfo, Decoded_VkPipelineFragmentDensityMapLayeredCreateInfoVALVE* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxFragmentDensityMapLayers << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineFragmentDensityMapLayeredCreateInfoVALVE");
    out << "\t\t" << "VkPipelineFragmentDensityMapLayeredCreateInfoVALVE " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePresentMeteringFeaturesNV(std::ostream &out, const VkPhysicalDevicePresentMeteringFeaturesNV* structInfo, Decoded_VkPhysicalDevicePresentMeteringFeaturesNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentMetering << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePresentMeteringFeaturesNV");
    out << "\t\t" << "VkPhysicalDevicePresentMeteringFeaturesNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkSetPresentConfigNV(std::ostream &out, const VkSetPresentConfigNV* structInfo, Decoded_VkSetPresentConfigNV* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->numFramesPerBatch << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->presentConfigFeedback << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "setPresentConfigNV");
    out << "\t\t" << "VkSetPresentConfigNV " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT(std::ostream &out, const VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->zeroInitializeDeviceMemory << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceZeroInitializeDeviceMemoryFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceZeroInitializeDeviceMemoryFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShader64BitIndexingFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShader64BitIndexingFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShader64BitIndexingFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shader64BitIndexing << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShader64BitIndexingFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShader64BitIndexingFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkBeginCustomResolveInfoEXT(std::ostream &out, const VkBeginCustomResolveInfoEXT* structInfo, Decoded_VkBeginCustomResolveInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "beginCustomResolveInfoEXT");
    out << "\t\t" << "VkBeginCustomResolveInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCustomResolveCreateInfoEXT(std::ostream &out, const VkCustomResolveCreateInfoEXT* structInfo, Decoded_VkCustomResolveCreateInfoEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pcolor_attachment_formats_values;
    std::string pcolor_attachment_formats_array = "NULL";
    if (structInfo->pColorAttachmentFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            pcolor_attachment_formats_values += util::ToString<VkFormat>(structInfo->pColorAttachmentFormats[idx]) + ", ";
        }
        pcolor_attachment_formats_array = "pColorAttachmentFormats_" + std::to_string(consumer.GetNextId());
        out << "\t\t" << "VkFormat " << pcolor_attachment_formats_array << "[] = {" << pcolor_attachment_formats_values << "};" << std::endl;
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->customResolve << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->colorAttachmentCount << "," << std::endl;
    struct_body << "\t\t\t" << pcolor_attachment_formats_array << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->depthAttachmentFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->stencilAttachmentFormat << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "customResolveCreateInfoEXT");
    out << "\t\t" << "VkCustomResolveCreateInfoEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceCustomResolveFeaturesEXT(std::ostream &out, const VkPhysicalDeviceCustomResolveFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceCustomResolveFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->customResolve << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceCustomResolveFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceCustomResolveFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDataGraphPipelineBuiltinModelCreateInfoQCOM(std::ostream &out, const VkDataGraphPipelineBuiltinModelCreateInfoQCOM* structInfo, Decoded_VkDataGraphPipelineBuiltinModelCreateInfoQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string poperation_struct = "NULL";
    if (structInfo->pOperation != NULL) {
        poperation_struct = GenerateStruct_VkPhysicalDeviceDataGraphOperationSupportARM(out,
                                                                                        structInfo->pOperation,
                                                                                        metaInfo->pOperation->GetMetaStructPointer(),
                                                                                        consumer);
        poperation_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << poperation_struct << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "dataGraphPipelineBuiltinModelCreateInfoQCOM");
    out << "\t\t" << "VkDataGraphPipelineBuiltinModelCreateInfoQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceDataGraphModelFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceDataGraphModelFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceDataGraphModelFeaturesQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dataGraphModel << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceDataGraphModelFeaturesQCOM");
    out << "\t\t" << "VkPhysicalDeviceDataGraphModelFeaturesQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPipelineCacheHeaderVersionDataGraphQCOM(std::ostream &out, const VkPipelineCacheHeaderVersionDataGraphQCOM* structInfo, Decoded_VkPipelineCacheHeaderVersionDataGraphQCOM* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->headerSize << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineCacheHeaderVersion(" << structInfo->headerVersion << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkDataGraphModelCacheTypeQCOM(" << structInfo->cacheType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->cacheVersion << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->toolchainVersion[0]), VK_DATA_GRAPH_MODEL_TOOLCHAIN_VERSION_LENGTH_QCOM) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "pipelineCacheHeaderVersionDataGraphQCOM");
    out << "\t\t" << "VkPipelineCacheHeaderVersionDataGraphQCOM " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC(std::ostream &out, const VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC* structInfo, Decoded_VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pipelineCacheIncrementalMode << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDevicePipelineCacheIncrementalModeFeaturesSEC");
    out << "\t\t" << "VkPhysicalDevicePipelineCacheIncrementalModeFeaturesSEC " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderUniformBufferUnsizedArray << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceShaderUniformBufferUnsizedArrayFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureBuildGeometryInfoKHR(std::ostream &out, const VkAccelerationStructureBuildGeometryInfoKHR* structInfo, Decoded_VkAccelerationStructureBuildGeometryInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pgeometries_array = "NULL";
    if (structInfo->pGeometries != NULL) {
        pgeometries_array = "pGeometries_" + std::to_string(consumer.GetNextId());
        std::string pgeometries_names;
        for (uint32_t idx = 0; idx < structInfo->geometryCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pGeometries + idx != NULL) {
                variable_name = GenerateStruct_VkAccelerationStructureGeometryKHR(out,
                                                                                  structInfo->pGeometries + idx,
                                                                                  metaInfo->pGeometries->GetMetaStructPointer() + idx,
                                                                                  consumer);
            }
            pgeometries_names += variable_name + ", ";
        }
        out << "\t\t" << "VkAccelerationStructureGeometryKHR " << pgeometries_array << "[] = {" << pgeometries_names << "};" << std::endl;
    }
    std::string pp_geometries_array = "NULL";
    if (structInfo->ppGeometries != NULL) {
        pp_geometries_array = "ppGeometries_" + std::to_string(consumer.GetNextId());
        std::string pp_geometries_names;
        for (uint32_t idx0 = 0; idx0 < structInfo->geometryCount; ++idx0) {
            for (uint32_t idx1 = 0; idx1 < 1; ++idx1) {
                std::string variable_name = "NULL";
                variable_name = GenerateStruct_VkAccelerationStructureGeometryKHR(out,
                                                                                  &(structInfo->ppGeometries[idx0][idx1]),
                                                                                  &(metaInfo->ppGeometries->GetMetaStructPointer()[idx0][idx1]),
                                                                                  consumer);
                pp_geometries_names += variable_name + ", ";
            }
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccelerationStructureTypeKHR(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBuildAccelerationStructureFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << "VkBuildAccelerationStructureModeKHR(" << structInfo->mode << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->srcAccelerationStructure) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dstAccelerationStructure) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->geometryCount << "," << std::endl;
    struct_body << "\t\t\t" << pgeometries_array << "," << std::endl;
    struct_body << "\t\t\t" << pp_geometries_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->scratchData.deviceAddress << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureBuildGeometryInfoKHR");
    out << "\t\t" << "VkAccelerationStructureBuildGeometryInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureBuildRangeInfoKHR(std::ostream &out, const VkAccelerationStructureBuildRangeInfoKHR* structInfo, Decoded_VkAccelerationStructureBuildRangeInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->primitiveCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primitiveOffset << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->firstVertex << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->transformOffset << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureBuildRangeInfoKHR");
    out << "\t\t" << "VkAccelerationStructureBuildRangeInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureCreateInfoKHR(std::ostream &out, const VkAccelerationStructureCreateInfoKHR* structInfo, Decoded_VkAccelerationStructureCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccelerationStructureCreateFlagsKHR(" << structInfo->createFlags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->buffer) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->offset << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << "VkAccelerationStructureTypeKHR(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->deviceAddress << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureCreateInfoKHR");
    out << "\t\t" << "VkAccelerationStructureCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureDeviceAddressInfoKHR(std::ostream &out, const VkAccelerationStructureDeviceAddressInfoKHR* structInfo, Decoded_VkAccelerationStructureDeviceAddressInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->accelerationStructure) << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureDeviceAddressInfoKHR");
    out << "\t\t" << "VkAccelerationStructureDeviceAddressInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureGeometryAabbsDataKHR(std::ostream &out, const VkAccelerationStructureGeometryAabbsDataKHR* structInfo, Decoded_VkAccelerationStructureGeometryAabbsDataKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->data.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stride << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureGeometryAabbsDataKHR");
    out << "\t\t" << "VkAccelerationStructureGeometryAabbsDataKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureGeometryInstancesDataKHR(std::ostream &out, const VkAccelerationStructureGeometryInstancesDataKHR* structInfo, Decoded_VkAccelerationStructureGeometryInstancesDataKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->arrayOfPointers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->data.deviceAddress << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureGeometryInstancesDataKHR");
    out << "\t\t" << "VkAccelerationStructureGeometryInstancesDataKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureGeometryTrianglesDataKHR(std::ostream &out, const VkAccelerationStructureGeometryTrianglesDataKHR* structInfo, Decoded_VkAccelerationStructureGeometryTrianglesDataKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkFormat(" << structInfo->vertexFormat << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexData.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->vertexStride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxVertex << "," << std::endl;
    struct_body << "\t\t\t" << "VkIndexType(" << structInfo->indexType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->indexData.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->transformData.deviceAddress << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureGeometryTrianglesDataKHR");
    out << "\t\t" << "VkAccelerationStructureGeometryTrianglesDataKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkAccelerationStructureVersionInfoKHR(std::ostream &out, const VkAccelerationStructureVersionInfoKHR* structInfo, Decoded_VkAccelerationStructureVersionInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pversion_data_array = "NULL";
    std::string pversion_data_values;
    for (uint32_t idx0 = 0; idx0 < 2*VK_UUID_SIZE; ++idx0) {
        pversion_data_values += std::to_string(structInfo->pVersionData[idx0]) + ", ";
    }
    pversion_data_array = "pVersionData_" + std::to_string(consumer.GetNextId());
    out << "\t\t" << "uint8_t " << pversion_data_array << "[] = {" << pversion_data_values << "};" << std::endl;
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << pversion_data_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "accelerationStructureVersionInfoKHR");
    out << "\t\t" << "VkAccelerationStructureVersionInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyAccelerationStructureInfoKHR(std::ostream &out, const VkCopyAccelerationStructureInfoKHR* structInfo, Decoded_VkCopyAccelerationStructureInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->src) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dst) << "," << std::endl;
    struct_body << "\t\t\t" << "VkCopyAccelerationStructureModeKHR(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyAccelerationStructureInfoKHR");
    out << "\t\t" << "VkCopyAccelerationStructureInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyAccelerationStructureToMemoryInfoKHR(std::ostream &out, const VkCopyAccelerationStructureToMemoryInfoKHR* structInfo, Decoded_VkCopyAccelerationStructureToMemoryInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->src) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->dst.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << "VkCopyAccelerationStructureModeKHR(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyAccelerationStructureToMemoryInfoKHR");
    out << "\t\t" << "VkCopyAccelerationStructureToMemoryInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkCopyMemoryToAccelerationStructureInfoKHR(std::ostream &out, const VkCopyMemoryToAccelerationStructureInfoKHR* structInfo, Decoded_VkCopyMemoryToAccelerationStructureInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->src.deviceAddress << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->dst) << "," << std::endl;
    struct_body << "\t\t\t" << "VkCopyAccelerationStructureModeKHR(" << structInfo->mode << ")" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "copyMemoryToAccelerationStructureInfoKHR");
    out << "\t\t" << "VkCopyMemoryToAccelerationStructureInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceAccelerationStructureFeaturesKHR(std::ostream &out, const VkPhysicalDeviceAccelerationStructureFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceAccelerationStructureFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->accelerationStructure << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->accelerationStructureCaptureReplay << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->accelerationStructureIndirectBuild << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->accelerationStructureHostCommands << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->descriptorBindingAccelerationStructureUpdateAfterBind << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceAccelerationStructureFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceAccelerationStructureFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceAccelerationStructurePropertiesKHR(std::ostream &out, const VkPhysicalDeviceAccelerationStructurePropertiesKHR* structInfo, Decoded_VkPhysicalDeviceAccelerationStructurePropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxGeometryCount << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxInstanceCount << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPrimitiveCount << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorAccelerationStructures << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPerStageDescriptorUpdateAfterBindAccelerationStructures << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetAccelerationStructures << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxDescriptorSetUpdateAfterBindAccelerationStructures << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->minAccelerationStructureScratchOffsetAlignment << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceAccelerationStructurePropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceAccelerationStructurePropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkWriteDescriptorSetAccelerationStructureKHR(std::ostream &out, const VkWriteDescriptorSetAccelerationStructureKHR* structInfo, Decoded_VkWriteDescriptorSetAccelerationStructureKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pacceleration_structures_array = "NULL";
    if (metaInfo->pAccelerationStructures.GetPointer() != NULL && structInfo->accelerationStructureCount > 0) {
        pacceleration_structures_array = "pacceleration_structures_array_" + std::to_string(consumer.GetNextId(VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR));
        std::string pacceleration_structures_values = toStringJoin(metaInfo->pAccelerationStructures.GetPointer(),
                                                                   metaInfo->pAccelerationStructures.GetPointer() + structInfo->accelerationStructureCount,
                                                                   [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                                   ", ");
        if (structInfo->accelerationStructureCount == 1) {
            pacceleration_structures_array = "&" + pacceleration_structures_values;
        } else if (structInfo->accelerationStructureCount > 1) {
            out << "\t\t" << "VkAccelerationStructureKHR " << pacceleration_structures_array << "[] = {" << pacceleration_structures_values << "};" << std::endl;
        }
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->accelerationStructureCount << "," << std::endl;
    struct_body << "\t\t\t" << pacceleration_structures_array << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "writeDescriptorSetAccelerationStructureKHR");
    out << "\t\t" << "VkWriteDescriptorSetAccelerationStructureKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(std::ostream &out, const VkPhysicalDeviceRayTracingPipelineFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceRayTracingPipelineFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rayTracingPipeline << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rayTracingPipelineShaderGroupHandleCaptureReplay << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rayTracingPipelineShaderGroupHandleCaptureReplayMixed << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rayTracingPipelineTraceRaysIndirect << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rayTraversalPrimitiveCulling << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingPipelineFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceRayTracingPipelineFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(std::ostream &out, const VkPhysicalDeviceRayTracingPipelinePropertiesKHR* structInfo, Decoded_VkPhysicalDeviceRayTracingPipelinePropertiesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderGroupHandleSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxRayRecursionDepth << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxShaderGroupStride << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderGroupBaseAlignment << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderGroupHandleCaptureReplaySize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxRayDispatchInvocationCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->shaderGroupHandleAlignment << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxRayHitAttributeSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayTracingPipelinePropertiesKHR");
    out << "\t\t" << "VkPhysicalDeviceRayTracingPipelinePropertiesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRayTracingPipelineCreateInfoKHR(std::ostream &out, const VkRayTracingPipelineCreateInfoKHR* structInfo, Decoded_VkRayTracingPipelineCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    std::string pstages_array = "NULL";
    if (structInfo->pStages != NULL) {
        pstages_array = "pStages_" + std::to_string(consumer.GetNextId());
        std::string pstages_names;
        for (uint32_t idx = 0; idx < structInfo->stageCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pStages + idx != NULL) {
                variable_name = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                                               structInfo->pStages + idx,
                                                                               metaInfo->pStages->GetMetaStructPointer() + idx,
                                                                               consumer);
            }
            pstages_names += variable_name + ", ";
        }
        out << "\t\t" << "VkPipelineShaderStageCreateInfo " << pstages_array << "[] = {" << pstages_names << "};" << std::endl;
    }
    std::string pgroups_array = "NULL";
    if (structInfo->pGroups != NULL) {
        pgroups_array = "pGroups_" + std::to_string(consumer.GetNextId());
        std::string pgroups_names;
        for (uint32_t idx = 0; idx < structInfo->groupCount; idx++) {
            std::string variable_name = "NULL";
            if (structInfo->pGroups + idx != NULL) {
                variable_name = GenerateStruct_VkRayTracingShaderGroupCreateInfoKHR(out,
                                                                                    structInfo->pGroups + idx,
                                                                                    metaInfo->pGroups->GetMetaStructPointer() + idx,
                                                                                    consumer);
            }
            pgroups_names += variable_name + ", ";
        }
        out << "\t\t" << "VkRayTracingShaderGroupCreateInfoKHR " << pgroups_array << "[] = {" << pgroups_names << "};" << std::endl;
    }
    std::string plibrary_info_struct = "NULL";
    if (structInfo->pLibraryInfo != NULL) {
        plibrary_info_struct = GenerateStruct_VkPipelineLibraryCreateInfoKHR(out,
                                                                             structInfo->pLibraryInfo,
                                                                             metaInfo->pLibraryInfo->GetMetaStructPointer(),
                                                                             consumer);
        plibrary_info_struct.insert(0, "&");
    }
    std::string plibrary_interface_struct = "NULL";
    if (structInfo->pLibraryInterface != NULL) {
        plibrary_interface_struct = GenerateStruct_VkRayTracingPipelineInterfaceCreateInfoKHR(out,
                                                                                              structInfo->pLibraryInterface,
                                                                                              metaInfo->pLibraryInterface->GetMetaStructPointer(),
                                                                                              consumer);
        plibrary_interface_struct.insert(0, "&");
    }
    std::string pdynamic_state_struct = "NULL";
    if (structInfo->pDynamicState != NULL) {
        pdynamic_state_struct = GenerateStruct_VkPipelineDynamicStateCreateInfo(out,
                                                                                structInfo->pDynamicState,
                                                                                metaInfo->pDynamicState->GetMetaStructPointer(),
                                                                                consumer);
        pdynamic_state_struct.insert(0, "&");
    }
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkPipelineCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stageCount << "," << std::endl;
    struct_body << "\t\t\t" << pstages_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->groupCount << "," << std::endl;
    struct_body << "\t\t\t" << pgroups_array << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPipelineRayRecursionDepth << "," << std::endl;
    struct_body << "\t\t\t" << plibrary_info_struct << "," << std::endl;
    struct_body << "\t\t\t" << plibrary_interface_struct << "," << std::endl;
    struct_body << "\t\t\t" << pdynamic_state_struct << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->layout) << "," << std::endl;
    struct_body << "\t\t\t" << consumer.GetHandle(metaInfo->basePipelineHandle) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->basePipelineIndex << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "rayTracingPipelineCreateInfoKHR");
    out << "\t\t" << "VkRayTracingPipelineCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRayTracingPipelineInterfaceCreateInfoKHR(std::ostream &out, const VkRayTracingPipelineInterfaceCreateInfoKHR* structInfo, Decoded_VkRayTracingPipelineInterfaceCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPipelineRayPayloadSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPipelineRayHitAttributeSize << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "rayTracingPipelineInterfaceCreateInfoKHR");
    out << "\t\t" << "VkRayTracingPipelineInterfaceCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkRayTracingShaderGroupCreateInfoKHR(std::ostream &out, const VkRayTracingShaderGroupCreateInfoKHR* structInfo, Decoded_VkRayTracingShaderGroupCreateInfoKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << "VkRayTracingShaderGroupTypeKHR(" << structInfo->type << ")" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->generalShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->closestHitShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->anyHitShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->intersectionShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->pShaderGroupCaptureReplayHandle << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "rayTracingShaderGroupCreateInfoKHR");
    out << "\t\t" << "VkRayTracingShaderGroupCreateInfoKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkStridedDeviceAddressRegionKHR(std::ostream &out, const VkStridedDeviceAddressRegionKHR* structInfo, Decoded_VkStridedDeviceAddressRegionKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->deviceAddress << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->stride << "UL" << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->size << "UL" << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "stridedDeviceAddressRegionKHR");
    out << "\t\t" << "VkStridedDeviceAddressRegionKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkTraceRaysIndirectCommandKHR(std::ostream &out, const VkTraceRaysIndirectCommandKHR* structInfo, Decoded_VkTraceRaysIndirectCommandKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->width << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->height << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->depth << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "traceRaysIndirectCommandKHR");
    out << "\t\t" << "VkTraceRaysIndirectCommandKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceRayQueryFeaturesKHR(std::ostream &out, const VkPhysicalDeviceRayQueryFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceRayQueryFeaturesKHR* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->rayQuery << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceRayQueryFeaturesKHR");
    out << "\t\t" << "VkPhysicalDeviceRayQueryFeaturesKHR " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkDrawMeshTasksIndirectCommandEXT(std::ostream &out, const VkDrawMeshTasksIndirectCommandEXT* structInfo, Decoded_VkDrawMeshTasksIndirectCommandEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    struct_body << "\t" << structInfo->groupCountX << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->groupCountY << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->groupCountZ << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "drawMeshTasksIndirectCommandEXT");
    out << "\t\t" << "VkDrawMeshTasksIndirectCommandEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMeshShaderFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMeshShaderFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMeshShaderFeaturesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->taskShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->meshShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->multiviewMeshShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->primitiveFragmentShadingRateMeshShader << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->meshShaderQueries << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMeshShaderFeaturesEXT");
    out << "\t\t" << "VkPhysicalDeviceMeshShaderFeaturesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


std::string GenerateStruct_VkPhysicalDeviceMeshShaderPropertiesEXT(std::ostream &out, const VkPhysicalDeviceMeshShaderPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceMeshShaderPropertiesEXT* metaInfo, VulkanCppConsumerBase &consumer){
    std::stringstream struct_body;
    std::string pnext_name = GenerateExtension(out, structInfo->pNext, metaInfo->pNext, consumer);
    struct_body << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
    struct_body << "\t\t\t" << pnext_name << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTaskWorkGroupTotalCount << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxTaskWorkGroupCount[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTaskWorkGroupInvocations << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxTaskWorkGroupSize[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTaskPayloadSize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTaskSharedMemorySize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxTaskPayloadAndSharedMemorySize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshWorkGroupTotalCount << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxMeshWorkGroupCount[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshWorkGroupInvocations << "," << std::endl;
    struct_body << "\t\t\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxMeshWorkGroupSize[0]), 3) << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshSharedMemorySize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshPayloadAndSharedMemorySize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshOutputMemorySize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshPayloadAndOutputMemorySize << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshOutputComponents << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshOutputVertices << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshOutputPrimitives << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshOutputLayers << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxMeshMultiviewViewCount << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->meshOutputPerVertexGranularity << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->meshOutputPerPrimitiveGranularity << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPreferredTaskWorkGroupInvocations << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->maxPreferredMeshWorkGroupInvocations << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->prefersLocalInvocationVertexOutput << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->prefersLocalInvocationPrimitiveOutput << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->prefersCompactVertexOutput << "," << std::endl;
    struct_body << "\t\t\t" << structInfo->prefersCompactPrimitiveOutput << ",";
    std::string variable_name = consumer.AddStruct(struct_body, "physicalDeviceMeshShaderPropertiesEXT");
    out << "\t\t" << "VkPhysicalDeviceMeshShaderPropertiesEXT " << variable_name << " {" << std::endl;
    out << "\t\t" << struct_body.str() << std::endl;
    out << "\t\t" << "};" << std::endl;
    return variable_name;
}


GFXRECON_END_NAMESPACE(decode)
GFXRECON_END_NAMESPACE(gfxrecon)
