/*
** Copyright (c) 2021 Samsung
** Copyright (c) 2023 Google
** Copyright (c) 2023 LunarG, Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following conditions:
**
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
** FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
*/

/*
** This file is generated from the Khronos Vulkan XML API Registry.
**
*/

#include "decode/vulkan_cpp_structs.h"
#include "generated/generated_vulkan_cpp_structs.h"
#include "generated/generated_vulkan_cpp_consumer.h"
#include "generated/generated_vulkan_cpp_consumer_extension.h"
#include "generated/generated_vulkan_enum_to_string.h"
GFXRECON_BEGIN_NAMESPACE(gfxrecon)
GFXRECON_BEGIN_NAMESPACE(decode)

std::string GenerateStruct_StdVideoH264SpsVuiFlags(std::ostream &out, const StdVideoH264SpsVuiFlags* structInfo, Decoded_StdVideoH264SpsVuiFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* aspect_ratio_info_present_flag */
    structBody << "\t" << structInfo->aspect_ratio_info_present_flag << "," << std::endl;
/* overscan_info_present_flag */
    structBody << "\t" << structInfo->overscan_info_present_flag << "," << std::endl;
/* overscan_appropriate_flag */
    structBody << "\t" << structInfo->overscan_appropriate_flag << "," << std::endl;
/* video_signal_type_present_flag */
    structBody << "\t" << structInfo->video_signal_type_present_flag << "," << std::endl;
/* video_full_range_flag */
    structBody << "\t" << structInfo->video_full_range_flag << "," << std::endl;
/* color_description_present_flag */
    structBody << "\t" << structInfo->color_description_present_flag << "," << std::endl;
/* chroma_loc_info_present_flag */
    structBody << "\t" << structInfo->chroma_loc_info_present_flag << "," << std::endl;
/* timing_info_present_flag */
    structBody << "\t" << structInfo->timing_info_present_flag << "," << std::endl;
/* fixed_frame_rate_flag */
    structBody << "\t" << structInfo->fixed_frame_rate_flag << "," << std::endl;
/* bitstream_restriction_flag */
    structBody << "\t" << structInfo->bitstream_restriction_flag << "," << std::endl;
/* nal_hrd_parameters_present_flag */
    structBody << "\t" << structInfo->nal_hrd_parameters_present_flag << "," << std::endl;
/* vcl_hrd_parameters_present_flag */
    structBody << "\t" << structInfo->vcl_hrd_parameters_present_flag << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH264SpsVuiFlags");
    out << "StdVideoH264SpsVuiFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH264HrdParameters(std::ostream &out, const StdVideoH264HrdParameters* structInfo, Decoded_StdVideoH264HrdParameters* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* cpb_cnt_minus1 */
    structBody << "\t" << structInfo->cpb_cnt_minus1 << "," << std::endl;
/* bit_rate_scale */
    structBody << "\t" << structInfo->bit_rate_scale << "," << std::endl;
/* cpb_size_scale */
    structBody << "\t" << structInfo->cpb_size_scale << "," << std::endl;
/* reserved1 */
    structBody << "\t" << structInfo->reserved1 << "," << std::endl;
/* bit_rate_value_minus1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->bit_rate_value_minus1[0]), STD_VIDEO_H264_CPB_CNT_LIST_SIZE) << "," << std::endl;
/* cpb_size_value_minus1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->cpb_size_value_minus1[0]), STD_VIDEO_H264_CPB_CNT_LIST_SIZE) << "," << std::endl;
/* cbr_flag */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->cbr_flag[0]), STD_VIDEO_H264_CPB_CNT_LIST_SIZE) << "," << std::endl;
/* initial_cpb_removal_delay_length_minus1 */
    structBody << "\t" << structInfo->initial_cpb_removal_delay_length_minus1 << "," << std::endl;
/* cpb_removal_delay_length_minus1 */
    structBody << "\t" << structInfo->cpb_removal_delay_length_minus1 << "," << std::endl;
/* dpb_output_delay_length_minus1 */
    structBody << "\t" << structInfo->dpb_output_delay_length_minus1 << "," << std::endl;
/* time_offset_length */
    structBody << "\t" << structInfo->time_offset_length << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH264HrdParameters");
    out << "StdVideoH264HrdParameters " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH264SequenceParameterSetVui(std::ostream &out, const StdVideoH264SequenceParameterSetVui* structInfo, Decoded_StdVideoH264SequenceParameterSetVui* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoH264SpsVuiFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
    std::string pHrdParametersStruct = "NULL";
    if (structInfo->pHrdParameters != NULL) {
        pHrdParametersStruct = GenerateStruct_StdVideoH264HrdParameters(out,
                                                              structInfo->pHrdParameters,
                                                              metainfo->pHrdParameters->GetMetaStructPointer(),
                                                              consumer);
        pHrdParametersStruct.insert(0, "&");
    }
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* aspect_ratio_idc */
    structBody << "\t" << "StdVideoH264AspectRatioIdc(" << structInfo->aspect_ratio_idc << ")" << "," << std::endl;
/* sar_width */
    structBody << "\t" << structInfo->sar_width << "," << std::endl;
/* sar_height */
    structBody << "\t" << structInfo->sar_height << "," << std::endl;
/* video_format */
    structBody << "\t" << structInfo->video_format << "," << std::endl;
/* colour_primaries */
    structBody << "\t" << structInfo->colour_primaries << "," << std::endl;
/* transfer_characteristics */
    structBody << "\t" << structInfo->transfer_characteristics << "," << std::endl;
/* matrix_coefficients */
    structBody << "\t" << structInfo->matrix_coefficients << "," << std::endl;
/* num_units_in_tick */
    structBody << "\t" << structInfo->num_units_in_tick << "," << std::endl;
/* time_scale */
    structBody << "\t" << structInfo->time_scale << "," << std::endl;
/* max_num_reorder_frames */
    structBody << "\t" << structInfo->max_num_reorder_frames << "," << std::endl;
/* max_dec_frame_buffering */
    structBody << "\t" << structInfo->max_dec_frame_buffering << "," << std::endl;
/* chroma_sample_loc_type_top_field */
    structBody << "\t" << structInfo->chroma_sample_loc_type_top_field << "," << std::endl;
/* chroma_sample_loc_type_bottom_field */
    structBody << "\t" << structInfo->chroma_sample_loc_type_bottom_field << "," << std::endl;
/* reserved1 */
    structBody << "\t" << structInfo->reserved1 << "," << std::endl;
/* pHrdParameters */
    structBody << "\t" << pHrdParametersStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH264SequenceParameterSetVui");
    out << "StdVideoH264SequenceParameterSetVui " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH264SpsFlags(std::ostream &out, const StdVideoH264SpsFlags* structInfo, Decoded_StdVideoH264SpsFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* constraint_set0_flag */
    structBody << "\t" << structInfo->constraint_set0_flag << "," << std::endl;
/* constraint_set1_flag */
    structBody << "\t" << structInfo->constraint_set1_flag << "," << std::endl;
/* constraint_set2_flag */
    structBody << "\t" << structInfo->constraint_set2_flag << "," << std::endl;
/* constraint_set3_flag */
    structBody << "\t" << structInfo->constraint_set3_flag << "," << std::endl;
/* constraint_set4_flag */
    structBody << "\t" << structInfo->constraint_set4_flag << "," << std::endl;
/* constraint_set5_flag */
    structBody << "\t" << structInfo->constraint_set5_flag << "," << std::endl;
/* direct_8x8_inference_flag */
    structBody << "\t" << structInfo->direct_8x8_inference_flag << "," << std::endl;
/* mb_adaptive_frame_field_flag */
    structBody << "\t" << structInfo->mb_adaptive_frame_field_flag << "," << std::endl;
/* frame_mbs_only_flag */
    structBody << "\t" << structInfo->frame_mbs_only_flag << "," << std::endl;
/* delta_pic_order_always_zero_flag */
    structBody << "\t" << structInfo->delta_pic_order_always_zero_flag << "," << std::endl;
/* separate_colour_plane_flag */
    structBody << "\t" << structInfo->separate_colour_plane_flag << "," << std::endl;
/* gaps_in_frame_num_value_allowed_flag */
    structBody << "\t" << structInfo->gaps_in_frame_num_value_allowed_flag << "," << std::endl;
/* qpprime_y_zero_transform_bypass_flag */
    structBody << "\t" << structInfo->qpprime_y_zero_transform_bypass_flag << "," << std::endl;
/* frame_cropping_flag */
    structBody << "\t" << structInfo->frame_cropping_flag << "," << std::endl;
/* seq_scaling_matrix_present_flag */
    structBody << "\t" << structInfo->seq_scaling_matrix_present_flag << "," << std::endl;
/* vui_parameters_present_flag */
    structBody << "\t" << structInfo->vui_parameters_present_flag << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH264SpsFlags");
    out << "StdVideoH264SpsFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH264ScalingLists(std::ostream &out, const StdVideoH264ScalingLists* structInfo, Decoded_StdVideoH264ScalingLists* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* scaling_list_present_mask */
    structBody << "\t" << structInfo->scaling_list_present_mask << "," << std::endl;
/* use_default_scaling_matrix_mask */
    structBody << "\t" << structInfo->use_default_scaling_matrix_mask << "," << std::endl;
/* ScalingList4x4 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingList4x4[0][0]), STD_VIDEO_H264_SCALING_LIST_4X4_NUM_LISTS) << "," << std::endl;
/* ScalingList8x8 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingList8x8[0][0]), STD_VIDEO_H264_SCALING_LIST_8X8_NUM_LISTS) << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH264ScalingLists");
    out << "StdVideoH264ScalingLists " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH264SequenceParameterSet(std::ostream &out, const StdVideoH264SequenceParameterSet* structInfo, Decoded_StdVideoH264SequenceParameterSet* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoH264SpsFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
    std::string pOffsetForRefFrameArray = "NULL";
    if (structInfo->pOffsetForRefFrame != NULL) {
        pOffsetForRefFrameArray = "pOffsetForRefFrame_" + std::to_string(consumer.getNextId());
        out << "int32_t " << pOffsetForRefFrameArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pOffsetForRefFrame, structInfo->num_ref_frames_in_pic_order_cnt_cycle) << ";" << std::endl;
    }
    std::string pScalingListsStruct = "NULL";
    if (structInfo->pScalingLists != NULL) {
        pScalingListsStruct = GenerateStruct_StdVideoH264ScalingLists(out,
                                                             structInfo->pScalingLists,
                                                             metainfo->pScalingLists->GetMetaStructPointer(),
                                                             consumer);
        pScalingListsStruct.insert(0, "&");
    }
    std::string pSequenceParameterSetVuiStruct = "NULL";
    if (structInfo->pSequenceParameterSetVui != NULL) {
        pSequenceParameterSetVuiStruct = GenerateStruct_StdVideoH264SequenceParameterSetVui(out,
                                                                        structInfo->pSequenceParameterSetVui,
                                                                        metainfo->pSequenceParameterSetVui->GetMetaStructPointer(),
                                                                        consumer);
        pSequenceParameterSetVuiStruct.insert(0, "&");
    }
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* profile_idc */
    structBody << "\t" << "StdVideoH264ProfileIdc(" << structInfo->profile_idc << ")" << "," << std::endl;
/* level_idc */
    structBody << "\t" << "StdVideoH264LevelIdc(" << structInfo->level_idc << ")" << "," << std::endl;
/* chroma_format_idc */
    structBody << "\t" << "StdVideoH264ChromaFormatIdc(" << structInfo->chroma_format_idc << ")" << "," << std::endl;
/* seq_parameter_set_id */
    structBody << "\t" << structInfo->seq_parameter_set_id << "," << std::endl;
/* bit_depth_luma_minus8 */
    structBody << "\t" << structInfo->bit_depth_luma_minus8 << "," << std::endl;
/* bit_depth_chroma_minus8 */
    structBody << "\t" << structInfo->bit_depth_chroma_minus8 << "," << std::endl;
/* log2_max_frame_num_minus4 */
    structBody << "\t" << structInfo->log2_max_frame_num_minus4 << "," << std::endl;
/* pic_order_cnt_type */
    structBody << "\t" << "StdVideoH264PocType(" << structInfo->pic_order_cnt_type << ")" << "," << std::endl;
/* offset_for_non_ref_pic */
    structBody << "\t" << structInfo->offset_for_non_ref_pic << "," << std::endl;
/* offset_for_top_to_bottom_field */
    structBody << "\t" << structInfo->offset_for_top_to_bottom_field << "," << std::endl;
/* log2_max_pic_order_cnt_lsb_minus4 */
    structBody << "\t" << structInfo->log2_max_pic_order_cnt_lsb_minus4 << "," << std::endl;
/* num_ref_frames_in_pic_order_cnt_cycle */
    structBody << "\t" << structInfo->num_ref_frames_in_pic_order_cnt_cycle << "," << std::endl;
/* max_num_ref_frames */
    structBody << "\t" << structInfo->max_num_ref_frames << "," << std::endl;
/* reserved1 */
    structBody << "\t" << structInfo->reserved1 << "," << std::endl;
/* pic_width_in_mbs_minus1 */
    structBody << "\t" << structInfo->pic_width_in_mbs_minus1 << "," << std::endl;
/* pic_height_in_map_units_minus1 */
    structBody << "\t" << structInfo->pic_height_in_map_units_minus1 << "," << std::endl;
/* frame_crop_left_offset */
    structBody << "\t" << structInfo->frame_crop_left_offset << "," << std::endl;
/* frame_crop_right_offset */
    structBody << "\t" << structInfo->frame_crop_right_offset << "," << std::endl;
/* frame_crop_top_offset */
    structBody << "\t" << structInfo->frame_crop_top_offset << "," << std::endl;
/* frame_crop_bottom_offset */
    structBody << "\t" << structInfo->frame_crop_bottom_offset << "," << std::endl;
/* reserved2 */
    structBody << "\t" << structInfo->reserved2 << "," << std::endl;
/* pOffsetForRefFrame */
    structBody << "\t" << pOffsetForRefFrameArray << "," << std::endl;
/* pScalingLists */
    structBody << "\t" << pScalingListsStruct << "," << std::endl;
/* pSequenceParameterSetVui */
    structBody << "\t" << pSequenceParameterSetVuiStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH264SequenceParameterSet");
    out << "StdVideoH264SequenceParameterSet " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH264PpsFlags(std::ostream &out, const StdVideoH264PpsFlags* structInfo, Decoded_StdVideoH264PpsFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* transform_8x8_mode_flag */
    structBody << "\t" << structInfo->transform_8x8_mode_flag << "," << std::endl;
/* redundant_pic_cnt_present_flag */
    structBody << "\t" << structInfo->redundant_pic_cnt_present_flag << "," << std::endl;
/* constrained_intra_pred_flag */
    structBody << "\t" << structInfo->constrained_intra_pred_flag << "," << std::endl;
/* deblocking_filter_control_present_flag */
    structBody << "\t" << structInfo->deblocking_filter_control_present_flag << "," << std::endl;
/* weighted_pred_flag */
    structBody << "\t" << structInfo->weighted_pred_flag << "," << std::endl;
/* bottom_field_pic_order_in_frame_present_flag */
    structBody << "\t" << structInfo->bottom_field_pic_order_in_frame_present_flag << "," << std::endl;
/* entropy_coding_mode_flag */
    structBody << "\t" << structInfo->entropy_coding_mode_flag << "," << std::endl;
/* pic_scaling_matrix_present_flag */
    structBody << "\t" << structInfo->pic_scaling_matrix_present_flag << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH264PpsFlags");
    out << "StdVideoH264PpsFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH264PictureParameterSet(std::ostream &out, const StdVideoH264PictureParameterSet* structInfo, Decoded_StdVideoH264PictureParameterSet* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoH264PpsFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
    std::string pScalingListsStruct = "NULL";
    if (structInfo->pScalingLists != NULL) {
        pScalingListsStruct = GenerateStruct_StdVideoH264ScalingLists(out,
                                                             structInfo->pScalingLists,
                                                             metainfo->pScalingLists->GetMetaStructPointer(),
                                                             consumer);
        pScalingListsStruct.insert(0, "&");
    }
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* seq_parameter_set_id */
    structBody << "\t" << structInfo->seq_parameter_set_id << "," << std::endl;
/* pic_parameter_set_id */
    structBody << "\t" << structInfo->pic_parameter_set_id << "," << std::endl;
/* num_ref_idx_l0_default_active_minus1 */
    structBody << "\t" << structInfo->num_ref_idx_l0_default_active_minus1 << "," << std::endl;
/* num_ref_idx_l1_default_active_minus1 */
    structBody << "\t" << structInfo->num_ref_idx_l1_default_active_minus1 << "," << std::endl;
/* weighted_bipred_idc */
    structBody << "\t" << "StdVideoH264WeightedBipredIdc(" << structInfo->weighted_bipred_idc << ")" << "," << std::endl;
/* pic_init_qp_minus26 */
    structBody << "\t" << structInfo->pic_init_qp_minus26 << "," << std::endl;
/* pic_init_qs_minus26 */
    structBody << "\t" << structInfo->pic_init_qs_minus26 << "," << std::endl;
/* chroma_qp_index_offset */
    structBody << "\t" << structInfo->chroma_qp_index_offset << "," << std::endl;
/* second_chroma_qp_index_offset */
    structBody << "\t" << structInfo->second_chroma_qp_index_offset << "," << std::endl;
/* pScalingLists */
    structBody << "\t" << pScalingListsStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH264PictureParameterSet");
    out << "StdVideoH264PictureParameterSet " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoDecodeH264PictureInfoFlags(std::ostream &out, const StdVideoDecodeH264PictureInfoFlags* structInfo, Decoded_StdVideoDecodeH264PictureInfoFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* field_pic_flag */
    structBody << "\t" << structInfo->field_pic_flag << "," << std::endl;
/* is_intra */
    structBody << "\t" << structInfo->is_intra << "," << std::endl;
/* IdrPicFlag */
    structBody << "\t" << structInfo->IdrPicFlag << "," << std::endl;
/* bottom_field_flag */
    structBody << "\t" << structInfo->bottom_field_flag << "," << std::endl;
/* is_reference */
    structBody << "\t" << structInfo->is_reference << "," << std::endl;
/* complementary_field_pair */
    structBody << "\t" << structInfo->complementary_field_pair << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoDecodeH264PictureInfoFlags");
    out << "StdVideoDecodeH264PictureInfoFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoDecodeH264PictureInfo(std::ostream &out, const StdVideoDecodeH264PictureInfo* structInfo, Decoded_StdVideoDecodeH264PictureInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoDecodeH264PictureInfoFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* seq_parameter_set_id */
    structBody << "\t" << structInfo->seq_parameter_set_id << "," << std::endl;
/* pic_parameter_set_id */
    structBody << "\t" << structInfo->pic_parameter_set_id << "," << std::endl;
/* reserved1 */
    structBody << "\t" << structInfo->reserved1 << "," << std::endl;
/* reserved2 */
    structBody << "\t" << structInfo->reserved2 << "," << std::endl;
/* frame_num */
    structBody << "\t" << structInfo->frame_num << "," << std::endl;
/* idr_pic_id */
    structBody << "\t" << structInfo->idr_pic_id << "," << std::endl;
/* PicOrderCnt */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int32_t*>(&structInfo->PicOrderCnt[0]), STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE) << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoDecodeH264PictureInfo");
    out << "StdVideoDecodeH264PictureInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoDecodeH264ReferenceInfoFlags(std::ostream &out, const StdVideoDecodeH264ReferenceInfoFlags* structInfo, Decoded_StdVideoDecodeH264ReferenceInfoFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* top_field_flag */
    structBody << "\t" << structInfo->top_field_flag << "," << std::endl;
/* bottom_field_flag */
    structBody << "\t" << structInfo->bottom_field_flag << "," << std::endl;
/* used_for_long_term_reference */
    structBody << "\t" << structInfo->used_for_long_term_reference << "," << std::endl;
/* is_non_existing */
    structBody << "\t" << structInfo->is_non_existing << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoDecodeH264ReferenceInfoFlags");
    out << "StdVideoDecodeH264ReferenceInfoFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoDecodeH264ReferenceInfo(std::ostream &out, const StdVideoDecodeH264ReferenceInfo* structInfo, Decoded_StdVideoDecodeH264ReferenceInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoDecodeH264ReferenceInfoFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* FrameNum */
    structBody << "\t" << structInfo->FrameNum << "," << std::endl;
/* reserved */
    structBody << "\t" << structInfo->reserved << "," << std::endl;
/* PicOrderCnt */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int32_t*>(&structInfo->PicOrderCnt[0]), STD_VIDEO_DECODE_H264_FIELD_ORDER_COUNT_LIST_SIZE) << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoDecodeH264ReferenceInfo");
    out << "StdVideoDecodeH264ReferenceInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH264WeightTableFlags(std::ostream &out, const StdVideoEncodeH264WeightTableFlags* structInfo, Decoded_StdVideoEncodeH264WeightTableFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* luma_weight_l0_flag */
    structBody << "\t" << structInfo->luma_weight_l0_flag << "," << std::endl;
/* chroma_weight_l0_flag */
    structBody << "\t" << structInfo->chroma_weight_l0_flag << "," << std::endl;
/* luma_weight_l1_flag */
    structBody << "\t" << structInfo->luma_weight_l1_flag << "," << std::endl;
/* chroma_weight_l1_flag */
    structBody << "\t" << structInfo->chroma_weight_l1_flag << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH264WeightTableFlags");
    out << "StdVideoEncodeH264WeightTableFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH264WeightTable(std::ostream &out, const StdVideoEncodeH264WeightTable* structInfo, Decoded_StdVideoEncodeH264WeightTable* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoEncodeH264WeightTableFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* luma_log2_weight_denom */
    structBody << "\t" << structInfo->luma_log2_weight_denom << "," << std::endl;
/* chroma_log2_weight_denom */
    structBody << "\t" << structInfo->chroma_log2_weight_denom << "," << std::endl;
/* luma_weight_l0 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_weight_l0[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
/* luma_offset_l0 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_offset_l0[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
/* chroma_weight_l0 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->chroma_weight_l0[0][0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
/* chroma_offset_l0 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->chroma_offset_l0[0][0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
/* luma_weight_l1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_weight_l1[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
/* luma_offset_l1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_offset_l1[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
/* chroma_weight_l1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->chroma_weight_l1[0][0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
/* chroma_offset_l1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->chroma_offset_l1[0][0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH264WeightTable");
    out << "StdVideoEncodeH264WeightTable " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH264SliceHeaderFlags(std::ostream &out, const StdVideoEncodeH264SliceHeaderFlags* structInfo, Decoded_StdVideoEncodeH264SliceHeaderFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* direct_spatial_mv_pred_flag */
    structBody << "\t" << structInfo->direct_spatial_mv_pred_flag << "," << std::endl;
/* num_ref_idx_active_override_flag */
    structBody << "\t" << structInfo->num_ref_idx_active_override_flag << "," << std::endl;
/* reserved */
    structBody << "\t" << structInfo->reserved << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH264SliceHeaderFlags");
    out << "StdVideoEncodeH264SliceHeaderFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH264PictureInfoFlags(std::ostream &out, const StdVideoEncodeH264PictureInfoFlags* structInfo, Decoded_StdVideoEncodeH264PictureInfoFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* IdrPicFlag */
    structBody << "\t" << structInfo->IdrPicFlag << "," << std::endl;
/* is_reference */
    structBody << "\t" << structInfo->is_reference << "," << std::endl;
/* no_output_of_prior_pics_flag */
    structBody << "\t" << structInfo->no_output_of_prior_pics_flag << "," << std::endl;
/* long_term_reference_flag */
    structBody << "\t" << structInfo->long_term_reference_flag << "," << std::endl;
/* adaptive_ref_pic_marking_mode_flag */
    structBody << "\t" << structInfo->adaptive_ref_pic_marking_mode_flag << "," << std::endl;
/* reserved */
    structBody << "\t" << structInfo->reserved << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH264PictureInfoFlags");
    out << "StdVideoEncodeH264PictureInfoFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH264ReferenceInfoFlags(std::ostream &out, const StdVideoEncodeH264ReferenceInfoFlags* structInfo, Decoded_StdVideoEncodeH264ReferenceInfoFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* used_for_long_term_reference */
    structBody << "\t" << structInfo->used_for_long_term_reference << "," << std::endl;
/* reserved */
    structBody << "\t" << structInfo->reserved << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH264ReferenceInfoFlags");
    out << "StdVideoEncodeH264ReferenceInfoFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH264ReferenceListsInfoFlags(std::ostream &out, const StdVideoEncodeH264ReferenceListsInfoFlags* structInfo, Decoded_StdVideoEncodeH264ReferenceListsInfoFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* ref_pic_list_modification_flag_l0 */
    structBody << "\t" << structInfo->ref_pic_list_modification_flag_l0 << "," << std::endl;
/* ref_pic_list_modification_flag_l1 */
    structBody << "\t" << structInfo->ref_pic_list_modification_flag_l1 << "," << std::endl;
/* reserved */
    structBody << "\t" << structInfo->reserved << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH264ReferenceListsInfoFlags");
    out << "StdVideoEncodeH264ReferenceListsInfoFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH264RefListModEntry(std::ostream &out, const StdVideoEncodeH264RefListModEntry* structInfo, Decoded_StdVideoEncodeH264RefListModEntry* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* modification_of_pic_nums_idc */
    structBody << "\t" << "StdVideoH264ModificationOfPicNumsIdc(" << structInfo->modification_of_pic_nums_idc << ")" << "," << std::endl;
/* abs_diff_pic_num_minus1 */
    structBody << "\t" << structInfo->abs_diff_pic_num_minus1 << "," << std::endl;
/* long_term_pic_num */
    structBody << "\t" << structInfo->long_term_pic_num << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH264RefListModEntry");
    out << "StdVideoEncodeH264RefListModEntry " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH264RefPicMarkingEntry(std::ostream &out, const StdVideoEncodeH264RefPicMarkingEntry* structInfo, Decoded_StdVideoEncodeH264RefPicMarkingEntry* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* memory_management_control_operation */
    structBody << "\t" << "StdVideoH264MemMgmtControlOp(" << structInfo->memory_management_control_operation << ")" << "," << std::endl;
/* difference_of_pic_nums_minus1 */
    structBody << "\t" << structInfo->difference_of_pic_nums_minus1 << "," << std::endl;
/* long_term_pic_num */
    structBody << "\t" << structInfo->long_term_pic_num << "," << std::endl;
/* long_term_frame_idx */
    structBody << "\t" << structInfo->long_term_frame_idx << "," << std::endl;
/* max_long_term_frame_idx_plus1 */
    structBody << "\t" << structInfo->max_long_term_frame_idx_plus1 << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH264RefPicMarkingEntry");
    out << "StdVideoEncodeH264RefPicMarkingEntry " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH264ReferenceListsInfo(std::ostream &out, const StdVideoEncodeH264ReferenceListsInfo* structInfo, Decoded_StdVideoEncodeH264ReferenceListsInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoEncodeH264ReferenceListsInfoFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
    std::string pRefList0ModOperationsStruct = "NULL";
    if (structInfo->pRefList0ModOperations != NULL) {
        pRefList0ModOperationsStruct = GenerateStruct_StdVideoEncodeH264RefListModEntry(out,
                                                                      structInfo->pRefList0ModOperations,
                                                                      metainfo->pRefList0ModOperations->GetMetaStructPointer(),
                                                                      consumer);
        pRefList0ModOperationsStruct.insert(0, "&");
    }
    std::string pRefList1ModOperationsStruct = "NULL";
    if (structInfo->pRefList1ModOperations != NULL) {
        pRefList1ModOperationsStruct = GenerateStruct_StdVideoEncodeH264RefListModEntry(out,
                                                                      structInfo->pRefList1ModOperations,
                                                                      metainfo->pRefList1ModOperations->GetMetaStructPointer(),
                                                                      consumer);
        pRefList1ModOperationsStruct.insert(0, "&");
    }
    std::string pRefPicMarkingOperationsStruct = "NULL";
    if (structInfo->pRefPicMarkingOperations != NULL) {
        pRefPicMarkingOperationsStruct = GenerateStruct_StdVideoEncodeH264RefPicMarkingEntry(out,
                                                                        structInfo->pRefPicMarkingOperations,
                                                                        metainfo->pRefPicMarkingOperations->GetMetaStructPointer(),
                                                                        consumer);
        pRefPicMarkingOperationsStruct.insert(0, "&");
    }
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* num_ref_idx_l0_active_minus1 */
    structBody << "\t" << structInfo->num_ref_idx_l0_active_minus1 << "," << std::endl;
/* num_ref_idx_l1_active_minus1 */
    structBody << "\t" << structInfo->num_ref_idx_l1_active_minus1 << "," << std::endl;
/* RefPicList0 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicList0[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
/* RefPicList1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicList1[0]), STD_VIDEO_H264_MAX_NUM_LIST_REF) << "," << std::endl;
/* refList0ModOpCount */
    structBody << "\t" << structInfo->refList0ModOpCount << "," << std::endl;
/* refList1ModOpCount */
    structBody << "\t" << structInfo->refList1ModOpCount << "," << std::endl;
/* refPicMarkingOpCount */
    structBody << "\t" << structInfo->refPicMarkingOpCount << "," << std::endl;
/* reserved1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->reserved1[0]), 7) << "," << std::endl;
/* pRefList0ModOperations */
    structBody << "\t" << pRefList0ModOperationsStruct << "," << std::endl;
/* pRefList1ModOperations */
    structBody << "\t" << pRefList1ModOperationsStruct << "," << std::endl;
/* pRefPicMarkingOperations */
    structBody << "\t" << pRefPicMarkingOperationsStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH264ReferenceListsInfo");
    out << "StdVideoEncodeH264ReferenceListsInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH264PictureInfo(std::ostream &out, const StdVideoEncodeH264PictureInfo* structInfo, Decoded_StdVideoEncodeH264PictureInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoEncodeH264PictureInfoFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
    std::string pRefListsStruct = "NULL";
    if (structInfo->pRefLists != NULL) {
        pRefListsStruct = GenerateStruct_StdVideoEncodeH264ReferenceListsInfo(out,
                                                         structInfo->pRefLists,
                                                         metainfo->pRefLists->GetMetaStructPointer(),
                                                         consumer);
        pRefListsStruct.insert(0, "&");
    }
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* seq_parameter_set_id */
    structBody << "\t" << structInfo->seq_parameter_set_id << "," << std::endl;
/* pic_parameter_set_id */
    structBody << "\t" << structInfo->pic_parameter_set_id << "," << std::endl;
/* idr_pic_id */
    structBody << "\t" << structInfo->idr_pic_id << "," << std::endl;
/* primary_pic_type */
    structBody << "\t" << "StdVideoH264PictureType(" << structInfo->primary_pic_type << ")" << "," << std::endl;
/* frame_num */
    structBody << "\t" << structInfo->frame_num << "," << std::endl;
/* PicOrderCnt */
    structBody << "\t" << structInfo->PicOrderCnt << "," << std::endl;
/* temporal_id */
    structBody << "\t" << structInfo->temporal_id << "," << std::endl;
/* reserved1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->reserved1[0]), 3) << "," << std::endl;
/* pRefLists */
    structBody << "\t" << pRefListsStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH264PictureInfo");
    out << "StdVideoEncodeH264PictureInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH264ReferenceInfo(std::ostream &out, const StdVideoEncodeH264ReferenceInfo* structInfo, Decoded_StdVideoEncodeH264ReferenceInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoEncodeH264ReferenceInfoFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* primary_pic_type */
    structBody << "\t" << "StdVideoH264PictureType(" << structInfo->primary_pic_type << ")" << "," << std::endl;
/* FrameNum */
    structBody << "\t" << structInfo->FrameNum << "," << std::endl;
/* PicOrderCnt */
    structBody << "\t" << structInfo->PicOrderCnt << "," << std::endl;
/* long_term_pic_num */
    structBody << "\t" << structInfo->long_term_pic_num << "," << std::endl;
/* long_term_frame_idx */
    structBody << "\t" << structInfo->long_term_frame_idx << "," << std::endl;
/* temporal_id */
    structBody << "\t" << structInfo->temporal_id << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH264ReferenceInfo");
    out << "StdVideoEncodeH264ReferenceInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH264SliceHeader(std::ostream &out, const StdVideoEncodeH264SliceHeader* structInfo, Decoded_StdVideoEncodeH264SliceHeader* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoEncodeH264SliceHeaderFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
    std::string pWeightTableStruct = "NULL";
    if (structInfo->pWeightTable != NULL) {
        pWeightTableStruct = GenerateStruct_StdVideoEncodeH264WeightTable(out,
                                                            structInfo->pWeightTable,
                                                            metainfo->pWeightTable->GetMetaStructPointer(),
                                                            consumer);
        pWeightTableStruct.insert(0, "&");
    }
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* first_mb_in_slice */
    structBody << "\t" << structInfo->first_mb_in_slice << "," << std::endl;
/* slice_type */
    structBody << "\t" << "StdVideoH264SliceType(" << structInfo->slice_type << ")" << "," << std::endl;
/* slice_alpha_c0_offset_div2 */
    structBody << "\t" << structInfo->slice_alpha_c0_offset_div2 << "," << std::endl;
/* slice_beta_offset_div2 */
    structBody << "\t" << structInfo->slice_beta_offset_div2 << "," << std::endl;
/* slice_qp_delta */
    structBody << "\t" << structInfo->slice_qp_delta << "," << std::endl;
/* reserved1 */
    structBody << "\t" << structInfo->reserved1 << "," << std::endl;
/* cabac_init_idc */
    structBody << "\t" << "StdVideoH264CabacInitIdc(" << structInfo->cabac_init_idc << ")" << "," << std::endl;
/* disable_deblocking_filter_idc */
    structBody << "\t" << "StdVideoH264DisableDeblockingFilterIdc(" << structInfo->disable_deblocking_filter_idc << ")" << "," << std::endl;
/* pWeightTable */
    structBody << "\t" << pWeightTableStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH264SliceHeader");
    out << "StdVideoEncodeH264SliceHeader " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265ProfileTierLevelFlags(std::ostream &out, const StdVideoH265ProfileTierLevelFlags* structInfo, Decoded_StdVideoH265ProfileTierLevelFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* general_tier_flag */
    structBody << "\t" << structInfo->general_tier_flag << "," << std::endl;
/* general_progressive_source_flag */
    structBody << "\t" << structInfo->general_progressive_source_flag << "," << std::endl;
/* general_interlaced_source_flag */
    structBody << "\t" << structInfo->general_interlaced_source_flag << "," << std::endl;
/* general_non_packed_constraint_flag */
    structBody << "\t" << structInfo->general_non_packed_constraint_flag << "," << std::endl;
/* general_frame_only_constraint_flag */
    structBody << "\t" << structInfo->general_frame_only_constraint_flag << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265ProfileTierLevelFlags");
    out << "StdVideoH265ProfileTierLevelFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265ProfileTierLevel(std::ostream &out, const StdVideoH265ProfileTierLevel* structInfo, Decoded_StdVideoH265ProfileTierLevel* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoH265ProfileTierLevelFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* general_profile_idc */
    structBody << "\t" << "StdVideoH265ProfileIdc(" << structInfo->general_profile_idc << ")" << "," << std::endl;
/* general_level_idc */
    structBody << "\t" << "StdVideoH265LevelIdc(" << structInfo->general_level_idc << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265ProfileTierLevel");
    out << "StdVideoH265ProfileTierLevel " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265DecPicBufMgr(std::ostream &out, const StdVideoH265DecPicBufMgr* structInfo, Decoded_StdVideoH265DecPicBufMgr* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* max_latency_increase_plus1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->max_latency_increase_plus1[0]), STD_VIDEO_H265_SUBLAYERS_LIST_SIZE) << "," << std::endl;
/* max_dec_pic_buffering_minus1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->max_dec_pic_buffering_minus1[0]), STD_VIDEO_H265_SUBLAYERS_LIST_SIZE) << "," << std::endl;
/* max_num_reorder_pics */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->max_num_reorder_pics[0]), STD_VIDEO_H265_SUBLAYERS_LIST_SIZE) << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265DecPicBufMgr");
    out << "StdVideoH265DecPicBufMgr " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265SubLayerHrdParameters(std::ostream &out, const StdVideoH265SubLayerHrdParameters* structInfo, Decoded_StdVideoH265SubLayerHrdParameters* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* bit_rate_value_minus1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->bit_rate_value_minus1[0]), STD_VIDEO_H265_CPB_CNT_LIST_SIZE) << "," << std::endl;
/* cpb_size_value_minus1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->cpb_size_value_minus1[0]), STD_VIDEO_H265_CPB_CNT_LIST_SIZE) << "," << std::endl;
/* cpb_size_du_value_minus1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->cpb_size_du_value_minus1[0]), STD_VIDEO_H265_CPB_CNT_LIST_SIZE) << "," << std::endl;
/* bit_rate_du_value_minus1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->bit_rate_du_value_minus1[0]), STD_VIDEO_H265_CPB_CNT_LIST_SIZE) << "," << std::endl;
/* cbr_flag */
    structBody << "\t" << structInfo->cbr_flag << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265SubLayerHrdParameters");
    out << "StdVideoH265SubLayerHrdParameters " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265HrdFlags(std::ostream &out, const StdVideoH265HrdFlags* structInfo, Decoded_StdVideoH265HrdFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* nal_hrd_parameters_present_flag */
    structBody << "\t" << structInfo->nal_hrd_parameters_present_flag << "," << std::endl;
/* vcl_hrd_parameters_present_flag */
    structBody << "\t" << structInfo->vcl_hrd_parameters_present_flag << "," << std::endl;
/* sub_pic_hrd_params_present_flag */
    structBody << "\t" << structInfo->sub_pic_hrd_params_present_flag << "," << std::endl;
/* sub_pic_cpb_params_in_pic_timing_sei_flag */
    structBody << "\t" << structInfo->sub_pic_cpb_params_in_pic_timing_sei_flag << "," << std::endl;
/* fixed_pic_rate_general_flag */
    structBody << "\t" << structInfo->fixed_pic_rate_general_flag << "," << std::endl;
/* fixed_pic_rate_within_cvs_flag */
    structBody << "\t" << structInfo->fixed_pic_rate_within_cvs_flag << "," << std::endl;
/* low_delay_hrd_flag */
    structBody << "\t" << structInfo->low_delay_hrd_flag << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265HrdFlags");
    out << "StdVideoH265HrdFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265HrdParameters(std::ostream &out, const StdVideoH265HrdParameters* structInfo, Decoded_StdVideoH265HrdParameters* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoH265HrdFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
    std::string pSubLayerHrdParametersNalStruct = "NULL";
    if (structInfo->pSubLayerHrdParametersNal != NULL) {
        pSubLayerHrdParametersNalStruct = GenerateStruct_StdVideoH265SubLayerHrdParameters(out,
                                                                         structInfo->pSubLayerHrdParametersNal,
                                                                         metainfo->pSubLayerHrdParametersNal->GetMetaStructPointer(),
                                                                         consumer);
        pSubLayerHrdParametersNalStruct.insert(0, "&");
    }
    std::string pSubLayerHrdParametersVclStruct = "NULL";
    if (structInfo->pSubLayerHrdParametersVcl != NULL) {
        pSubLayerHrdParametersVclStruct = GenerateStruct_StdVideoH265SubLayerHrdParameters(out,
                                                                         structInfo->pSubLayerHrdParametersVcl,
                                                                         metainfo->pSubLayerHrdParametersVcl->GetMetaStructPointer(),
                                                                         consumer);
        pSubLayerHrdParametersVclStruct.insert(0, "&");
    }
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* tick_divisor_minus2 */
    structBody << "\t" << structInfo->tick_divisor_minus2 << "," << std::endl;
/* du_cpb_removal_delay_increment_length_minus1 */
    structBody << "\t" << structInfo->du_cpb_removal_delay_increment_length_minus1 << "," << std::endl;
/* dpb_output_delay_du_length_minus1 */
    structBody << "\t" << structInfo->dpb_output_delay_du_length_minus1 << "," << std::endl;
/* bit_rate_scale */
    structBody << "\t" << structInfo->bit_rate_scale << "," << std::endl;
/* cpb_size_scale */
    structBody << "\t" << structInfo->cpb_size_scale << "," << std::endl;
/* cpb_size_du_scale */
    structBody << "\t" << structInfo->cpb_size_du_scale << "," << std::endl;
/* initial_cpb_removal_delay_length_minus1 */
    structBody << "\t" << structInfo->initial_cpb_removal_delay_length_minus1 << "," << std::endl;
/* au_cpb_removal_delay_length_minus1 */
    structBody << "\t" << structInfo->au_cpb_removal_delay_length_minus1 << "," << std::endl;
/* dpb_output_delay_length_minus1 */
    structBody << "\t" << structInfo->dpb_output_delay_length_minus1 << "," << std::endl;
/* cpb_cnt_minus1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->cpb_cnt_minus1[0]), STD_VIDEO_H265_SUBLAYERS_LIST_SIZE) << "," << std::endl;
/* elemental_duration_in_tc_minus1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->elemental_duration_in_tc_minus1[0]), STD_VIDEO_H265_SUBLAYERS_LIST_SIZE) << "," << std::endl;
/* reserved */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->reserved[0]), 3) << "," << std::endl;
/* pSubLayerHrdParametersNal */
    structBody << "\t" << pSubLayerHrdParametersNalStruct << "," << std::endl;
/* pSubLayerHrdParametersVcl */
    structBody << "\t" << pSubLayerHrdParametersVclStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265HrdParameters");
    out << "StdVideoH265HrdParameters " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265VpsFlags(std::ostream &out, const StdVideoH265VpsFlags* structInfo, Decoded_StdVideoH265VpsFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* vps_temporal_id_nesting_flag */
    structBody << "\t" << structInfo->vps_temporal_id_nesting_flag << "," << std::endl;
/* vps_sub_layer_ordering_info_present_flag */
    structBody << "\t" << structInfo->vps_sub_layer_ordering_info_present_flag << "," << std::endl;
/* vps_timing_info_present_flag */
    structBody << "\t" << structInfo->vps_timing_info_present_flag << "," << std::endl;
/* vps_poc_proportional_to_timing_flag */
    structBody << "\t" << structInfo->vps_poc_proportional_to_timing_flag << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265VpsFlags");
    out << "StdVideoH265VpsFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265VideoParameterSet(std::ostream &out, const StdVideoH265VideoParameterSet* structInfo, Decoded_StdVideoH265VideoParameterSet* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoH265VpsFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
    std::string pDecPicBufMgrStruct = "NULL";
    if (structInfo->pDecPicBufMgr != NULL) {
        pDecPicBufMgrStruct = GenerateStruct_StdVideoH265DecPicBufMgr(out,
                                                             structInfo->pDecPicBufMgr,
                                                             metainfo->pDecPicBufMgr->GetMetaStructPointer(),
                                                             consumer);
        pDecPicBufMgrStruct.insert(0, "&");
    }
    std::string pHrdParametersStruct = "NULL";
    if (structInfo->pHrdParameters != NULL) {
        pHrdParametersStruct = GenerateStruct_StdVideoH265HrdParameters(out,
                                                              structInfo->pHrdParameters,
                                                              metainfo->pHrdParameters->GetMetaStructPointer(),
                                                              consumer);
        pHrdParametersStruct.insert(0, "&");
    }
    std::string pProfileTierLevelStruct = "NULL";
    if (structInfo->pProfileTierLevel != NULL) {
        pProfileTierLevelStruct = GenerateStruct_StdVideoH265ProfileTierLevel(out,
                                                                 structInfo->pProfileTierLevel,
                                                                 metainfo->pProfileTierLevel->GetMetaStructPointer(),
                                                                 consumer);
        pProfileTierLevelStruct.insert(0, "&");
    }
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* vps_video_parameter_set_id */
    structBody << "\t" << structInfo->vps_video_parameter_set_id << "," << std::endl;
/* vps_max_sub_layers_minus1 */
    structBody << "\t" << structInfo->vps_max_sub_layers_minus1 << "," << std::endl;
/* reserved1 */
    structBody << "\t" << structInfo->reserved1 << "," << std::endl;
/* reserved2 */
    structBody << "\t" << structInfo->reserved2 << "," << std::endl;
/* vps_num_units_in_tick */
    structBody << "\t" << structInfo->vps_num_units_in_tick << "," << std::endl;
/* vps_time_scale */
    structBody << "\t" << structInfo->vps_time_scale << "," << std::endl;
/* vps_num_ticks_poc_diff_one_minus1 */
    structBody << "\t" << structInfo->vps_num_ticks_poc_diff_one_minus1 << "," << std::endl;
/* reserved3 */
    structBody << "\t" << structInfo->reserved3 << "," << std::endl;
/* pDecPicBufMgr */
    structBody << "\t" << pDecPicBufMgrStruct << "," << std::endl;
/* pHrdParameters */
    structBody << "\t" << pHrdParametersStruct << "," << std::endl;
/* pProfileTierLevel */
    structBody << "\t" << pProfileTierLevelStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265VideoParameterSet");
    out << "StdVideoH265VideoParameterSet " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265ScalingLists(std::ostream &out, const StdVideoH265ScalingLists* structInfo, Decoded_StdVideoH265ScalingLists* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* ScalingList4x4 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingList4x4[0][0]), STD_VIDEO_H265_SCALING_LIST_4X4_NUM_LISTS) << "," << std::endl;
/* ScalingList8x8 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingList8x8[0][0]), STD_VIDEO_H265_SCALING_LIST_8X8_NUM_LISTS) << "," << std::endl;
/* ScalingList16x16 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingList16x16[0][0]), STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS) << "," << std::endl;
/* ScalingList32x32 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingList32x32[0][0]), STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS) << "," << std::endl;
/* ScalingListDCCoef16x16 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingListDCCoef16x16[0]), STD_VIDEO_H265_SCALING_LIST_16X16_NUM_LISTS) << "," << std::endl;
/* ScalingListDCCoef32x32 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->ScalingListDCCoef32x32[0]), STD_VIDEO_H265_SCALING_LIST_32X32_NUM_LISTS) << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265ScalingLists");
    out << "StdVideoH265ScalingLists " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265ShortTermRefPicSetFlags(std::ostream &out, const StdVideoH265ShortTermRefPicSetFlags* structInfo, Decoded_StdVideoH265ShortTermRefPicSetFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* inter_ref_pic_set_prediction_flag */
    structBody << "\t" << structInfo->inter_ref_pic_set_prediction_flag << "," << std::endl;
/* delta_rps_sign */
    structBody << "\t" << structInfo->delta_rps_sign << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265ShortTermRefPicSetFlags");
    out << "StdVideoH265ShortTermRefPicSetFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265ShortTermRefPicSet(std::ostream &out, const StdVideoH265ShortTermRefPicSet* structInfo, Decoded_StdVideoH265ShortTermRefPicSet* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoH265ShortTermRefPicSetFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* delta_idx_minus1 */
    structBody << "\t" << structInfo->delta_idx_minus1 << "," << std::endl;
/* use_delta_flag */
    structBody << "\t" << structInfo->use_delta_flag << "," << std::endl;
/* abs_delta_rps_minus1 */
    structBody << "\t" << structInfo->abs_delta_rps_minus1 << "," << std::endl;
/* used_by_curr_pic_flag */
    structBody << "\t" << structInfo->used_by_curr_pic_flag << "," << std::endl;
/* used_by_curr_pic_s0_flag */
    structBody << "\t" << structInfo->used_by_curr_pic_s0_flag << "," << std::endl;
/* used_by_curr_pic_s1_flag */
    structBody << "\t" << structInfo->used_by_curr_pic_s1_flag << "," << std::endl;
/* reserved1 */
    structBody << "\t" << structInfo->reserved1 << "," << std::endl;
/* reserved2 */
    structBody << "\t" << structInfo->reserved2 << "," << std::endl;
/* reserved3 */
    structBody << "\t" << structInfo->reserved3 << "," << std::endl;
/* num_negative_pics */
    structBody << "\t" << structInfo->num_negative_pics << "," << std::endl;
/* num_positive_pics */
    structBody << "\t" << structInfo->num_positive_pics << "," << std::endl;
/* delta_poc_s0_minus1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->delta_poc_s0_minus1[0]), STD_VIDEO_H265_MAX_DPB_SIZE) << "," << std::endl;
/* delta_poc_s1_minus1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->delta_poc_s1_minus1[0]), STD_VIDEO_H265_MAX_DPB_SIZE) << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265ShortTermRefPicSet");
    out << "StdVideoH265ShortTermRefPicSet " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265LongTermRefPicsSps(std::ostream &out, const StdVideoH265LongTermRefPicsSps* structInfo, Decoded_StdVideoH265LongTermRefPicsSps* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* used_by_curr_pic_lt_sps_flag */
    structBody << "\t" << structInfo->used_by_curr_pic_lt_sps_flag << "," << std::endl;
/* lt_ref_pic_poc_lsb_sps */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->lt_ref_pic_poc_lsb_sps[0]), STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS) << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265LongTermRefPicsSps");
    out << "StdVideoH265LongTermRefPicsSps " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265SpsVuiFlags(std::ostream &out, const StdVideoH265SpsVuiFlags* structInfo, Decoded_StdVideoH265SpsVuiFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* aspect_ratio_info_present_flag */
    structBody << "\t" << structInfo->aspect_ratio_info_present_flag << "," << std::endl;
/* overscan_info_present_flag */
    structBody << "\t" << structInfo->overscan_info_present_flag << "," << std::endl;
/* overscan_appropriate_flag */
    structBody << "\t" << structInfo->overscan_appropriate_flag << "," << std::endl;
/* video_signal_type_present_flag */
    structBody << "\t" << structInfo->video_signal_type_present_flag << "," << std::endl;
/* video_full_range_flag */
    structBody << "\t" << structInfo->video_full_range_flag << "," << std::endl;
/* colour_description_present_flag */
    structBody << "\t" << structInfo->colour_description_present_flag << "," << std::endl;
/* chroma_loc_info_present_flag */
    structBody << "\t" << structInfo->chroma_loc_info_present_flag << "," << std::endl;
/* neutral_chroma_indication_flag */
    structBody << "\t" << structInfo->neutral_chroma_indication_flag << "," << std::endl;
/* field_seq_flag */
    structBody << "\t" << structInfo->field_seq_flag << "," << std::endl;
/* frame_field_info_present_flag */
    structBody << "\t" << structInfo->frame_field_info_present_flag << "," << std::endl;
/* default_display_window_flag */
    structBody << "\t" << structInfo->default_display_window_flag << "," << std::endl;
/* vui_timing_info_present_flag */
    structBody << "\t" << structInfo->vui_timing_info_present_flag << "," << std::endl;
/* vui_poc_proportional_to_timing_flag */
    structBody << "\t" << structInfo->vui_poc_proportional_to_timing_flag << "," << std::endl;
/* vui_hrd_parameters_present_flag */
    structBody << "\t" << structInfo->vui_hrd_parameters_present_flag << "," << std::endl;
/* bitstream_restriction_flag */
    structBody << "\t" << structInfo->bitstream_restriction_flag << "," << std::endl;
/* tiles_fixed_structure_flag */
    structBody << "\t" << structInfo->tiles_fixed_structure_flag << "," << std::endl;
/* motion_vectors_over_pic_boundaries_flag */
    structBody << "\t" << structInfo->motion_vectors_over_pic_boundaries_flag << "," << std::endl;
/* restricted_ref_pic_lists_flag */
    structBody << "\t" << structInfo->restricted_ref_pic_lists_flag << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265SpsVuiFlags");
    out << "StdVideoH265SpsVuiFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265SequenceParameterSetVui(std::ostream &out, const StdVideoH265SequenceParameterSetVui* structInfo, Decoded_StdVideoH265SequenceParameterSetVui* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoH265SpsVuiFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
    std::string pHrdParametersStruct = "NULL";
    if (structInfo->pHrdParameters != NULL) {
        pHrdParametersStruct = GenerateStruct_StdVideoH265HrdParameters(out,
                                                              structInfo->pHrdParameters,
                                                              metainfo->pHrdParameters->GetMetaStructPointer(),
                                                              consumer);
        pHrdParametersStruct.insert(0, "&");
    }
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* aspect_ratio_idc */
    structBody << "\t" << "StdVideoH265AspectRatioIdc(" << structInfo->aspect_ratio_idc << ")" << "," << std::endl;
/* sar_width */
    structBody << "\t" << structInfo->sar_width << "," << std::endl;
/* sar_height */
    structBody << "\t" << structInfo->sar_height << "," << std::endl;
/* video_format */
    structBody << "\t" << structInfo->video_format << "," << std::endl;
/* colour_primaries */
    structBody << "\t" << structInfo->colour_primaries << "," << std::endl;
/* transfer_characteristics */
    structBody << "\t" << structInfo->transfer_characteristics << "," << std::endl;
/* matrix_coeffs */
    structBody << "\t" << structInfo->matrix_coeffs << "," << std::endl;
/* chroma_sample_loc_type_top_field */
    structBody << "\t" << structInfo->chroma_sample_loc_type_top_field << "," << std::endl;
/* chroma_sample_loc_type_bottom_field */
    structBody << "\t" << structInfo->chroma_sample_loc_type_bottom_field << "," << std::endl;
/* reserved1 */
    structBody << "\t" << structInfo->reserved1 << "," << std::endl;
/* reserved2 */
    structBody << "\t" << structInfo->reserved2 << "," << std::endl;
/* def_disp_win_left_offset */
    structBody << "\t" << structInfo->def_disp_win_left_offset << "," << std::endl;
/* def_disp_win_right_offset */
    structBody << "\t" << structInfo->def_disp_win_right_offset << "," << std::endl;
/* def_disp_win_top_offset */
    structBody << "\t" << structInfo->def_disp_win_top_offset << "," << std::endl;
/* def_disp_win_bottom_offset */
    structBody << "\t" << structInfo->def_disp_win_bottom_offset << "," << std::endl;
/* vui_num_units_in_tick */
    structBody << "\t" << structInfo->vui_num_units_in_tick << "," << std::endl;
/* vui_time_scale */
    structBody << "\t" << structInfo->vui_time_scale << "," << std::endl;
/* vui_num_ticks_poc_diff_one_minus1 */
    structBody << "\t" << structInfo->vui_num_ticks_poc_diff_one_minus1 << "," << std::endl;
/* min_spatial_segmentation_idc */
    structBody << "\t" << structInfo->min_spatial_segmentation_idc << "," << std::endl;
/* reserved3 */
    structBody << "\t" << structInfo->reserved3 << "," << std::endl;
/* max_bytes_per_pic_denom */
    structBody << "\t" << structInfo->max_bytes_per_pic_denom << "," << std::endl;
/* max_bits_per_min_cu_denom */
    structBody << "\t" << structInfo->max_bits_per_min_cu_denom << "," << std::endl;
/* log2_max_mv_length_horizontal */
    structBody << "\t" << structInfo->log2_max_mv_length_horizontal << "," << std::endl;
/* log2_max_mv_length_vertical */
    structBody << "\t" << structInfo->log2_max_mv_length_vertical << "," << std::endl;
/* pHrdParameters */
    structBody << "\t" << pHrdParametersStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265SequenceParameterSetVui");
    out << "StdVideoH265SequenceParameterSetVui " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265PredictorPaletteEntries(std::ostream &out, const StdVideoH265PredictorPaletteEntries* structInfo, Decoded_StdVideoH265PredictorPaletteEntries* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* PredictorPaletteEntries */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->PredictorPaletteEntries[0][0]), STD_VIDEO_H265_PREDICTOR_PALETTE_COMPONENTS_LIST_SIZE) << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265PredictorPaletteEntries");
    out << "StdVideoH265PredictorPaletteEntries " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265SpsFlags(std::ostream &out, const StdVideoH265SpsFlags* structInfo, Decoded_StdVideoH265SpsFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* sps_temporal_id_nesting_flag */
    structBody << "\t" << structInfo->sps_temporal_id_nesting_flag << "," << std::endl;
/* separate_colour_plane_flag */
    structBody << "\t" << structInfo->separate_colour_plane_flag << "," << std::endl;
/* conformance_window_flag */
    structBody << "\t" << structInfo->conformance_window_flag << "," << std::endl;
/* sps_sub_layer_ordering_info_present_flag */
    structBody << "\t" << structInfo->sps_sub_layer_ordering_info_present_flag << "," << std::endl;
/* scaling_list_enabled_flag */
    structBody << "\t" << structInfo->scaling_list_enabled_flag << "," << std::endl;
/* sps_scaling_list_data_present_flag */
    structBody << "\t" << structInfo->sps_scaling_list_data_present_flag << "," << std::endl;
/* amp_enabled_flag */
    structBody << "\t" << structInfo->amp_enabled_flag << "," << std::endl;
/* sample_adaptive_offset_enabled_flag */
    structBody << "\t" << structInfo->sample_adaptive_offset_enabled_flag << "," << std::endl;
/* pcm_enabled_flag */
    structBody << "\t" << structInfo->pcm_enabled_flag << "," << std::endl;
/* pcm_loop_filter_disabled_flag */
    structBody << "\t" << structInfo->pcm_loop_filter_disabled_flag << "," << std::endl;
/* long_term_ref_pics_present_flag */
    structBody << "\t" << structInfo->long_term_ref_pics_present_flag << "," << std::endl;
/* sps_temporal_mvp_enabled_flag */
    structBody << "\t" << structInfo->sps_temporal_mvp_enabled_flag << "," << std::endl;
/* strong_intra_smoothing_enabled_flag */
    structBody << "\t" << structInfo->strong_intra_smoothing_enabled_flag << "," << std::endl;
/* vui_parameters_present_flag */
    structBody << "\t" << structInfo->vui_parameters_present_flag << "," << std::endl;
/* sps_extension_present_flag */
    structBody << "\t" << structInfo->sps_extension_present_flag << "," << std::endl;
/* sps_range_extension_flag */
    structBody << "\t" << structInfo->sps_range_extension_flag << "," << std::endl;
/* transform_skip_rotation_enabled_flag */
    structBody << "\t" << structInfo->transform_skip_rotation_enabled_flag << "," << std::endl;
/* transform_skip_context_enabled_flag */
    structBody << "\t" << structInfo->transform_skip_context_enabled_flag << "," << std::endl;
/* implicit_rdpcm_enabled_flag */
    structBody << "\t" << structInfo->implicit_rdpcm_enabled_flag << "," << std::endl;
/* explicit_rdpcm_enabled_flag */
    structBody << "\t" << structInfo->explicit_rdpcm_enabled_flag << "," << std::endl;
/* extended_precision_processing_flag */
    structBody << "\t" << structInfo->extended_precision_processing_flag << "," << std::endl;
/* intra_smoothing_disabled_flag */
    structBody << "\t" << structInfo->intra_smoothing_disabled_flag << "," << std::endl;
/* high_precision_offsets_enabled_flag */
    structBody << "\t" << structInfo->high_precision_offsets_enabled_flag << "," << std::endl;
/* persistent_rice_adaptation_enabled_flag */
    structBody << "\t" << structInfo->persistent_rice_adaptation_enabled_flag << "," << std::endl;
/* cabac_bypass_alignment_enabled_flag */
    structBody << "\t" << structInfo->cabac_bypass_alignment_enabled_flag << "," << std::endl;
/* sps_scc_extension_flag */
    structBody << "\t" << structInfo->sps_scc_extension_flag << "," << std::endl;
/* sps_curr_pic_ref_enabled_flag */
    structBody << "\t" << structInfo->sps_curr_pic_ref_enabled_flag << "," << std::endl;
/* palette_mode_enabled_flag */
    structBody << "\t" << structInfo->palette_mode_enabled_flag << "," << std::endl;
/* sps_palette_predictor_initializers_present_flag */
    structBody << "\t" << structInfo->sps_palette_predictor_initializers_present_flag << "," << std::endl;
/* intra_boundary_filtering_disabled_flag */
    structBody << "\t" << structInfo->intra_boundary_filtering_disabled_flag << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265SpsFlags");
    out << "StdVideoH265SpsFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265SequenceParameterSet(std::ostream &out, const StdVideoH265SequenceParameterSet* structInfo, Decoded_StdVideoH265SequenceParameterSet* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoH265SpsFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
    std::string pProfileTierLevelStruct = "NULL";
    if (structInfo->pProfileTierLevel != NULL) {
        pProfileTierLevelStruct = GenerateStruct_StdVideoH265ProfileTierLevel(out,
                                                                 structInfo->pProfileTierLevel,
                                                                 metainfo->pProfileTierLevel->GetMetaStructPointer(),
                                                                 consumer);
        pProfileTierLevelStruct.insert(0, "&");
    }
    std::string pDecPicBufMgrStruct = "NULL";
    if (structInfo->pDecPicBufMgr != NULL) {
        pDecPicBufMgrStruct = GenerateStruct_StdVideoH265DecPicBufMgr(out,
                                                             structInfo->pDecPicBufMgr,
                                                             metainfo->pDecPicBufMgr->GetMetaStructPointer(),
                                                             consumer);
        pDecPicBufMgrStruct.insert(0, "&");
    }
    std::string pScalingListsStruct = "NULL";
    if (structInfo->pScalingLists != NULL) {
        pScalingListsStruct = GenerateStruct_StdVideoH265ScalingLists(out,
                                                             structInfo->pScalingLists,
                                                             metainfo->pScalingLists->GetMetaStructPointer(),
                                                             consumer);
        pScalingListsStruct.insert(0, "&");
    }
    std::string pShortTermRefPicSetStruct = "NULL";
    if (structInfo->pShortTermRefPicSet != NULL) {
        pShortTermRefPicSetStruct = GenerateStruct_StdVideoH265ShortTermRefPicSet(out,
                                                                   structInfo->pShortTermRefPicSet,
                                                                   metainfo->pShortTermRefPicSet->GetMetaStructPointer(),
                                                                   consumer);
        pShortTermRefPicSetStruct.insert(0, "&");
    }
    std::string pLongTermRefPicsSpsStruct = "NULL";
    if (structInfo->pLongTermRefPicsSps != NULL) {
        pLongTermRefPicsSpsStruct = GenerateStruct_StdVideoH265LongTermRefPicsSps(out,
                                                                   structInfo->pLongTermRefPicsSps,
                                                                   metainfo->pLongTermRefPicsSps->GetMetaStructPointer(),
                                                                   consumer);
        pLongTermRefPicsSpsStruct.insert(0, "&");
    }
    std::string pSequenceParameterSetVuiStruct = "NULL";
    if (structInfo->pSequenceParameterSetVui != NULL) {
        pSequenceParameterSetVuiStruct = GenerateStruct_StdVideoH265SequenceParameterSetVui(out,
                                                                        structInfo->pSequenceParameterSetVui,
                                                                        metainfo->pSequenceParameterSetVui->GetMetaStructPointer(),
                                                                        consumer);
        pSequenceParameterSetVuiStruct.insert(0, "&");
    }
    std::string pPredictorPaletteEntriesStruct = "NULL";
    if (structInfo->pPredictorPaletteEntries != NULL) {
        pPredictorPaletteEntriesStruct = GenerateStruct_StdVideoH265PredictorPaletteEntries(out,
                                                                        structInfo->pPredictorPaletteEntries,
                                                                        metainfo->pPredictorPaletteEntries->GetMetaStructPointer(),
                                                                        consumer);
        pPredictorPaletteEntriesStruct.insert(0, "&");
    }
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* chroma_format_idc */
    structBody << "\t" << "StdVideoH265ChromaFormatIdc(" << structInfo->chroma_format_idc << ")" << "," << std::endl;
/* pic_width_in_luma_samples */
    structBody << "\t" << structInfo->pic_width_in_luma_samples << "," << std::endl;
/* pic_height_in_luma_samples */
    structBody << "\t" << structInfo->pic_height_in_luma_samples << "," << std::endl;
/* sps_video_parameter_set_id */
    structBody << "\t" << structInfo->sps_video_parameter_set_id << "," << std::endl;
/* sps_max_sub_layers_minus1 */
    structBody << "\t" << structInfo->sps_max_sub_layers_minus1 << "," << std::endl;
/* sps_seq_parameter_set_id */
    structBody << "\t" << structInfo->sps_seq_parameter_set_id << "," << std::endl;
/* bit_depth_luma_minus8 */
    structBody << "\t" << structInfo->bit_depth_luma_minus8 << "," << std::endl;
/* bit_depth_chroma_minus8 */
    structBody << "\t" << structInfo->bit_depth_chroma_minus8 << "," << std::endl;
/* log2_max_pic_order_cnt_lsb_minus4 */
    structBody << "\t" << structInfo->log2_max_pic_order_cnt_lsb_minus4 << "," << std::endl;
/* log2_min_luma_coding_block_size_minus3 */
    structBody << "\t" << structInfo->log2_min_luma_coding_block_size_minus3 << "," << std::endl;
/* log2_diff_max_min_luma_coding_block_size */
    structBody << "\t" << structInfo->log2_diff_max_min_luma_coding_block_size << "," << std::endl;
/* log2_min_luma_transform_block_size_minus2 */
    structBody << "\t" << structInfo->log2_min_luma_transform_block_size_minus2 << "," << std::endl;
/* log2_diff_max_min_luma_transform_block_size */
    structBody << "\t" << structInfo->log2_diff_max_min_luma_transform_block_size << "," << std::endl;
/* max_transform_hierarchy_depth_inter */
    structBody << "\t" << structInfo->max_transform_hierarchy_depth_inter << "," << std::endl;
/* max_transform_hierarchy_depth_intra */
    structBody << "\t" << structInfo->max_transform_hierarchy_depth_intra << "," << std::endl;
/* num_short_term_ref_pic_sets */
    structBody << "\t" << structInfo->num_short_term_ref_pic_sets << "," << std::endl;
/* num_long_term_ref_pics_sps */
    structBody << "\t" << structInfo->num_long_term_ref_pics_sps << "," << std::endl;
/* pcm_sample_bit_depth_luma_minus1 */
    structBody << "\t" << structInfo->pcm_sample_bit_depth_luma_minus1 << "," << std::endl;
/* pcm_sample_bit_depth_chroma_minus1 */
    structBody << "\t" << structInfo->pcm_sample_bit_depth_chroma_minus1 << "," << std::endl;
/* log2_min_pcm_luma_coding_block_size_minus3 */
    structBody << "\t" << structInfo->log2_min_pcm_luma_coding_block_size_minus3 << "," << std::endl;
/* log2_diff_max_min_pcm_luma_coding_block_size */
    structBody << "\t" << structInfo->log2_diff_max_min_pcm_luma_coding_block_size << "," << std::endl;
/* reserved1 */
    structBody << "\t" << structInfo->reserved1 << "," << std::endl;
/* reserved2 */
    structBody << "\t" << structInfo->reserved2 << "," << std::endl;
/* palette_max_size */
    structBody << "\t" << structInfo->palette_max_size << "," << std::endl;
/* delta_palette_max_predictor_size */
    structBody << "\t" << structInfo->delta_palette_max_predictor_size << "," << std::endl;
/* motion_vector_resolution_control_idc */
    structBody << "\t" << structInfo->motion_vector_resolution_control_idc << "," << std::endl;
/* sps_num_palette_predictor_initializers_minus1 */
    structBody << "\t" << structInfo->sps_num_palette_predictor_initializers_minus1 << "," << std::endl;
/* conf_win_left_offset */
    structBody << "\t" << structInfo->conf_win_left_offset << "," << std::endl;
/* conf_win_right_offset */
    structBody << "\t" << structInfo->conf_win_right_offset << "," << std::endl;
/* conf_win_top_offset */
    structBody << "\t" << structInfo->conf_win_top_offset << "," << std::endl;
/* conf_win_bottom_offset */
    structBody << "\t" << structInfo->conf_win_bottom_offset << "," << std::endl;
/* pProfileTierLevel */
    structBody << "\t" << pProfileTierLevelStruct << "," << std::endl;
/* pDecPicBufMgr */
    structBody << "\t" << pDecPicBufMgrStruct << "," << std::endl;
/* pScalingLists */
    structBody << "\t" << pScalingListsStruct << "," << std::endl;
/* pShortTermRefPicSet */
    structBody << "\t" << pShortTermRefPicSetStruct << "," << std::endl;
/* pLongTermRefPicsSps */
    structBody << "\t" << pLongTermRefPicsSpsStruct << "," << std::endl;
/* pSequenceParameterSetVui */
    structBody << "\t" << pSequenceParameterSetVuiStruct << "," << std::endl;
/* pPredictorPaletteEntries */
    structBody << "\t" << pPredictorPaletteEntriesStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265SequenceParameterSet");
    out << "StdVideoH265SequenceParameterSet " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265PpsFlags(std::ostream &out, const StdVideoH265PpsFlags* structInfo, Decoded_StdVideoH265PpsFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* dependent_slice_segments_enabled_flag */
    structBody << "\t" << structInfo->dependent_slice_segments_enabled_flag << "," << std::endl;
/* output_flag_present_flag */
    structBody << "\t" << structInfo->output_flag_present_flag << "," << std::endl;
/* sign_data_hiding_enabled_flag */
    structBody << "\t" << structInfo->sign_data_hiding_enabled_flag << "," << std::endl;
/* cabac_init_present_flag */
    structBody << "\t" << structInfo->cabac_init_present_flag << "," << std::endl;
/* constrained_intra_pred_flag */
    structBody << "\t" << structInfo->constrained_intra_pred_flag << "," << std::endl;
/* transform_skip_enabled_flag */
    structBody << "\t" << structInfo->transform_skip_enabled_flag << "," << std::endl;
/* cu_qp_delta_enabled_flag */
    structBody << "\t" << structInfo->cu_qp_delta_enabled_flag << "," << std::endl;
/* pps_slice_chroma_qp_offsets_present_flag */
    structBody << "\t" << structInfo->pps_slice_chroma_qp_offsets_present_flag << "," << std::endl;
/* weighted_pred_flag */
    structBody << "\t" << structInfo->weighted_pred_flag << "," << std::endl;
/* weighted_bipred_flag */
    structBody << "\t" << structInfo->weighted_bipred_flag << "," << std::endl;
/* transquant_bypass_enabled_flag */
    structBody << "\t" << structInfo->transquant_bypass_enabled_flag << "," << std::endl;
/* tiles_enabled_flag */
    structBody << "\t" << structInfo->tiles_enabled_flag << "," << std::endl;
/* entropy_coding_sync_enabled_flag */
    structBody << "\t" << structInfo->entropy_coding_sync_enabled_flag << "," << std::endl;
/* uniform_spacing_flag */
    structBody << "\t" << structInfo->uniform_spacing_flag << "," << std::endl;
/* loop_filter_across_tiles_enabled_flag */
    structBody << "\t" << structInfo->loop_filter_across_tiles_enabled_flag << "," << std::endl;
/* pps_loop_filter_across_slices_enabled_flag */
    structBody << "\t" << structInfo->pps_loop_filter_across_slices_enabled_flag << "," << std::endl;
/* deblocking_filter_control_present_flag */
    structBody << "\t" << structInfo->deblocking_filter_control_present_flag << "," << std::endl;
/* deblocking_filter_override_enabled_flag */
    structBody << "\t" << structInfo->deblocking_filter_override_enabled_flag << "," << std::endl;
/* pps_deblocking_filter_disabled_flag */
    structBody << "\t" << structInfo->pps_deblocking_filter_disabled_flag << "," << std::endl;
/* pps_scaling_list_data_present_flag */
    structBody << "\t" << structInfo->pps_scaling_list_data_present_flag << "," << std::endl;
/* lists_modification_present_flag */
    structBody << "\t" << structInfo->lists_modification_present_flag << "," << std::endl;
/* slice_segment_header_extension_present_flag */
    structBody << "\t" << structInfo->slice_segment_header_extension_present_flag << "," << std::endl;
/* pps_extension_present_flag */
    structBody << "\t" << structInfo->pps_extension_present_flag << "," << std::endl;
/* cross_component_prediction_enabled_flag */
    structBody << "\t" << structInfo->cross_component_prediction_enabled_flag << "," << std::endl;
/* chroma_qp_offset_list_enabled_flag */
    structBody << "\t" << structInfo->chroma_qp_offset_list_enabled_flag << "," << std::endl;
/* pps_curr_pic_ref_enabled_flag */
    structBody << "\t" << structInfo->pps_curr_pic_ref_enabled_flag << "," << std::endl;
/* residual_adaptive_colour_transform_enabled_flag */
    structBody << "\t" << structInfo->residual_adaptive_colour_transform_enabled_flag << "," << std::endl;
/* pps_slice_act_qp_offsets_present_flag */
    structBody << "\t" << structInfo->pps_slice_act_qp_offsets_present_flag << "," << std::endl;
/* pps_palette_predictor_initializers_present_flag */
    structBody << "\t" << structInfo->pps_palette_predictor_initializers_present_flag << "," << std::endl;
/* monochrome_palette_flag */
    structBody << "\t" << structInfo->monochrome_palette_flag << "," << std::endl;
/* pps_range_extension_flag */
    structBody << "\t" << structInfo->pps_range_extension_flag << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265PpsFlags");
    out << "StdVideoH265PpsFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoH265PictureParameterSet(std::ostream &out, const StdVideoH265PictureParameterSet* structInfo, Decoded_StdVideoH265PictureParameterSet* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoH265PpsFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
    std::string pScalingListsStruct = "NULL";
    if (structInfo->pScalingLists != NULL) {
        pScalingListsStruct = GenerateStruct_StdVideoH265ScalingLists(out,
                                                             structInfo->pScalingLists,
                                                             metainfo->pScalingLists->GetMetaStructPointer(),
                                                             consumer);
        pScalingListsStruct.insert(0, "&");
    }
    std::string pPredictorPaletteEntriesStruct = "NULL";
    if (structInfo->pPredictorPaletteEntries != NULL) {
        pPredictorPaletteEntriesStruct = GenerateStruct_StdVideoH265PredictorPaletteEntries(out,
                                                                        structInfo->pPredictorPaletteEntries,
                                                                        metainfo->pPredictorPaletteEntries->GetMetaStructPointer(),
                                                                        consumer);
        pPredictorPaletteEntriesStruct.insert(0, "&");
    }
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* pps_pic_parameter_set_id */
    structBody << "\t" << structInfo->pps_pic_parameter_set_id << "," << std::endl;
/* pps_seq_parameter_set_id */
    structBody << "\t" << structInfo->pps_seq_parameter_set_id << "," << std::endl;
/* sps_video_parameter_set_id */
    structBody << "\t" << structInfo->sps_video_parameter_set_id << "," << std::endl;
/* num_extra_slice_header_bits */
    structBody << "\t" << structInfo->num_extra_slice_header_bits << "," << std::endl;
/* num_ref_idx_l0_default_active_minus1 */
    structBody << "\t" << structInfo->num_ref_idx_l0_default_active_minus1 << "," << std::endl;
/* num_ref_idx_l1_default_active_minus1 */
    structBody << "\t" << structInfo->num_ref_idx_l1_default_active_minus1 << "," << std::endl;
/* init_qp_minus26 */
    structBody << "\t" << structInfo->init_qp_minus26 << "," << std::endl;
/* diff_cu_qp_delta_depth */
    structBody << "\t" << structInfo->diff_cu_qp_delta_depth << "," << std::endl;
/* pps_cb_qp_offset */
    structBody << "\t" << structInfo->pps_cb_qp_offset << "," << std::endl;
/* pps_cr_qp_offset */
    structBody << "\t" << structInfo->pps_cr_qp_offset << "," << std::endl;
/* pps_beta_offset_div2 */
    structBody << "\t" << structInfo->pps_beta_offset_div2 << "," << std::endl;
/* pps_tc_offset_div2 */
    structBody << "\t" << structInfo->pps_tc_offset_div2 << "," << std::endl;
/* log2_parallel_merge_level_minus2 */
    structBody << "\t" << structInfo->log2_parallel_merge_level_minus2 << "," << std::endl;
/* log2_max_transform_skip_block_size_minus2 */
    structBody << "\t" << structInfo->log2_max_transform_skip_block_size_minus2 << "," << std::endl;
/* diff_cu_chroma_qp_offset_depth */
    structBody << "\t" << structInfo->diff_cu_chroma_qp_offset_depth << "," << std::endl;
/* chroma_qp_offset_list_len_minus1 */
    structBody << "\t" << structInfo->chroma_qp_offset_list_len_minus1 << "," << std::endl;
/* cb_qp_offset_list */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->cb_qp_offset_list[0]), STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE) << "," << std::endl;
/* cr_qp_offset_list */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->cr_qp_offset_list[0]), STD_VIDEO_H265_CHROMA_QP_OFFSET_LIST_SIZE) << "," << std::endl;
/* log2_sao_offset_scale_luma */
    structBody << "\t" << structInfo->log2_sao_offset_scale_luma << "," << std::endl;
/* log2_sao_offset_scale_chroma */
    structBody << "\t" << structInfo->log2_sao_offset_scale_chroma << "," << std::endl;
/* pps_act_y_qp_offset_plus5 */
    structBody << "\t" << structInfo->pps_act_y_qp_offset_plus5 << "," << std::endl;
/* pps_act_cb_qp_offset_plus5 */
    structBody << "\t" << structInfo->pps_act_cb_qp_offset_plus5 << "," << std::endl;
/* pps_act_cr_qp_offset_plus3 */
    structBody << "\t" << structInfo->pps_act_cr_qp_offset_plus3 << "," << std::endl;
/* pps_num_palette_predictor_initializers */
    structBody << "\t" << structInfo->pps_num_palette_predictor_initializers << "," << std::endl;
/* luma_bit_depth_entry_minus8 */
    structBody << "\t" << structInfo->luma_bit_depth_entry_minus8 << "," << std::endl;
/* chroma_bit_depth_entry_minus8 */
    structBody << "\t" << structInfo->chroma_bit_depth_entry_minus8 << "," << std::endl;
/* num_tile_columns_minus1 */
    structBody << "\t" << structInfo->num_tile_columns_minus1 << "," << std::endl;
/* num_tile_rows_minus1 */
    structBody << "\t" << structInfo->num_tile_rows_minus1 << "," << std::endl;
/* reserved1 */
    structBody << "\t" << structInfo->reserved1 << "," << std::endl;
/* reserved2 */
    structBody << "\t" << structInfo->reserved2 << "," << std::endl;
/* column_width_minus1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->column_width_minus1[0]), STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_COLS_LIST_SIZE) << "," << std::endl;
/* row_height_minus1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint16_t*>(&structInfo->row_height_minus1[0]), STD_VIDEO_H265_CHROMA_QP_OFFSET_TILE_ROWS_LIST_SIZE) << "," << std::endl;
/* reserved3 */
    structBody << "\t" << structInfo->reserved3 << "," << std::endl;
/* pScalingLists */
    structBody << "\t" << pScalingListsStruct << "," << std::endl;
/* pPredictorPaletteEntries */
    structBody << "\t" << pPredictorPaletteEntriesStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoH265PictureParameterSet");
    out << "StdVideoH265PictureParameterSet " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoDecodeH265PictureInfoFlags(std::ostream &out, const StdVideoDecodeH265PictureInfoFlags* structInfo, Decoded_StdVideoDecodeH265PictureInfoFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* IrapPicFlag */
    structBody << "\t" << structInfo->IrapPicFlag << "," << std::endl;
/* IdrPicFlag */
    structBody << "\t" << structInfo->IdrPicFlag << "," << std::endl;
/* IsReference */
    structBody << "\t" << structInfo->IsReference << "," << std::endl;
/* short_term_ref_pic_set_sps_flag */
    structBody << "\t" << structInfo->short_term_ref_pic_set_sps_flag << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoDecodeH265PictureInfoFlags");
    out << "StdVideoDecodeH265PictureInfoFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoDecodeH265PictureInfo(std::ostream &out, const StdVideoDecodeH265PictureInfo* structInfo, Decoded_StdVideoDecodeH265PictureInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoDecodeH265PictureInfoFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* sps_video_parameter_set_id */
    structBody << "\t" << structInfo->sps_video_parameter_set_id << "," << std::endl;
/* pps_seq_parameter_set_id */
    structBody << "\t" << structInfo->pps_seq_parameter_set_id << "," << std::endl;
/* pps_pic_parameter_set_id */
    structBody << "\t" << structInfo->pps_pic_parameter_set_id << "," << std::endl;
/* NumDeltaPocsOfRefRpsIdx */
    structBody << "\t" << structInfo->NumDeltaPocsOfRefRpsIdx << "," << std::endl;
/* PicOrderCntVal */
    structBody << "\t" << structInfo->PicOrderCntVal << "," << std::endl;
/* NumBitsForSTRefPicSetInSlice */
    structBody << "\t" << structInfo->NumBitsForSTRefPicSetInSlice << "," << std::endl;
/* reserved */
    structBody << "\t" << structInfo->reserved << "," << std::endl;
/* RefPicSetStCurrBefore */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicSetStCurrBefore[0]), STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE) << "," << std::endl;
/* RefPicSetStCurrAfter */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicSetStCurrAfter[0]), STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE) << "," << std::endl;
/* RefPicSetLtCurr */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicSetLtCurr[0]), STD_VIDEO_DECODE_H265_REF_PIC_SET_LIST_SIZE) << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoDecodeH265PictureInfo");
    out << "StdVideoDecodeH265PictureInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoDecodeH265ReferenceInfoFlags(std::ostream &out, const StdVideoDecodeH265ReferenceInfoFlags* structInfo, Decoded_StdVideoDecodeH265ReferenceInfoFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* used_for_long_term_reference */
    structBody << "\t" << structInfo->used_for_long_term_reference << "," << std::endl;
/* unused_for_reference */
    structBody << "\t" << structInfo->unused_for_reference << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoDecodeH265ReferenceInfoFlags");
    out << "StdVideoDecodeH265ReferenceInfoFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoDecodeH265ReferenceInfo(std::ostream &out, const StdVideoDecodeH265ReferenceInfo* structInfo, Decoded_StdVideoDecodeH265ReferenceInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoDecodeH265ReferenceInfoFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* PicOrderCntVal */
    structBody << "\t" << structInfo->PicOrderCntVal << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoDecodeH265ReferenceInfo");
    out << "StdVideoDecodeH265ReferenceInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH265WeightTableFlags(std::ostream &out, const StdVideoEncodeH265WeightTableFlags* structInfo, Decoded_StdVideoEncodeH265WeightTableFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* luma_weight_l0_flag */
    structBody << "\t" << structInfo->luma_weight_l0_flag << "," << std::endl;
/* chroma_weight_l0_flag */
    structBody << "\t" << structInfo->chroma_weight_l0_flag << "," << std::endl;
/* luma_weight_l1_flag */
    structBody << "\t" << structInfo->luma_weight_l1_flag << "," << std::endl;
/* chroma_weight_l1_flag */
    structBody << "\t" << structInfo->chroma_weight_l1_flag << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH265WeightTableFlags");
    out << "StdVideoEncodeH265WeightTableFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH265WeightTable(std::ostream &out, const StdVideoEncodeH265WeightTable* structInfo, Decoded_StdVideoEncodeH265WeightTable* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoEncodeH265WeightTableFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* luma_log2_weight_denom */
    structBody << "\t" << structInfo->luma_log2_weight_denom << "," << std::endl;
/* delta_chroma_log2_weight_denom */
    structBody << "\t" << structInfo->delta_chroma_log2_weight_denom << "," << std::endl;
/* delta_luma_weight_l0 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->delta_luma_weight_l0[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
/* luma_offset_l0 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_offset_l0[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
/* delta_chroma_weight_l0 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->delta_chroma_weight_l0[0][0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
/* delta_chroma_offset_l0 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->delta_chroma_offset_l0[0][0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
/* delta_luma_weight_l1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->delta_luma_weight_l1[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
/* luma_offset_l1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->luma_offset_l1[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
/* delta_chroma_weight_l1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->delta_chroma_weight_l1[0][0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
/* delta_chroma_offset_l1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const int8_t*>(&structInfo->delta_chroma_offset_l1[0][0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH265WeightTable");
    out << "StdVideoEncodeH265WeightTable " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH265LongTermRefPics(std::ostream &out, const StdVideoEncodeH265LongTermRefPics* structInfo, Decoded_StdVideoEncodeH265LongTermRefPics* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* num_long_term_sps */
    structBody << "\t" << structInfo->num_long_term_sps << "," << std::endl;
/* num_long_term_pics */
    structBody << "\t" << structInfo->num_long_term_pics << "," << std::endl;
/* lt_idx_sps */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->lt_idx_sps[0]), STD_VIDEO_H265_MAX_LONG_TERM_REF_PICS_SPS) << "," << std::endl;
/* poc_lsb_lt */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->poc_lsb_lt[0]), STD_VIDEO_H265_MAX_LONG_TERM_PICS) << "," << std::endl;
/* used_by_curr_pic_lt_flag */
    structBody << "\t" << structInfo->used_by_curr_pic_lt_flag << "," << std::endl;
/* delta_poc_msb_present_flag */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->delta_poc_msb_present_flag[0]), STD_VIDEO_H265_MAX_DELTA_POC) << "," << std::endl;
/* delta_poc_msb_cycle_lt */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->delta_poc_msb_cycle_lt[0]), STD_VIDEO_H265_MAX_DELTA_POC) << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH265LongTermRefPics");
    out << "StdVideoEncodeH265LongTermRefPics " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH265SliceSegmentHeaderFlags(std::ostream &out, const StdVideoEncodeH265SliceSegmentHeaderFlags* structInfo, Decoded_StdVideoEncodeH265SliceSegmentHeaderFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* first_slice_segment_in_pic_flag */
    structBody << "\t" << structInfo->first_slice_segment_in_pic_flag << "," << std::endl;
/* dependent_slice_segment_flag */
    structBody << "\t" << structInfo->dependent_slice_segment_flag << "," << std::endl;
/* slice_sao_luma_flag */
    structBody << "\t" << structInfo->slice_sao_luma_flag << "," << std::endl;
/* slice_sao_chroma_flag */
    structBody << "\t" << structInfo->slice_sao_chroma_flag << "," << std::endl;
/* num_ref_idx_active_override_flag */
    structBody << "\t" << structInfo->num_ref_idx_active_override_flag << "," << std::endl;
/* mvd_l1_zero_flag */
    structBody << "\t" << structInfo->mvd_l1_zero_flag << "," << std::endl;
/* cabac_init_flag */
    structBody << "\t" << structInfo->cabac_init_flag << "," << std::endl;
/* cu_chroma_qp_offset_enabled_flag */
    structBody << "\t" << structInfo->cu_chroma_qp_offset_enabled_flag << "," << std::endl;
/* deblocking_filter_override_flag */
    structBody << "\t" << structInfo->deblocking_filter_override_flag << "," << std::endl;
/* slice_deblocking_filter_disabled_flag */
    structBody << "\t" << structInfo->slice_deblocking_filter_disabled_flag << "," << std::endl;
/* collocated_from_l0_flag */
    structBody << "\t" << structInfo->collocated_from_l0_flag << "," << std::endl;
/* slice_loop_filter_across_slices_enabled_flag */
    structBody << "\t" << structInfo->slice_loop_filter_across_slices_enabled_flag << "," << std::endl;
/* reserved */
    structBody << "\t" << structInfo->reserved << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH265SliceSegmentHeaderFlags");
    out << "StdVideoEncodeH265SliceSegmentHeaderFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH265SliceSegmentHeader(std::ostream &out, const StdVideoEncodeH265SliceSegmentHeader* structInfo, Decoded_StdVideoEncodeH265SliceSegmentHeader* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoEncodeH265SliceSegmentHeaderFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
    std::string pWeightTableStruct = "NULL";
    if (structInfo->pWeightTable != NULL) {
        pWeightTableStruct = GenerateStruct_StdVideoEncodeH265WeightTable(out,
                                                            structInfo->pWeightTable,
                                                            metainfo->pWeightTable->GetMetaStructPointer(),
                                                            consumer);
        pWeightTableStruct.insert(0, "&");
    }
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* slice_type */
    structBody << "\t" << "StdVideoH265SliceType(" << structInfo->slice_type << ")" << "," << std::endl;
/* slice_segment_address */
    structBody << "\t" << structInfo->slice_segment_address << "," << std::endl;
/* collocated_ref_idx */
    structBody << "\t" << structInfo->collocated_ref_idx << "," << std::endl;
/* MaxNumMergeCand */
    structBody << "\t" << structInfo->MaxNumMergeCand << "," << std::endl;
/* slice_cb_qp_offset */
    structBody << "\t" << structInfo->slice_cb_qp_offset << "," << std::endl;
/* slice_cr_qp_offset */
    structBody << "\t" << structInfo->slice_cr_qp_offset << "," << std::endl;
/* slice_beta_offset_div2 */
    structBody << "\t" << structInfo->slice_beta_offset_div2 << "," << std::endl;
/* slice_tc_offset_div2 */
    structBody << "\t" << structInfo->slice_tc_offset_div2 << "," << std::endl;
/* slice_act_y_qp_offset */
    structBody << "\t" << structInfo->slice_act_y_qp_offset << "," << std::endl;
/* slice_act_cb_qp_offset */
    structBody << "\t" << structInfo->slice_act_cb_qp_offset << "," << std::endl;
/* slice_act_cr_qp_offset */
    structBody << "\t" << structInfo->slice_act_cr_qp_offset << "," << std::endl;
/* slice_qp_delta */
    structBody << "\t" << structInfo->slice_qp_delta << "," << std::endl;
/* reserved1 */
    structBody << "\t" << structInfo->reserved1 << "," << std::endl;
/* pWeightTable */
    structBody << "\t" << pWeightTableStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH265SliceSegmentHeader");
    out << "StdVideoEncodeH265SliceSegmentHeader " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH265ReferenceListsInfoFlags(std::ostream &out, const StdVideoEncodeH265ReferenceListsInfoFlags* structInfo, Decoded_StdVideoEncodeH265ReferenceListsInfoFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* ref_pic_list_modification_flag_l0 */
    structBody << "\t" << structInfo->ref_pic_list_modification_flag_l0 << "," << std::endl;
/* ref_pic_list_modification_flag_l1 */
    structBody << "\t" << structInfo->ref_pic_list_modification_flag_l1 << "," << std::endl;
/* reserved */
    structBody << "\t" << structInfo->reserved << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH265ReferenceListsInfoFlags");
    out << "StdVideoEncodeH265ReferenceListsInfoFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH265ReferenceListsInfo(std::ostream &out, const StdVideoEncodeH265ReferenceListsInfo* structInfo, Decoded_StdVideoEncodeH265ReferenceListsInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoEncodeH265ReferenceListsInfoFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* num_ref_idx_l0_active_minus1 */
    structBody << "\t" << structInfo->num_ref_idx_l0_active_minus1 << "," << std::endl;
/* num_ref_idx_l1_active_minus1 */
    structBody << "\t" << structInfo->num_ref_idx_l1_active_minus1 << "," << std::endl;
/* RefPicList0 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicList0[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
/* RefPicList1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->RefPicList1[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
/* list_entry_l0 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->list_entry_l0[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," << std::endl;
/* list_entry_l1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->list_entry_l1[0]), STD_VIDEO_H265_MAX_NUM_LIST_REF) << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH265ReferenceListsInfo");
    out << "StdVideoEncodeH265ReferenceListsInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH265PictureInfoFlags(std::ostream &out, const StdVideoEncodeH265PictureInfoFlags* structInfo, Decoded_StdVideoEncodeH265PictureInfoFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* is_reference */
    structBody << "\t" << structInfo->is_reference << "," << std::endl;
/* IrapPicFlag */
    structBody << "\t" << structInfo->IrapPicFlag << "," << std::endl;
/* used_for_long_term_reference */
    structBody << "\t" << structInfo->used_for_long_term_reference << "," << std::endl;
/* discardable_flag */
    structBody << "\t" << structInfo->discardable_flag << "," << std::endl;
/* cross_layer_bla_flag */
    structBody << "\t" << structInfo->cross_layer_bla_flag << "," << std::endl;
/* pic_output_flag */
    structBody << "\t" << structInfo->pic_output_flag << "," << std::endl;
/* no_output_of_prior_pics_flag */
    structBody << "\t" << structInfo->no_output_of_prior_pics_flag << "," << std::endl;
/* short_term_ref_pic_set_sps_flag */
    structBody << "\t" << structInfo->short_term_ref_pic_set_sps_flag << "," << std::endl;
/* slice_temporal_mvp_enabled_flag */
    structBody << "\t" << structInfo->slice_temporal_mvp_enabled_flag << "," << std::endl;
/* reserved */
    structBody << "\t" << structInfo->reserved << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH265PictureInfoFlags");
    out << "StdVideoEncodeH265PictureInfoFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH265PictureInfo(std::ostream &out, const StdVideoEncodeH265PictureInfo* structInfo, Decoded_StdVideoEncodeH265PictureInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoEncodeH265PictureInfoFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
    std::string pRefListsStruct = "NULL";
    if (structInfo->pRefLists != NULL) {
        pRefListsStruct = GenerateStruct_StdVideoEncodeH265ReferenceListsInfo(out,
                                                         structInfo->pRefLists,
                                                         metainfo->pRefLists->GetMetaStructPointer(),
                                                         consumer);
        pRefListsStruct.insert(0, "&");
    }
    std::string pShortTermRefPicSetStruct = "NULL";
    if (structInfo->pShortTermRefPicSet != NULL) {
        pShortTermRefPicSetStruct = GenerateStruct_StdVideoH265ShortTermRefPicSet(out,
                                                                   structInfo->pShortTermRefPicSet,
                                                                   metainfo->pShortTermRefPicSet->GetMetaStructPointer(),
                                                                   consumer);
        pShortTermRefPicSetStruct.insert(0, "&");
    }
    std::string pLongTermRefPicsStruct = "NULL";
    if (structInfo->pLongTermRefPics != NULL) {
        pLongTermRefPicsStruct = GenerateStruct_StdVideoEncodeH265LongTermRefPics(out,
                                                                structInfo->pLongTermRefPics,
                                                                metainfo->pLongTermRefPics->GetMetaStructPointer(),
                                                                consumer);
        pLongTermRefPicsStruct.insert(0, "&");
    }
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* pic_type */
    structBody << "\t" << "StdVideoH265PictureType(" << structInfo->pic_type << ")" << "," << std::endl;
/* sps_video_parameter_set_id */
    structBody << "\t" << structInfo->sps_video_parameter_set_id << "," << std::endl;
/* pps_seq_parameter_set_id */
    structBody << "\t" << structInfo->pps_seq_parameter_set_id << "," << std::endl;
/* pps_pic_parameter_set_id */
    structBody << "\t" << structInfo->pps_pic_parameter_set_id << "," << std::endl;
/* short_term_ref_pic_set_idx */
    structBody << "\t" << structInfo->short_term_ref_pic_set_idx << "," << std::endl;
/* PicOrderCntVal */
    structBody << "\t" << structInfo->PicOrderCntVal << "," << std::endl;
/* TemporalId */
    structBody << "\t" << structInfo->TemporalId << "," << std::endl;
/* reserved1 */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->reserved1[0]), 7) << "," << std::endl;
/* pRefLists */
    structBody << "\t" << pRefListsStruct << "," << std::endl;
/* pShortTermRefPicSet */
    structBody << "\t" << pShortTermRefPicSetStruct << "," << std::endl;
/* pLongTermRefPics */
    structBody << "\t" << pLongTermRefPicsStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH265PictureInfo");
    out << "StdVideoEncodeH265PictureInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH265ReferenceInfoFlags(std::ostream &out, const StdVideoEncodeH265ReferenceInfoFlags* structInfo, Decoded_StdVideoEncodeH265ReferenceInfoFlags* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* used_for_long_term_reference */
    structBody << "\t" << structInfo->used_for_long_term_reference << "," << std::endl;
/* unused_for_reference */
    structBody << "\t" << structInfo->unused_for_reference << "," << std::endl;
/* reserved */
    structBody << "\t" << structInfo->reserved << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH265ReferenceInfoFlags");
    out << "StdVideoEncodeH265ReferenceInfoFlags " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_StdVideoEncodeH265ReferenceInfo(std::ostream &out, const StdVideoEncodeH265ReferenceInfo* structInfo, Decoded_StdVideoEncodeH265ReferenceInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string flagsInfoVar = GenerateStruct_StdVideoEncodeH265ReferenceInfoFlags(out,
                                                              &structInfo->flags,
                                                              metainfo->flags,
                                                              consumer);
/* flags */
    structBody << "\t" << flagsInfoVar << "," << std::endl;
/* pic_type */
    structBody << "\t" << "StdVideoH265PictureType(" << structInfo->pic_type << ")" << "," << std::endl;
/* PicOrderCntVal */
    structBody << "\t" << structInfo->PicOrderCntVal << "," << std::endl;
/* TemporalId */
    structBody << "\t" << structInfo->TemporalId << "," ;
    std::string varname = consumer.AddStruct(structBody, "stdVideoEncodeH265ReferenceInfo");
    out << "StdVideoEncodeH265ReferenceInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExtent2D(std::ostream &out, const VkExtent2D* structInfo, Decoded_VkExtent2D* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* width */
    structBody << "\t" << structInfo->width << "," << std::endl;
/* height */
    structBody << "\t" << structInfo->height << "," ;
    std::string varname = consumer.AddStruct(structBody, "extent2D");
    out << "VkExtent2D " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExtent3D(std::ostream &out, const VkExtent3D* structInfo, Decoded_VkExtent3D* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* width */
    structBody << "\t" << structInfo->width << "," << std::endl;
/* height */
    structBody << "\t" << structInfo->height << "," << std::endl;
/* depth */
    structBody << "\t" << structInfo->depth << "," ;
    std::string varname = consumer.AddStruct(structBody, "extent3D");
    out << "VkExtent3D " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkOffset2D(std::ostream &out, const VkOffset2D* structInfo, Decoded_VkOffset2D* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* x */
    structBody << "\t" << structInfo->x << "," << std::endl;
/* y */
    structBody << "\t" << structInfo->y << "," ;
    std::string varname = consumer.AddStruct(structBody, "offset2D");
    out << "VkOffset2D " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkOffset3D(std::ostream &out, const VkOffset3D* structInfo, Decoded_VkOffset3D* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* x */
    structBody << "\t" << structInfo->x << "," << std::endl;
/* y */
    structBody << "\t" << structInfo->y << "," << std::endl;
/* z */
    structBody << "\t" << structInfo->z << "," ;
    std::string varname = consumer.AddStruct(structBody, "offset3D");
    out << "VkOffset3D " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRect2D(std::ostream &out, const VkRect2D* structInfo, Decoded_VkRect2D* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string offsetInfoVar = GenerateStruct_VkOffset2D(out,
                                                               &structInfo->offset,
                                                               metainfo->offset,
                                                               consumer);
    std::string extentInfoVar = GenerateStruct_VkExtent2D(out,
                                                               &structInfo->extent,
                                                               metainfo->extent,
                                                               consumer);
/* offset */
    structBody << "\t" << offsetInfoVar << "," << std::endl;
/* extent */
    structBody << "\t" << extentInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "rect2D");
    out << "VkRect2D " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBufferMemoryBarrier(std::ostream &out, const VkBufferMemoryBarrier* structInfo, Decoded_VkBufferMemoryBarrier* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcAccessMask */
    structBody << "\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
/* dstAccessMask */
    structBody << "\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << "," << std::endl;
/* srcQueueFamilyIndex */
    structBody << "\t" << structInfo->srcQueueFamilyIndex << "," << std::endl;
/* dstQueueFamilyIndex */
    structBody << "\t" << structInfo->dstQueueFamilyIndex << "," << std::endl;
/* buffer */
    structBody << "\t" << consumer.GetHandle(metainfo->buffer) << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "bufferMemoryBarrier");
    out << "VkBufferMemoryBarrier " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDispatchIndirectCommand(std::ostream &out, const VkDispatchIndirectCommand* structInfo, Decoded_VkDispatchIndirectCommand* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* x */
    structBody << "\t" << structInfo->x << "," << std::endl;
/* y */
    structBody << "\t" << structInfo->y << "," << std::endl;
/* z */
    structBody << "\t" << structInfo->z << "," ;
    std::string varname = consumer.AddStruct(structBody, "dispatchIndirectCommand");
    out << "VkDispatchIndirectCommand " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDrawIndexedIndirectCommand(std::ostream &out, const VkDrawIndexedIndirectCommand* structInfo, Decoded_VkDrawIndexedIndirectCommand* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* indexCount */
    structBody << "\t" << structInfo->indexCount << "," << std::endl;
/* instanceCount */
    structBody << "\t" << structInfo->instanceCount << "," << std::endl;
/* firstIndex */
    structBody << "\t" << structInfo->firstIndex << "," << std::endl;
/* vertexOffset */
    structBody << "\t" << structInfo->vertexOffset << "," << std::endl;
/* firstInstance */
    structBody << "\t" << structInfo->firstInstance << "," ;
    std::string varname = consumer.AddStruct(structBody, "drawIndexedIndirectCommand");
    out << "VkDrawIndexedIndirectCommand " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDrawIndirectCommand(std::ostream &out, const VkDrawIndirectCommand* structInfo, Decoded_VkDrawIndirectCommand* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* vertexCount */
    structBody << "\t" << structInfo->vertexCount << "," << std::endl;
/* instanceCount */
    structBody << "\t" << structInfo->instanceCount << "," << std::endl;
/* firstVertex */
    structBody << "\t" << structInfo->firstVertex << "," << std::endl;
/* firstInstance */
    structBody << "\t" << structInfo->firstInstance << "," ;
    std::string varname = consumer.AddStruct(structBody, "drawIndirectCommand");
    out << "VkDrawIndirectCommand " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageSubresourceRange(std::ostream &out, const VkImageSubresourceRange* structInfo, Decoded_VkImageSubresourceRange* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* aspectMask */
    structBody << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
/* baseMipLevel */
    structBody << "\t" << structInfo->baseMipLevel << "," << std::endl;
/* levelCount */
    structBody << "\t" << structInfo->levelCount << "," << std::endl;
/* baseArrayLayer */
    structBody << "\t" << structInfo->baseArrayLayer << "," << std::endl;
/* layerCount */
    structBody << "\t" << structInfo->layerCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageSubresourceRange");
    out << "VkImageSubresourceRange " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageMemoryBarrier(std::ostream &out, const VkImageMemoryBarrier* structInfo, Decoded_VkImageMemoryBarrier* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string subresourceRangeInfoVar = GenerateStruct_VkImageSubresourceRange(out,
                                                                         &structInfo->subresourceRange,
                                                                         metainfo->subresourceRange,
                                                                         consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcAccessMask */
    structBody << "\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
/* dstAccessMask */
    structBody << "\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << "," << std::endl;
/* oldLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->oldLayout << ")" << "," << std::endl;
/* newLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->newLayout << ")" << "," << std::endl;
/* srcQueueFamilyIndex */
    structBody << "\t" << structInfo->srcQueueFamilyIndex << "," << std::endl;
/* dstQueueFamilyIndex */
    structBody << "\t" << structInfo->dstQueueFamilyIndex << "," << std::endl;
/* image */
    structBody << "\t" << consumer.GetHandle(metainfo->image) << "," << std::endl;
/* subresourceRange */
    structBody << "\t" << subresourceRangeInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageMemoryBarrier");
    out << "VkImageMemoryBarrier " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryBarrier(std::ostream &out, const VkMemoryBarrier* structInfo, Decoded_VkMemoryBarrier* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcAccessMask */
    structBody << "\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
/* dstAccessMask */
    structBody << "\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryBarrier");
    out << "VkMemoryBarrier " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineCacheHeaderVersionOne(std::ostream &out, const VkPipelineCacheHeaderVersionOne* structInfo, Decoded_VkPipelineCacheHeaderVersionOne* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* headerSize */
    structBody << "\t" << structInfo->headerSize << "," << std::endl;
/* headerVersion */
    structBody << "\t" << "VkPipelineCacheHeaderVersion(" << structInfo->headerVersion << ")" << "," << std::endl;
/* vendorID */
    structBody << "\t" << structInfo->vendorID << "," << std::endl;
/* deviceID */
    structBody << "\t" << structInfo->deviceID << "," << std::endl;
/* pipelineCacheUUID */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->pipelineCacheUUID[0]), VK_UUID_SIZE) << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineCacheHeaderVersionOne");
    out << "VkPipelineCacheHeaderVersionOne " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAllocationCallbacks(std::ostream &out, const VkAllocationCallbacks* structInfo, Decoded_VkAllocationCallbacks* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* pUserData */
    out << "// TODO: Support pUserData (output?) argument." << std::endl;
/* pfnAllocation */
    structBody << "\t" << structInfo->pfnAllocation << "," << std::endl;
/* pfnReallocation */
    structBody << "\t" << structInfo->pfnReallocation << "," << std::endl;
/* pfnFree */
    structBody << "\t" << structInfo->pfnFree << "," << std::endl;
/* pfnInternalAllocation */
    structBody << "\t" << structInfo->pfnInternalAllocation << "," << std::endl;
/* pfnInternalFree */
    structBody << "\t" << structInfo->pfnInternalFree << "," ;
    std::string varname = consumer.AddStruct(structBody, "allocationCallbacks");
    out << "VkAllocationCallbacks " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkApplicationInfo(std::ostream &out, const VkApplicationInfo* structInfo, Decoded_VkApplicationInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pApplicationName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->pApplicationName) << "," << std::endl;
/* applicationVersion */
    structBody << "\t" << structInfo->applicationVersion << "," << std::endl;
/* pEngineName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->pEngineName) << "," << std::endl;
/* engineVersion */
    structBody << "\t" << structInfo->engineVersion << "," << std::endl;
/* apiVersion */
    structBody << "\t" << structInfo->apiVersion << "," ;
    std::string varname = consumer.AddStruct(structBody, "applicationInfo");
    out << "VkApplicationInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkFormatProperties(std::ostream &out, const VkFormatProperties* structInfo, Decoded_VkFormatProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* linearTilingFeatures */
    structBody << "\t" << "VkFormatFeatureFlags(" << structInfo->linearTilingFeatures << ")" << "," << std::endl;
/* optimalTilingFeatures */
    structBody << "\t" << "VkFormatFeatureFlags(" << structInfo->optimalTilingFeatures << ")" << "," << std::endl;
/* bufferFeatures */
    structBody << "\t" << "VkFormatFeatureFlags(" << structInfo->bufferFeatures << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "formatProperties");
    out << "VkFormatProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageFormatProperties(std::ostream &out, const VkImageFormatProperties* structInfo, Decoded_VkImageFormatProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string maxExtentInfoVar = GenerateStruct_VkExtent3D(out,
                                                                  &structInfo->maxExtent,
                                                                  metainfo->maxExtent,
                                                                  consumer);
/* maxExtent */
    structBody << "\t" << maxExtentInfoVar << "," << std::endl;
/* maxMipLevels */
    structBody << "\t" << structInfo->maxMipLevels << "," << std::endl;
/* maxArrayLayers */
    structBody << "\t" << structInfo->maxArrayLayers << "," << std::endl;
/* sampleCounts */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->sampleCounts << ")" << "," << std::endl;
/* maxResourceSize */
    structBody << "\t" << structInfo->maxResourceSize << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageFormatProperties");
    out << "VkImageFormatProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkInstanceCreateInfo(std::ostream &out, const VkInstanceCreateInfo* structInfo, Decoded_VkInstanceCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pApplicationInfoStruct = "NULL";
    if (structInfo->pApplicationInfo != NULL) {
        pApplicationInfoStruct = GenerateStruct_VkApplicationInfo(out,
                                                                structInfo->pApplicationInfo,
                                                                metainfo->pApplicationInfo->GetMetaStructPointer(),
                                                                consumer);
        pApplicationInfoStruct.insert(0, "&");
    }
    std::string ppEnabledLayerNamesVar = "NULL";
    if (structInfo->enabledLayerCount) {
    ppEnabledLayerNamesVar = "ppEnabledLayerNames_" + std::to_string(consumer.getNextId());
    out << "const char* " << ppEnabledLayerNamesVar << "[] = " << VulkanCppConsumerBase::escapeStringArray(structInfo->ppEnabledLayerNames, structInfo->enabledLayerCount) << ";" << std::endl;
    }
    std::string ppEnabledExtensionNamesVar = "NULL";
    if (structInfo->enabledExtensionCount) {
    ppEnabledExtensionNamesVar = "ppEnabledExtensionNames_" + std::to_string(consumer.getNextId());
    out << "const char* " << ppEnabledExtensionNamesVar << "[] = " << VulkanCppConsumerBase::escapeStringArray(structInfo->ppEnabledExtensionNames, structInfo->enabledExtensionCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkInstanceCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* pApplicationInfo */
    structBody << "\t" << pApplicationInfoStruct << "," << std::endl;
/* enabledLayerCount */
    structBody << "\t" << structInfo->enabledLayerCount << "," << std::endl;
/* ppEnabledLayerNames */
    structBody << "\t" << ppEnabledLayerNamesVar << "," << std::endl;
/* enabledExtensionCount */
    structBody << "\t" << structInfo->enabledExtensionCount << "," << std::endl;
/* ppEnabledExtensionNames */
    structBody << "\t" << ppEnabledExtensionNamesVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "instanceCreateInfo");
    out << "VkInstanceCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryHeap(std::ostream &out, const VkMemoryHeap* structInfo, Decoded_VkMemoryHeap* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," << std::endl;
/* flags */
    structBody << "\t" << "VkMemoryHeapFlags(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryHeap");
    out << "VkMemoryHeap " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryType(std::ostream &out, const VkMemoryType* structInfo, Decoded_VkMemoryType* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* propertyFlags */
    structBody << "\t" << "VkMemoryPropertyFlags(" << structInfo->propertyFlags << ")" << "," << std::endl;
/* heapIndex */
    structBody << "\t" << structInfo->heapIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryType");
    out << "VkMemoryType " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFeatures(std::ostream &out, const VkPhysicalDeviceFeatures* structInfo, Decoded_VkPhysicalDeviceFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* robustBufferAccess */
    structBody << "\t" << structInfo->robustBufferAccess << "," << std::endl;
/* fullDrawIndexUint32 */
    structBody << "\t" << structInfo->fullDrawIndexUint32 << "," << std::endl;
/* imageCubeArray */
    structBody << "\t" << structInfo->imageCubeArray << "," << std::endl;
/* independentBlend */
    structBody << "\t" << structInfo->independentBlend << "," << std::endl;
/* geometryShader */
    structBody << "\t" << structInfo->geometryShader << "," << std::endl;
/* tessellationShader */
    structBody << "\t" << structInfo->tessellationShader << "," << std::endl;
/* sampleRateShading */
    structBody << "\t" << structInfo->sampleRateShading << "," << std::endl;
/* dualSrcBlend */
    structBody << "\t" << structInfo->dualSrcBlend << "," << std::endl;
/* logicOp */
    structBody << "\t" << structInfo->logicOp << "," << std::endl;
/* multiDrawIndirect */
    structBody << "\t" << structInfo->multiDrawIndirect << "," << std::endl;
/* drawIndirectFirstInstance */
    structBody << "\t" << structInfo->drawIndirectFirstInstance << "," << std::endl;
/* depthClamp */
    structBody << "\t" << structInfo->depthClamp << "," << std::endl;
/* depthBiasClamp */
    structBody << "\t" << structInfo->depthBiasClamp << "," << std::endl;
/* fillModeNonSolid */
    structBody << "\t" << structInfo->fillModeNonSolid << "," << std::endl;
/* depthBounds */
    structBody << "\t" << structInfo->depthBounds << "," << std::endl;
/* wideLines */
    structBody << "\t" << structInfo->wideLines << "," << std::endl;
/* largePoints */
    structBody << "\t" << structInfo->largePoints << "," << std::endl;
/* alphaToOne */
    structBody << "\t" << structInfo->alphaToOne << "," << std::endl;
/* multiViewport */
    structBody << "\t" << structInfo->multiViewport << "," << std::endl;
/* samplerAnisotropy */
    structBody << "\t" << structInfo->samplerAnisotropy << "," << std::endl;
/* textureCompressionETC2 */
    structBody << "\t" << structInfo->textureCompressionETC2 << "," << std::endl;
/* textureCompressionASTC_LDR */
    structBody << "\t" << structInfo->textureCompressionASTC_LDR << "," << std::endl;
/* textureCompressionBC */
    structBody << "\t" << structInfo->textureCompressionBC << "," << std::endl;
/* occlusionQueryPrecise */
    structBody << "\t" << structInfo->occlusionQueryPrecise << "," << std::endl;
/* pipelineStatisticsQuery */
    structBody << "\t" << structInfo->pipelineStatisticsQuery << "," << std::endl;
/* vertexPipelineStoresAndAtomics */
    structBody << "\t" << structInfo->vertexPipelineStoresAndAtomics << "," << std::endl;
/* fragmentStoresAndAtomics */
    structBody << "\t" << structInfo->fragmentStoresAndAtomics << "," << std::endl;
/* shaderTessellationAndGeometryPointSize */
    structBody << "\t" << structInfo->shaderTessellationAndGeometryPointSize << "," << std::endl;
/* shaderImageGatherExtended */
    structBody << "\t" << structInfo->shaderImageGatherExtended << "," << std::endl;
/* shaderStorageImageExtendedFormats */
    structBody << "\t" << structInfo->shaderStorageImageExtendedFormats << "," << std::endl;
/* shaderStorageImageMultisample */
    structBody << "\t" << structInfo->shaderStorageImageMultisample << "," << std::endl;
/* shaderStorageImageReadWithoutFormat */
    structBody << "\t" << structInfo->shaderStorageImageReadWithoutFormat << "," << std::endl;
/* shaderStorageImageWriteWithoutFormat */
    structBody << "\t" << structInfo->shaderStorageImageWriteWithoutFormat << "," << std::endl;
/* shaderUniformBufferArrayDynamicIndexing */
    structBody << "\t" << structInfo->shaderUniformBufferArrayDynamicIndexing << "," << std::endl;
/* shaderSampledImageArrayDynamicIndexing */
    structBody << "\t" << structInfo->shaderSampledImageArrayDynamicIndexing << "," << std::endl;
/* shaderStorageBufferArrayDynamicIndexing */
    structBody << "\t" << structInfo->shaderStorageBufferArrayDynamicIndexing << "," << std::endl;
/* shaderStorageImageArrayDynamicIndexing */
    structBody << "\t" << structInfo->shaderStorageImageArrayDynamicIndexing << "," << std::endl;
/* shaderClipDistance */
    structBody << "\t" << structInfo->shaderClipDistance << "," << std::endl;
/* shaderCullDistance */
    structBody << "\t" << structInfo->shaderCullDistance << "," << std::endl;
/* shaderFloat64 */
    structBody << "\t" << structInfo->shaderFloat64 << "," << std::endl;
/* shaderInt64 */
    structBody << "\t" << structInfo->shaderInt64 << "," << std::endl;
/* shaderInt16 */
    structBody << "\t" << structInfo->shaderInt16 << "," << std::endl;
/* shaderResourceResidency */
    structBody << "\t" << structInfo->shaderResourceResidency << "," << std::endl;
/* shaderResourceMinLod */
    structBody << "\t" << structInfo->shaderResourceMinLod << "," << std::endl;
/* sparseBinding */
    structBody << "\t" << structInfo->sparseBinding << "," << std::endl;
/* sparseResidencyBuffer */
    structBody << "\t" << structInfo->sparseResidencyBuffer << "," << std::endl;
/* sparseResidencyImage2D */
    structBody << "\t" << structInfo->sparseResidencyImage2D << "," << std::endl;
/* sparseResidencyImage3D */
    structBody << "\t" << structInfo->sparseResidencyImage3D << "," << std::endl;
/* sparseResidency2Samples */
    structBody << "\t" << structInfo->sparseResidency2Samples << "," << std::endl;
/* sparseResidency4Samples */
    structBody << "\t" << structInfo->sparseResidency4Samples << "," << std::endl;
/* sparseResidency8Samples */
    structBody << "\t" << structInfo->sparseResidency8Samples << "," << std::endl;
/* sparseResidency16Samples */
    structBody << "\t" << structInfo->sparseResidency16Samples << "," << std::endl;
/* sparseResidencyAliased */
    structBody << "\t" << structInfo->sparseResidencyAliased << "," << std::endl;
/* variableMultisampleRate */
    structBody << "\t" << structInfo->variableMultisampleRate << "," << std::endl;
/* inheritedQueries */
    structBody << "\t" << structInfo->inheritedQueries << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFeatures");
    out << "VkPhysicalDeviceFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceLimits(std::ostream &out, const VkPhysicalDeviceLimits* structInfo, Decoded_VkPhysicalDeviceLimits* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* maxImageDimension1D */
    structBody << "\t" << structInfo->maxImageDimension1D << "," << std::endl;
/* maxImageDimension2D */
    structBody << "\t" << structInfo->maxImageDimension2D << "," << std::endl;
/* maxImageDimension3D */
    structBody << "\t" << structInfo->maxImageDimension3D << "," << std::endl;
/* maxImageDimensionCube */
    structBody << "\t" << structInfo->maxImageDimensionCube << "," << std::endl;
/* maxImageArrayLayers */
    structBody << "\t" << structInfo->maxImageArrayLayers << "," << std::endl;
/* maxTexelBufferElements */
    structBody << "\t" << structInfo->maxTexelBufferElements << "," << std::endl;
/* maxUniformBufferRange */
    structBody << "\t" << structInfo->maxUniformBufferRange << "," << std::endl;
/* maxStorageBufferRange */
    structBody << "\t" << structInfo->maxStorageBufferRange << "," << std::endl;
/* maxPushConstantsSize */
    structBody << "\t" << structInfo->maxPushConstantsSize << "," << std::endl;
/* maxMemoryAllocationCount */
    structBody << "\t" << structInfo->maxMemoryAllocationCount << "," << std::endl;
/* maxSamplerAllocationCount */
    structBody << "\t" << structInfo->maxSamplerAllocationCount << "," << std::endl;
/* bufferImageGranularity */
    structBody << "\t" << structInfo->bufferImageGranularity << "UL" << "," << std::endl;
/* sparseAddressSpaceSize */
    structBody << "\t" << structInfo->sparseAddressSpaceSize << "UL" << "," << std::endl;
/* maxBoundDescriptorSets */
    structBody << "\t" << structInfo->maxBoundDescriptorSets << "," << std::endl;
/* maxPerStageDescriptorSamplers */
    structBody << "\t" << structInfo->maxPerStageDescriptorSamplers << "," << std::endl;
/* maxPerStageDescriptorUniformBuffers */
    structBody << "\t" << structInfo->maxPerStageDescriptorUniformBuffers << "," << std::endl;
/* maxPerStageDescriptorStorageBuffers */
    structBody << "\t" << structInfo->maxPerStageDescriptorStorageBuffers << "," << std::endl;
/* maxPerStageDescriptorSampledImages */
    structBody << "\t" << structInfo->maxPerStageDescriptorSampledImages << "," << std::endl;
/* maxPerStageDescriptorStorageImages */
    structBody << "\t" << structInfo->maxPerStageDescriptorStorageImages << "," << std::endl;
/* maxPerStageDescriptorInputAttachments */
    structBody << "\t" << structInfo->maxPerStageDescriptorInputAttachments << "," << std::endl;
/* maxPerStageResources */
    structBody << "\t" << structInfo->maxPerStageResources << "," << std::endl;
/* maxDescriptorSetSamplers */
    structBody << "\t" << structInfo->maxDescriptorSetSamplers << "," << std::endl;
/* maxDescriptorSetUniformBuffers */
    structBody << "\t" << structInfo->maxDescriptorSetUniformBuffers << "," << std::endl;
/* maxDescriptorSetUniformBuffersDynamic */
    structBody << "\t" << structInfo->maxDescriptorSetUniformBuffersDynamic << "," << std::endl;
/* maxDescriptorSetStorageBuffers */
    structBody << "\t" << structInfo->maxDescriptorSetStorageBuffers << "," << std::endl;
/* maxDescriptorSetStorageBuffersDynamic */
    structBody << "\t" << structInfo->maxDescriptorSetStorageBuffersDynamic << "," << std::endl;
/* maxDescriptorSetSampledImages */
    structBody << "\t" << structInfo->maxDescriptorSetSampledImages << "," << std::endl;
/* maxDescriptorSetStorageImages */
    structBody << "\t" << structInfo->maxDescriptorSetStorageImages << "," << std::endl;
/* maxDescriptorSetInputAttachments */
    structBody << "\t" << structInfo->maxDescriptorSetInputAttachments << "," << std::endl;
/* maxVertexInputAttributes */
    structBody << "\t" << structInfo->maxVertexInputAttributes << "," << std::endl;
/* maxVertexInputBindings */
    structBody << "\t" << structInfo->maxVertexInputBindings << "," << std::endl;
/* maxVertexInputAttributeOffset */
    structBody << "\t" << structInfo->maxVertexInputAttributeOffset << "," << std::endl;
/* maxVertexInputBindingStride */
    structBody << "\t" << structInfo->maxVertexInputBindingStride << "," << std::endl;
/* maxVertexOutputComponents */
    structBody << "\t" << structInfo->maxVertexOutputComponents << "," << std::endl;
/* maxTessellationGenerationLevel */
    structBody << "\t" << structInfo->maxTessellationGenerationLevel << "," << std::endl;
/* maxTessellationPatchSize */
    structBody << "\t" << structInfo->maxTessellationPatchSize << "," << std::endl;
/* maxTessellationControlPerVertexInputComponents */
    structBody << "\t" << structInfo->maxTessellationControlPerVertexInputComponents << "," << std::endl;
/* maxTessellationControlPerVertexOutputComponents */
    structBody << "\t" << structInfo->maxTessellationControlPerVertexOutputComponents << "," << std::endl;
/* maxTessellationControlPerPatchOutputComponents */
    structBody << "\t" << structInfo->maxTessellationControlPerPatchOutputComponents << "," << std::endl;
/* maxTessellationControlTotalOutputComponents */
    structBody << "\t" << structInfo->maxTessellationControlTotalOutputComponents << "," << std::endl;
/* maxTessellationEvaluationInputComponents */
    structBody << "\t" << structInfo->maxTessellationEvaluationInputComponents << "," << std::endl;
/* maxTessellationEvaluationOutputComponents */
    structBody << "\t" << structInfo->maxTessellationEvaluationOutputComponents << "," << std::endl;
/* maxGeometryShaderInvocations */
    structBody << "\t" << structInfo->maxGeometryShaderInvocations << "," << std::endl;
/* maxGeometryInputComponents */
    structBody << "\t" << structInfo->maxGeometryInputComponents << "," << std::endl;
/* maxGeometryOutputComponents */
    structBody << "\t" << structInfo->maxGeometryOutputComponents << "," << std::endl;
/* maxGeometryOutputVertices */
    structBody << "\t" << structInfo->maxGeometryOutputVertices << "," << std::endl;
/* maxGeometryTotalOutputComponents */
    structBody << "\t" << structInfo->maxGeometryTotalOutputComponents << "," << std::endl;
/* maxFragmentInputComponents */
    structBody << "\t" << structInfo->maxFragmentInputComponents << "," << std::endl;
/* maxFragmentOutputAttachments */
    structBody << "\t" << structInfo->maxFragmentOutputAttachments << "," << std::endl;
/* maxFragmentDualSrcAttachments */
    structBody << "\t" << structInfo->maxFragmentDualSrcAttachments << "," << std::endl;
/* maxFragmentCombinedOutputResources */
    structBody << "\t" << structInfo->maxFragmentCombinedOutputResources << "," << std::endl;
/* maxComputeSharedMemorySize */
    structBody << "\t" << structInfo->maxComputeSharedMemorySize << "," << std::endl;
/* maxComputeWorkGroupCount */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxComputeWorkGroupCount[0]), 3) << "," << std::endl;
/* maxComputeWorkGroupInvocations */
    structBody << "\t" << structInfo->maxComputeWorkGroupInvocations << "," << std::endl;
/* maxComputeWorkGroupSize */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxComputeWorkGroupSize[0]), 3) << "," << std::endl;
/* subPixelPrecisionBits */
    structBody << "\t" << structInfo->subPixelPrecisionBits << "," << std::endl;
/* subTexelPrecisionBits */
    structBody << "\t" << structInfo->subTexelPrecisionBits << "," << std::endl;
/* mipmapPrecisionBits */
    structBody << "\t" << structInfo->mipmapPrecisionBits << "," << std::endl;
/* maxDrawIndexedIndexValue */
    structBody << "\t" << structInfo->maxDrawIndexedIndexValue << "," << std::endl;
/* maxDrawIndirectCount */
    structBody << "\t" << structInfo->maxDrawIndirectCount << "," << std::endl;
/* maxSamplerLodBias */
    structBody << "\t" << structInfo->maxSamplerLodBias << "," << std::endl;
/* maxSamplerAnisotropy */
    structBody << "\t" << structInfo->maxSamplerAnisotropy << "," << std::endl;
/* maxViewports */
    structBody << "\t" << structInfo->maxViewports << "," << std::endl;
/* maxViewportDimensions */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxViewportDimensions[0]), 2) << "," << std::endl;
/* viewportBoundsRange */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->viewportBoundsRange[0]), 2) << "," << std::endl;
/* viewportSubPixelBits */
    structBody << "\t" << structInfo->viewportSubPixelBits << "," << std::endl;
/* minMemoryMapAlignment */
    structBody << "\t" << structInfo->minMemoryMapAlignment << "," << std::endl;
/* minTexelBufferOffsetAlignment */
    structBody << "\t" << structInfo->minTexelBufferOffsetAlignment << "UL" << "," << std::endl;
/* minUniformBufferOffsetAlignment */
    structBody << "\t" << structInfo->minUniformBufferOffsetAlignment << "UL" << "," << std::endl;
/* minStorageBufferOffsetAlignment */
    structBody << "\t" << structInfo->minStorageBufferOffsetAlignment << "UL" << "," << std::endl;
/* minTexelOffset */
    structBody << "\t" << structInfo->minTexelOffset << "," << std::endl;
/* maxTexelOffset */
    structBody << "\t" << structInfo->maxTexelOffset << "," << std::endl;
/* minTexelGatherOffset */
    structBody << "\t" << structInfo->minTexelGatherOffset << "," << std::endl;
/* maxTexelGatherOffset */
    structBody << "\t" << structInfo->maxTexelGatherOffset << "," << std::endl;
/* minInterpolationOffset */
    structBody << "\t" << structInfo->minInterpolationOffset << "," << std::endl;
/* maxInterpolationOffset */
    structBody << "\t" << structInfo->maxInterpolationOffset << "," << std::endl;
/* subPixelInterpolationOffsetBits */
    structBody << "\t" << structInfo->subPixelInterpolationOffsetBits << "," << std::endl;
/* maxFramebufferWidth */
    structBody << "\t" << structInfo->maxFramebufferWidth << "," << std::endl;
/* maxFramebufferHeight */
    structBody << "\t" << structInfo->maxFramebufferHeight << "," << std::endl;
/* maxFramebufferLayers */
    structBody << "\t" << structInfo->maxFramebufferLayers << "," << std::endl;
/* framebufferColorSampleCounts */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->framebufferColorSampleCounts << ")" << "," << std::endl;
/* framebufferDepthSampleCounts */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->framebufferDepthSampleCounts << ")" << "," << std::endl;
/* framebufferStencilSampleCounts */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->framebufferStencilSampleCounts << ")" << "," << std::endl;
/* framebufferNoAttachmentsSampleCounts */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->framebufferNoAttachmentsSampleCounts << ")" << "," << std::endl;
/* maxColorAttachments */
    structBody << "\t" << structInfo->maxColorAttachments << "," << std::endl;
/* sampledImageColorSampleCounts */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->sampledImageColorSampleCounts << ")" << "," << std::endl;
/* sampledImageIntegerSampleCounts */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->sampledImageIntegerSampleCounts << ")" << "," << std::endl;
/* sampledImageDepthSampleCounts */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->sampledImageDepthSampleCounts << ")" << "," << std::endl;
/* sampledImageStencilSampleCounts */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->sampledImageStencilSampleCounts << ")" << "," << std::endl;
/* storageImageSampleCounts */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->storageImageSampleCounts << ")" << "," << std::endl;
/* maxSampleMaskWords */
    structBody << "\t" << structInfo->maxSampleMaskWords << "," << std::endl;
/* timestampComputeAndGraphics */
    structBody << "\t" << structInfo->timestampComputeAndGraphics << "," << std::endl;
/* timestampPeriod */
    structBody << "\t" << structInfo->timestampPeriod << "," << std::endl;
/* maxClipDistances */
    structBody << "\t" << structInfo->maxClipDistances << "," << std::endl;
/* maxCullDistances */
    structBody << "\t" << structInfo->maxCullDistances << "," << std::endl;
/* maxCombinedClipAndCullDistances */
    structBody << "\t" << structInfo->maxCombinedClipAndCullDistances << "," << std::endl;
/* discreteQueuePriorities */
    structBody << "\t" << structInfo->discreteQueuePriorities << "," << std::endl;
/* pointSizeRange */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->pointSizeRange[0]), 2) << "," << std::endl;
/* lineWidthRange */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->lineWidthRange[0]), 2) << "," << std::endl;
/* pointSizeGranularity */
    structBody << "\t" << structInfo->pointSizeGranularity << "," << std::endl;
/* lineWidthGranularity */
    structBody << "\t" << structInfo->lineWidthGranularity << "," << std::endl;
/* strictLines */
    structBody << "\t" << structInfo->strictLines << "," << std::endl;
/* standardSampleLocations */
    structBody << "\t" << structInfo->standardSampleLocations << "," << std::endl;
/* optimalBufferCopyOffsetAlignment */
    structBody << "\t" << structInfo->optimalBufferCopyOffsetAlignment << "UL" << "," << std::endl;
/* optimalBufferCopyRowPitchAlignment */
    structBody << "\t" << structInfo->optimalBufferCopyRowPitchAlignment << "UL" << "," << std::endl;
/* nonCoherentAtomSize */
    structBody << "\t" << structInfo->nonCoherentAtomSize << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceLimits");
    out << "VkPhysicalDeviceLimits " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMemoryProperties(std::ostream &out, const VkPhysicalDeviceMemoryProperties* structInfo, Decoded_VkPhysicalDeviceMemoryProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string memoryTypesArray = "memoryTypes_" + std::to_string(consumer.getNextId());
    std::string memoryTypesNames;
    for (uint32_t idx = 0; idx < structInfo->memoryTypeCount; idx++) {
        std::string varName = "NULL";
        if (structInfo->memoryTypes + idx != NULL) {
            varName = GenerateStruct_VkMemoryType(out,
                                                     structInfo->memoryTypes + idx,
                                                     metainfo->memoryTypes->GetMetaStructPointer() + idx,
                                                     consumer);
        }
        memoryTypesNames += varName + ", ";
    }
    out << "VkMemoryType " << memoryTypesArray << "[] = {" << memoryTypesNames << "};" << std::endl;
    std::string memoryHeapsArray = "memoryHeaps_" + std::to_string(consumer.getNextId());
    std::string memoryHeapsNames;
    for (uint32_t idx = 0; idx < structInfo->memoryHeapCount; idx++) {
        std::string varName = "NULL";
        if (structInfo->memoryHeaps + idx != NULL) {
            varName = GenerateStruct_VkMemoryHeap(out,
                                                     structInfo->memoryHeaps + idx,
                                                     metainfo->memoryHeaps->GetMetaStructPointer() + idx,
                                                     consumer);
        }
        memoryHeapsNames += varName + ", ";
    }
    out << "VkMemoryHeap " << memoryHeapsArray << "[] = {" << memoryHeapsNames << "};" << std::endl;
/* memoryTypeCount */
    structBody << "\t" << structInfo->memoryTypeCount << "," << std::endl;
/* memoryTypes */
    structBody << "\t" << memoryTypesArray << "," << std::endl;
/* memoryHeapCount */
    structBody << "\t" << structInfo->memoryHeapCount << "," << std::endl;
/* memoryHeaps */
    structBody << "\t" << memoryHeapsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMemoryProperties");
    out << "VkPhysicalDeviceMemoryProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceSparseProperties(std::ostream &out, const VkPhysicalDeviceSparseProperties* structInfo, Decoded_VkPhysicalDeviceSparseProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* residencyStandard2DBlockShape */
    structBody << "\t" << structInfo->residencyStandard2DBlockShape << "," << std::endl;
/* residencyStandard2DMultisampleBlockShape */
    structBody << "\t" << structInfo->residencyStandard2DMultisampleBlockShape << "," << std::endl;
/* residencyStandard3DBlockShape */
    structBody << "\t" << structInfo->residencyStandard3DBlockShape << "," << std::endl;
/* residencyAlignedMipSize */
    structBody << "\t" << structInfo->residencyAlignedMipSize << "," << std::endl;
/* residencyNonResidentStrict */
    structBody << "\t" << structInfo->residencyNonResidentStrict << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceSparseProperties");
    out << "VkPhysicalDeviceSparseProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceProperties(std::ostream &out, const VkPhysicalDeviceProperties* structInfo, Decoded_VkPhysicalDeviceProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string limitsInfoVar = GenerateStruct_VkPhysicalDeviceLimits(out,
                                                               &structInfo->limits,
                                                               metainfo->limits,
                                                               consumer);
    std::string sparsePropertiesInfoVar = GenerateStruct_VkPhysicalDeviceSparseProperties(out,
                                                                         &structInfo->sparseProperties,
                                                                         metainfo->sparseProperties,
                                                                         consumer);
/* apiVersion */
    structBody << "\t" << structInfo->apiVersion << "," << std::endl;
/* driverVersion */
    structBody << "\t" << structInfo->driverVersion << "," << std::endl;
/* vendorID */
    structBody << "\t" << structInfo->vendorID << "," << std::endl;
/* deviceID */
    structBody << "\t" << structInfo->deviceID << "," << std::endl;
/* deviceType */
    structBody << "\t" << "VkPhysicalDeviceType(" << structInfo->deviceType << ")" << "," << std::endl;
/* deviceName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->deviceName) << "," << std::endl;
/* pipelineCacheUUID */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->pipelineCacheUUID[0]), VK_UUID_SIZE) << "," << std::endl;
/* limits */
    structBody << "\t" << limitsInfoVar << "," << std::endl;
/* sparseProperties */
    structBody << "\t" << sparsePropertiesInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceProperties");
    out << "VkPhysicalDeviceProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkQueueFamilyProperties(std::ostream &out, const VkQueueFamilyProperties* structInfo, Decoded_VkQueueFamilyProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string minImageTransferGranularityInfoVar = GenerateStruct_VkExtent3D(out,
                                                                                    &structInfo->minImageTransferGranularity,
                                                                                    metainfo->minImageTransferGranularity,
                                                                                    consumer);
/* queueFlags */
    structBody << "\t" << "VkQueueFlags(" << structInfo->queueFlags << ")" << "," << std::endl;
/* queueCount */
    structBody << "\t" << structInfo->queueCount << "," << std::endl;
/* timestampValidBits */
    structBody << "\t" << structInfo->timestampValidBits << "," << std::endl;
/* minImageTransferGranularity */
    structBody << "\t" << minImageTransferGranularityInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "queueFamilyProperties");
    out << "VkQueueFamilyProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceQueueCreateInfo(std::ostream &out, const VkDeviceQueueCreateInfo* structInfo, Decoded_VkDeviceQueueCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pQueuePrioritiesArray = "NULL";
    if (structInfo->pQueuePriorities != NULL) {
        pQueuePrioritiesArray = "pQueuePriorities_" + std::to_string(consumer.getNextId());
        out << "float " << pQueuePrioritiesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pQueuePriorities, structInfo->queueCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDeviceQueueCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* queueFamilyIndex */
    structBody << "\t" << structInfo->queueFamilyIndex << "," << std::endl;
/* queueCount */
    structBody << "\t" << structInfo->queueCount << "," << std::endl;
/* pQueuePriorities */
    structBody << "\t" << pQueuePrioritiesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceQueueCreateInfo");
    out << "VkDeviceQueueCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceCreateInfo(std::ostream &out, const VkDeviceCreateInfo* structInfo, Decoded_VkDeviceCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pQueueCreateInfosArray = "NULL";
    if (structInfo->pQueueCreateInfos != NULL) {
        pQueueCreateInfosArray = "pQueueCreateInfos_" + std::to_string(consumer.getNextId());
        std::string pQueueCreateInfosNames;
        for (uint32_t idx = 0; idx < structInfo->queueCreateInfoCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pQueueCreateInfos + idx != NULL) {
                varName = GenerateStruct_VkDeviceQueueCreateInfo(out,
                                                         structInfo->pQueueCreateInfos + idx,
                                                         metainfo->pQueueCreateInfos->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pQueueCreateInfosNames += varName + ", ";
        }
        out << "VkDeviceQueueCreateInfo " << pQueueCreateInfosArray << "[] = {" << pQueueCreateInfosNames << "};" << std::endl;
    }
    std::string ppEnabledLayerNamesVar = "NULL";
    if (structInfo->enabledLayerCount) {
    ppEnabledLayerNamesVar = "ppEnabledLayerNames_" + std::to_string(consumer.getNextId());
    out << "const char* " << ppEnabledLayerNamesVar << "[] = " << VulkanCppConsumerBase::escapeStringArray(structInfo->ppEnabledLayerNames, structInfo->enabledLayerCount) << ";" << std::endl;
    }
    std::string ppEnabledExtensionNamesVar = "NULL";
    if (structInfo->enabledExtensionCount) {
    ppEnabledExtensionNamesVar = "ppEnabledExtensionNames_" + std::to_string(consumer.getNextId());
    out << "const char* " << ppEnabledExtensionNamesVar << "[] = " << VulkanCppConsumerBase::escapeStringArray(structInfo->ppEnabledExtensionNames, structInfo->enabledExtensionCount) << ";" << std::endl;
    }
    std::string pEnabledFeaturesStruct = "NULL";
    if (structInfo->pEnabledFeatures != NULL) {
        pEnabledFeaturesStruct = GenerateStruct_VkPhysicalDeviceFeatures(out,
                                                                structInfo->pEnabledFeatures,
                                                                metainfo->pEnabledFeatures->GetMetaStructPointer(),
                                                                consumer);
        pEnabledFeaturesStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDeviceCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* queueCreateInfoCount */
    structBody << "\t" << structInfo->queueCreateInfoCount << "," << std::endl;
/* pQueueCreateInfos */
    structBody << "\t" << pQueueCreateInfosArray << "," << std::endl;
/* enabledLayerCount */
    structBody << "\t" << structInfo->enabledLayerCount << "," << std::endl;
/* ppEnabledLayerNames */
    structBody << "\t" << ppEnabledLayerNamesVar << "," << std::endl;
/* enabledExtensionCount */
    structBody << "\t" << structInfo->enabledExtensionCount << "," << std::endl;
/* ppEnabledExtensionNames */
    structBody << "\t" << ppEnabledExtensionNamesVar << "," << std::endl;
/* pEnabledFeatures */
    structBody << "\t" << pEnabledFeaturesStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceCreateInfo");
    out << "VkDeviceCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExtensionProperties(std::ostream &out, const VkExtensionProperties* structInfo, Decoded_VkExtensionProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* extensionName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->extensionName) << "," << std::endl;
/* specVersion */
    structBody << "\t" << structInfo->specVersion << "," ;
    std::string varname = consumer.AddStruct(structBody, "extensionProperties");
    out << "VkExtensionProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkLayerProperties(std::ostream &out, const VkLayerProperties* structInfo, Decoded_VkLayerProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* layerName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->layerName) << "," << std::endl;
/* specVersion */
    structBody << "\t" << structInfo->specVersion << "," << std::endl;
/* implementationVersion */
    structBody << "\t" << structInfo->implementationVersion << "," << std::endl;
/* description */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->description) << "," ;
    std::string varname = consumer.AddStruct(structBody, "layerProperties");
    out << "VkLayerProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubmitInfo(std::ostream &out, const VkSubmitInfo* structInfo, Decoded_VkSubmitInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pWaitSemaphoresArray = "NULL";
    if (metainfo->pWaitSemaphores.GetPointer() != NULL && structInfo->waitSemaphoreCount > 0) {
        pWaitSemaphoresArray = "pWaitSemaphoresArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_SEMAPHORE));
        std::string pWaitSemaphoresValues = toStringJoin(metainfo->pWaitSemaphores.GetPointer(),
                                                         metainfo->pWaitSemaphores.GetPointer() + structInfo->waitSemaphoreCount,
                                                         [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                         ", ");
        if (structInfo->waitSemaphoreCount == 1) {
            pWaitSemaphoresArray = "&" + pWaitSemaphoresValues;
        } else if (structInfo->waitSemaphoreCount > 1) {
            out << "VkSemaphore " << pWaitSemaphoresArray << "[] = {" << pWaitSemaphoresValues << "};" << std::endl;
        }
    }
    std::string pWaitDstStageMaskValues;
    std::string pWaitDstStageMaskArray = "NULL";
    if (structInfo->pWaitDstStageMask != NULL) {
        for (uint32_t idx = 0; idx < structInfo->waitSemaphoreCount; idx++) {
            pWaitDstStageMaskValues += util::ToString<VkPipelineStageFlags>(structInfo->pWaitDstStageMask[idx]) + ", ";
        }
        pWaitDstStageMaskArray = "pWaitDstStageMask_" + std::to_string(consumer.getNextId());
        out << "VkPipelineStageFlags " << pWaitDstStageMaskArray << "[] = {" << pWaitDstStageMaskValues << "};" << std::endl;
    }
    std::string pCommandBuffersArray = "NULL";
    if (metainfo->pCommandBuffers.GetPointer() != NULL && structInfo->commandBufferCount > 0) {
        pCommandBuffersArray = "pCommandBuffersArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_COMMAND_BUFFER));
        std::string pCommandBuffersValues = toStringJoin(metainfo->pCommandBuffers.GetPointer(),
                                                         metainfo->pCommandBuffers.GetPointer() + structInfo->commandBufferCount,
                                                         [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                         ", ");
        if (structInfo->commandBufferCount == 1) {
            pCommandBuffersArray = "&" + pCommandBuffersValues;
        } else if (structInfo->commandBufferCount > 1) {
            out << "VkCommandBuffer " << pCommandBuffersArray << "[] = {" << pCommandBuffersValues << "};" << std::endl;
        }
    }
    std::string pSignalSemaphoresArray = "NULL";
    if (metainfo->pSignalSemaphores.GetPointer() != NULL && structInfo->signalSemaphoreCount > 0) {
        pSignalSemaphoresArray = "pSignalSemaphoresArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_SEMAPHORE));
        std::string pSignalSemaphoresValues = toStringJoin(metainfo->pSignalSemaphores.GetPointer(),
                                                           metainfo->pSignalSemaphores.GetPointer() + structInfo->signalSemaphoreCount,
                                                           [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                           ", ");
        if (structInfo->signalSemaphoreCount == 1) {
            pSignalSemaphoresArray = "&" + pSignalSemaphoresValues;
        } else if (structInfo->signalSemaphoreCount > 1) {
            out << "VkSemaphore " << pSignalSemaphoresArray << "[] = {" << pSignalSemaphoresValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* waitSemaphoreCount */
    structBody << "\t" << structInfo->waitSemaphoreCount << "," << std::endl;
/* pWaitSemaphores */
    structBody << "\t" << pWaitSemaphoresArray << "," << std::endl;
/* pWaitDstStageMask */
    structBody << "\t" << pWaitDstStageMaskArray << "," << std::endl;
/* commandBufferCount */
    structBody << "\t" << structInfo->commandBufferCount << "," << std::endl;
/* pCommandBuffers */
    structBody << "\t" << pCommandBuffersArray << "," << std::endl;
/* signalSemaphoreCount */
    structBody << "\t" << structInfo->signalSemaphoreCount << "," << std::endl;
/* pSignalSemaphores */
    structBody << "\t" << pSignalSemaphoresArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "submitInfo");
    out << "VkSubmitInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMappedMemoryRange(std::ostream &out, const VkMappedMemoryRange* structInfo, Decoded_VkMappedMemoryRange* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "mappedMemoryRange");
    out << "VkMappedMemoryRange " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryAllocateInfo(std::ostream &out, const VkMemoryAllocateInfo* structInfo, Decoded_VkMemoryAllocateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* allocationSize */
    structBody << "\t" << structInfo->allocationSize << "UL" << "," << std::endl;
/* memoryTypeIndex */
    structBody << "\t" << structInfo->memoryTypeIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryAllocateInfo");
    out << "VkMemoryAllocateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryRequirements(std::ostream &out, const VkMemoryRequirements* structInfo, Decoded_VkMemoryRequirements* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," << std::endl;
/* alignment */
    structBody << "\t" << structInfo->alignment << "UL" << "," << std::endl;
/* memoryTypeBits */
    structBody << "\t" << structInfo->memoryTypeBits << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryRequirements");
    out << "VkMemoryRequirements " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSparseMemoryBind(std::ostream &out, const VkSparseMemoryBind* structInfo, Decoded_VkSparseMemoryBind* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* resourceOffset */
    structBody << "\t" << structInfo->resourceOffset << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," << std::endl;
/* memoryOffset */
    structBody << "\t" << structInfo->memoryOffset << "UL" << "," << std::endl;
/* flags */
    structBody << "\t" << "VkSparseMemoryBindFlags(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "sparseMemoryBind");
    out << "VkSparseMemoryBind " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSparseBufferMemoryBindInfo(std::ostream &out, const VkSparseBufferMemoryBindInfo* structInfo, Decoded_VkSparseBufferMemoryBindInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pBindsArray = "NULL";
    if (structInfo->pBinds != NULL) {
        pBindsArray = "pBinds_" + std::to_string(consumer.getNextId());
        std::string pBindsNames;
        for (uint32_t idx = 0; idx < structInfo->bindCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pBinds + idx != NULL) {
                varName = GenerateStruct_VkSparseMemoryBind(out,
                                                         structInfo->pBinds + idx,
                                                         metainfo->pBinds->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pBindsNames += varName + ", ";
        }
        out << "VkSparseMemoryBind " << pBindsArray << "[] = {" << pBindsNames << "};" << std::endl;
    }
/* buffer */
    structBody << "\t" << consumer.GetHandle(metainfo->buffer) << "," << std::endl;
/* bindCount */
    structBody << "\t" << structInfo->bindCount << "," << std::endl;
/* pBinds */
    structBody << "\t" << pBindsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "sparseBufferMemoryBindInfo");
    out << "VkSparseBufferMemoryBindInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSparseImageOpaqueMemoryBindInfo(std::ostream &out, const VkSparseImageOpaqueMemoryBindInfo* structInfo, Decoded_VkSparseImageOpaqueMemoryBindInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pBindsArray = "NULL";
    if (structInfo->pBinds != NULL) {
        pBindsArray = "pBinds_" + std::to_string(consumer.getNextId());
        std::string pBindsNames;
        for (uint32_t idx = 0; idx < structInfo->bindCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pBinds + idx != NULL) {
                varName = GenerateStruct_VkSparseMemoryBind(out,
                                                         structInfo->pBinds + idx,
                                                         metainfo->pBinds->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pBindsNames += varName + ", ";
        }
        out << "VkSparseMemoryBind " << pBindsArray << "[] = {" << pBindsNames << "};" << std::endl;
    }
/* image */
    structBody << "\t" << consumer.GetHandle(metainfo->image) << "," << std::endl;
/* bindCount */
    structBody << "\t" << structInfo->bindCount << "," << std::endl;
/* pBinds */
    structBody << "\t" << pBindsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "sparseImageOpaqueMemoryBindInfo");
    out << "VkSparseImageOpaqueMemoryBindInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageSubresource(std::ostream &out, const VkImageSubresource* structInfo, Decoded_VkImageSubresource* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* aspectMask */
    structBody << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
/* mipLevel */
    structBody << "\t" << structInfo->mipLevel << "," << std::endl;
/* arrayLayer */
    structBody << "\t" << structInfo->arrayLayer << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageSubresource");
    out << "VkImageSubresource " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSparseImageMemoryBind(std::ostream &out, const VkSparseImageMemoryBind* structInfo, Decoded_VkSparseImageMemoryBind* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string subresourceInfoVar = GenerateStruct_VkImageSubresource(out,
                                                                    &structInfo->subresource,
                                                                    metainfo->subresource,
                                                                    consumer);
    std::string offsetInfoVar = GenerateStruct_VkOffset3D(out,
                                                               &structInfo->offset,
                                                               metainfo->offset,
                                                               consumer);
    std::string extentInfoVar = GenerateStruct_VkExtent3D(out,
                                                               &structInfo->extent,
                                                               metainfo->extent,
                                                               consumer);
/* subresource */
    structBody << "\t" << subresourceInfoVar << "," << std::endl;
/* offset */
    structBody << "\t" << offsetInfoVar << "," << std::endl;
/* extent */
    structBody << "\t" << extentInfoVar << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," << std::endl;
/* memoryOffset */
    structBody << "\t" << structInfo->memoryOffset << "UL" << "," << std::endl;
/* flags */
    structBody << "\t" << "VkSparseMemoryBindFlags(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "sparseImageMemoryBind");
    out << "VkSparseImageMemoryBind " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSparseImageMemoryBindInfo(std::ostream &out, const VkSparseImageMemoryBindInfo* structInfo, Decoded_VkSparseImageMemoryBindInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pBindsArray = "NULL";
    if (structInfo->pBinds != NULL) {
        pBindsArray = "pBinds_" + std::to_string(consumer.getNextId());
        std::string pBindsNames;
        for (uint32_t idx = 0; idx < structInfo->bindCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pBinds + idx != NULL) {
                varName = GenerateStruct_VkSparseImageMemoryBind(out,
                                                         structInfo->pBinds + idx,
                                                         metainfo->pBinds->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pBindsNames += varName + ", ";
        }
        out << "VkSparseImageMemoryBind " << pBindsArray << "[] = {" << pBindsNames << "};" << std::endl;
    }
/* image */
    structBody << "\t" << consumer.GetHandle(metainfo->image) << "," << std::endl;
/* bindCount */
    structBody << "\t" << structInfo->bindCount << "," << std::endl;
/* pBinds */
    structBody << "\t" << pBindsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "sparseImageMemoryBindInfo");
    out << "VkSparseImageMemoryBindInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBindSparseInfo(std::ostream &out, const VkBindSparseInfo* structInfo, Decoded_VkBindSparseInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pWaitSemaphoresArray = "NULL";
    if (metainfo->pWaitSemaphores.GetPointer() != NULL && structInfo->waitSemaphoreCount > 0) {
        pWaitSemaphoresArray = "pWaitSemaphoresArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_SEMAPHORE));
        std::string pWaitSemaphoresValues = toStringJoin(metainfo->pWaitSemaphores.GetPointer(),
                                                         metainfo->pWaitSemaphores.GetPointer() + structInfo->waitSemaphoreCount,
                                                         [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                         ", ");
        if (structInfo->waitSemaphoreCount == 1) {
            pWaitSemaphoresArray = "&" + pWaitSemaphoresValues;
        } else if (structInfo->waitSemaphoreCount > 1) {
            out << "VkSemaphore " << pWaitSemaphoresArray << "[] = {" << pWaitSemaphoresValues << "};" << std::endl;
        }
    }
    std::string pBufferBindsArray = "NULL";
    if (structInfo->pBufferBinds != NULL) {
        pBufferBindsArray = "pBufferBinds_" + std::to_string(consumer.getNextId());
        std::string pBufferBindsNames;
        for (uint32_t idx = 0; idx < structInfo->bufferBindCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pBufferBinds + idx != NULL) {
                varName = GenerateStruct_VkSparseBufferMemoryBindInfo(out,
                                                         structInfo->pBufferBinds + idx,
                                                         metainfo->pBufferBinds->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pBufferBindsNames += varName + ", ";
        }
        out << "VkSparseBufferMemoryBindInfo " << pBufferBindsArray << "[] = {" << pBufferBindsNames << "};" << std::endl;
    }
    std::string pImageOpaqueBindsArray = "NULL";
    if (structInfo->pImageOpaqueBinds != NULL) {
        pImageOpaqueBindsArray = "pImageOpaqueBinds_" + std::to_string(consumer.getNextId());
        std::string pImageOpaqueBindsNames;
        for (uint32_t idx = 0; idx < structInfo->imageOpaqueBindCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pImageOpaqueBinds + idx != NULL) {
                varName = GenerateStruct_VkSparseImageOpaqueMemoryBindInfo(out,
                                                         structInfo->pImageOpaqueBinds + idx,
                                                         metainfo->pImageOpaqueBinds->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pImageOpaqueBindsNames += varName + ", ";
        }
        out << "VkSparseImageOpaqueMemoryBindInfo " << pImageOpaqueBindsArray << "[] = {" << pImageOpaqueBindsNames << "};" << std::endl;
    }
    std::string pImageBindsArray = "NULL";
    if (structInfo->pImageBinds != NULL) {
        pImageBindsArray = "pImageBinds_" + std::to_string(consumer.getNextId());
        std::string pImageBindsNames;
        for (uint32_t idx = 0; idx < structInfo->imageBindCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pImageBinds + idx != NULL) {
                varName = GenerateStruct_VkSparseImageMemoryBindInfo(out,
                                                         structInfo->pImageBinds + idx,
                                                         metainfo->pImageBinds->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pImageBindsNames += varName + ", ";
        }
        out << "VkSparseImageMemoryBindInfo " << pImageBindsArray << "[] = {" << pImageBindsNames << "};" << std::endl;
    }
    std::string pSignalSemaphoresArray = "NULL";
    if (metainfo->pSignalSemaphores.GetPointer() != NULL && structInfo->signalSemaphoreCount > 0) {
        pSignalSemaphoresArray = "pSignalSemaphoresArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_SEMAPHORE));
        std::string pSignalSemaphoresValues = toStringJoin(metainfo->pSignalSemaphores.GetPointer(),
                                                           metainfo->pSignalSemaphores.GetPointer() + structInfo->signalSemaphoreCount,
                                                           [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                           ", ");
        if (structInfo->signalSemaphoreCount == 1) {
            pSignalSemaphoresArray = "&" + pSignalSemaphoresValues;
        } else if (structInfo->signalSemaphoreCount > 1) {
            out << "VkSemaphore " << pSignalSemaphoresArray << "[] = {" << pSignalSemaphoresValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* waitSemaphoreCount */
    structBody << "\t" << structInfo->waitSemaphoreCount << "," << std::endl;
/* pWaitSemaphores */
    structBody << "\t" << pWaitSemaphoresArray << "," << std::endl;
/* bufferBindCount */
    structBody << "\t" << structInfo->bufferBindCount << "," << std::endl;
/* pBufferBinds */
    structBody << "\t" << pBufferBindsArray << "," << std::endl;
/* imageOpaqueBindCount */
    structBody << "\t" << structInfo->imageOpaqueBindCount << "," << std::endl;
/* pImageOpaqueBinds */
    structBody << "\t" << pImageOpaqueBindsArray << "," << std::endl;
/* imageBindCount */
    structBody << "\t" << structInfo->imageBindCount << "," << std::endl;
/* pImageBinds */
    structBody << "\t" << pImageBindsArray << "," << std::endl;
/* signalSemaphoreCount */
    structBody << "\t" << structInfo->signalSemaphoreCount << "," << std::endl;
/* pSignalSemaphores */
    structBody << "\t" << pSignalSemaphoresArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "bindSparseInfo");
    out << "VkBindSparseInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSparseImageFormatProperties(std::ostream &out, const VkSparseImageFormatProperties* structInfo, Decoded_VkSparseImageFormatProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string imageGranularityInfoVar = GenerateStruct_VkExtent3D(out,
                                                                         &structInfo->imageGranularity,
                                                                         metainfo->imageGranularity,
                                                                         consumer);
/* aspectMask */
    structBody << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
/* imageGranularity */
    structBody << "\t" << imageGranularityInfoVar << "," << std::endl;
/* flags */
    structBody << "\t" << "VkSparseImageFormatFlags(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "sparseImageFormatProperties");
    out << "VkSparseImageFormatProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSparseImageMemoryRequirements(std::ostream &out, const VkSparseImageMemoryRequirements* structInfo, Decoded_VkSparseImageMemoryRequirements* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string formatPropertiesInfoVar = GenerateStruct_VkSparseImageFormatProperties(out,
                                                                         &structInfo->formatProperties,
                                                                         metainfo->formatProperties,
                                                                         consumer);
/* formatProperties */
    structBody << "\t" << formatPropertiesInfoVar << "," << std::endl;
/* imageMipTailFirstLod */
    structBody << "\t" << structInfo->imageMipTailFirstLod << "," << std::endl;
/* imageMipTailSize */
    structBody << "\t" << structInfo->imageMipTailSize << "UL" << "," << std::endl;
/* imageMipTailOffset */
    structBody << "\t" << structInfo->imageMipTailOffset << "UL" << "," << std::endl;
/* imageMipTailStride */
    structBody << "\t" << structInfo->imageMipTailStride << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "sparseImageMemoryRequirements");
    out << "VkSparseImageMemoryRequirements " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkFenceCreateInfo(std::ostream &out, const VkFenceCreateInfo* structInfo, Decoded_VkFenceCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkFenceCreateFlags(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "fenceCreateInfo");
    out << "VkFenceCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSemaphoreCreateInfo(std::ostream &out, const VkSemaphoreCreateInfo* structInfo, Decoded_VkSemaphoreCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkSemaphoreCreateFlags(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "semaphoreCreateInfo");
    out << "VkSemaphoreCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkEventCreateInfo(std::ostream &out, const VkEventCreateInfo* structInfo, Decoded_VkEventCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkEventCreateFlags(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "eventCreateInfo");
    out << "VkEventCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkQueryPoolCreateInfo(std::ostream &out, const VkQueryPoolCreateInfo* structInfo, Decoded_VkQueryPoolCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkQueryPoolCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* queryType */
    structBody << "\t" << "VkQueryType(" << structInfo->queryType << ")" << "," << std::endl;
/* queryCount */
    structBody << "\t" << structInfo->queryCount << "," << std::endl;
/* pipelineStatistics */
    structBody << "\t" << "VkQueryPipelineStatisticFlags(" << structInfo->pipelineStatistics << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "queryPoolCreateInfo");
    out << "VkQueryPoolCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBufferCreateInfo(std::ostream &out, const VkBufferCreateInfo* structInfo, Decoded_VkBufferCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pQueueFamilyIndicesArray = "NULL";
    if (structInfo->pQueueFamilyIndices != NULL) {
        pQueueFamilyIndicesArray = "pQueueFamilyIndices_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pQueueFamilyIndicesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pQueueFamilyIndices, structInfo->queueFamilyIndexCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkBufferCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," << std::endl;
/* usage */
    structBody << "\t" << "VkBufferUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
/* sharingMode */
    structBody << "\t" << "VkSharingMode(" << structInfo->sharingMode << ")" << "," << std::endl;
/* queueFamilyIndexCount */
    structBody << "\t" << structInfo->queueFamilyIndexCount << "," << std::endl;
/* pQueueFamilyIndices */
    structBody << "\t" << pQueueFamilyIndicesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "bufferCreateInfo");
    out << "VkBufferCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBufferViewCreateInfo(std::ostream &out, const VkBufferViewCreateInfo* structInfo, Decoded_VkBufferViewCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkBufferViewCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* buffer */
    structBody << "\t" << consumer.GetHandle(metainfo->buffer) << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "UL" << "," << std::endl;
/* range */
    structBody << "\t" << structInfo->range << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "bufferViewCreateInfo");
    out << "VkBufferViewCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageCreateInfo(std::ostream &out, const VkImageCreateInfo* structInfo, Decoded_VkImageCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string extentInfoVar = GenerateStruct_VkExtent3D(out,
                                                               &structInfo->extent,
                                                               metainfo->extent,
                                                               consumer);
    std::string pQueueFamilyIndicesArray = "NULL";
    if (structInfo->pQueueFamilyIndices != NULL) {
        pQueueFamilyIndicesArray = "pQueueFamilyIndices_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pQueueFamilyIndicesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pQueueFamilyIndices, structInfo->queueFamilyIndexCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkImageCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* imageType */
    structBody << "\t" << "VkImageType(" << structInfo->imageType << ")" << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
/* extent */
    structBody << "\t" << extentInfoVar << "," << std::endl;
/* mipLevels */
    structBody << "\t" << structInfo->mipLevels << "," << std::endl;
/* arrayLayers */
    structBody << "\t" << structInfo->arrayLayers << "," << std::endl;
/* samples */
    structBody << "\t" << "VkSampleCountFlagBits(" << structInfo->samples << ")" << "," << std::endl;
/* tiling */
    structBody << "\t" << "VkImageTiling(" << structInfo->tiling << ")" << "," << std::endl;
/* usage */
    structBody << "\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
/* sharingMode */
    structBody << "\t" << "VkSharingMode(" << structInfo->sharingMode << ")" << "," << std::endl;
/* queueFamilyIndexCount */
    structBody << "\t" << structInfo->queueFamilyIndexCount << "," << std::endl;
/* pQueueFamilyIndices */
    structBody << "\t" << pQueueFamilyIndicesArray << "," << std::endl;
/* initialLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->initialLayout << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageCreateInfo");
    out << "VkImageCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubresourceLayout(std::ostream &out, const VkSubresourceLayout* structInfo, Decoded_VkSubresourceLayout* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* offset */
    structBody << "\t" << structInfo->offset << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," << std::endl;
/* rowPitch */
    structBody << "\t" << structInfo->rowPitch << "UL" << "," << std::endl;
/* arrayPitch */
    structBody << "\t" << structInfo->arrayPitch << "UL" << "," << std::endl;
/* depthPitch */
    structBody << "\t" << structInfo->depthPitch << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "subresourceLayout");
    out << "VkSubresourceLayout " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkComponentMapping(std::ostream &out, const VkComponentMapping* structInfo, Decoded_VkComponentMapping* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* r */
    structBody << "\t" << "VkComponentSwizzle(" << structInfo->r << ")" << "," << std::endl;
/* g */
    structBody << "\t" << "VkComponentSwizzle(" << structInfo->g << ")" << "," << std::endl;
/* b */
    structBody << "\t" << "VkComponentSwizzle(" << structInfo->b << ")" << "," << std::endl;
/* a */
    structBody << "\t" << "VkComponentSwizzle(" << structInfo->a << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "componentMapping");
    out << "VkComponentMapping " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageViewCreateInfo(std::ostream &out, const VkImageViewCreateInfo* structInfo, Decoded_VkImageViewCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string componentsInfoVar = GenerateStruct_VkComponentMapping(out,
                                                                   &structInfo->components,
                                                                   metainfo->components,
                                                                   consumer);
    std::string subresourceRangeInfoVar = GenerateStruct_VkImageSubresourceRange(out,
                                                                         &structInfo->subresourceRange,
                                                                         metainfo->subresourceRange,
                                                                         consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkImageViewCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* image */
    structBody << "\t" << consumer.GetHandle(metainfo->image) << "," << std::endl;
/* viewType */
    structBody << "\t" << "VkImageViewType(" << structInfo->viewType << ")" << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
/* components */
    structBody << "\t" << componentsInfoVar << "," << std::endl;
/* subresourceRange */
    structBody << "\t" << subresourceRangeInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageViewCreateInfo");
    out << "VkImageViewCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkShaderModuleCreateInfo(std::ostream &out, const VkShaderModuleCreateInfo* structInfo, Decoded_VkShaderModuleCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pCodeArray = "NULL";
    if (structInfo->pCode != NULL) {
        pCodeArray = "pCode_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pCodeArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCode, structInfo->codeSize / 4) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkShaderModuleCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* codeSize */
    structBody << "\t" << structInfo->codeSize << "," << std::endl;
/* pCode */
    structBody << "\t" << pCodeArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "shaderModuleCreateInfo");
    out << "VkShaderModuleCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineCacheCreateInfo(std::ostream &out, const VkPipelineCacheCreateInfo* structInfo, Decoded_VkPipelineCacheCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pInitialDataArray = "NULL";
    if (structInfo->pInitialData != NULL) {
        std::string pInitialDataValues;
        for (uint32_t idx0 = 0; idx0 < structInfo->initialDataSize; ++idx0) {
            pInitialDataValues += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pInitialData)[idx0]) + ", ";
        }
        pInitialDataArray = "pInitialData_" + std::to_string(consumer.getNextId());
        out << "uint8_t " << pInitialDataArray << "[] = {" << pInitialDataValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineCacheCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* initialDataSize */
    structBody << "\t" << structInfo->initialDataSize << "," << std::endl;
/* pInitialData */
    structBody << "\t" << pInitialDataArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineCacheCreateInfo");
    out << "VkPipelineCacheCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSpecializationMapEntry(std::ostream &out, const VkSpecializationMapEntry* structInfo, Decoded_VkSpecializationMapEntry* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* constantID */
    structBody << "\t" << structInfo->constantID << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "," ;
    std::string varname = consumer.AddStruct(structBody, "specializationMapEntry");
    out << "VkSpecializationMapEntry " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSpecializationInfo(std::ostream &out, const VkSpecializationInfo* structInfo, Decoded_VkSpecializationInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pMapEntriesArray = "NULL";
    if (structInfo->pMapEntries != NULL) {
        pMapEntriesArray = "pMapEntries_" + std::to_string(consumer.getNextId());
        std::string pMapEntriesNames;
        for (uint32_t idx = 0; idx < structInfo->mapEntryCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pMapEntries + idx != NULL) {
                varName = GenerateStruct_VkSpecializationMapEntry(out,
                                                         structInfo->pMapEntries + idx,
                                                         metainfo->pMapEntries->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pMapEntriesNames += varName + ", ";
        }
        out << "VkSpecializationMapEntry " << pMapEntriesArray << "[] = {" << pMapEntriesNames << "};" << std::endl;
    }
    std::string pDataArray = "NULL";
    if (structInfo->pData != NULL) {
        std::string pDataValues;
        for (uint32_t idx0 = 0; idx0 < structInfo->dataSize; ++idx0) {
            pDataValues += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pData)[idx0]) + ", ";
        }
        pDataArray = "pData_" + std::to_string(consumer.getNextId());
        out << "uint8_t " << pDataArray << "[] = {" << pDataValues << "};" << std::endl;
    }
/* mapEntryCount */
    structBody << "\t" << structInfo->mapEntryCount << "," << std::endl;
/* pMapEntries */
    structBody << "\t" << pMapEntriesArray << "," << std::endl;
/* dataSize */
    structBody << "\t" << structInfo->dataSize << "," << std::endl;
/* pData */
    structBody << "\t" << pDataArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "specializationInfo");
    out << "VkSpecializationInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineShaderStageCreateInfo(std::ostream &out, const VkPipelineShaderStageCreateInfo* structInfo, Decoded_VkPipelineShaderStageCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pSpecializationInfoStruct = "NULL";
    if (structInfo->pSpecializationInfo != NULL) {
        pSpecializationInfoStruct = GenerateStruct_VkSpecializationInfo(out,
                                                                   structInfo->pSpecializationInfo,
                                                                   metainfo->pSpecializationInfo->GetMetaStructPointer(),
                                                                   consumer);
        pSpecializationInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineShaderStageCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* stage */
    structBody << "\t" << "VkShaderStageFlagBits(" << structInfo->stage << ")" << "," << std::endl;
/* module */
    structBody << "\t" << consumer.GetHandle(metainfo->module) << "," << std::endl;
/* pName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->pName) << "," << std::endl;
/* pSpecializationInfo */
    structBody << "\t" << pSpecializationInfoStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineShaderStageCreateInfo");
    out << "VkPipelineShaderStageCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkComputePipelineCreateInfo(std::ostream &out, const VkComputePipelineCreateInfo* structInfo, Decoded_VkComputePipelineCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string stageInfoVar = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                              &structInfo->stage,
                                                              metainfo->stage,
                                                              consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* stage */
    structBody << "\t" << stageInfoVar << "," << std::endl;
/* layout */
    structBody << "\t" << consumer.GetHandle(metainfo->layout) << "," << std::endl;
/* basePipelineHandle */
    structBody << "\t" << consumer.GetHandle(metainfo->basePipelineHandle) << "," << std::endl;
/* basePipelineIndex */
    structBody << "\t" << structInfo->basePipelineIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "computePipelineCreateInfo");
    out << "VkComputePipelineCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVertexInputBindingDescription(std::ostream &out, const VkVertexInputBindingDescription* structInfo, Decoded_VkVertexInputBindingDescription* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* binding */
    structBody << "\t" << structInfo->binding << "," << std::endl;
/* stride */
    structBody << "\t" << structInfo->stride << "," << std::endl;
/* inputRate */
    structBody << "\t" << "VkVertexInputRate(" << structInfo->inputRate << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "vertexInputBindingDescription");
    out << "VkVertexInputBindingDescription " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVertexInputAttributeDescription(std::ostream &out, const VkVertexInputAttributeDescription* structInfo, Decoded_VkVertexInputAttributeDescription* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* location */
    structBody << "\t" << structInfo->location << "," << std::endl;
/* binding */
    structBody << "\t" << structInfo->binding << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "," ;
    std::string varname = consumer.AddStruct(structBody, "vertexInputAttributeDescription");
    out << "VkVertexInputAttributeDescription " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineVertexInputStateCreateInfo(std::ostream &out, const VkPipelineVertexInputStateCreateInfo* structInfo, Decoded_VkPipelineVertexInputStateCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pVertexBindingDescriptionsArray = "NULL";
    if (structInfo->pVertexBindingDescriptions != NULL) {
        pVertexBindingDescriptionsArray = "pVertexBindingDescriptions_" + std::to_string(consumer.getNextId());
        std::string pVertexBindingDescriptionsNames;
        for (uint32_t idx = 0; idx < structInfo->vertexBindingDescriptionCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pVertexBindingDescriptions + idx != NULL) {
                varName = GenerateStruct_VkVertexInputBindingDescription(out,
                                                         structInfo->pVertexBindingDescriptions + idx,
                                                         metainfo->pVertexBindingDescriptions->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pVertexBindingDescriptionsNames += varName + ", ";
        }
        out << "VkVertexInputBindingDescription " << pVertexBindingDescriptionsArray << "[] = {" << pVertexBindingDescriptionsNames << "};" << std::endl;
    }
    std::string pVertexAttributeDescriptionsArray = "NULL";
    if (structInfo->pVertexAttributeDescriptions != NULL) {
        pVertexAttributeDescriptionsArray = "pVertexAttributeDescriptions_" + std::to_string(consumer.getNextId());
        std::string pVertexAttributeDescriptionsNames;
        for (uint32_t idx = 0; idx < structInfo->vertexAttributeDescriptionCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pVertexAttributeDescriptions + idx != NULL) {
                varName = GenerateStruct_VkVertexInputAttributeDescription(out,
                                                         structInfo->pVertexAttributeDescriptions + idx,
                                                         metainfo->pVertexAttributeDescriptions->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pVertexAttributeDescriptionsNames += varName + ", ";
        }
        out << "VkVertexInputAttributeDescription " << pVertexAttributeDescriptionsArray << "[] = {" << pVertexAttributeDescriptionsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineVertexInputStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* vertexBindingDescriptionCount */
    structBody << "\t" << structInfo->vertexBindingDescriptionCount << "," << std::endl;
/* pVertexBindingDescriptions */
    structBody << "\t" << pVertexBindingDescriptionsArray << "," << std::endl;
/* vertexAttributeDescriptionCount */
    structBody << "\t" << structInfo->vertexAttributeDescriptionCount << "," << std::endl;
/* pVertexAttributeDescriptions */
    structBody << "\t" << pVertexAttributeDescriptionsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineVertexInputStateCreateInfo");
    out << "VkPipelineVertexInputStateCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineInputAssemblyStateCreateInfo(std::ostream &out, const VkPipelineInputAssemblyStateCreateInfo* structInfo, Decoded_VkPipelineInputAssemblyStateCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineInputAssemblyStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* topology */
    structBody << "\t" << "VkPrimitiveTopology(" << structInfo->topology << ")" << "," << std::endl;
/* primitiveRestartEnable */
    structBody << "\t" << structInfo->primitiveRestartEnable << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineInputAssemblyStateCreateInfo");
    out << "VkPipelineInputAssemblyStateCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineTessellationStateCreateInfo(std::ostream &out, const VkPipelineTessellationStateCreateInfo* structInfo, Decoded_VkPipelineTessellationStateCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineTessellationStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* patchControlPoints */
    structBody << "\t" << structInfo->patchControlPoints << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineTessellationStateCreateInfo");
    out << "VkPipelineTessellationStateCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkViewport(std::ostream &out, const VkViewport* structInfo, Decoded_VkViewport* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* x */
    structBody << "\t" << structInfo->x << "," << std::endl;
/* y */
    structBody << "\t" << structInfo->y << "," << std::endl;
/* width */
    structBody << "\t" << structInfo->width << "," << std::endl;
/* height */
    structBody << "\t" << structInfo->height << "," << std::endl;
/* minDepth */
    structBody << "\t" << structInfo->minDepth << "," << std::endl;
/* maxDepth */
    structBody << "\t" << structInfo->maxDepth << "," ;
    std::string varname = consumer.AddStruct(structBody, "viewport");
    out << "VkViewport " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineViewportStateCreateInfo(std::ostream &out, const VkPipelineViewportStateCreateInfo* structInfo, Decoded_VkPipelineViewportStateCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pViewportsArray = "NULL";
    if (structInfo->pViewports != NULL) {
        pViewportsArray = "pViewports_" + std::to_string(consumer.getNextId());
        std::string pViewportsNames;
        for (uint32_t idx = 0; idx < structInfo->viewportCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pViewports + idx != NULL) {
                varName = GenerateStruct_VkViewport(out,
                                                         structInfo->pViewports + idx,
                                                         metainfo->pViewports->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pViewportsNames += varName + ", ";
        }
        out << "VkViewport " << pViewportsArray << "[] = {" << pViewportsNames << "};" << std::endl;
    }
    std::string pScissorsArray = "NULL";
    if (structInfo->pScissors != NULL) {
        pScissorsArray = "pScissors_" + std::to_string(consumer.getNextId());
        out << "VkRect2D " << pScissorsArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pScissors, structInfo->scissorCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineViewportStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* viewportCount */
    structBody << "\t" << structInfo->viewportCount << "," << std::endl;
/* pViewports */
    structBody << "\t" << pViewportsArray << "," << std::endl;
/* scissorCount */
    structBody << "\t" << structInfo->scissorCount << "," << std::endl;
/* pScissors */
    structBody << "\t" << pScissorsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineViewportStateCreateInfo");
    out << "VkPipelineViewportStateCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineRasterizationStateCreateInfo(std::ostream &out, const VkPipelineRasterizationStateCreateInfo* structInfo, Decoded_VkPipelineRasterizationStateCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineRasterizationStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* depthClampEnable */
    structBody << "\t" << structInfo->depthClampEnable << "," << std::endl;
/* rasterizerDiscardEnable */
    structBody << "\t" << structInfo->rasterizerDiscardEnable << "," << std::endl;
/* polygonMode */
    structBody << "\t" << "VkPolygonMode(" << structInfo->polygonMode << ")" << "," << std::endl;
/* cullMode */
    structBody << "\t" << "VkCullModeFlags(" << structInfo->cullMode << ")" << "," << std::endl;
/* frontFace */
    structBody << "\t" << "VkFrontFace(" << structInfo->frontFace << ")" << "," << std::endl;
/* depthBiasEnable */
    structBody << "\t" << structInfo->depthBiasEnable << "," << std::endl;
/* depthBiasConstantFactor */
    structBody << "\t" << structInfo->depthBiasConstantFactor << "," << std::endl;
/* depthBiasClamp */
    structBody << "\t" << structInfo->depthBiasClamp << "," << std::endl;
/* depthBiasSlopeFactor */
    structBody << "\t" << structInfo->depthBiasSlopeFactor << "," << std::endl;
/* lineWidth */
    structBody << "\t" << structInfo->lineWidth << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineRasterizationStateCreateInfo");
    out << "VkPipelineRasterizationStateCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineMultisampleStateCreateInfo(std::ostream &out, const VkPipelineMultisampleStateCreateInfo* structInfo, Decoded_VkPipelineMultisampleStateCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pSampleMaskArray = "NULL";
    if (structInfo->pSampleMask != NULL) {
        std::string pSampleMaskValues;
        for (uint32_t idx0 = 0; idx0 < (structInfo->rasterizationSamples + 31) / 32; ++idx0) {
            pSampleMaskValues += std::to_string(structInfo->pSampleMask[idx0]) + ", ";
        }
        pSampleMaskArray = "pSampleMask_" + std::to_string(consumer.getNextId());
        out << "VkSampleMask " << pSampleMaskArray << "[] = {" << pSampleMaskValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineMultisampleStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* rasterizationSamples */
    structBody << "\t" << "VkSampleCountFlagBits(" << structInfo->rasterizationSamples << ")" << "," << std::endl;
/* sampleShadingEnable */
    structBody << "\t" << structInfo->sampleShadingEnable << "," << std::endl;
/* minSampleShading */
    structBody << "\t" << structInfo->minSampleShading << "," << std::endl;
/* pSampleMask */
    structBody << "\t" << pSampleMaskArray << "," << std::endl;
/* alphaToCoverageEnable */
    structBody << "\t" << structInfo->alphaToCoverageEnable << "," << std::endl;
/* alphaToOneEnable */
    structBody << "\t" << structInfo->alphaToOneEnable << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineMultisampleStateCreateInfo");
    out << "VkPipelineMultisampleStateCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkStencilOpState(std::ostream &out, const VkStencilOpState* structInfo, Decoded_VkStencilOpState* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* failOp */
    structBody << "\t" << "VkStencilOp(" << structInfo->failOp << ")" << "," << std::endl;
/* passOp */
    structBody << "\t" << "VkStencilOp(" << structInfo->passOp << ")" << "," << std::endl;
/* depthFailOp */
    structBody << "\t" << "VkStencilOp(" << structInfo->depthFailOp << ")" << "," << std::endl;
/* compareOp */
    structBody << "\t" << "VkCompareOp(" << structInfo->compareOp << ")" << "," << std::endl;
/* compareMask */
    structBody << "\t" << structInfo->compareMask << "," << std::endl;
/* writeMask */
    structBody << "\t" << structInfo->writeMask << "," << std::endl;
/* reference */
    structBody << "\t" << structInfo->reference << "," ;
    std::string varname = consumer.AddStruct(structBody, "stencilOpState");
    out << "VkStencilOpState " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineDepthStencilStateCreateInfo(std::ostream &out, const VkPipelineDepthStencilStateCreateInfo* structInfo, Decoded_VkPipelineDepthStencilStateCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string frontInfoVar = GenerateStruct_VkStencilOpState(out,
                                                              &structInfo->front,
                                                              metainfo->front,
                                                              consumer);
    std::string backInfoVar = GenerateStruct_VkStencilOpState(out,
                                                             &structInfo->back,
                                                             metainfo->back,
                                                             consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineDepthStencilStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* depthTestEnable */
    structBody << "\t" << structInfo->depthTestEnable << "," << std::endl;
/* depthWriteEnable */
    structBody << "\t" << structInfo->depthWriteEnable << "," << std::endl;
/* depthCompareOp */
    structBody << "\t" << "VkCompareOp(" << structInfo->depthCompareOp << ")" << "," << std::endl;
/* depthBoundsTestEnable */
    structBody << "\t" << structInfo->depthBoundsTestEnable << "," << std::endl;
/* stencilTestEnable */
    structBody << "\t" << structInfo->stencilTestEnable << "," << std::endl;
/* front */
    structBody << "\t" << frontInfoVar << "," << std::endl;
/* back */
    structBody << "\t" << backInfoVar << "," << std::endl;
/* minDepthBounds */
    structBody << "\t" << structInfo->minDepthBounds << "," << std::endl;
/* maxDepthBounds */
    structBody << "\t" << structInfo->maxDepthBounds << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineDepthStencilStateCreateInfo");
    out << "VkPipelineDepthStencilStateCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineColorBlendAttachmentState(std::ostream &out, const VkPipelineColorBlendAttachmentState* structInfo, Decoded_VkPipelineColorBlendAttachmentState* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* blendEnable */
    structBody << "\t" << structInfo->blendEnable << "," << std::endl;
/* srcColorBlendFactor */
    structBody << "\t" << "VkBlendFactor(" << structInfo->srcColorBlendFactor << ")" << "," << std::endl;
/* dstColorBlendFactor */
    structBody << "\t" << "VkBlendFactor(" << structInfo->dstColorBlendFactor << ")" << "," << std::endl;
/* colorBlendOp */
    structBody << "\t" << "VkBlendOp(" << structInfo->colorBlendOp << ")" << "," << std::endl;
/* srcAlphaBlendFactor */
    structBody << "\t" << "VkBlendFactor(" << structInfo->srcAlphaBlendFactor << ")" << "," << std::endl;
/* dstAlphaBlendFactor */
    structBody << "\t" << "VkBlendFactor(" << structInfo->dstAlphaBlendFactor << ")" << "," << std::endl;
/* alphaBlendOp */
    structBody << "\t" << "VkBlendOp(" << structInfo->alphaBlendOp << ")" << "," << std::endl;
/* colorWriteMask */
    structBody << "\t" << "VkColorComponentFlags(" << structInfo->colorWriteMask << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineColorBlendAttachmentState");
    out << "VkPipelineColorBlendAttachmentState " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineColorBlendStateCreateInfo(std::ostream &out, const VkPipelineColorBlendStateCreateInfo* structInfo, Decoded_VkPipelineColorBlendStateCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pAttachmentsArray = "NULL";
    if (structInfo->pAttachments != NULL) {
        pAttachmentsArray = "pAttachments_" + std::to_string(consumer.getNextId());
        std::string pAttachmentsNames;
        for (uint32_t idx = 0; idx < structInfo->attachmentCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pAttachments + idx != NULL) {
                varName = GenerateStruct_VkPipelineColorBlendAttachmentState(out,
                                                         structInfo->pAttachments + idx,
                                                         metainfo->pAttachments->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pAttachmentsNames += varName + ", ";
        }
        out << "VkPipelineColorBlendAttachmentState " << pAttachmentsArray << "[] = {" << pAttachmentsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineColorBlendStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* logicOpEnable */
    structBody << "\t" << structInfo->logicOpEnable << "," << std::endl;
/* logicOp */
    structBody << "\t" << "VkLogicOp(" << structInfo->logicOp << ")" << "," << std::endl;
/* attachmentCount */
    structBody << "\t" << structInfo->attachmentCount << "," << std::endl;
/* pAttachments */
    structBody << "\t" << pAttachmentsArray << "," << std::endl;
/* blendConstants */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->blendConstants[0]), 4) << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineColorBlendStateCreateInfo");
    out << "VkPipelineColorBlendStateCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineDynamicStateCreateInfo(std::ostream &out, const VkPipelineDynamicStateCreateInfo* structInfo, Decoded_VkPipelineDynamicStateCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDynamicStatesValues;
    std::string pDynamicStatesArray = "NULL";
    if (structInfo->pDynamicStates != NULL) {
        for (uint32_t idx = 0; idx < structInfo->dynamicStateCount; idx++) {
            pDynamicStatesValues += util::ToString<VkDynamicState>(structInfo->pDynamicStates[idx]) + ", ";
        }
        pDynamicStatesArray = "pDynamicStates_" + std::to_string(consumer.getNextId());
        out << "VkDynamicState " << pDynamicStatesArray << "[] = {" << pDynamicStatesValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineDynamicStateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* dynamicStateCount */
    structBody << "\t" << structInfo->dynamicStateCount << "," << std::endl;
/* pDynamicStates */
    structBody << "\t" << pDynamicStatesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineDynamicStateCreateInfo");
    out << "VkPipelineDynamicStateCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkGraphicsPipelineCreateInfo(std::ostream &out, const VkGraphicsPipelineCreateInfo* structInfo, Decoded_VkGraphicsPipelineCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStagesArray = "NULL";
    if (structInfo->pStages != NULL) {
        pStagesArray = "pStages_" + std::to_string(consumer.getNextId());
        std::string pStagesNames;
        for (uint32_t idx = 0; idx < structInfo->stageCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStages + idx != NULL) {
                varName = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                         structInfo->pStages + idx,
                                                         metainfo->pStages->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStagesNames += varName + ", ";
        }
        out << "VkPipelineShaderStageCreateInfo " << pStagesArray << "[] = {" << pStagesNames << "};" << std::endl;
    }
    std::string pVertexInputStateStruct = "NULL";
    if (structInfo->pVertexInputState != NULL) {
        pVertexInputStateStruct = GenerateStruct_VkPipelineVertexInputStateCreateInfo(out,
                                                                 structInfo->pVertexInputState,
                                                                 metainfo->pVertexInputState->GetMetaStructPointer(),
                                                                 consumer);
        pVertexInputStateStruct.insert(0, "&");
    }
    std::string pInputAssemblyStateStruct = "NULL";
    if (structInfo->pInputAssemblyState != NULL) {
        pInputAssemblyStateStruct = GenerateStruct_VkPipelineInputAssemblyStateCreateInfo(out,
                                                                   structInfo->pInputAssemblyState,
                                                                   metainfo->pInputAssemblyState->GetMetaStructPointer(),
                                                                   consumer);
        pInputAssemblyStateStruct.insert(0, "&");
    }
    std::string pTessellationStateStruct = "NULL";
    if (structInfo->pTessellationState != NULL) {
        pTessellationStateStruct = GenerateStruct_VkPipelineTessellationStateCreateInfo(out,
                                                                  structInfo->pTessellationState,
                                                                  metainfo->pTessellationState->GetMetaStructPointer(),
                                                                  consumer);
        pTessellationStateStruct.insert(0, "&");
    }
    std::string pViewportStateStruct = "NULL";
    if (structInfo->pViewportState != NULL) {
        pViewportStateStruct = GenerateStruct_VkPipelineViewportStateCreateInfo(out,
                                                              structInfo->pViewportState,
                                                              metainfo->pViewportState->GetMetaStructPointer(),
                                                              consumer);
        pViewportStateStruct.insert(0, "&");
    }
    std::string pRasterizationStateStruct = "NULL";
    if (structInfo->pRasterizationState != NULL) {
        pRasterizationStateStruct = GenerateStruct_VkPipelineRasterizationStateCreateInfo(out,
                                                                   structInfo->pRasterizationState,
                                                                   metainfo->pRasterizationState->GetMetaStructPointer(),
                                                                   consumer);
        pRasterizationStateStruct.insert(0, "&");
    }
    std::string pMultisampleStateStruct = "NULL";
    if (structInfo->pMultisampleState != NULL) {
        pMultisampleStateStruct = GenerateStruct_VkPipelineMultisampleStateCreateInfo(out,
                                                                 structInfo->pMultisampleState,
                                                                 metainfo->pMultisampleState->GetMetaStructPointer(),
                                                                 consumer);
        pMultisampleStateStruct.insert(0, "&");
    }
    std::string pDepthStencilStateStruct = "NULL";
    if (structInfo->pDepthStencilState != NULL) {
        pDepthStencilStateStruct = GenerateStruct_VkPipelineDepthStencilStateCreateInfo(out,
                                                                  structInfo->pDepthStencilState,
                                                                  metainfo->pDepthStencilState->GetMetaStructPointer(),
                                                                  consumer);
        pDepthStencilStateStruct.insert(0, "&");
    }
    std::string pColorBlendStateStruct = "NULL";
    if (structInfo->pColorBlendState != NULL) {
        pColorBlendStateStruct = GenerateStruct_VkPipelineColorBlendStateCreateInfo(out,
                                                                structInfo->pColorBlendState,
                                                                metainfo->pColorBlendState->GetMetaStructPointer(),
                                                                consumer);
        pColorBlendStateStruct.insert(0, "&");
    }
    std::string pDynamicStateStruct = "NULL";
    if (structInfo->pDynamicState != NULL) {
        pDynamicStateStruct = GenerateStruct_VkPipelineDynamicStateCreateInfo(out,
                                                             structInfo->pDynamicState,
                                                             metainfo->pDynamicState->GetMetaStructPointer(),
                                                             consumer);
        pDynamicStateStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* stageCount */
    structBody << "\t" << structInfo->stageCount << "," << std::endl;
/* pStages */
    structBody << "\t" << pStagesArray << "," << std::endl;
/* pVertexInputState */
    structBody << "\t" << pVertexInputStateStruct << "," << std::endl;
/* pInputAssemblyState */
    structBody << "\t" << pInputAssemblyStateStruct << "," << std::endl;
/* pTessellationState */
    structBody << "\t" << pTessellationStateStruct << "," << std::endl;
/* pViewportState */
    structBody << "\t" << pViewportStateStruct << "," << std::endl;
/* pRasterizationState */
    structBody << "\t" << pRasterizationStateStruct << "," << std::endl;
/* pMultisampleState */
    structBody << "\t" << pMultisampleStateStruct << "," << std::endl;
/* pDepthStencilState */
    structBody << "\t" << pDepthStencilStateStruct << "," << std::endl;
/* pColorBlendState */
    structBody << "\t" << pColorBlendStateStruct << "," << std::endl;
/* pDynamicState */
    structBody << "\t" << pDynamicStateStruct << "," << std::endl;
/* layout */
    structBody << "\t" << consumer.GetHandle(metainfo->layout) << "," << std::endl;
/* renderPass */
    structBody << "\t" << consumer.GetHandle(metainfo->renderPass) << "," << std::endl;
/* subpass */
    structBody << "\t" << structInfo->subpass << "," << std::endl;
/* basePipelineHandle */
    structBody << "\t" << consumer.GetHandle(metainfo->basePipelineHandle) << "," << std::endl;
/* basePipelineIndex */
    structBody << "\t" << structInfo->basePipelineIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "graphicsPipelineCreateInfo");
    out << "VkGraphicsPipelineCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPushConstantRange(std::ostream &out, const VkPushConstantRange* structInfo, Decoded_VkPushConstantRange* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* stageFlags */
    structBody << "\t" << "VkShaderStageFlags(" << structInfo->stageFlags << ")" << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "," ;
    std::string varname = consumer.AddStruct(structBody, "pushConstantRange");
    out << "VkPushConstantRange " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineLayoutCreateInfo(std::ostream &out, const VkPipelineLayoutCreateInfo* structInfo, Decoded_VkPipelineLayoutCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pSetLayoutsArray = "NULL";
    if (metainfo->pSetLayouts.GetPointer() != NULL && structInfo->setLayoutCount > 0) {
        pSetLayoutsArray = "pSetLayoutsArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT));
        std::string pSetLayoutsValues = toStringJoin(metainfo->pSetLayouts.GetPointer(),
                                                     metainfo->pSetLayouts.GetPointer() + structInfo->setLayoutCount,
                                                     [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                     ", ");
        if (structInfo->setLayoutCount == 1) {
            pSetLayoutsArray = "&" + pSetLayoutsValues;
        } else if (structInfo->setLayoutCount > 1) {
            out << "VkDescriptorSetLayout " << pSetLayoutsArray << "[] = {" << pSetLayoutsValues << "};" << std::endl;
        }
    }
    std::string pPushConstantRangesArray = "NULL";
    if (structInfo->pPushConstantRanges != NULL) {
        pPushConstantRangesArray = "pPushConstantRanges_" + std::to_string(consumer.getNextId());
        std::string pPushConstantRangesNames;
        for (uint32_t idx = 0; idx < structInfo->pushConstantRangeCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pPushConstantRanges + idx != NULL) {
                varName = GenerateStruct_VkPushConstantRange(out,
                                                         structInfo->pPushConstantRanges + idx,
                                                         metainfo->pPushConstantRanges->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pPushConstantRangesNames += varName + ", ";
        }
        out << "VkPushConstantRange " << pPushConstantRangesArray << "[] = {" << pPushConstantRangesNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineLayoutCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* setLayoutCount */
    structBody << "\t" << structInfo->setLayoutCount << "," << std::endl;
/* pSetLayouts */
    structBody << "\t" << pSetLayoutsArray << "," << std::endl;
/* pushConstantRangeCount */
    structBody << "\t" << structInfo->pushConstantRangeCount << "," << std::endl;
/* pPushConstantRanges */
    structBody << "\t" << pPushConstantRangesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineLayoutCreateInfo");
    out << "VkPipelineLayoutCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSamplerCreateInfo(std::ostream &out, const VkSamplerCreateInfo* structInfo, Decoded_VkSamplerCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkSamplerCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* magFilter */
    structBody << "\t" << "VkFilter(" << structInfo->magFilter << ")" << "," << std::endl;
/* minFilter */
    structBody << "\t" << "VkFilter(" << structInfo->minFilter << ")" << "," << std::endl;
/* mipmapMode */
    structBody << "\t" << "VkSamplerMipmapMode(" << structInfo->mipmapMode << ")" << "," << std::endl;
/* addressModeU */
    structBody << "\t" << "VkSamplerAddressMode(" << structInfo->addressModeU << ")" << "," << std::endl;
/* addressModeV */
    structBody << "\t" << "VkSamplerAddressMode(" << structInfo->addressModeV << ")" << "," << std::endl;
/* addressModeW */
    structBody << "\t" << "VkSamplerAddressMode(" << structInfo->addressModeW << ")" << "," << std::endl;
/* mipLodBias */
    structBody << "\t" << structInfo->mipLodBias << "," << std::endl;
/* anisotropyEnable */
    structBody << "\t" << structInfo->anisotropyEnable << "," << std::endl;
/* maxAnisotropy */
    structBody << "\t" << structInfo->maxAnisotropy << "," << std::endl;
/* compareEnable */
    structBody << "\t" << structInfo->compareEnable << "," << std::endl;
/* compareOp */
    structBody << "\t" << "VkCompareOp(" << structInfo->compareOp << ")" << "," << std::endl;
/* minLod */
    structBody << "\t" << structInfo->minLod << "," << std::endl;
/* maxLod */
    structBody << "\t" << structInfo->maxLod << "," << std::endl;
/* borderColor */
    structBody << "\t" << "VkBorderColor(" << structInfo->borderColor << ")" << "," << std::endl;
/* unnormalizedCoordinates */
    structBody << "\t" << structInfo->unnormalizedCoordinates << "," ;
    std::string varname = consumer.AddStruct(structBody, "samplerCreateInfo");
    out << "VkSamplerCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyDescriptorSet(std::ostream &out, const VkCopyDescriptorSet* structInfo, Decoded_VkCopyDescriptorSet* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcSet */
    structBody << "\t" << consumer.GetHandle(metainfo->srcSet) << "," << std::endl;
/* srcBinding */
    structBody << "\t" << structInfo->srcBinding << "," << std::endl;
/* srcArrayElement */
    structBody << "\t" << structInfo->srcArrayElement << "," << std::endl;
/* dstSet */
    structBody << "\t" << consumer.GetHandle(metainfo->dstSet) << "," << std::endl;
/* dstBinding */
    structBody << "\t" << structInfo->dstBinding << "," << std::endl;
/* dstArrayElement */
    structBody << "\t" << structInfo->dstArrayElement << "," << std::endl;
/* descriptorCount */
    structBody << "\t" << structInfo->descriptorCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyDescriptorSet");
    out << "VkCopyDescriptorSet " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDescriptorBufferInfo(std::ostream &out, const VkDescriptorBufferInfo* structInfo, Decoded_VkDescriptorBufferInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* buffer */
    structBody << "\t" << consumer.GetHandle(metainfo->buffer) << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "UL" << "," << std::endl;
/* range */
    structBody << "\t" << structInfo->range << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "descriptorBufferInfo");
    out << "VkDescriptorBufferInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDescriptorPoolSize(std::ostream &out, const VkDescriptorPoolSize* structInfo, Decoded_VkDescriptorPoolSize* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* type */
    structBody << "\t" << "VkDescriptorType(" << structInfo->type << ")" << "," << std::endl;
/* descriptorCount */
    structBody << "\t" << structInfo->descriptorCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "descriptorPoolSize");
    out << "VkDescriptorPoolSize " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDescriptorPoolCreateInfo(std::ostream &out, const VkDescriptorPoolCreateInfo* structInfo, Decoded_VkDescriptorPoolCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pPoolSizesArray = "NULL";
    if (structInfo->pPoolSizes != NULL) {
        pPoolSizesArray = "pPoolSizes_" + std::to_string(consumer.getNextId());
        std::string pPoolSizesNames;
        for (uint32_t idx = 0; idx < structInfo->poolSizeCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pPoolSizes + idx != NULL) {
                varName = GenerateStruct_VkDescriptorPoolSize(out,
                                                         structInfo->pPoolSizes + idx,
                                                         metainfo->pPoolSizes->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pPoolSizesNames += varName + ", ";
        }
        out << "VkDescriptorPoolSize " << pPoolSizesArray << "[] = {" << pPoolSizesNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDescriptorPoolCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* maxSets */
    structBody << "\t" << structInfo->maxSets << "," << std::endl;
/* poolSizeCount */
    structBody << "\t" << structInfo->poolSizeCount << "," << std::endl;
/* pPoolSizes */
    structBody << "\t" << pPoolSizesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "descriptorPoolCreateInfo");
    out << "VkDescriptorPoolCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDescriptorSetAllocateInfo(std::ostream &out, const VkDescriptorSetAllocateInfo* structInfo, Decoded_VkDescriptorSetAllocateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pSetLayoutsArray = "NULL";
    if (metainfo->pSetLayouts.GetPointer() != NULL && structInfo->descriptorSetCount > 0) {
        pSetLayoutsArray = "pSetLayoutsArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT));
        std::string pSetLayoutsValues = toStringJoin(metainfo->pSetLayouts.GetPointer(),
                                                     metainfo->pSetLayouts.GetPointer() + structInfo->descriptorSetCount,
                                                     [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                     ", ");
        if (structInfo->descriptorSetCount == 1) {
            pSetLayoutsArray = "&" + pSetLayoutsValues;
        } else if (structInfo->descriptorSetCount > 1) {
            out << "VkDescriptorSetLayout " << pSetLayoutsArray << "[] = {" << pSetLayoutsValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* descriptorPool */
    structBody << "\t" << consumer.GetHandle(metainfo->descriptorPool) << "," << std::endl;
/* descriptorSetCount */
    structBody << "\t" << structInfo->descriptorSetCount << "," << std::endl;
/* pSetLayouts */
    structBody << "\t" << pSetLayoutsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "descriptorSetAllocateInfo");
    out << "VkDescriptorSetAllocateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDescriptorSetLayoutBinding(std::ostream &out, const VkDescriptorSetLayoutBinding* structInfo, Decoded_VkDescriptorSetLayoutBinding* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pImmutableSamplersArray = "NULL";
    if (metainfo->pImmutableSamplers.GetPointer() != NULL && structInfo->descriptorCount > 0) {
        pImmutableSamplersArray = "pImmutableSamplersArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_SAMPLER));
        std::string pImmutableSamplersValues = toStringJoin(metainfo->pImmutableSamplers.GetPointer(),
                                                            metainfo->pImmutableSamplers.GetPointer() + structInfo->descriptorCount,
                                                            [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                            ", ");
        if (structInfo->descriptorCount == 1) {
            pImmutableSamplersArray = "&" + pImmutableSamplersValues;
        } else if (structInfo->descriptorCount > 1) {
            out << "VkSampler " << pImmutableSamplersArray << "[] = {" << pImmutableSamplersValues << "};" << std::endl;
        }
    }
/* binding */
    structBody << "\t" << structInfo->binding << "," << std::endl;
/* descriptorType */
    structBody << "\t" << "VkDescriptorType(" << structInfo->descriptorType << ")" << "," << std::endl;
/* descriptorCount */
    structBody << "\t" << structInfo->descriptorCount << "," << std::endl;
/* stageFlags */
    structBody << "\t" << "VkShaderStageFlags(" << structInfo->stageFlags << ")" << "," << std::endl;
/* pImmutableSamplers */
    structBody << "\t" << pImmutableSamplersArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "descriptorSetLayoutBinding");
    out << "VkDescriptorSetLayoutBinding " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDescriptorSetLayoutCreateInfo(std::ostream &out, const VkDescriptorSetLayoutCreateInfo* structInfo, Decoded_VkDescriptorSetLayoutCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pBindingsArray = "NULL";
    if (structInfo->pBindings != NULL) {
        pBindingsArray = "pBindings_" + std::to_string(consumer.getNextId());
        std::string pBindingsNames;
        for (uint32_t idx = 0; idx < structInfo->bindingCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pBindings + idx != NULL) {
                varName = GenerateStruct_VkDescriptorSetLayoutBinding(out,
                                                         structInfo->pBindings + idx,
                                                         metainfo->pBindings->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pBindingsNames += varName + ", ";
        }
        out << "VkDescriptorSetLayoutBinding " << pBindingsArray << "[] = {" << pBindingsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDescriptorSetLayoutCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* bindingCount */
    structBody << "\t" << structInfo->bindingCount << "," << std::endl;
/* pBindings */
    structBody << "\t" << pBindingsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "descriptorSetLayoutCreateInfo");
    out << "VkDescriptorSetLayoutCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAttachmentDescription(std::ostream &out, const VkAttachmentDescription* structInfo, Decoded_VkAttachmentDescription* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* flags */
    structBody << "\t" << "VkAttachmentDescriptionFlags(" << structInfo->flags << ")" << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
/* samples */
    structBody << "\t" << "VkSampleCountFlagBits(" << structInfo->samples << ")" << "," << std::endl;
/* loadOp */
    structBody << "\t" << "VkAttachmentLoadOp(" << structInfo->loadOp << ")" << "," << std::endl;
/* storeOp */
    structBody << "\t" << "VkAttachmentStoreOp(" << structInfo->storeOp << ")" << "," << std::endl;
/* stencilLoadOp */
    structBody << "\t" << "VkAttachmentLoadOp(" << structInfo->stencilLoadOp << ")" << "," << std::endl;
/* stencilStoreOp */
    structBody << "\t" << "VkAttachmentStoreOp(" << structInfo->stencilStoreOp << ")" << "," << std::endl;
/* initialLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->initialLayout << ")" << "," << std::endl;
/* finalLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->finalLayout << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "attachmentDescription");
    out << "VkAttachmentDescription " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAttachmentReference(std::ostream &out, const VkAttachmentReference* structInfo, Decoded_VkAttachmentReference* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* attachment */
    structBody << "\t" << structInfo->attachment << "," << std::endl;
/* layout */
    structBody << "\t" << "VkImageLayout(" << structInfo->layout << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "attachmentReference");
    out << "VkAttachmentReference " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkFramebufferCreateInfo(std::ostream &out, const VkFramebufferCreateInfo* structInfo, Decoded_VkFramebufferCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pAttachmentsArray = "NULL";
    if (metainfo->pAttachments.GetPointer() != NULL && structInfo->attachmentCount > 0) {
        pAttachmentsArray = "pAttachmentsArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_IMAGE_VIEW));
        std::string pAttachmentsValues = toStringJoin(metainfo->pAttachments.GetPointer(),
                                                      metainfo->pAttachments.GetPointer() + structInfo->attachmentCount,
                                                      [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                      ", ");
        if (structInfo->attachmentCount == 1) {
            pAttachmentsArray = "&" + pAttachmentsValues;
        } else if (structInfo->attachmentCount > 1) {
            out << "VkImageView " << pAttachmentsArray << "[] = {" << pAttachmentsValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkFramebufferCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* renderPass */
    structBody << "\t" << consumer.GetHandle(metainfo->renderPass) << "," << std::endl;
/* attachmentCount */
    structBody << "\t" << structInfo->attachmentCount << "," << std::endl;
/* pAttachments */
    structBody << "\t" << pAttachmentsArray << "," << std::endl;
/* width */
    structBody << "\t" << structInfo->width << "," << std::endl;
/* height */
    structBody << "\t" << structInfo->height << "," << std::endl;
/* layers */
    structBody << "\t" << structInfo->layers << "," ;
    std::string varname = consumer.AddStruct(structBody, "framebufferCreateInfo");
    out << "VkFramebufferCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubpassDescription(std::ostream &out, const VkSubpassDescription* structInfo, Decoded_VkSubpassDescription* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pInputAttachmentsArray = "NULL";
    if (structInfo->pInputAttachments != NULL) {
        pInputAttachmentsArray = "pInputAttachments_" + std::to_string(consumer.getNextId());
        std::string pInputAttachmentsNames;
        for (uint32_t idx = 0; idx < structInfo->inputAttachmentCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pInputAttachments + idx != NULL) {
                varName = GenerateStruct_VkAttachmentReference(out,
                                                         structInfo->pInputAttachments + idx,
                                                         metainfo->pInputAttachments->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pInputAttachmentsNames += varName + ", ";
        }
        out << "VkAttachmentReference " << pInputAttachmentsArray << "[] = {" << pInputAttachmentsNames << "};" << std::endl;
    }
    std::string pColorAttachmentsArray = "NULL";
    if (structInfo->pColorAttachments != NULL) {
        pColorAttachmentsArray = "pColorAttachments_" + std::to_string(consumer.getNextId());
        std::string pColorAttachmentsNames;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pColorAttachments + idx != NULL) {
                varName = GenerateStruct_VkAttachmentReference(out,
                                                         structInfo->pColorAttachments + idx,
                                                         metainfo->pColorAttachments->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pColorAttachmentsNames += varName + ", ";
        }
        out << "VkAttachmentReference " << pColorAttachmentsArray << "[] = {" << pColorAttachmentsNames << "};" << std::endl;
    }
    std::string pResolveAttachmentsArray = "NULL";
    if (structInfo->pResolveAttachments != NULL) {
        pResolveAttachmentsArray = "pResolveAttachments_" + std::to_string(consumer.getNextId());
        std::string pResolveAttachmentsNames;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pResolveAttachments + idx != NULL) {
                varName = GenerateStruct_VkAttachmentReference(out,
                                                         structInfo->pResolveAttachments + idx,
                                                         metainfo->pResolveAttachments->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pResolveAttachmentsNames += varName + ", ";
        }
        out << "VkAttachmentReference " << pResolveAttachmentsArray << "[] = {" << pResolveAttachmentsNames << "};" << std::endl;
    }
    std::string pDepthStencilAttachmentStruct = "NULL";
    if (structInfo->pDepthStencilAttachment != NULL) {
        pDepthStencilAttachmentStruct = GenerateStruct_VkAttachmentReference(out,
                                                                       structInfo->pDepthStencilAttachment,
                                                                       metainfo->pDepthStencilAttachment->GetMetaStructPointer(),
                                                                       consumer);
        pDepthStencilAttachmentStruct.insert(0, "&");
    }
    std::string pPreserveAttachmentsArray = "NULL";
    if (structInfo->pPreserveAttachments != NULL) {
        pPreserveAttachmentsArray = "pPreserveAttachments_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pPreserveAttachmentsArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pPreserveAttachments, structInfo->preserveAttachmentCount) << ";" << std::endl;
    }
/* flags */
    structBody << "\t" << "VkSubpassDescriptionFlags(" << structInfo->flags << ")" << "," << std::endl;
/* pipelineBindPoint */
    structBody << "\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
/* inputAttachmentCount */
    structBody << "\t" << structInfo->inputAttachmentCount << "," << std::endl;
/* pInputAttachments */
    structBody << "\t" << pInputAttachmentsArray << "," << std::endl;
/* colorAttachmentCount */
    structBody << "\t" << structInfo->colorAttachmentCount << "," << std::endl;
/* pColorAttachments */
    structBody << "\t" << pColorAttachmentsArray << "," << std::endl;
/* pResolveAttachments */
    structBody << "\t" << pResolveAttachmentsArray << "," << std::endl;
/* pDepthStencilAttachment */
    structBody << "\t" << pDepthStencilAttachmentStruct << "," << std::endl;
/* preserveAttachmentCount */
    structBody << "\t" << structInfo->preserveAttachmentCount << "," << std::endl;
/* pPreserveAttachments */
    structBody << "\t" << pPreserveAttachmentsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "subpassDescription");
    out << "VkSubpassDescription " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubpassDependency(std::ostream &out, const VkSubpassDependency* structInfo, Decoded_VkSubpassDependency* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* srcSubpass */
    structBody << "\t" << structInfo->srcSubpass << "," << std::endl;
/* dstSubpass */
    structBody << "\t" << structInfo->dstSubpass << "," << std::endl;
/* srcStageMask */
    structBody << "\t" << "VkPipelineStageFlags(" << structInfo->srcStageMask << ")" << "," << std::endl;
/* dstStageMask */
    structBody << "\t" << "VkPipelineStageFlags(" << structInfo->dstStageMask << ")" << "," << std::endl;
/* srcAccessMask */
    structBody << "\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
/* dstAccessMask */
    structBody << "\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << "," << std::endl;
/* dependencyFlags */
    structBody << "\t" << "VkDependencyFlags(" << structInfo->dependencyFlags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "subpassDependency");
    out << "VkSubpassDependency " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderPassCreateInfo(std::ostream &out, const VkRenderPassCreateInfo* structInfo, Decoded_VkRenderPassCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pAttachmentsArray = "NULL";
    if (structInfo->pAttachments != NULL) {
        pAttachmentsArray = "pAttachments_" + std::to_string(consumer.getNextId());
        std::string pAttachmentsNames;
        for (uint32_t idx = 0; idx < structInfo->attachmentCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pAttachments + idx != NULL) {
                varName = GenerateStruct_VkAttachmentDescription(out,
                                                         structInfo->pAttachments + idx,
                                                         metainfo->pAttachments->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pAttachmentsNames += varName + ", ";
        }
        out << "VkAttachmentDescription " << pAttachmentsArray << "[] = {" << pAttachmentsNames << "};" << std::endl;
    }
    std::string pSubpassesArray = "NULL";
    if (structInfo->pSubpasses != NULL) {
        pSubpassesArray = "pSubpasses_" + std::to_string(consumer.getNextId());
        std::string pSubpassesNames;
        for (uint32_t idx = 0; idx < structInfo->subpassCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pSubpasses + idx != NULL) {
                varName = GenerateStruct_VkSubpassDescription(out,
                                                         structInfo->pSubpasses + idx,
                                                         metainfo->pSubpasses->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pSubpassesNames += varName + ", ";
        }
        out << "VkSubpassDescription " << pSubpassesArray << "[] = {" << pSubpassesNames << "};" << std::endl;
    }
    std::string pDependenciesArray = "NULL";
    if (structInfo->pDependencies != NULL) {
        pDependenciesArray = "pDependencies_" + std::to_string(consumer.getNextId());
        std::string pDependenciesNames;
        for (uint32_t idx = 0; idx < structInfo->dependencyCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pDependencies + idx != NULL) {
                varName = GenerateStruct_VkSubpassDependency(out,
                                                         structInfo->pDependencies + idx,
                                                         metainfo->pDependencies->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pDependenciesNames += varName + ", ";
        }
        out << "VkSubpassDependency " << pDependenciesArray << "[] = {" << pDependenciesNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkRenderPassCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* attachmentCount */
    structBody << "\t" << structInfo->attachmentCount << "," << std::endl;
/* pAttachments */
    structBody << "\t" << pAttachmentsArray << "," << std::endl;
/* subpassCount */
    structBody << "\t" << structInfo->subpassCount << "," << std::endl;
/* pSubpasses */
    structBody << "\t" << pSubpassesArray << "," << std::endl;
/* dependencyCount */
    structBody << "\t" << structInfo->dependencyCount << "," << std::endl;
/* pDependencies */
    structBody << "\t" << pDependenciesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderPassCreateInfo");
    out << "VkRenderPassCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCommandPoolCreateInfo(std::ostream &out, const VkCommandPoolCreateInfo* structInfo, Decoded_VkCommandPoolCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkCommandPoolCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* queueFamilyIndex */
    structBody << "\t" << structInfo->queueFamilyIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "commandPoolCreateInfo");
    out << "VkCommandPoolCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCommandBufferAllocateInfo(std::ostream &out, const VkCommandBufferAllocateInfo* structInfo, Decoded_VkCommandBufferAllocateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* commandPool */
    structBody << "\t" << consumer.GetHandle(metainfo->commandPool) << "," << std::endl;
/* level */
    structBody << "\t" << "VkCommandBufferLevel(" << structInfo->level << ")" << "," << std::endl;
/* commandBufferCount */
    structBody << "\t" << structInfo->commandBufferCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "commandBufferAllocateInfo");
    out << "VkCommandBufferAllocateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCommandBufferInheritanceInfo(std::ostream &out, const VkCommandBufferInheritanceInfo* structInfo, Decoded_VkCommandBufferInheritanceInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* renderPass */
    structBody << "\t" << consumer.GetHandle(metainfo->renderPass) << "," << std::endl;
/* subpass */
    structBody << "\t" << structInfo->subpass << "," << std::endl;
/* framebuffer */
    structBody << "\t" << consumer.GetHandle(metainfo->framebuffer) << "," << std::endl;
/* occlusionQueryEnable */
    structBody << "\t" << structInfo->occlusionQueryEnable << "," << std::endl;
/* queryFlags */
    structBody << "\t" << "VkQueryControlFlags(" << structInfo->queryFlags << ")" << "," << std::endl;
/* pipelineStatistics */
    structBody << "\t" << "VkQueryPipelineStatisticFlags(" << structInfo->pipelineStatistics << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "commandBufferInheritanceInfo");
    out << "VkCommandBufferInheritanceInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCommandBufferBeginInfo(std::ostream &out, const VkCommandBufferBeginInfo* structInfo, Decoded_VkCommandBufferBeginInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pInheritanceInfoStruct = "NULL";
    if (structInfo->pInheritanceInfo != NULL) {
        pInheritanceInfoStruct = GenerateStruct_VkCommandBufferInheritanceInfo(out,
                                                                structInfo->pInheritanceInfo,
                                                                metainfo->pInheritanceInfo->GetMetaStructPointer(),
                                                                consumer);
        pInheritanceInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkCommandBufferUsageFlags(" << structInfo->flags << ")" << "," << std::endl;
/* pInheritanceInfo */
    structBody << "\t" << pInheritanceInfoStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "commandBufferBeginInfo");
    out << "VkCommandBufferBeginInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBufferCopy(std::ostream &out, const VkBufferCopy* structInfo, Decoded_VkBufferCopy* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* srcOffset */
    structBody << "\t" << structInfo->srcOffset << "UL" << "," << std::endl;
/* dstOffset */
    structBody << "\t" << structInfo->dstOffset << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "bufferCopy");
    out << "VkBufferCopy " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageSubresourceLayers(std::ostream &out, const VkImageSubresourceLayers* structInfo, Decoded_VkImageSubresourceLayers* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* aspectMask */
    structBody << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
/* mipLevel */
    structBody << "\t" << structInfo->mipLevel << "," << std::endl;
/* baseArrayLayer */
    structBody << "\t" << structInfo->baseArrayLayer << "," << std::endl;
/* layerCount */
    structBody << "\t" << structInfo->layerCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageSubresourceLayers");
    out << "VkImageSubresourceLayers " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBufferImageCopy(std::ostream &out, const VkBufferImageCopy* structInfo, Decoded_VkBufferImageCopy* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string imageSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                         &structInfo->imageSubresource,
                                                                         metainfo->imageSubresource,
                                                                         consumer);
    std::string imageOffsetInfoVar = GenerateStruct_VkOffset3D(out,
                                                                    &structInfo->imageOffset,
                                                                    metainfo->imageOffset,
                                                                    consumer);
    std::string imageExtentInfoVar = GenerateStruct_VkExtent3D(out,
                                                                    &structInfo->imageExtent,
                                                                    metainfo->imageExtent,
                                                                    consumer);
/* bufferOffset */
    structBody << "\t" << structInfo->bufferOffset << "UL" << "," << std::endl;
/* bufferRowLength */
    structBody << "\t" << structInfo->bufferRowLength << "," << std::endl;
/* bufferImageHeight */
    structBody << "\t" << structInfo->bufferImageHeight << "," << std::endl;
/* imageSubresource */
    structBody << "\t" << imageSubresourceInfoVar << "," << std::endl;
/* imageOffset */
    structBody << "\t" << imageOffsetInfoVar << "," << std::endl;
/* imageExtent */
    structBody << "\t" << imageExtentInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "bufferImageCopy");
    out << "VkBufferImageCopy " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkClearDepthStencilValue(std::ostream &out, const VkClearDepthStencilValue* structInfo, Decoded_VkClearDepthStencilValue* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* depth */
    structBody << "\t" << structInfo->depth << "," << std::endl;
/* stencil */
    structBody << "\t" << structInfo->stencil << "," ;
    std::string varname = consumer.AddStruct(structBody, "clearDepthStencilValue");
    out << "VkClearDepthStencilValue " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkClearAttachment(std::ostream &out, const VkClearAttachment* structInfo, Decoded_VkClearAttachment* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string colorInfoVar = GenerateStruct_VkClearColorValue(out,
                                                                       &structInfo->clearValue.color,
                                                                       metainfo->clearValue->color,
                                                                       consumer);
/* aspectMask */
    structBody << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," << std::endl;
/* colorAttachment */
    structBody << "\t" << structInfo->colorAttachment << "," << std::endl;
/* clearValue */
    structBody << "\t" << colorInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "clearAttachment");
    out << "VkClearAttachment " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkClearRect(std::ostream &out, const VkClearRect* structInfo, Decoded_VkClearRect* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string rectInfoVar = GenerateStruct_VkRect2D(out,
                                                             &structInfo->rect,
                                                             metainfo->rect,
                                                             consumer);
/* rect */
    structBody << "\t" << rectInfoVar << "," << std::endl;
/* baseArrayLayer */
    structBody << "\t" << structInfo->baseArrayLayer << "," << std::endl;
/* layerCount */
    structBody << "\t" << structInfo->layerCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "clearRect");
    out << "VkClearRect " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageBlit(std::ostream &out, const VkImageBlit* structInfo, Decoded_VkImageBlit* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string srcSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                       &structInfo->srcSubresource,
                                                                       metainfo->srcSubresource,
                                                                       consumer);
    std::string dstSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                       &structInfo->dstSubresource,
                                                                       metainfo->dstSubresource,
                                                                       consumer);
/* srcSubresource */
    structBody << "\t" << srcSubresourceInfoVar << "," << std::endl;
/* srcOffsets */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkOffset3D*>(&structInfo->srcOffsets[0]), 2) << "," << std::endl;
/* dstSubresource */
    structBody << "\t" << dstSubresourceInfoVar << "," << std::endl;
/* dstOffsets */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkOffset3D*>(&structInfo->dstOffsets[0]), 2) << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageBlit");
    out << "VkImageBlit " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageCopy(std::ostream &out, const VkImageCopy* structInfo, Decoded_VkImageCopy* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string srcSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                       &structInfo->srcSubresource,
                                                                       metainfo->srcSubresource,
                                                                       consumer);
    std::string srcOffsetInfoVar = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->srcOffset,
                                                                  metainfo->srcOffset,
                                                                  consumer);
    std::string dstSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                       &structInfo->dstSubresource,
                                                                       metainfo->dstSubresource,
                                                                       consumer);
    std::string dstOffsetInfoVar = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->dstOffset,
                                                                  metainfo->dstOffset,
                                                                  consumer);
    std::string extentInfoVar = GenerateStruct_VkExtent3D(out,
                                                               &structInfo->extent,
                                                               metainfo->extent,
                                                               consumer);
/* srcSubresource */
    structBody << "\t" << srcSubresourceInfoVar << "," << std::endl;
/* srcOffset */
    structBody << "\t" << srcOffsetInfoVar << "," << std::endl;
/* dstSubresource */
    structBody << "\t" << dstSubresourceInfoVar << "," << std::endl;
/* dstOffset */
    structBody << "\t" << dstOffsetInfoVar << "," << std::endl;
/* extent */
    structBody << "\t" << extentInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageCopy");
    out << "VkImageCopy " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageResolve(std::ostream &out, const VkImageResolve* structInfo, Decoded_VkImageResolve* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string srcSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                       &structInfo->srcSubresource,
                                                                       metainfo->srcSubresource,
                                                                       consumer);
    std::string srcOffsetInfoVar = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->srcOffset,
                                                                  metainfo->srcOffset,
                                                                  consumer);
    std::string dstSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                       &structInfo->dstSubresource,
                                                                       metainfo->dstSubresource,
                                                                       consumer);
    std::string dstOffsetInfoVar = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->dstOffset,
                                                                  metainfo->dstOffset,
                                                                  consumer);
    std::string extentInfoVar = GenerateStruct_VkExtent3D(out,
                                                               &structInfo->extent,
                                                               metainfo->extent,
                                                               consumer);
/* srcSubresource */
    structBody << "\t" << srcSubresourceInfoVar << "," << std::endl;
/* srcOffset */
    structBody << "\t" << srcOffsetInfoVar << "," << std::endl;
/* dstSubresource */
    structBody << "\t" << dstSubresourceInfoVar << "," << std::endl;
/* dstOffset */
    structBody << "\t" << dstOffsetInfoVar << "," << std::endl;
/* extent */
    structBody << "\t" << extentInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageResolve");
    out << "VkImageResolve " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderPassBeginInfo(std::ostream &out, const VkRenderPassBeginInfo* structInfo, Decoded_VkRenderPassBeginInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string renderAreaInfoVar = GenerateStruct_VkRect2D(out,
                                                                   &structInfo->renderArea,
                                                                   metainfo->renderArea,
                                                                   consumer);
    std::string pClearValuesArray = "NULL";
    if (structInfo->pClearValues != NULL) {
        pClearValuesArray = "pClearValues_" + std::to_string(consumer.getNextId());
        out << "VkClearValue " << pClearValuesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pClearValues, structInfo->clearValueCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* renderPass */
    structBody << "\t" << consumer.GetHandle(metainfo->renderPass) << "," << std::endl;
/* framebuffer */
    structBody << "\t" << consumer.GetHandle(metainfo->framebuffer) << "," << std::endl;
/* renderArea */
    structBody << "\t" << renderAreaInfoVar << "," << std::endl;
/* clearValueCount */
    structBody << "\t" << structInfo->clearValueCount << "," << std::endl;
/* pClearValues */
    structBody << "\t" << pClearValuesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderPassBeginInfo");
    out << "VkRenderPassBeginInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceSubgroupProperties(std::ostream &out, const VkPhysicalDeviceSubgroupProperties* structInfo, Decoded_VkPhysicalDeviceSubgroupProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* subgroupSize */
    structBody << "\t" << structInfo->subgroupSize << "," << std::endl;
/* supportedStages */
    structBody << "\t" << "VkShaderStageFlags(" << structInfo->supportedStages << ")" << "," << std::endl;
/* supportedOperations */
    structBody << "\t" << "VkSubgroupFeatureFlags(" << structInfo->supportedOperations << ")" << "," << std::endl;
/* quadOperationsInAllStages */
    structBody << "\t" << structInfo->quadOperationsInAllStages << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceSubgroupProperties");
    out << "VkPhysicalDeviceSubgroupProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBindBufferMemoryInfo(std::ostream &out, const VkBindBufferMemoryInfo* structInfo, Decoded_VkBindBufferMemoryInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* buffer */
    structBody << "\t" << consumer.GetHandle(metainfo->buffer) << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," << std::endl;
/* memoryOffset */
    structBody << "\t" << structInfo->memoryOffset << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "bindBufferMemoryInfo");
    out << "VkBindBufferMemoryInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBindImageMemoryInfo(std::ostream &out, const VkBindImageMemoryInfo* structInfo, Decoded_VkBindImageMemoryInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* image */
    structBody << "\t" << consumer.GetHandle(metainfo->image) << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," << std::endl;
/* memoryOffset */
    structBody << "\t" << structInfo->memoryOffset << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "bindImageMemoryInfo");
    out << "VkBindImageMemoryInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevice16BitStorageFeatures(std::ostream &out, const VkPhysicalDevice16BitStorageFeatures* structInfo, Decoded_VkPhysicalDevice16BitStorageFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* storageBuffer16BitAccess */
    structBody << "\t" << structInfo->storageBuffer16BitAccess << "," << std::endl;
/* uniformAndStorageBuffer16BitAccess */
    structBody << "\t" << structInfo->uniformAndStorageBuffer16BitAccess << "," << std::endl;
/* storagePushConstant16 */
    structBody << "\t" << structInfo->storagePushConstant16 << "," << std::endl;
/* storageInputOutput16 */
    structBody << "\t" << structInfo->storageInputOutput16 << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevice16BitStorageFeatures");
    out << "VkPhysicalDevice16BitStorageFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryDedicatedRequirements(std::ostream &out, const VkMemoryDedicatedRequirements* structInfo, Decoded_VkMemoryDedicatedRequirements* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* prefersDedicatedAllocation */
    structBody << "\t" << structInfo->prefersDedicatedAllocation << "," << std::endl;
/* requiresDedicatedAllocation */
    structBody << "\t" << structInfo->requiresDedicatedAllocation << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryDedicatedRequirements");
    out << "VkMemoryDedicatedRequirements " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryDedicatedAllocateInfo(std::ostream &out, const VkMemoryDedicatedAllocateInfo* structInfo, Decoded_VkMemoryDedicatedAllocateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* image */
    structBody << "\t" << consumer.GetHandle(metainfo->image) << "," << std::endl;
/* buffer */
    structBody << "\t" << consumer.GetHandle(metainfo->buffer) << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryDedicatedAllocateInfo");
    out << "VkMemoryDedicatedAllocateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryAllocateFlagsInfo(std::ostream &out, const VkMemoryAllocateFlagsInfo* structInfo, Decoded_VkMemoryAllocateFlagsInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkMemoryAllocateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* deviceMask */
    structBody << "\t" << structInfo->deviceMask << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryAllocateFlagsInfo");
    out << "VkMemoryAllocateFlagsInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceGroupRenderPassBeginInfo(std::ostream &out, const VkDeviceGroupRenderPassBeginInfo* structInfo, Decoded_VkDeviceGroupRenderPassBeginInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDeviceRenderAreasArray = "NULL";
    if (structInfo->pDeviceRenderAreas != NULL) {
        pDeviceRenderAreasArray = "pDeviceRenderAreas_" + std::to_string(consumer.getNextId());
        out << "VkRect2D " << pDeviceRenderAreasArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceRenderAreas, structInfo->deviceRenderAreaCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceMask */
    structBody << "\t" << structInfo->deviceMask << "," << std::endl;
/* deviceRenderAreaCount */
    structBody << "\t" << structInfo->deviceRenderAreaCount << "," << std::endl;
/* pDeviceRenderAreas */
    structBody << "\t" << pDeviceRenderAreasArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceGroupRenderPassBeginInfo");
    out << "VkDeviceGroupRenderPassBeginInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceGroupCommandBufferBeginInfo(std::ostream &out, const VkDeviceGroupCommandBufferBeginInfo* structInfo, Decoded_VkDeviceGroupCommandBufferBeginInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceMask */
    structBody << "\t" << structInfo->deviceMask << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceGroupCommandBufferBeginInfo");
    out << "VkDeviceGroupCommandBufferBeginInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceGroupSubmitInfo(std::ostream &out, const VkDeviceGroupSubmitInfo* structInfo, Decoded_VkDeviceGroupSubmitInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pWaitSemaphoreDeviceIndicesArray = "NULL";
    if (structInfo->pWaitSemaphoreDeviceIndices != NULL) {
        pWaitSemaphoreDeviceIndicesArray = "pWaitSemaphoreDeviceIndices_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pWaitSemaphoreDeviceIndicesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pWaitSemaphoreDeviceIndices, structInfo->waitSemaphoreCount) << ";" << std::endl;
    }
    std::string pCommandBufferDeviceMasksArray = "NULL";
    if (structInfo->pCommandBufferDeviceMasks != NULL) {
        pCommandBufferDeviceMasksArray = "pCommandBufferDeviceMasks_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pCommandBufferDeviceMasksArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCommandBufferDeviceMasks, structInfo->commandBufferCount) << ";" << std::endl;
    }
    std::string pSignalSemaphoreDeviceIndicesArray = "NULL";
    if (structInfo->pSignalSemaphoreDeviceIndices != NULL) {
        pSignalSemaphoreDeviceIndicesArray = "pSignalSemaphoreDeviceIndices_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pSignalSemaphoreDeviceIndicesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pSignalSemaphoreDeviceIndices, structInfo->signalSemaphoreCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* waitSemaphoreCount */
    structBody << "\t" << structInfo->waitSemaphoreCount << "," << std::endl;
/* pWaitSemaphoreDeviceIndices */
    structBody << "\t" << pWaitSemaphoreDeviceIndicesArray << "," << std::endl;
/* commandBufferCount */
    structBody << "\t" << structInfo->commandBufferCount << "," << std::endl;
/* pCommandBufferDeviceMasks */
    structBody << "\t" << pCommandBufferDeviceMasksArray << "," << std::endl;
/* signalSemaphoreCount */
    structBody << "\t" << structInfo->signalSemaphoreCount << "," << std::endl;
/* pSignalSemaphoreDeviceIndices */
    structBody << "\t" << pSignalSemaphoreDeviceIndicesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceGroupSubmitInfo");
    out << "VkDeviceGroupSubmitInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceGroupBindSparseInfo(std::ostream &out, const VkDeviceGroupBindSparseInfo* structInfo, Decoded_VkDeviceGroupBindSparseInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* resourceDeviceIndex */
    structBody << "\t" << structInfo->resourceDeviceIndex << "," << std::endl;
/* memoryDeviceIndex */
    structBody << "\t" << structInfo->memoryDeviceIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceGroupBindSparseInfo");
    out << "VkDeviceGroupBindSparseInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBindBufferMemoryDeviceGroupInfo(std::ostream &out, const VkBindBufferMemoryDeviceGroupInfo* structInfo, Decoded_VkBindBufferMemoryDeviceGroupInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDeviceIndicesArray = "NULL";
    if (structInfo->pDeviceIndices != NULL) {
        pDeviceIndicesArray = "pDeviceIndices_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pDeviceIndicesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceIndices, structInfo->deviceIndexCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceIndexCount */
    structBody << "\t" << structInfo->deviceIndexCount << "," << std::endl;
/* pDeviceIndices */
    structBody << "\t" << pDeviceIndicesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "bindBufferMemoryDeviceGroupInfo");
    out << "VkBindBufferMemoryDeviceGroupInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBindImageMemoryDeviceGroupInfo(std::ostream &out, const VkBindImageMemoryDeviceGroupInfo* structInfo, Decoded_VkBindImageMemoryDeviceGroupInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDeviceIndicesArray = "NULL";
    if (structInfo->pDeviceIndices != NULL) {
        pDeviceIndicesArray = "pDeviceIndices_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pDeviceIndicesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceIndices, structInfo->deviceIndexCount) << ";" << std::endl;
    }
    std::string pSplitInstanceBindRegionsArray = "NULL";
    if (structInfo->pSplitInstanceBindRegions != NULL) {
        pSplitInstanceBindRegionsArray = "pSplitInstanceBindRegions_" + std::to_string(consumer.getNextId());
        out << "VkRect2D " << pSplitInstanceBindRegionsArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pSplitInstanceBindRegions, structInfo->splitInstanceBindRegionCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceIndexCount */
    structBody << "\t" << structInfo->deviceIndexCount << "," << std::endl;
/* pDeviceIndices */
    structBody << "\t" << pDeviceIndicesArray << "," << std::endl;
/* splitInstanceBindRegionCount */
    structBody << "\t" << structInfo->splitInstanceBindRegionCount << "," << std::endl;
/* pSplitInstanceBindRegions */
    structBody << "\t" << pSplitInstanceBindRegionsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "bindImageMemoryDeviceGroupInfo");
    out << "VkBindImageMemoryDeviceGroupInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceGroupProperties(std::ostream &out, const VkPhysicalDeviceGroupProperties* structInfo, Decoded_VkPhysicalDeviceGroupProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* physicalDeviceCount */
    structBody << "\t" << structInfo->physicalDeviceCount << "," << std::endl;
/* physicalDevices */
    out << "// TODO: Support physicalDevices (output with array length value?) argument." << std::endl;
/* subsetAllocation */
    structBody << "\t" << structInfo->subsetAllocation << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceGroupProperties");
    out << "VkPhysicalDeviceGroupProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceGroupDeviceCreateInfo(std::ostream &out, const VkDeviceGroupDeviceCreateInfo* structInfo, Decoded_VkDeviceGroupDeviceCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pPhysicalDevicesArray = "NULL";
    if (metainfo->pPhysicalDevices.GetPointer() != NULL && structInfo->physicalDeviceCount > 0) {
        pPhysicalDevicesArray = "pPhysicalDevicesArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_PHYSICAL_DEVICE));
        std::string pPhysicalDevicesValues = toStringJoin(metainfo->pPhysicalDevices.GetPointer(),
                                                          metainfo->pPhysicalDevices.GetPointer() + structInfo->physicalDeviceCount,
                                                          [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                          ", ");
        if (structInfo->physicalDeviceCount == 1) {
            pPhysicalDevicesArray = "&" + pPhysicalDevicesValues;
        } else if (structInfo->physicalDeviceCount > 1) {
            out << "VkPhysicalDevice " << pPhysicalDevicesArray << "[] = {" << pPhysicalDevicesValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* physicalDeviceCount */
    structBody << "\t" << structInfo->physicalDeviceCount << "," << std::endl;
/* pPhysicalDevices */
    structBody << "\t" << pPhysicalDevicesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceGroupDeviceCreateInfo");
    out << "VkDeviceGroupDeviceCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBufferMemoryRequirementsInfo2(std::ostream &out, const VkBufferMemoryRequirementsInfo2* structInfo, Decoded_VkBufferMemoryRequirementsInfo2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* buffer */
    structBody << "\t" << consumer.GetHandle(metainfo->buffer) << "," ;
    std::string varname = consumer.AddStruct(structBody, "bufferMemoryRequirementsInfo2");
    out << "VkBufferMemoryRequirementsInfo2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageMemoryRequirementsInfo2(std::ostream &out, const VkImageMemoryRequirementsInfo2* structInfo, Decoded_VkImageMemoryRequirementsInfo2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* image */
    structBody << "\t" << consumer.GetHandle(metainfo->image) << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageMemoryRequirementsInfo2");
    out << "VkImageMemoryRequirementsInfo2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageSparseMemoryRequirementsInfo2(std::ostream &out, const VkImageSparseMemoryRequirementsInfo2* structInfo, Decoded_VkImageSparseMemoryRequirementsInfo2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* image */
    structBody << "\t" << consumer.GetHandle(metainfo->image) << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageSparseMemoryRequirementsInfo2");
    out << "VkImageSparseMemoryRequirementsInfo2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryRequirements2(std::ostream &out, const VkMemoryRequirements2* structInfo, Decoded_VkMemoryRequirements2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string memoryRequirementsInfoVar = GenerateStruct_VkMemoryRequirements(out,
                                                                           &structInfo->memoryRequirements,
                                                                           metainfo->memoryRequirements,
                                                                           consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memoryRequirements */
    structBody << "\t" << memoryRequirementsInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryRequirements2");
    out << varname << " = {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSparseImageMemoryRequirements2(std::ostream &out, const VkSparseImageMemoryRequirements2* structInfo, Decoded_VkSparseImageMemoryRequirements2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string memoryRequirementsInfoVar = GenerateStruct_VkSparseImageMemoryRequirements(out,
                                                                           &structInfo->memoryRequirements,
                                                                           metainfo->memoryRequirements,
                                                                           consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memoryRequirements */
    structBody << "\t" << memoryRequirementsInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "sparseImageMemoryRequirements2");
    out << "VkSparseImageMemoryRequirements2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFeatures2(std::ostream &out, const VkPhysicalDeviceFeatures2* structInfo, Decoded_VkPhysicalDeviceFeatures2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string featuresInfoVar = GenerateStruct_VkPhysicalDeviceFeatures(out,
                                                                 &structInfo->features,
                                                                 metainfo->features,
                                                                 consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* features */
    structBody << "\t" << featuresInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFeatures2");
    out << "VkPhysicalDeviceFeatures2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceProperties2(std::ostream &out, const VkPhysicalDeviceProperties2* structInfo, Decoded_VkPhysicalDeviceProperties2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string propertiesInfoVar = GenerateStruct_VkPhysicalDeviceProperties(out,
                                                                   &structInfo->properties,
                                                                   metainfo->properties,
                                                                   consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* properties */
    structBody << "\t" << propertiesInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceProperties2");
    out << "VkPhysicalDeviceProperties2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkFormatProperties2(std::ostream &out, const VkFormatProperties2* structInfo, Decoded_VkFormatProperties2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string formatPropertiesInfoVar = GenerateStruct_VkFormatProperties(out,
                                                                         &structInfo->formatProperties,
                                                                         metainfo->formatProperties,
                                                                         consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* formatProperties */
    structBody << "\t" << formatPropertiesInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "formatProperties2");
    out << "VkFormatProperties2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageFormatProperties2(std::ostream &out, const VkImageFormatProperties2* structInfo, Decoded_VkImageFormatProperties2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string imageFormatPropertiesInfoVar = GenerateStruct_VkImageFormatProperties(out,
                                                                              &structInfo->imageFormatProperties,
                                                                              metainfo->imageFormatProperties,
                                                                              consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* imageFormatProperties */
    structBody << "\t" << imageFormatPropertiesInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageFormatProperties2");
    out << "VkImageFormatProperties2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceImageFormatInfo2(std::ostream &out, const VkPhysicalDeviceImageFormatInfo2* structInfo, Decoded_VkPhysicalDeviceImageFormatInfo2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
/* type */
    structBody << "\t" << "VkImageType(" << structInfo->type << ")" << "," << std::endl;
/* tiling */
    structBody << "\t" << "VkImageTiling(" << structInfo->tiling << ")" << "," << std::endl;
/* usage */
    structBody << "\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
/* flags */
    structBody << "\t" << "VkImageCreateFlags(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceImageFormatInfo2");
    out << "VkPhysicalDeviceImageFormatInfo2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkQueueFamilyProperties2(std::ostream &out, const VkQueueFamilyProperties2* structInfo, Decoded_VkQueueFamilyProperties2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string queueFamilyPropertiesInfoVar = GenerateStruct_VkQueueFamilyProperties(out,
                                                                              &structInfo->queueFamilyProperties,
                                                                              metainfo->queueFamilyProperties,
                                                                              consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* queueFamilyProperties */
    structBody << "\t" << queueFamilyPropertiesInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "queueFamilyProperties2");
    out << "VkQueueFamilyProperties2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMemoryProperties2(std::ostream &out, const VkPhysicalDeviceMemoryProperties2* structInfo, Decoded_VkPhysicalDeviceMemoryProperties2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string memoryPropertiesInfoVar = GenerateStruct_VkPhysicalDeviceMemoryProperties(out,
                                                                         &structInfo->memoryProperties,
                                                                         metainfo->memoryProperties,
                                                                         consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memoryProperties */
    structBody << "\t" << memoryPropertiesInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMemoryProperties2");
    out << "VkPhysicalDeviceMemoryProperties2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSparseImageFormatProperties2(std::ostream &out, const VkSparseImageFormatProperties2* structInfo, Decoded_VkSparseImageFormatProperties2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string propertiesInfoVar = GenerateStruct_VkSparseImageFormatProperties(out,
                                                                   &structInfo->properties,
                                                                   metainfo->properties,
                                                                   consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* properties */
    structBody << "\t" << propertiesInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "sparseImageFormatProperties2");
    out << "VkSparseImageFormatProperties2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceSparseImageFormatInfo2(std::ostream &out, const VkPhysicalDeviceSparseImageFormatInfo2* structInfo, Decoded_VkPhysicalDeviceSparseImageFormatInfo2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
/* type */
    structBody << "\t" << "VkImageType(" << structInfo->type << ")" << "," << std::endl;
/* samples */
    structBody << "\t" << "VkSampleCountFlagBits(" << structInfo->samples << ")" << "," << std::endl;
/* usage */
    structBody << "\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
/* tiling */
    structBody << "\t" << "VkImageTiling(" << structInfo->tiling << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceSparseImageFormatInfo2");
    out << "VkPhysicalDeviceSparseImageFormatInfo2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePointClippingProperties(std::ostream &out, const VkPhysicalDevicePointClippingProperties* structInfo, Decoded_VkPhysicalDevicePointClippingProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pointClippingBehavior */
    structBody << "\t" << "VkPointClippingBehavior(" << structInfo->pointClippingBehavior << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePointClippingProperties");
    out << "VkPhysicalDevicePointClippingProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkInputAttachmentAspectReference(std::ostream &out, const VkInputAttachmentAspectReference* structInfo, Decoded_VkInputAttachmentAspectReference* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* subpass */
    structBody << "\t" << structInfo->subpass << "," << std::endl;
/* inputAttachmentIndex */
    structBody << "\t" << structInfo->inputAttachmentIndex << "," << std::endl;
/* aspectMask */
    structBody << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "inputAttachmentAspectReference");
    out << "VkInputAttachmentAspectReference " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderPassInputAttachmentAspectCreateInfo(std::ostream &out, const VkRenderPassInputAttachmentAspectCreateInfo* structInfo, Decoded_VkRenderPassInputAttachmentAspectCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pAspectReferencesArray = "NULL";
    if (structInfo->pAspectReferences != NULL) {
        pAspectReferencesArray = "pAspectReferences_" + std::to_string(consumer.getNextId());
        std::string pAspectReferencesNames;
        for (uint32_t idx = 0; idx < structInfo->aspectReferenceCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pAspectReferences + idx != NULL) {
                varName = GenerateStruct_VkInputAttachmentAspectReference(out,
                                                         structInfo->pAspectReferences + idx,
                                                         metainfo->pAspectReferences->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pAspectReferencesNames += varName + ", ";
        }
        out << "VkInputAttachmentAspectReference " << pAspectReferencesArray << "[] = {" << pAspectReferencesNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* aspectReferenceCount */
    structBody << "\t" << structInfo->aspectReferenceCount << "," << std::endl;
/* pAspectReferences */
    structBody << "\t" << pAspectReferencesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderPassInputAttachmentAspectCreateInfo");
    out << "VkRenderPassInputAttachmentAspectCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageViewUsageCreateInfo(std::ostream &out, const VkImageViewUsageCreateInfo* structInfo, Decoded_VkImageViewUsageCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* usage */
    structBody << "\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageViewUsageCreateInfo");
    out << "VkImageViewUsageCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineTessellationDomainOriginStateCreateInfo(std::ostream &out, const VkPipelineTessellationDomainOriginStateCreateInfo* structInfo, Decoded_VkPipelineTessellationDomainOriginStateCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* domainOrigin */
    structBody << "\t" << "VkTessellationDomainOrigin(" << structInfo->domainOrigin << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineTessellationDomainOriginStateCreateInfo");
    out << "VkPipelineTessellationDomainOriginStateCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderPassMultiviewCreateInfo(std::ostream &out, const VkRenderPassMultiviewCreateInfo* structInfo, Decoded_VkRenderPassMultiviewCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pViewMasksArray = "NULL";
    if (structInfo->pViewMasks != NULL) {
        pViewMasksArray = "pViewMasks_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pViewMasksArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pViewMasks, structInfo->subpassCount) << ";" << std::endl;
    }
    std::string pViewOffsetsArray = "NULL";
    if (structInfo->pViewOffsets != NULL) {
        pViewOffsetsArray = "pViewOffsets_" + std::to_string(consumer.getNextId());
        out << "int32_t " << pViewOffsetsArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pViewOffsets, structInfo->dependencyCount) << ";" << std::endl;
    }
    std::string pCorrelationMasksArray = "NULL";
    if (structInfo->pCorrelationMasks != NULL) {
        pCorrelationMasksArray = "pCorrelationMasks_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pCorrelationMasksArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCorrelationMasks, structInfo->correlationMaskCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* subpassCount */
    structBody << "\t" << structInfo->subpassCount << "," << std::endl;
/* pViewMasks */
    structBody << "\t" << pViewMasksArray << "," << std::endl;
/* dependencyCount */
    structBody << "\t" << structInfo->dependencyCount << "," << std::endl;
/* pViewOffsets */
    structBody << "\t" << pViewOffsetsArray << "," << std::endl;
/* correlationMaskCount */
    structBody << "\t" << structInfo->correlationMaskCount << "," << std::endl;
/* pCorrelationMasks */
    structBody << "\t" << pCorrelationMasksArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderPassMultiviewCreateInfo");
    out << "VkRenderPassMultiviewCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewFeatures(std::ostream &out, const VkPhysicalDeviceMultiviewFeatures* structInfo, Decoded_VkPhysicalDeviceMultiviewFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* multiview */
    structBody << "\t" << structInfo->multiview << "," << std::endl;
/* multiviewGeometryShader */
    structBody << "\t" << structInfo->multiviewGeometryShader << "," << std::endl;
/* multiviewTessellationShader */
    structBody << "\t" << structInfo->multiviewTessellationShader << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMultiviewFeatures");
    out << "VkPhysicalDeviceMultiviewFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewProperties(std::ostream &out, const VkPhysicalDeviceMultiviewProperties* structInfo, Decoded_VkPhysicalDeviceMultiviewProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxMultiviewViewCount */
    structBody << "\t" << structInfo->maxMultiviewViewCount << "," << std::endl;
/* maxMultiviewInstanceIndex */
    structBody << "\t" << structInfo->maxMultiviewInstanceIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMultiviewProperties");
    out << "VkPhysicalDeviceMultiviewProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceVariablePointersFeatures(std::ostream &out, const VkPhysicalDeviceVariablePointersFeatures* structInfo, Decoded_VkPhysicalDeviceVariablePointersFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* variablePointersStorageBuffer */
    structBody << "\t" << structInfo->variablePointersStorageBuffer << "," << std::endl;
/* variablePointers */
    structBody << "\t" << structInfo->variablePointers << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceVariablePointersFeatures");
    out << "VkPhysicalDeviceVariablePointersFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceProtectedMemoryFeatures(std::ostream &out, const VkPhysicalDeviceProtectedMemoryFeatures* structInfo, Decoded_VkPhysicalDeviceProtectedMemoryFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* protectedMemory */
    structBody << "\t" << structInfo->protectedMemory << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceProtectedMemoryFeatures");
    out << "VkPhysicalDeviceProtectedMemoryFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceProtectedMemoryProperties(std::ostream &out, const VkPhysicalDeviceProtectedMemoryProperties* structInfo, Decoded_VkPhysicalDeviceProtectedMemoryProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* protectedNoFault */
    structBody << "\t" << structInfo->protectedNoFault << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceProtectedMemoryProperties");
    out << "VkPhysicalDeviceProtectedMemoryProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceQueueInfo2(std::ostream &out, const VkDeviceQueueInfo2* structInfo, Decoded_VkDeviceQueueInfo2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDeviceQueueCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* queueFamilyIndex */
    structBody << "\t" << structInfo->queueFamilyIndex << "," << std::endl;
/* queueIndex */
    structBody << "\t" << structInfo->queueIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceQueueInfo2");
    out << "VkDeviceQueueInfo2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkProtectedSubmitInfo(std::ostream &out, const VkProtectedSubmitInfo* structInfo, Decoded_VkProtectedSubmitInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* protectedSubmit */
    structBody << "\t" << structInfo->protectedSubmit << "," ;
    std::string varname = consumer.AddStruct(structBody, "protectedSubmitInfo");
    out << "VkProtectedSubmitInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSamplerYcbcrConversionCreateInfo(std::ostream &out, const VkSamplerYcbcrConversionCreateInfo* structInfo, Decoded_VkSamplerYcbcrConversionCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string componentsInfoVar = GenerateStruct_VkComponentMapping(out,
                                                                   &structInfo->components,
                                                                   metainfo->components,
                                                                   consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
/* ycbcrModel */
    structBody << "\t" << "VkSamplerYcbcrModelConversion(" << structInfo->ycbcrModel << ")" << "," << std::endl;
/* ycbcrRange */
    structBody << "\t" << "VkSamplerYcbcrRange(" << structInfo->ycbcrRange << ")" << "," << std::endl;
/* components */
    structBody << "\t" << componentsInfoVar << "," << std::endl;
/* xChromaOffset */
    structBody << "\t" << "VkChromaLocation(" << structInfo->xChromaOffset << ")" << "," << std::endl;
/* yChromaOffset */
    structBody << "\t" << "VkChromaLocation(" << structInfo->yChromaOffset << ")" << "," << std::endl;
/* chromaFilter */
    structBody << "\t" << "VkFilter(" << structInfo->chromaFilter << ")" << "," << std::endl;
/* forceExplicitReconstruction */
    structBody << "\t" << structInfo->forceExplicitReconstruction << "," ;
    std::string varname = consumer.AddStruct(structBody, "samplerYcbcrConversionCreateInfo");
    out << "VkSamplerYcbcrConversionCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSamplerYcbcrConversionInfo(std::ostream &out, const VkSamplerYcbcrConversionInfo* structInfo, Decoded_VkSamplerYcbcrConversionInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* conversion */
    structBody << "\t" << consumer.GetHandle(metainfo->conversion) << "," ;
    std::string varname = consumer.AddStruct(structBody, "samplerYcbcrConversionInfo");
    out << "VkSamplerYcbcrConversionInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBindImagePlaneMemoryInfo(std::ostream &out, const VkBindImagePlaneMemoryInfo* structInfo, Decoded_VkBindImagePlaneMemoryInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* planeAspect */
    structBody << "\t" << "VkImageAspectFlagBits(" << structInfo->planeAspect << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "bindImagePlaneMemoryInfo");
    out << "VkBindImagePlaneMemoryInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImagePlaneMemoryRequirementsInfo(std::ostream &out, const VkImagePlaneMemoryRequirementsInfo* structInfo, Decoded_VkImagePlaneMemoryRequirementsInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* planeAspect */
    structBody << "\t" << "VkImageAspectFlagBits(" << structInfo->planeAspect << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "imagePlaneMemoryRequirementsInfo");
    out << "VkImagePlaneMemoryRequirementsInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceSamplerYcbcrConversionFeatures(std::ostream &out, const VkPhysicalDeviceSamplerYcbcrConversionFeatures* structInfo, Decoded_VkPhysicalDeviceSamplerYcbcrConversionFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* samplerYcbcrConversion */
    structBody << "\t" << structInfo->samplerYcbcrConversion << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceSamplerYcbcrConversionFeatures");
    out << "VkPhysicalDeviceSamplerYcbcrConversionFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSamplerYcbcrConversionImageFormatProperties(std::ostream &out, const VkSamplerYcbcrConversionImageFormatProperties* structInfo, Decoded_VkSamplerYcbcrConversionImageFormatProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* combinedImageSamplerDescriptorCount */
    structBody << "\t" << structInfo->combinedImageSamplerDescriptorCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "samplerYcbcrConversionImageFormatProperties");
    out << "VkSamplerYcbcrConversionImageFormatProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDescriptorUpdateTemplateCreateInfo(std::ostream &out, const VkDescriptorUpdateTemplateCreateInfo* structInfo, Decoded_VkDescriptorUpdateTemplateCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDescriptorUpdateEntriesArray = "NULL";
    if (structInfo->pDescriptorUpdateEntries != NULL) {
        pDescriptorUpdateEntriesArray = "pDescriptorUpdateEntries_" + std::to_string(consumer.getNextId());
        std::string pDescriptorUpdateEntriesNames;
        for (uint32_t idx = 0; idx < structInfo->descriptorUpdateEntryCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pDescriptorUpdateEntries + idx != NULL) {
                varName = GenerateStruct_VkDescriptorUpdateTemplateEntry(out,
                                                         structInfo->pDescriptorUpdateEntries + idx,
                                                         metainfo->pDescriptorUpdateEntries->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pDescriptorUpdateEntriesNames += varName + ", ";
        }
        out << "VkDescriptorUpdateTemplateEntry " << pDescriptorUpdateEntriesArray << "[] = {" << pDescriptorUpdateEntriesNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDescriptorUpdateTemplateCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* descriptorUpdateEntryCount */
    structBody << "\t" << structInfo->descriptorUpdateEntryCount << "," << std::endl;
/* pDescriptorUpdateEntries */
    structBody << "\t" << pDescriptorUpdateEntriesArray << "," << std::endl;
/* templateType */
    structBody << "\t" << "VkDescriptorUpdateTemplateType(" << structInfo->templateType << ")" << "," << std::endl;
/* descriptorSetLayout */
    structBody << "\t" << consumer.GetHandle(metainfo->descriptorSetLayout) << "," << std::endl;
/* pipelineBindPoint */
    structBody << "\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
/* pipelineLayout */
    structBody << "\t" << consumer.GetHandle(metainfo->pipelineLayout) << "," << std::endl;
/* set */
    structBody << "\t" << structInfo->set << "," ;
    std::string varname = consumer.AddStruct(structBody, "descriptorUpdateTemplateCreateInfo");
    out << "VkDescriptorUpdateTemplateCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExternalMemoryProperties(std::ostream &out, const VkExternalMemoryProperties* structInfo, Decoded_VkExternalMemoryProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* externalMemoryFeatures */
    structBody << "\t" << "VkExternalMemoryFeatureFlags(" << structInfo->externalMemoryFeatures << ")" << "," << std::endl;
/* exportFromImportedHandleTypes */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->exportFromImportedHandleTypes << ")" << "," << std::endl;
/* compatibleHandleTypes */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->compatibleHandleTypes << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "externalMemoryProperties");
    out << "VkExternalMemoryProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExternalImageFormatInfo(std::ostream &out, const VkPhysicalDeviceExternalImageFormatInfo* structInfo, Decoded_VkPhysicalDeviceExternalImageFormatInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExternalImageFormatInfo");
    out << "VkPhysicalDeviceExternalImageFormatInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExternalImageFormatProperties(std::ostream &out, const VkExternalImageFormatProperties* structInfo, Decoded_VkExternalImageFormatProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string externalMemoryPropertiesInfoVar = GenerateStruct_VkExternalMemoryProperties(out,
                                                                                 &structInfo->externalMemoryProperties,
                                                                                 metainfo->externalMemoryProperties,
                                                                                 consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* externalMemoryProperties */
    structBody << "\t" << externalMemoryPropertiesInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "externalImageFormatProperties");
    out << "VkExternalImageFormatProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExternalBufferInfo(std::ostream &out, const VkPhysicalDeviceExternalBufferInfo* structInfo, Decoded_VkPhysicalDeviceExternalBufferInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkBufferCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* usage */
    structBody << "\t" << "VkBufferUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExternalBufferInfo");
    out << "VkPhysicalDeviceExternalBufferInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExternalBufferProperties(std::ostream &out, const VkExternalBufferProperties* structInfo, Decoded_VkExternalBufferProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string externalMemoryPropertiesInfoVar = GenerateStruct_VkExternalMemoryProperties(out,
                                                                                 &structInfo->externalMemoryProperties,
                                                                                 metainfo->externalMemoryProperties,
                                                                                 consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* externalMemoryProperties */
    structBody << "\t" << externalMemoryPropertiesInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "externalBufferProperties");
    out << "VkExternalBufferProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceIDProperties(std::ostream &out, const VkPhysicalDeviceIDProperties* structInfo, Decoded_VkPhysicalDeviceIDProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceUUID */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->deviceUUID[0]), VK_UUID_SIZE) << "," << std::endl;
/* driverUUID */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->driverUUID[0]), VK_UUID_SIZE) << "," << std::endl;
/* deviceLUID */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->deviceLUID[0]), VK_LUID_SIZE) << "," << std::endl;
/* deviceNodeMask */
    structBody << "\t" << structInfo->deviceNodeMask << "," << std::endl;
/* deviceLUIDValid */
    structBody << "\t" << structInfo->deviceLUIDValid << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceIDProperties");
    out << "VkPhysicalDeviceIDProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExternalMemoryImageCreateInfo(std::ostream &out, const VkExternalMemoryImageCreateInfo* structInfo, Decoded_VkExternalMemoryImageCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleTypes */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->handleTypes << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "externalMemoryImageCreateInfo");
    out << "VkExternalMemoryImageCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExternalMemoryBufferCreateInfo(std::ostream &out, const VkExternalMemoryBufferCreateInfo* structInfo, Decoded_VkExternalMemoryBufferCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleTypes */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->handleTypes << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "externalMemoryBufferCreateInfo");
    out << "VkExternalMemoryBufferCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExportMemoryAllocateInfo(std::ostream &out, const VkExportMemoryAllocateInfo* structInfo, Decoded_VkExportMemoryAllocateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleTypes */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlags(" << structInfo->handleTypes << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "exportMemoryAllocateInfo");
    out << "VkExportMemoryAllocateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExternalFenceInfo(std::ostream &out, const VkPhysicalDeviceExternalFenceInfo* structInfo, Decoded_VkPhysicalDeviceExternalFenceInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExternalFenceInfo");
    out << "VkPhysicalDeviceExternalFenceInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExternalFenceProperties(std::ostream &out, const VkExternalFenceProperties* structInfo, Decoded_VkExternalFenceProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* exportFromImportedHandleTypes */
    structBody << "\t" << "VkExternalFenceHandleTypeFlags(" << structInfo->exportFromImportedHandleTypes << ")" << "," << std::endl;
/* compatibleHandleTypes */
    structBody << "\t" << "VkExternalFenceHandleTypeFlags(" << structInfo->compatibleHandleTypes << ")" << "," << std::endl;
/* externalFenceFeatures */
    structBody << "\t" << "VkExternalFenceFeatureFlags(" << structInfo->externalFenceFeatures << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "externalFenceProperties");
    out << "VkExternalFenceProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExportFenceCreateInfo(std::ostream &out, const VkExportFenceCreateInfo* structInfo, Decoded_VkExportFenceCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleTypes */
    structBody << "\t" << "VkExternalFenceHandleTypeFlags(" << structInfo->handleTypes << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "exportFenceCreateInfo");
    out << "VkExportFenceCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExportSemaphoreCreateInfo(std::ostream &out, const VkExportSemaphoreCreateInfo* structInfo, Decoded_VkExportSemaphoreCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleTypes */
    structBody << "\t" << "VkExternalSemaphoreHandleTypeFlags(" << structInfo->handleTypes << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "exportSemaphoreCreateInfo");
    out << "VkExportSemaphoreCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExternalSemaphoreInfo(std::ostream &out, const VkPhysicalDeviceExternalSemaphoreInfo* structInfo, Decoded_VkPhysicalDeviceExternalSemaphoreInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExternalSemaphoreInfo");
    out << "VkPhysicalDeviceExternalSemaphoreInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExternalSemaphoreProperties(std::ostream &out, const VkExternalSemaphoreProperties* structInfo, Decoded_VkExternalSemaphoreProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* exportFromImportedHandleTypes */
    structBody << "\t" << "VkExternalSemaphoreHandleTypeFlags(" << structInfo->exportFromImportedHandleTypes << ")" << "," << std::endl;
/* compatibleHandleTypes */
    structBody << "\t" << "VkExternalSemaphoreHandleTypeFlags(" << structInfo->compatibleHandleTypes << ")" << "," << std::endl;
/* externalSemaphoreFeatures */
    structBody << "\t" << "VkExternalSemaphoreFeatureFlags(" << structInfo->externalSemaphoreFeatures << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "externalSemaphoreProperties");
    out << "VkExternalSemaphoreProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance3Properties(std::ostream &out, const VkPhysicalDeviceMaintenance3Properties* structInfo, Decoded_VkPhysicalDeviceMaintenance3Properties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxPerSetDescriptors */
    structBody << "\t" << structInfo->maxPerSetDescriptors << "," << std::endl;
/* maxMemoryAllocationSize */
    structBody << "\t" << structInfo->maxMemoryAllocationSize << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMaintenance3Properties");
    out << "VkPhysicalDeviceMaintenance3Properties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDescriptorSetLayoutSupport(std::ostream &out, const VkDescriptorSetLayoutSupport* structInfo, Decoded_VkDescriptorSetLayoutSupport* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* supported */
    structBody << "\t" << structInfo->supported << "," ;
    std::string varname = consumer.AddStruct(structBody, "descriptorSetLayoutSupport");
    out << "VkDescriptorSetLayoutSupport " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderDrawParametersFeatures(std::ostream &out, const VkPhysicalDeviceShaderDrawParametersFeatures* structInfo, Decoded_VkPhysicalDeviceShaderDrawParametersFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderDrawParameters */
    structBody << "\t" << structInfo->shaderDrawParameters << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderDrawParametersFeatures");
    out << "VkPhysicalDeviceShaderDrawParametersFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan11Features(std::ostream &out, const VkPhysicalDeviceVulkan11Features* structInfo, Decoded_VkPhysicalDeviceVulkan11Features* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* storageBuffer16BitAccess */
    structBody << "\t" << structInfo->storageBuffer16BitAccess << "," << std::endl;
/* uniformAndStorageBuffer16BitAccess */
    structBody << "\t" << structInfo->uniformAndStorageBuffer16BitAccess << "," << std::endl;
/* storagePushConstant16 */
    structBody << "\t" << structInfo->storagePushConstant16 << "," << std::endl;
/* storageInputOutput16 */
    structBody << "\t" << structInfo->storageInputOutput16 << "," << std::endl;
/* multiview */
    structBody << "\t" << structInfo->multiview << "," << std::endl;
/* multiviewGeometryShader */
    structBody << "\t" << structInfo->multiviewGeometryShader << "," << std::endl;
/* multiviewTessellationShader */
    structBody << "\t" << structInfo->multiviewTessellationShader << "," << std::endl;
/* variablePointersStorageBuffer */
    structBody << "\t" << structInfo->variablePointersStorageBuffer << "," << std::endl;
/* variablePointers */
    structBody << "\t" << structInfo->variablePointers << "," << std::endl;
/* protectedMemory */
    structBody << "\t" << structInfo->protectedMemory << "," << std::endl;
/* samplerYcbcrConversion */
    structBody << "\t" << structInfo->samplerYcbcrConversion << "," << std::endl;
/* shaderDrawParameters */
    structBody << "\t" << structInfo->shaderDrawParameters << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceVulkan11Features");
    out << "VkPhysicalDeviceVulkan11Features " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan11Properties(std::ostream &out, const VkPhysicalDeviceVulkan11Properties* structInfo, Decoded_VkPhysicalDeviceVulkan11Properties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceUUID */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->deviceUUID[0]), VK_UUID_SIZE) << "," << std::endl;
/* driverUUID */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->driverUUID[0]), VK_UUID_SIZE) << "," << std::endl;
/* deviceLUID */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->deviceLUID[0]), VK_LUID_SIZE) << "," << std::endl;
/* deviceNodeMask */
    structBody << "\t" << structInfo->deviceNodeMask << "," << std::endl;
/* deviceLUIDValid */
    structBody << "\t" << structInfo->deviceLUIDValid << "," << std::endl;
/* subgroupSize */
    structBody << "\t" << structInfo->subgroupSize << "," << std::endl;
/* subgroupSupportedStages */
    structBody << "\t" << "VkShaderStageFlags(" << structInfo->subgroupSupportedStages << ")" << "," << std::endl;
/* subgroupSupportedOperations */
    structBody << "\t" << "VkSubgroupFeatureFlags(" << structInfo->subgroupSupportedOperations << ")" << "," << std::endl;
/* subgroupQuadOperationsInAllStages */
    structBody << "\t" << structInfo->subgroupQuadOperationsInAllStages << "," << std::endl;
/* pointClippingBehavior */
    structBody << "\t" << "VkPointClippingBehavior(" << structInfo->pointClippingBehavior << ")" << "," << std::endl;
/* maxMultiviewViewCount */
    structBody << "\t" << structInfo->maxMultiviewViewCount << "," << std::endl;
/* maxMultiviewInstanceIndex */
    structBody << "\t" << structInfo->maxMultiviewInstanceIndex << "," << std::endl;
/* protectedNoFault */
    structBody << "\t" << structInfo->protectedNoFault << "," << std::endl;
/* maxPerSetDescriptors */
    structBody << "\t" << structInfo->maxPerSetDescriptors << "," << std::endl;
/* maxMemoryAllocationSize */
    structBody << "\t" << structInfo->maxMemoryAllocationSize << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceVulkan11Properties");
    out << "VkPhysicalDeviceVulkan11Properties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan12Features(std::ostream &out, const VkPhysicalDeviceVulkan12Features* structInfo, Decoded_VkPhysicalDeviceVulkan12Features* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* samplerMirrorClampToEdge */
    structBody << "\t" << structInfo->samplerMirrorClampToEdge << "," << std::endl;
/* drawIndirectCount */
    structBody << "\t" << structInfo->drawIndirectCount << "," << std::endl;
/* storageBuffer8BitAccess */
    structBody << "\t" << structInfo->storageBuffer8BitAccess << "," << std::endl;
/* uniformAndStorageBuffer8BitAccess */
    structBody << "\t" << structInfo->uniformAndStorageBuffer8BitAccess << "," << std::endl;
/* storagePushConstant8 */
    structBody << "\t" << structInfo->storagePushConstant8 << "," << std::endl;
/* shaderBufferInt64Atomics */
    structBody << "\t" << structInfo->shaderBufferInt64Atomics << "," << std::endl;
/* shaderSharedInt64Atomics */
    structBody << "\t" << structInfo->shaderSharedInt64Atomics << "," << std::endl;
/* shaderFloat16 */
    structBody << "\t" << structInfo->shaderFloat16 << "," << std::endl;
/* shaderInt8 */
    structBody << "\t" << structInfo->shaderInt8 << "," << std::endl;
/* descriptorIndexing */
    structBody << "\t" << structInfo->descriptorIndexing << "," << std::endl;
/* shaderInputAttachmentArrayDynamicIndexing */
    structBody << "\t" << structInfo->shaderInputAttachmentArrayDynamicIndexing << "," << std::endl;
/* shaderUniformTexelBufferArrayDynamicIndexing */
    structBody << "\t" << structInfo->shaderUniformTexelBufferArrayDynamicIndexing << "," << std::endl;
/* shaderStorageTexelBufferArrayDynamicIndexing */
    structBody << "\t" << structInfo->shaderStorageTexelBufferArrayDynamicIndexing << "," << std::endl;
/* shaderUniformBufferArrayNonUniformIndexing */
    structBody << "\t" << structInfo->shaderUniformBufferArrayNonUniformIndexing << "," << std::endl;
/* shaderSampledImageArrayNonUniformIndexing */
    structBody << "\t" << structInfo->shaderSampledImageArrayNonUniformIndexing << "," << std::endl;
/* shaderStorageBufferArrayNonUniformIndexing */
    structBody << "\t" << structInfo->shaderStorageBufferArrayNonUniformIndexing << "," << std::endl;
/* shaderStorageImageArrayNonUniformIndexing */
    structBody << "\t" << structInfo->shaderStorageImageArrayNonUniformIndexing << "," << std::endl;
/* shaderInputAttachmentArrayNonUniformIndexing */
    structBody << "\t" << structInfo->shaderInputAttachmentArrayNonUniformIndexing << "," << std::endl;
/* shaderUniformTexelBufferArrayNonUniformIndexing */
    structBody << "\t" << structInfo->shaderUniformTexelBufferArrayNonUniformIndexing << "," << std::endl;
/* shaderStorageTexelBufferArrayNonUniformIndexing */
    structBody << "\t" << structInfo->shaderStorageTexelBufferArrayNonUniformIndexing << "," << std::endl;
/* descriptorBindingUniformBufferUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingUniformBufferUpdateAfterBind << "," << std::endl;
/* descriptorBindingSampledImageUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingSampledImageUpdateAfterBind << "," << std::endl;
/* descriptorBindingStorageImageUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingStorageImageUpdateAfterBind << "," << std::endl;
/* descriptorBindingStorageBufferUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingStorageBufferUpdateAfterBind << "," << std::endl;
/* descriptorBindingUniformTexelBufferUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingUniformTexelBufferUpdateAfterBind << "," << std::endl;
/* descriptorBindingStorageTexelBufferUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingStorageTexelBufferUpdateAfterBind << "," << std::endl;
/* descriptorBindingUpdateUnusedWhilePending */
    structBody << "\t" << structInfo->descriptorBindingUpdateUnusedWhilePending << "," << std::endl;
/* descriptorBindingPartiallyBound */
    structBody << "\t" << structInfo->descriptorBindingPartiallyBound << "," << std::endl;
/* descriptorBindingVariableDescriptorCount */
    structBody << "\t" << structInfo->descriptorBindingVariableDescriptorCount << "," << std::endl;
/* runtimeDescriptorArray */
    structBody << "\t" << structInfo->runtimeDescriptorArray << "," << std::endl;
/* samplerFilterMinmax */
    structBody << "\t" << structInfo->samplerFilterMinmax << "," << std::endl;
/* scalarBlockLayout */
    structBody << "\t" << structInfo->scalarBlockLayout << "," << std::endl;
/* imagelessFramebuffer */
    structBody << "\t" << structInfo->imagelessFramebuffer << "," << std::endl;
/* uniformBufferStandardLayout */
    structBody << "\t" << structInfo->uniformBufferStandardLayout << "," << std::endl;
/* shaderSubgroupExtendedTypes */
    structBody << "\t" << structInfo->shaderSubgroupExtendedTypes << "," << std::endl;
/* separateDepthStencilLayouts */
    structBody << "\t" << structInfo->separateDepthStencilLayouts << "," << std::endl;
/* hostQueryReset */
    structBody << "\t" << structInfo->hostQueryReset << "," << std::endl;
/* timelineSemaphore */
    structBody << "\t" << structInfo->timelineSemaphore << "," << std::endl;
/* bufferDeviceAddress */
    structBody << "\t" << structInfo->bufferDeviceAddress << "," << std::endl;
/* bufferDeviceAddressCaptureReplay */
    structBody << "\t" << structInfo->bufferDeviceAddressCaptureReplay << "," << std::endl;
/* bufferDeviceAddressMultiDevice */
    structBody << "\t" << structInfo->bufferDeviceAddressMultiDevice << "," << std::endl;
/* vulkanMemoryModel */
    structBody << "\t" << structInfo->vulkanMemoryModel << "," << std::endl;
/* vulkanMemoryModelDeviceScope */
    structBody << "\t" << structInfo->vulkanMemoryModelDeviceScope << "," << std::endl;
/* vulkanMemoryModelAvailabilityVisibilityChains */
    structBody << "\t" << structInfo->vulkanMemoryModelAvailabilityVisibilityChains << "," << std::endl;
/* shaderOutputViewportIndex */
    structBody << "\t" << structInfo->shaderOutputViewportIndex << "," << std::endl;
/* shaderOutputLayer */
    structBody << "\t" << structInfo->shaderOutputLayer << "," << std::endl;
/* subgroupBroadcastDynamicId */
    structBody << "\t" << structInfo->subgroupBroadcastDynamicId << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceVulkan12Features");
    out << "VkPhysicalDeviceVulkan12Features " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkConformanceVersion(std::ostream &out, const VkConformanceVersion* structInfo, Decoded_VkConformanceVersion* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* major */
    structBody << "\t" << structInfo->major << "," << std::endl;
/* minor */
    structBody << "\t" << structInfo->minor << "," << std::endl;
/* subminor */
    structBody << "\t" << structInfo->subminor << "," << std::endl;
/* patch */
    structBody << "\t" << structInfo->patch << "," ;
    std::string varname = consumer.AddStruct(structBody, "conformanceVersion");
    out << "VkConformanceVersion " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan12Properties(std::ostream &out, const VkPhysicalDeviceVulkan12Properties* structInfo, Decoded_VkPhysicalDeviceVulkan12Properties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string conformanceVersionInfoVar = GenerateStruct_VkConformanceVersion(out,
                                                                           &structInfo->conformanceVersion,
                                                                           metainfo->conformanceVersion,
                                                                           consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* driverID */
    structBody << "\t" << "VkDriverId(" << structInfo->driverID << ")" << "," << std::endl;
/* driverName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->driverName) << "," << std::endl;
/* driverInfo */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->driverInfo) << "," << std::endl;
/* conformanceVersion */
    structBody << "\t" << conformanceVersionInfoVar << "," << std::endl;
/* denormBehaviorIndependence */
    structBody << "\t" << "VkShaderFloatControlsIndependence(" << structInfo->denormBehaviorIndependence << ")" << "," << std::endl;
/* roundingModeIndependence */
    structBody << "\t" << "VkShaderFloatControlsIndependence(" << structInfo->roundingModeIndependence << ")" << "," << std::endl;
/* shaderSignedZeroInfNanPreserveFloat16 */
    structBody << "\t" << structInfo->shaderSignedZeroInfNanPreserveFloat16 << "," << std::endl;
/* shaderSignedZeroInfNanPreserveFloat32 */
    structBody << "\t" << structInfo->shaderSignedZeroInfNanPreserveFloat32 << "," << std::endl;
/* shaderSignedZeroInfNanPreserveFloat64 */
    structBody << "\t" << structInfo->shaderSignedZeroInfNanPreserveFloat64 << "," << std::endl;
/* shaderDenormPreserveFloat16 */
    structBody << "\t" << structInfo->shaderDenormPreserveFloat16 << "," << std::endl;
/* shaderDenormPreserveFloat32 */
    structBody << "\t" << structInfo->shaderDenormPreserveFloat32 << "," << std::endl;
/* shaderDenormPreserveFloat64 */
    structBody << "\t" << structInfo->shaderDenormPreserveFloat64 << "," << std::endl;
/* shaderDenormFlushToZeroFloat16 */
    structBody << "\t" << structInfo->shaderDenormFlushToZeroFloat16 << "," << std::endl;
/* shaderDenormFlushToZeroFloat32 */
    structBody << "\t" << structInfo->shaderDenormFlushToZeroFloat32 << "," << std::endl;
/* shaderDenormFlushToZeroFloat64 */
    structBody << "\t" << structInfo->shaderDenormFlushToZeroFloat64 << "," << std::endl;
/* shaderRoundingModeRTEFloat16 */
    structBody << "\t" << structInfo->shaderRoundingModeRTEFloat16 << "," << std::endl;
/* shaderRoundingModeRTEFloat32 */
    structBody << "\t" << structInfo->shaderRoundingModeRTEFloat32 << "," << std::endl;
/* shaderRoundingModeRTEFloat64 */
    structBody << "\t" << structInfo->shaderRoundingModeRTEFloat64 << "," << std::endl;
/* shaderRoundingModeRTZFloat16 */
    structBody << "\t" << structInfo->shaderRoundingModeRTZFloat16 << "," << std::endl;
/* shaderRoundingModeRTZFloat32 */
    structBody << "\t" << structInfo->shaderRoundingModeRTZFloat32 << "," << std::endl;
/* shaderRoundingModeRTZFloat64 */
    structBody << "\t" << structInfo->shaderRoundingModeRTZFloat64 << "," << std::endl;
/* maxUpdateAfterBindDescriptorsInAllPools */
    structBody << "\t" << structInfo->maxUpdateAfterBindDescriptorsInAllPools << "," << std::endl;
/* shaderUniformBufferArrayNonUniformIndexingNative */
    structBody << "\t" << structInfo->shaderUniformBufferArrayNonUniformIndexingNative << "," << std::endl;
/* shaderSampledImageArrayNonUniformIndexingNative */
    structBody << "\t" << structInfo->shaderSampledImageArrayNonUniformIndexingNative << "," << std::endl;
/* shaderStorageBufferArrayNonUniformIndexingNative */
    structBody << "\t" << structInfo->shaderStorageBufferArrayNonUniformIndexingNative << "," << std::endl;
/* shaderStorageImageArrayNonUniformIndexingNative */
    structBody << "\t" << structInfo->shaderStorageImageArrayNonUniformIndexingNative << "," << std::endl;
/* shaderInputAttachmentArrayNonUniformIndexingNative */
    structBody << "\t" << structInfo->shaderInputAttachmentArrayNonUniformIndexingNative << "," << std::endl;
/* robustBufferAccessUpdateAfterBind */
    structBody << "\t" << structInfo->robustBufferAccessUpdateAfterBind << "," << std::endl;
/* quadDivergentImplicitLod */
    structBody << "\t" << structInfo->quadDivergentImplicitLod << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindSamplers */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindSamplers << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindUniformBuffers */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindUniformBuffers << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindStorageBuffers */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindStorageBuffers << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindSampledImages */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindSampledImages << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindStorageImages */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindStorageImages << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindInputAttachments */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindInputAttachments << "," << std::endl;
/* maxPerStageUpdateAfterBindResources */
    structBody << "\t" << structInfo->maxPerStageUpdateAfterBindResources << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindSamplers */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindSamplers << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindUniformBuffers */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindUniformBuffers << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindUniformBuffersDynamic */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindStorageBuffers */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageBuffers << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindStorageBuffersDynamic */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindSampledImages */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindSampledImages << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindStorageImages */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageImages << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindInputAttachments */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindInputAttachments << "," << std::endl;
/* supportedDepthResolveModes */
    structBody << "\t" << "VkResolveModeFlags(" << structInfo->supportedDepthResolveModes << ")" << "," << std::endl;
/* supportedStencilResolveModes */
    structBody << "\t" << "VkResolveModeFlags(" << structInfo->supportedStencilResolveModes << ")" << "," << std::endl;
/* independentResolveNone */
    structBody << "\t" << structInfo->independentResolveNone << "," << std::endl;
/* independentResolve */
    structBody << "\t" << structInfo->independentResolve << "," << std::endl;
/* filterMinmaxSingleComponentFormats */
    structBody << "\t" << structInfo->filterMinmaxSingleComponentFormats << "," << std::endl;
/* filterMinmaxImageComponentMapping */
    structBody << "\t" << structInfo->filterMinmaxImageComponentMapping << "," << std::endl;
/* maxTimelineSemaphoreValueDifference */
    structBody << "\t" << structInfo->maxTimelineSemaphoreValueDifference << "UL" << "," << std::endl;
/* framebufferIntegerColorSampleCounts */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->framebufferIntegerColorSampleCounts << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceVulkan12Properties");
    out << "VkPhysicalDeviceVulkan12Properties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageFormatListCreateInfo(std::ostream &out, const VkImageFormatListCreateInfo* structInfo, Decoded_VkImageFormatListCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pViewFormatsValues;
    std::string pViewFormatsArray = "NULL";
    if (structInfo->pViewFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->viewFormatCount; idx++) {
            pViewFormatsValues += util::ToString<VkFormat>(structInfo->pViewFormats[idx]) + ", ";
        }
        pViewFormatsArray = "pViewFormats_" + std::to_string(consumer.getNextId());
        out << "VkFormat " << pViewFormatsArray << "[] = {" << pViewFormatsValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* viewFormatCount */
    structBody << "\t" << structInfo->viewFormatCount << "," << std::endl;
/* pViewFormats */
    structBody << "\t" << pViewFormatsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageFormatListCreateInfo");
    out << "VkImageFormatListCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAttachmentDescription2(std::ostream &out, const VkAttachmentDescription2* structInfo, Decoded_VkAttachmentDescription2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkAttachmentDescriptionFlags(" << structInfo->flags << ")" << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
/* samples */
    structBody << "\t" << "VkSampleCountFlagBits(" << structInfo->samples << ")" << "," << std::endl;
/* loadOp */
    structBody << "\t" << "VkAttachmentLoadOp(" << structInfo->loadOp << ")" << "," << std::endl;
/* storeOp */
    structBody << "\t" << "VkAttachmentStoreOp(" << structInfo->storeOp << ")" << "," << std::endl;
/* stencilLoadOp */
    structBody << "\t" << "VkAttachmentLoadOp(" << structInfo->stencilLoadOp << ")" << "," << std::endl;
/* stencilStoreOp */
    structBody << "\t" << "VkAttachmentStoreOp(" << structInfo->stencilStoreOp << ")" << "," << std::endl;
/* initialLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->initialLayout << ")" << "," << std::endl;
/* finalLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->finalLayout << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "attachmentDescription2");
    out << "VkAttachmentDescription2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAttachmentReference2(std::ostream &out, const VkAttachmentReference2* structInfo, Decoded_VkAttachmentReference2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* attachment */
    structBody << "\t" << structInfo->attachment << "," << std::endl;
/* layout */
    structBody << "\t" << "VkImageLayout(" << structInfo->layout << ")" << "," << std::endl;
/* aspectMask */
    structBody << "\t" << "VkImageAspectFlags(" << structInfo->aspectMask << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "attachmentReference2");
    out << "VkAttachmentReference2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubpassDescription2(std::ostream &out, const VkSubpassDescription2* structInfo, Decoded_VkSubpassDescription2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pInputAttachmentsArray = "NULL";
    if (structInfo->pInputAttachments != NULL) {
        pInputAttachmentsArray = "pInputAttachments_" + std::to_string(consumer.getNextId());
        std::string pInputAttachmentsNames;
        for (uint32_t idx = 0; idx < structInfo->inputAttachmentCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pInputAttachments + idx != NULL) {
                varName = GenerateStruct_VkAttachmentReference2(out,
                                                         structInfo->pInputAttachments + idx,
                                                         metainfo->pInputAttachments->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pInputAttachmentsNames += varName + ", ";
        }
        out << "VkAttachmentReference2 " << pInputAttachmentsArray << "[] = {" << pInputAttachmentsNames << "};" << std::endl;
    }
    std::string pColorAttachmentsArray = "NULL";
    if (structInfo->pColorAttachments != NULL) {
        pColorAttachmentsArray = "pColorAttachments_" + std::to_string(consumer.getNextId());
        std::string pColorAttachmentsNames;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pColorAttachments + idx != NULL) {
                varName = GenerateStruct_VkAttachmentReference2(out,
                                                         structInfo->pColorAttachments + idx,
                                                         metainfo->pColorAttachments->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pColorAttachmentsNames += varName + ", ";
        }
        out << "VkAttachmentReference2 " << pColorAttachmentsArray << "[] = {" << pColorAttachmentsNames << "};" << std::endl;
    }
    std::string pResolveAttachmentsArray = "NULL";
    if (structInfo->pResolveAttachments != NULL) {
        pResolveAttachmentsArray = "pResolveAttachments_" + std::to_string(consumer.getNextId());
        std::string pResolveAttachmentsNames;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pResolveAttachments + idx != NULL) {
                varName = GenerateStruct_VkAttachmentReference2(out,
                                                         structInfo->pResolveAttachments + idx,
                                                         metainfo->pResolveAttachments->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pResolveAttachmentsNames += varName + ", ";
        }
        out << "VkAttachmentReference2 " << pResolveAttachmentsArray << "[] = {" << pResolveAttachmentsNames << "};" << std::endl;
    }
    std::string pDepthStencilAttachmentStruct = "NULL";
    if (structInfo->pDepthStencilAttachment != NULL) {
        pDepthStencilAttachmentStruct = GenerateStruct_VkAttachmentReference2(out,
                                                                       structInfo->pDepthStencilAttachment,
                                                                       metainfo->pDepthStencilAttachment->GetMetaStructPointer(),
                                                                       consumer);
        pDepthStencilAttachmentStruct.insert(0, "&");
    }
    std::string pPreserveAttachmentsArray = "NULL";
    if (structInfo->pPreserveAttachments != NULL) {
        pPreserveAttachmentsArray = "pPreserveAttachments_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pPreserveAttachmentsArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pPreserveAttachments, structInfo->preserveAttachmentCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkSubpassDescriptionFlags(" << structInfo->flags << ")" << "," << std::endl;
/* pipelineBindPoint */
    structBody << "\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
/* viewMask */
    structBody << "\t" << structInfo->viewMask << "," << std::endl;
/* inputAttachmentCount */
    structBody << "\t" << structInfo->inputAttachmentCount << "," << std::endl;
/* pInputAttachments */
    structBody << "\t" << pInputAttachmentsArray << "," << std::endl;
/* colorAttachmentCount */
    structBody << "\t" << structInfo->colorAttachmentCount << "," << std::endl;
/* pColorAttachments */
    structBody << "\t" << pColorAttachmentsArray << "," << std::endl;
/* pResolveAttachments */
    structBody << "\t" << pResolveAttachmentsArray << "," << std::endl;
/* pDepthStencilAttachment */
    structBody << "\t" << pDepthStencilAttachmentStruct << "," << std::endl;
/* preserveAttachmentCount */
    structBody << "\t" << structInfo->preserveAttachmentCount << "," << std::endl;
/* pPreserveAttachments */
    structBody << "\t" << pPreserveAttachmentsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "subpassDescription2");
    out << "VkSubpassDescription2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubpassDependency2(std::ostream &out, const VkSubpassDependency2* structInfo, Decoded_VkSubpassDependency2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcSubpass */
    structBody << "\t" << structInfo->srcSubpass << "," << std::endl;
/* dstSubpass */
    structBody << "\t" << structInfo->dstSubpass << "," << std::endl;
/* srcStageMask */
    structBody << "\t" << "VkPipelineStageFlags(" << structInfo->srcStageMask << ")" << "," << std::endl;
/* dstStageMask */
    structBody << "\t" << "VkPipelineStageFlags(" << structInfo->dstStageMask << ")" << "," << std::endl;
/* srcAccessMask */
    structBody << "\t" << "VkAccessFlags(" << structInfo->srcAccessMask << ")" << "," << std::endl;
/* dstAccessMask */
    structBody << "\t" << "VkAccessFlags(" << structInfo->dstAccessMask << ")" << "," << std::endl;
/* dependencyFlags */
    structBody << "\t" << "VkDependencyFlags(" << structInfo->dependencyFlags << ")" << "," << std::endl;
/* viewOffset */
    structBody << "\t" << structInfo->viewOffset << "," ;
    std::string varname = consumer.AddStruct(structBody, "subpassDependency2");
    out << "VkSubpassDependency2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderPassCreateInfo2(std::ostream &out, const VkRenderPassCreateInfo2* structInfo, Decoded_VkRenderPassCreateInfo2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pAttachmentsArray = "NULL";
    if (structInfo->pAttachments != NULL) {
        pAttachmentsArray = "pAttachments_" + std::to_string(consumer.getNextId());
        std::string pAttachmentsNames;
        for (uint32_t idx = 0; idx < structInfo->attachmentCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pAttachments + idx != NULL) {
                varName = GenerateStruct_VkAttachmentDescription2(out,
                                                         structInfo->pAttachments + idx,
                                                         metainfo->pAttachments->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pAttachmentsNames += varName + ", ";
        }
        out << "VkAttachmentDescription2 " << pAttachmentsArray << "[] = {" << pAttachmentsNames << "};" << std::endl;
    }
    std::string pSubpassesArray = "NULL";
    if (structInfo->pSubpasses != NULL) {
        pSubpassesArray = "pSubpasses_" + std::to_string(consumer.getNextId());
        std::string pSubpassesNames;
        for (uint32_t idx = 0; idx < structInfo->subpassCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pSubpasses + idx != NULL) {
                varName = GenerateStruct_VkSubpassDescription2(out,
                                                         structInfo->pSubpasses + idx,
                                                         metainfo->pSubpasses->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pSubpassesNames += varName + ", ";
        }
        out << "VkSubpassDescription2 " << pSubpassesArray << "[] = {" << pSubpassesNames << "};" << std::endl;
    }
    std::string pDependenciesArray = "NULL";
    if (structInfo->pDependencies != NULL) {
        pDependenciesArray = "pDependencies_" + std::to_string(consumer.getNextId());
        std::string pDependenciesNames;
        for (uint32_t idx = 0; idx < structInfo->dependencyCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pDependencies + idx != NULL) {
                varName = GenerateStruct_VkSubpassDependency2(out,
                                                         structInfo->pDependencies + idx,
                                                         metainfo->pDependencies->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pDependenciesNames += varName + ", ";
        }
        out << "VkSubpassDependency2 " << pDependenciesArray << "[] = {" << pDependenciesNames << "};" << std::endl;
    }
    std::string pCorrelatedViewMasksArray = "NULL";
    if (structInfo->pCorrelatedViewMasks != NULL) {
        pCorrelatedViewMasksArray = "pCorrelatedViewMasks_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pCorrelatedViewMasksArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCorrelatedViewMasks, structInfo->correlatedViewMaskCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkRenderPassCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* attachmentCount */
    structBody << "\t" << structInfo->attachmentCount << "," << std::endl;
/* pAttachments */
    structBody << "\t" << pAttachmentsArray << "," << std::endl;
/* subpassCount */
    structBody << "\t" << structInfo->subpassCount << "," << std::endl;
/* pSubpasses */
    structBody << "\t" << pSubpassesArray << "," << std::endl;
/* dependencyCount */
    structBody << "\t" << structInfo->dependencyCount << "," << std::endl;
/* pDependencies */
    structBody << "\t" << pDependenciesArray << "," << std::endl;
/* correlatedViewMaskCount */
    structBody << "\t" << structInfo->correlatedViewMaskCount << "," << std::endl;
/* pCorrelatedViewMasks */
    structBody << "\t" << pCorrelatedViewMasksArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderPassCreateInfo2");
    out << "VkRenderPassCreateInfo2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubpassBeginInfo(std::ostream &out, const VkSubpassBeginInfo* structInfo, Decoded_VkSubpassBeginInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* contents */
    structBody << "\t" << "VkSubpassContents(" << structInfo->contents << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "subpassBeginInfo");
    out << "VkSubpassBeginInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubpassEndInfo(std::ostream &out, const VkSubpassEndInfo* structInfo, Decoded_VkSubpassEndInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
    std::string varname = consumer.AddStruct(structBody, "subpassEndInfo");
    out << "VkSubpassEndInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevice8BitStorageFeatures(std::ostream &out, const VkPhysicalDevice8BitStorageFeatures* structInfo, Decoded_VkPhysicalDevice8BitStorageFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* storageBuffer8BitAccess */
    structBody << "\t" << structInfo->storageBuffer8BitAccess << "," << std::endl;
/* uniformAndStorageBuffer8BitAccess */
    structBody << "\t" << structInfo->uniformAndStorageBuffer8BitAccess << "," << std::endl;
/* storagePushConstant8 */
    structBody << "\t" << structInfo->storagePushConstant8 << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevice8BitStorageFeatures");
    out << "VkPhysicalDevice8BitStorageFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDriverProperties(std::ostream &out, const VkPhysicalDeviceDriverProperties* structInfo, Decoded_VkPhysicalDeviceDriverProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string conformanceVersionInfoVar = GenerateStruct_VkConformanceVersion(out,
                                                                           &structInfo->conformanceVersion,
                                                                           metainfo->conformanceVersion,
                                                                           consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* driverID */
    structBody << "\t" << "VkDriverId(" << structInfo->driverID << ")" << "," << std::endl;
/* driverName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->driverName) << "," << std::endl;
/* driverInfo */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->driverInfo) << "," << std::endl;
/* conformanceVersion */
    structBody << "\t" << conformanceVersionInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDriverProperties");
    out << "VkPhysicalDeviceDriverProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderAtomicInt64Features(std::ostream &out, const VkPhysicalDeviceShaderAtomicInt64Features* structInfo, Decoded_VkPhysicalDeviceShaderAtomicInt64Features* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderBufferInt64Atomics */
    structBody << "\t" << structInfo->shaderBufferInt64Atomics << "," << std::endl;
/* shaderSharedInt64Atomics */
    structBody << "\t" << structInfo->shaderSharedInt64Atomics << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderAtomicInt64Features");
    out << "VkPhysicalDeviceShaderAtomicInt64Features " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderFloat16Int8Features(std::ostream &out, const VkPhysicalDeviceShaderFloat16Int8Features* structInfo, Decoded_VkPhysicalDeviceShaderFloat16Int8Features* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderFloat16 */
    structBody << "\t" << structInfo->shaderFloat16 << "," << std::endl;
/* shaderInt8 */
    structBody << "\t" << structInfo->shaderInt8 << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderFloat16Int8Features");
    out << "VkPhysicalDeviceShaderFloat16Int8Features " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFloatControlsProperties(std::ostream &out, const VkPhysicalDeviceFloatControlsProperties* structInfo, Decoded_VkPhysicalDeviceFloatControlsProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* denormBehaviorIndependence */
    structBody << "\t" << "VkShaderFloatControlsIndependence(" << structInfo->denormBehaviorIndependence << ")" << "," << std::endl;
/* roundingModeIndependence */
    structBody << "\t" << "VkShaderFloatControlsIndependence(" << structInfo->roundingModeIndependence << ")" << "," << std::endl;
/* shaderSignedZeroInfNanPreserveFloat16 */
    structBody << "\t" << structInfo->shaderSignedZeroInfNanPreserveFloat16 << "," << std::endl;
/* shaderSignedZeroInfNanPreserveFloat32 */
    structBody << "\t" << structInfo->shaderSignedZeroInfNanPreserveFloat32 << "," << std::endl;
/* shaderSignedZeroInfNanPreserveFloat64 */
    structBody << "\t" << structInfo->shaderSignedZeroInfNanPreserveFloat64 << "," << std::endl;
/* shaderDenormPreserveFloat16 */
    structBody << "\t" << structInfo->shaderDenormPreserveFloat16 << "," << std::endl;
/* shaderDenormPreserveFloat32 */
    structBody << "\t" << structInfo->shaderDenormPreserveFloat32 << "," << std::endl;
/* shaderDenormPreserveFloat64 */
    structBody << "\t" << structInfo->shaderDenormPreserveFloat64 << "," << std::endl;
/* shaderDenormFlushToZeroFloat16 */
    structBody << "\t" << structInfo->shaderDenormFlushToZeroFloat16 << "," << std::endl;
/* shaderDenormFlushToZeroFloat32 */
    structBody << "\t" << structInfo->shaderDenormFlushToZeroFloat32 << "," << std::endl;
/* shaderDenormFlushToZeroFloat64 */
    structBody << "\t" << structInfo->shaderDenormFlushToZeroFloat64 << "," << std::endl;
/* shaderRoundingModeRTEFloat16 */
    structBody << "\t" << structInfo->shaderRoundingModeRTEFloat16 << "," << std::endl;
/* shaderRoundingModeRTEFloat32 */
    structBody << "\t" << structInfo->shaderRoundingModeRTEFloat32 << "," << std::endl;
/* shaderRoundingModeRTEFloat64 */
    structBody << "\t" << structInfo->shaderRoundingModeRTEFloat64 << "," << std::endl;
/* shaderRoundingModeRTZFloat16 */
    structBody << "\t" << structInfo->shaderRoundingModeRTZFloat16 << "," << std::endl;
/* shaderRoundingModeRTZFloat32 */
    structBody << "\t" << structInfo->shaderRoundingModeRTZFloat32 << "," << std::endl;
/* shaderRoundingModeRTZFloat64 */
    structBody << "\t" << structInfo->shaderRoundingModeRTZFloat64 << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFloatControlsProperties");
    out << "VkPhysicalDeviceFloatControlsProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDescriptorSetLayoutBindingFlagsCreateInfo(std::ostream &out, const VkDescriptorSetLayoutBindingFlagsCreateInfo* structInfo, Decoded_VkDescriptorSetLayoutBindingFlagsCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pBindingFlagsValues;
    std::string pBindingFlagsArray = "NULL";
    if (structInfo->pBindingFlags != NULL) {
        for (uint32_t idx = 0; idx < structInfo->bindingCount; idx++) {
            pBindingFlagsValues += util::ToString<VkDescriptorBindingFlags>(structInfo->pBindingFlags[idx]) + ", ";
        }
        pBindingFlagsArray = "pBindingFlags_" + std::to_string(consumer.getNextId());
        out << "VkDescriptorBindingFlags " << pBindingFlagsArray << "[] = {" << pBindingFlagsValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* bindingCount */
    structBody << "\t" << structInfo->bindingCount << "," << std::endl;
/* pBindingFlags */
    structBody << "\t" << pBindingFlagsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "descriptorSetLayoutBindingFlagsCreateInfo");
    out << "VkDescriptorSetLayoutBindingFlagsCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDescriptorIndexingFeatures(std::ostream &out, const VkPhysicalDeviceDescriptorIndexingFeatures* structInfo, Decoded_VkPhysicalDeviceDescriptorIndexingFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderInputAttachmentArrayDynamicIndexing */
    structBody << "\t" << structInfo->shaderInputAttachmentArrayDynamicIndexing << "," << std::endl;
/* shaderUniformTexelBufferArrayDynamicIndexing */
    structBody << "\t" << structInfo->shaderUniformTexelBufferArrayDynamicIndexing << "," << std::endl;
/* shaderStorageTexelBufferArrayDynamicIndexing */
    structBody << "\t" << structInfo->shaderStorageTexelBufferArrayDynamicIndexing << "," << std::endl;
/* shaderUniformBufferArrayNonUniformIndexing */
    structBody << "\t" << structInfo->shaderUniformBufferArrayNonUniformIndexing << "," << std::endl;
/* shaderSampledImageArrayNonUniformIndexing */
    structBody << "\t" << structInfo->shaderSampledImageArrayNonUniformIndexing << "," << std::endl;
/* shaderStorageBufferArrayNonUniformIndexing */
    structBody << "\t" << structInfo->shaderStorageBufferArrayNonUniformIndexing << "," << std::endl;
/* shaderStorageImageArrayNonUniformIndexing */
    structBody << "\t" << structInfo->shaderStorageImageArrayNonUniformIndexing << "," << std::endl;
/* shaderInputAttachmentArrayNonUniformIndexing */
    structBody << "\t" << structInfo->shaderInputAttachmentArrayNonUniformIndexing << "," << std::endl;
/* shaderUniformTexelBufferArrayNonUniformIndexing */
    structBody << "\t" << structInfo->shaderUniformTexelBufferArrayNonUniformIndexing << "," << std::endl;
/* shaderStorageTexelBufferArrayNonUniformIndexing */
    structBody << "\t" << structInfo->shaderStorageTexelBufferArrayNonUniformIndexing << "," << std::endl;
/* descriptorBindingUniformBufferUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingUniformBufferUpdateAfterBind << "," << std::endl;
/* descriptorBindingSampledImageUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingSampledImageUpdateAfterBind << "," << std::endl;
/* descriptorBindingStorageImageUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingStorageImageUpdateAfterBind << "," << std::endl;
/* descriptorBindingStorageBufferUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingStorageBufferUpdateAfterBind << "," << std::endl;
/* descriptorBindingUniformTexelBufferUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingUniformTexelBufferUpdateAfterBind << "," << std::endl;
/* descriptorBindingStorageTexelBufferUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingStorageTexelBufferUpdateAfterBind << "," << std::endl;
/* descriptorBindingUpdateUnusedWhilePending */
    structBody << "\t" << structInfo->descriptorBindingUpdateUnusedWhilePending << "," << std::endl;
/* descriptorBindingPartiallyBound */
    structBody << "\t" << structInfo->descriptorBindingPartiallyBound << "," << std::endl;
/* descriptorBindingVariableDescriptorCount */
    structBody << "\t" << structInfo->descriptorBindingVariableDescriptorCount << "," << std::endl;
/* runtimeDescriptorArray */
    structBody << "\t" << structInfo->runtimeDescriptorArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDescriptorIndexingFeatures");
    out << "VkPhysicalDeviceDescriptorIndexingFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDescriptorIndexingProperties(std::ostream &out, const VkPhysicalDeviceDescriptorIndexingProperties* structInfo, Decoded_VkPhysicalDeviceDescriptorIndexingProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxUpdateAfterBindDescriptorsInAllPools */
    structBody << "\t" << structInfo->maxUpdateAfterBindDescriptorsInAllPools << "," << std::endl;
/* shaderUniformBufferArrayNonUniformIndexingNative */
    structBody << "\t" << structInfo->shaderUniformBufferArrayNonUniformIndexingNative << "," << std::endl;
/* shaderSampledImageArrayNonUniformIndexingNative */
    structBody << "\t" << structInfo->shaderSampledImageArrayNonUniformIndexingNative << "," << std::endl;
/* shaderStorageBufferArrayNonUniformIndexingNative */
    structBody << "\t" << structInfo->shaderStorageBufferArrayNonUniformIndexingNative << "," << std::endl;
/* shaderStorageImageArrayNonUniformIndexingNative */
    structBody << "\t" << structInfo->shaderStorageImageArrayNonUniformIndexingNative << "," << std::endl;
/* shaderInputAttachmentArrayNonUniformIndexingNative */
    structBody << "\t" << structInfo->shaderInputAttachmentArrayNonUniformIndexingNative << "," << std::endl;
/* robustBufferAccessUpdateAfterBind */
    structBody << "\t" << structInfo->robustBufferAccessUpdateAfterBind << "," << std::endl;
/* quadDivergentImplicitLod */
    structBody << "\t" << structInfo->quadDivergentImplicitLod << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindSamplers */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindSamplers << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindUniformBuffers */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindUniformBuffers << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindStorageBuffers */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindStorageBuffers << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindSampledImages */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindSampledImages << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindStorageImages */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindStorageImages << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindInputAttachments */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindInputAttachments << "," << std::endl;
/* maxPerStageUpdateAfterBindResources */
    structBody << "\t" << structInfo->maxPerStageUpdateAfterBindResources << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindSamplers */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindSamplers << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindUniformBuffers */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindUniformBuffers << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindUniformBuffersDynamic */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindUniformBuffersDynamic << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindStorageBuffers */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageBuffers << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindStorageBuffersDynamic */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageBuffersDynamic << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindSampledImages */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindSampledImages << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindStorageImages */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindStorageImages << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindInputAttachments */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindInputAttachments << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDescriptorIndexingProperties");
    out << "VkPhysicalDeviceDescriptorIndexingProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDescriptorSetVariableDescriptorCountAllocateInfo(std::ostream &out, const VkDescriptorSetVariableDescriptorCountAllocateInfo* structInfo, Decoded_VkDescriptorSetVariableDescriptorCountAllocateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDescriptorCountsArray = "NULL";
    if (structInfo->pDescriptorCounts != NULL) {
        pDescriptorCountsArray = "pDescriptorCounts_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pDescriptorCountsArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDescriptorCounts, structInfo->descriptorSetCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* descriptorSetCount */
    structBody << "\t" << structInfo->descriptorSetCount << "," << std::endl;
/* pDescriptorCounts */
    structBody << "\t" << pDescriptorCountsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "descriptorSetVariableDescriptorCountAllocateInfo");
    out << "VkDescriptorSetVariableDescriptorCountAllocateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDescriptorSetVariableDescriptorCountLayoutSupport(std::ostream &out, const VkDescriptorSetVariableDescriptorCountLayoutSupport* structInfo, Decoded_VkDescriptorSetVariableDescriptorCountLayoutSupport* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxVariableDescriptorCount */
    structBody << "\t" << structInfo->maxVariableDescriptorCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "descriptorSetVariableDescriptorCountLayoutSupport");
    out << "VkDescriptorSetVariableDescriptorCountLayoutSupport " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubpassDescriptionDepthStencilResolve(std::ostream &out, const VkSubpassDescriptionDepthStencilResolve* structInfo, Decoded_VkSubpassDescriptionDepthStencilResolve* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDepthStencilResolveAttachmentStruct = "NULL";
    if (structInfo->pDepthStencilResolveAttachment != NULL) {
        pDepthStencilResolveAttachmentStruct = GenerateStruct_VkAttachmentReference2(out,
                                                                              structInfo->pDepthStencilResolveAttachment,
                                                                              metainfo->pDepthStencilResolveAttachment->GetMetaStructPointer(),
                                                                              consumer);
        pDepthStencilResolveAttachmentStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* depthResolveMode */
    structBody << "\t" << "VkResolveModeFlagBits(" << structInfo->depthResolveMode << ")" << "," << std::endl;
/* stencilResolveMode */
    structBody << "\t" << "VkResolveModeFlagBits(" << structInfo->stencilResolveMode << ")" << "," << std::endl;
/* pDepthStencilResolveAttachment */
    structBody << "\t" << pDepthStencilResolveAttachmentStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "subpassDescriptionDepthStencilResolve");
    out << "VkSubpassDescriptionDepthStencilResolve " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDepthStencilResolveProperties(std::ostream &out, const VkPhysicalDeviceDepthStencilResolveProperties* structInfo, Decoded_VkPhysicalDeviceDepthStencilResolveProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* supportedDepthResolveModes */
    structBody << "\t" << "VkResolveModeFlags(" << structInfo->supportedDepthResolveModes << ")" << "," << std::endl;
/* supportedStencilResolveModes */
    structBody << "\t" << "VkResolveModeFlags(" << structInfo->supportedStencilResolveModes << ")" << "," << std::endl;
/* independentResolveNone */
    structBody << "\t" << structInfo->independentResolveNone << "," << std::endl;
/* independentResolve */
    structBody << "\t" << structInfo->independentResolve << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDepthStencilResolveProperties");
    out << "VkPhysicalDeviceDepthStencilResolveProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceScalarBlockLayoutFeatures(std::ostream &out, const VkPhysicalDeviceScalarBlockLayoutFeatures* structInfo, Decoded_VkPhysicalDeviceScalarBlockLayoutFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* scalarBlockLayout */
    structBody << "\t" << structInfo->scalarBlockLayout << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceScalarBlockLayoutFeatures");
    out << "VkPhysicalDeviceScalarBlockLayoutFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageStencilUsageCreateInfo(std::ostream &out, const VkImageStencilUsageCreateInfo* structInfo, Decoded_VkImageStencilUsageCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stencilUsage */
    structBody << "\t" << "VkImageUsageFlags(" << structInfo->stencilUsage << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageStencilUsageCreateInfo");
    out << "VkImageStencilUsageCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSamplerReductionModeCreateInfo(std::ostream &out, const VkSamplerReductionModeCreateInfo* structInfo, Decoded_VkSamplerReductionModeCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* reductionMode */
    structBody << "\t" << "VkSamplerReductionMode(" << structInfo->reductionMode << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "samplerReductionModeCreateInfo");
    out << "VkSamplerReductionModeCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceSamplerFilterMinmaxProperties(std::ostream &out, const VkPhysicalDeviceSamplerFilterMinmaxProperties* structInfo, Decoded_VkPhysicalDeviceSamplerFilterMinmaxProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* filterMinmaxSingleComponentFormats */
    structBody << "\t" << structInfo->filterMinmaxSingleComponentFormats << "," << std::endl;
/* filterMinmaxImageComponentMapping */
    structBody << "\t" << structInfo->filterMinmaxImageComponentMapping << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceSamplerFilterMinmaxProperties");
    out << "VkPhysicalDeviceSamplerFilterMinmaxProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceVulkanMemoryModelFeatures(std::ostream &out, const VkPhysicalDeviceVulkanMemoryModelFeatures* structInfo, Decoded_VkPhysicalDeviceVulkanMemoryModelFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* vulkanMemoryModel */
    structBody << "\t" << structInfo->vulkanMemoryModel << "," << std::endl;
/* vulkanMemoryModelDeviceScope */
    structBody << "\t" << structInfo->vulkanMemoryModelDeviceScope << "," << std::endl;
/* vulkanMemoryModelAvailabilityVisibilityChains */
    structBody << "\t" << structInfo->vulkanMemoryModelAvailabilityVisibilityChains << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceVulkanMemoryModelFeatures");
    out << "VkPhysicalDeviceVulkanMemoryModelFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceImagelessFramebufferFeatures(std::ostream &out, const VkPhysicalDeviceImagelessFramebufferFeatures* structInfo, Decoded_VkPhysicalDeviceImagelessFramebufferFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* imagelessFramebuffer */
    structBody << "\t" << structInfo->imagelessFramebuffer << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceImagelessFramebufferFeatures");
    out << "VkPhysicalDeviceImagelessFramebufferFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkFramebufferAttachmentImageInfo(std::ostream &out, const VkFramebufferAttachmentImageInfo* structInfo, Decoded_VkFramebufferAttachmentImageInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pViewFormatsValues;
    std::string pViewFormatsArray = "NULL";
    if (structInfo->pViewFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->viewFormatCount; idx++) {
            pViewFormatsValues += util::ToString<VkFormat>(structInfo->pViewFormats[idx]) + ", ";
        }
        pViewFormatsArray = "pViewFormats_" + std::to_string(consumer.getNextId());
        out << "VkFormat " << pViewFormatsArray << "[] = {" << pViewFormatsValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkImageCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* usage */
    structBody << "\t" << "VkImageUsageFlags(" << structInfo->usage << ")" << "," << std::endl;
/* width */
    structBody << "\t" << structInfo->width << "," << std::endl;
/* height */
    structBody << "\t" << structInfo->height << "," << std::endl;
/* layerCount */
    structBody << "\t" << structInfo->layerCount << "," << std::endl;
/* viewFormatCount */
    structBody << "\t" << structInfo->viewFormatCount << "," << std::endl;
/* pViewFormats */
    structBody << "\t" << pViewFormatsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "framebufferAttachmentImageInfo");
    out << "VkFramebufferAttachmentImageInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkFramebufferAttachmentsCreateInfo(std::ostream &out, const VkFramebufferAttachmentsCreateInfo* structInfo, Decoded_VkFramebufferAttachmentsCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pAttachmentImageInfosArray = "NULL";
    if (structInfo->pAttachmentImageInfos != NULL) {
        pAttachmentImageInfosArray = "pAttachmentImageInfos_" + std::to_string(consumer.getNextId());
        std::string pAttachmentImageInfosNames;
        for (uint32_t idx = 0; idx < structInfo->attachmentImageInfoCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pAttachmentImageInfos + idx != NULL) {
                varName = GenerateStruct_VkFramebufferAttachmentImageInfo(out,
                                                         structInfo->pAttachmentImageInfos + idx,
                                                         metainfo->pAttachmentImageInfos->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pAttachmentImageInfosNames += varName + ", ";
        }
        out << "VkFramebufferAttachmentImageInfo " << pAttachmentImageInfosArray << "[] = {" << pAttachmentImageInfosNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* attachmentImageInfoCount */
    structBody << "\t" << structInfo->attachmentImageInfoCount << "," << std::endl;
/* pAttachmentImageInfos */
    structBody << "\t" << pAttachmentImageInfosArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "framebufferAttachmentsCreateInfo");
    out << "VkFramebufferAttachmentsCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderPassAttachmentBeginInfo(std::ostream &out, const VkRenderPassAttachmentBeginInfo* structInfo, Decoded_VkRenderPassAttachmentBeginInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pAttachmentsArray = "NULL";
    if (metainfo->pAttachments.GetPointer() != NULL && structInfo->attachmentCount > 0) {
        pAttachmentsArray = "pAttachmentsArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_IMAGE_VIEW));
        std::string pAttachmentsValues = toStringJoin(metainfo->pAttachments.GetPointer(),
                                                      metainfo->pAttachments.GetPointer() + structInfo->attachmentCount,
                                                      [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                      ", ");
        if (structInfo->attachmentCount == 1) {
            pAttachmentsArray = "&" + pAttachmentsValues;
        } else if (structInfo->attachmentCount > 1) {
            out << "VkImageView " << pAttachmentsArray << "[] = {" << pAttachmentsValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* attachmentCount */
    structBody << "\t" << structInfo->attachmentCount << "," << std::endl;
/* pAttachments */
    structBody << "\t" << pAttachmentsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderPassAttachmentBeginInfo");
    out << "VkRenderPassAttachmentBeginInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceUniformBufferStandardLayoutFeatures(std::ostream &out, const VkPhysicalDeviceUniformBufferStandardLayoutFeatures* structInfo, Decoded_VkPhysicalDeviceUniformBufferStandardLayoutFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* uniformBufferStandardLayout */
    structBody << "\t" << structInfo->uniformBufferStandardLayout << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceUniformBufferStandardLayoutFeatures");
    out << "VkPhysicalDeviceUniformBufferStandardLayoutFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures(std::ostream &out, const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* structInfo, Decoded_VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderSubgroupExtendedTypes */
    structBody << "\t" << structInfo->shaderSubgroupExtendedTypes << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderSubgroupExtendedTypesFeatures");
    out << "VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures(std::ostream &out, const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* structInfo, Decoded_VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* separateDepthStencilLayouts */
    structBody << "\t" << structInfo->separateDepthStencilLayouts << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceSeparateDepthStencilLayoutsFeatures");
    out << "VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAttachmentReferenceStencilLayout(std::ostream &out, const VkAttachmentReferenceStencilLayout* structInfo, Decoded_VkAttachmentReferenceStencilLayout* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stencilLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->stencilLayout << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "attachmentReferenceStencilLayout");
    out << "VkAttachmentReferenceStencilLayout " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAttachmentDescriptionStencilLayout(std::ostream &out, const VkAttachmentDescriptionStencilLayout* structInfo, Decoded_VkAttachmentDescriptionStencilLayout* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stencilInitialLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->stencilInitialLayout << ")" << "," << std::endl;
/* stencilFinalLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->stencilFinalLayout << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "attachmentDescriptionStencilLayout");
    out << "VkAttachmentDescriptionStencilLayout " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceHostQueryResetFeatures(std::ostream &out, const VkPhysicalDeviceHostQueryResetFeatures* structInfo, Decoded_VkPhysicalDeviceHostQueryResetFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* hostQueryReset */
    structBody << "\t" << structInfo->hostQueryReset << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceHostQueryResetFeatures");
    out << "VkPhysicalDeviceHostQueryResetFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceTimelineSemaphoreFeatures(std::ostream &out, const VkPhysicalDeviceTimelineSemaphoreFeatures* structInfo, Decoded_VkPhysicalDeviceTimelineSemaphoreFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* timelineSemaphore */
    structBody << "\t" << structInfo->timelineSemaphore << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceTimelineSemaphoreFeatures");
    out << "VkPhysicalDeviceTimelineSemaphoreFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceTimelineSemaphoreProperties(std::ostream &out, const VkPhysicalDeviceTimelineSemaphoreProperties* structInfo, Decoded_VkPhysicalDeviceTimelineSemaphoreProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxTimelineSemaphoreValueDifference */
    structBody << "\t" << structInfo->maxTimelineSemaphoreValueDifference << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceTimelineSemaphoreProperties");
    out << "VkPhysicalDeviceTimelineSemaphoreProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSemaphoreTypeCreateInfo(std::ostream &out, const VkSemaphoreTypeCreateInfo* structInfo, Decoded_VkSemaphoreTypeCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* semaphoreType */
    structBody << "\t" << "VkSemaphoreType(" << structInfo->semaphoreType << ")" << "," << std::endl;
/* initialValue */
    structBody << "\t" << structInfo->initialValue << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "semaphoreTypeCreateInfo");
    out << "VkSemaphoreTypeCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkTimelineSemaphoreSubmitInfo(std::ostream &out, const VkTimelineSemaphoreSubmitInfo* structInfo, Decoded_VkTimelineSemaphoreSubmitInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pWaitSemaphoreValuesArray = "pWaitSemaphoreValuesArray_" + std::to_string(consumer.getNextId());
    if (structInfo->waitSemaphoreValueCount > 0) {
        std::string pWaitSemaphoreValuesValues = toStringJoin(structInfo->pWaitSemaphoreValues,
                                                              structInfo->pWaitSemaphoreValues + structInfo->waitSemaphoreValueCount,
                                                              [](uint64_t current) { return std::to_string(current); },
                                                              ", ");
        if (structInfo->waitSemaphoreValueCount == 1) {
            pWaitSemaphoreValuesArray = "&" + pWaitSemaphoreValuesValues;
        } else if (structInfo->waitSemaphoreValueCount > 1) {
            out << "uint64_t " << pWaitSemaphoreValuesArray << "[] = {" << pWaitSemaphoreValuesValues << "};" << std::endl;
        }
    }
    std::string pSignalSemaphoreValuesArray = "pSignalSemaphoreValuesArray_" + std::to_string(consumer.getNextId());
    if (structInfo->signalSemaphoreValueCount > 0) {
        std::string pSignalSemaphoreValuesValues = toStringJoin(structInfo->pSignalSemaphoreValues,
                                                                structInfo->pSignalSemaphoreValues + structInfo->signalSemaphoreValueCount,
                                                                [](uint64_t current) { return std::to_string(current); },
                                                                ", ");
        if (structInfo->signalSemaphoreValueCount == 1) {
            pSignalSemaphoreValuesArray = "&" + pSignalSemaphoreValuesValues;
        } else if (structInfo->signalSemaphoreValueCount > 1) {
            out << "uint64_t " << pSignalSemaphoreValuesArray << "[] = {" << pSignalSemaphoreValuesValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* waitSemaphoreValueCount */
    structBody << "\t" << structInfo->waitSemaphoreValueCount << "," << std::endl;
/* pWaitSemaphoreValues */
    structBody << "\t" << "{ *" << pWaitSemaphoreValuesArray << " }" << "," << std::endl;
/* signalSemaphoreValueCount */
    structBody << "\t" << structInfo->signalSemaphoreValueCount << "," << std::endl;
/* pSignalSemaphoreValues */
    structBody << "\t" << "{ *" << pSignalSemaphoreValuesArray << " }" << "," ;
    std::string varname = consumer.AddStruct(structBody, "timelineSemaphoreSubmitInfo");
    out << "VkTimelineSemaphoreSubmitInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSemaphoreWaitInfo(std::ostream &out, const VkSemaphoreWaitInfo* structInfo, Decoded_VkSemaphoreWaitInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pSemaphoresArray = "NULL";
    if (metainfo->pSemaphores.GetPointer() != NULL && structInfo->semaphoreCount > 0) {
        pSemaphoresArray = "pSemaphoresArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_SEMAPHORE));
        std::string pSemaphoresValues = toStringJoin(metainfo->pSemaphores.GetPointer(),
                                                     metainfo->pSemaphores.GetPointer() + structInfo->semaphoreCount,
                                                     [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                     ", ");
        if (structInfo->semaphoreCount == 1) {
            pSemaphoresArray = "&" + pSemaphoresValues;
        } else if (structInfo->semaphoreCount > 1) {
            out << "VkSemaphore " << pSemaphoresArray << "[] = {" << pSemaphoresValues << "};" << std::endl;
        }
    }
    std::string pValuesArray = "pValuesArray_" + std::to_string(consumer.getNextId());
    if (structInfo->semaphoreCount > 0) {
        std::string pValuesValues = toStringJoin(structInfo->pValues,
                                                 structInfo->pValues + structInfo->semaphoreCount,
                                                 [](uint64_t current) { return std::to_string(current); },
                                                 ", ");
        if (structInfo->semaphoreCount == 1) {
            pValuesArray = "&" + pValuesValues;
        } else if (structInfo->semaphoreCount > 1) {
            out << "uint64_t " << pValuesArray << "[] = {" << pValuesValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkSemaphoreWaitFlags(" << structInfo->flags << ")" << "," << std::endl;
/* semaphoreCount */
    structBody << "\t" << structInfo->semaphoreCount << "," << std::endl;
/* pSemaphores */
    structBody << "\t" << pSemaphoresArray << "," << std::endl;
/* pValues */
    structBody << "\t" << "{ *" << pValuesArray << " }" << "," ;
    std::string varname = consumer.AddStruct(structBody, "semaphoreWaitInfo");
    out << "VkSemaphoreWaitInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSemaphoreSignalInfo(std::ostream &out, const VkSemaphoreSignalInfo* structInfo, Decoded_VkSemaphoreSignalInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* semaphore */
    structBody << "\t" << consumer.GetHandle(metainfo->semaphore) << "," << std::endl;
/* value */
    structBody << "\t" << structInfo->value << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "semaphoreSignalInfo");
    out << "VkSemaphoreSignalInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceBufferDeviceAddressFeatures(std::ostream &out, const VkPhysicalDeviceBufferDeviceAddressFeatures* structInfo, Decoded_VkPhysicalDeviceBufferDeviceAddressFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* bufferDeviceAddress */
    structBody << "\t" << structInfo->bufferDeviceAddress << "," << std::endl;
/* bufferDeviceAddressCaptureReplay */
    structBody << "\t" << structInfo->bufferDeviceAddressCaptureReplay << "," << std::endl;
/* bufferDeviceAddressMultiDevice */
    structBody << "\t" << structInfo->bufferDeviceAddressMultiDevice << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceBufferDeviceAddressFeatures");
    out << "VkPhysicalDeviceBufferDeviceAddressFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBufferDeviceAddressInfo(std::ostream &out, const VkBufferDeviceAddressInfo* structInfo, Decoded_VkBufferDeviceAddressInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* buffer */
    structBody << "\t" << consumer.GetHandle(metainfo->buffer) << "," ;
    std::string varname = consumer.AddStruct(structBody, "bufferDeviceAddressInfo");
    out << "VkBufferDeviceAddressInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBufferOpaqueCaptureAddressCreateInfo(std::ostream &out, const VkBufferOpaqueCaptureAddressCreateInfo* structInfo, Decoded_VkBufferOpaqueCaptureAddressCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* opaqueCaptureAddress */
    structBody << "\t" << structInfo->opaqueCaptureAddress << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "bufferOpaqueCaptureAddressCreateInfo");
    out << "VkBufferOpaqueCaptureAddressCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryOpaqueCaptureAddressAllocateInfo(std::ostream &out, const VkMemoryOpaqueCaptureAddressAllocateInfo* structInfo, Decoded_VkMemoryOpaqueCaptureAddressAllocateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* opaqueCaptureAddress */
    structBody << "\t" << structInfo->opaqueCaptureAddress << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryOpaqueCaptureAddressAllocateInfo");
    out << "VkMemoryOpaqueCaptureAddressAllocateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceMemoryOpaqueCaptureAddressInfo(std::ostream &out, const VkDeviceMemoryOpaqueCaptureAddressInfo* structInfo, Decoded_VkDeviceMemoryOpaqueCaptureAddressInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceMemoryOpaqueCaptureAddressInfo");
    out << "VkDeviceMemoryOpaqueCaptureAddressInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan13Features(std::ostream &out, const VkPhysicalDeviceVulkan13Features* structInfo, Decoded_VkPhysicalDeviceVulkan13Features* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* robustImageAccess */
    structBody << "\t" << structInfo->robustImageAccess << "," << std::endl;
/* inlineUniformBlock */
    structBody << "\t" << structInfo->inlineUniformBlock << "," << std::endl;
/* descriptorBindingInlineUniformBlockUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingInlineUniformBlockUpdateAfterBind << "," << std::endl;
/* pipelineCreationCacheControl */
    structBody << "\t" << structInfo->pipelineCreationCacheControl << "," << std::endl;
/* privateData */
    structBody << "\t" << structInfo->privateData << "," << std::endl;
/* shaderDemoteToHelperInvocation */
    structBody << "\t" << structInfo->shaderDemoteToHelperInvocation << "," << std::endl;
/* shaderTerminateInvocation */
    structBody << "\t" << structInfo->shaderTerminateInvocation << "," << std::endl;
/* subgroupSizeControl */
    structBody << "\t" << structInfo->subgroupSizeControl << "," << std::endl;
/* computeFullSubgroups */
    structBody << "\t" << structInfo->computeFullSubgroups << "," << std::endl;
/* synchronization2 */
    structBody << "\t" << structInfo->synchronization2 << "," << std::endl;
/* textureCompressionASTC_HDR */
    structBody << "\t" << structInfo->textureCompressionASTC_HDR << "," << std::endl;
/* shaderZeroInitializeWorkgroupMemory */
    structBody << "\t" << structInfo->shaderZeroInitializeWorkgroupMemory << "," << std::endl;
/* dynamicRendering */
    structBody << "\t" << structInfo->dynamicRendering << "," << std::endl;
/* shaderIntegerDotProduct */
    structBody << "\t" << structInfo->shaderIntegerDotProduct << "," << std::endl;
/* maintenance4 */
    structBody << "\t" << structInfo->maintenance4 << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceVulkan13Features");
    out << "VkPhysicalDeviceVulkan13Features " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceVulkan13Properties(std::ostream &out, const VkPhysicalDeviceVulkan13Properties* structInfo, Decoded_VkPhysicalDeviceVulkan13Properties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* minSubgroupSize */
    structBody << "\t" << structInfo->minSubgroupSize << "," << std::endl;
/* maxSubgroupSize */
    structBody << "\t" << structInfo->maxSubgroupSize << "," << std::endl;
/* maxComputeWorkgroupSubgroups */
    structBody << "\t" << structInfo->maxComputeWorkgroupSubgroups << "," << std::endl;
/* requiredSubgroupSizeStages */
    structBody << "\t" << "VkShaderStageFlags(" << structInfo->requiredSubgroupSizeStages << ")" << "," << std::endl;
/* maxInlineUniformBlockSize */
    structBody << "\t" << structInfo->maxInlineUniformBlockSize << "," << std::endl;
/* maxPerStageDescriptorInlineUniformBlocks */
    structBody << "\t" << structInfo->maxPerStageDescriptorInlineUniformBlocks << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks << "," << std::endl;
/* maxDescriptorSetInlineUniformBlocks */
    structBody << "\t" << structInfo->maxDescriptorSetInlineUniformBlocks << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindInlineUniformBlocks */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindInlineUniformBlocks << "," << std::endl;
/* maxInlineUniformTotalSize */
    structBody << "\t" << structInfo->maxInlineUniformTotalSize << "," << std::endl;
/* integerDotProduct8BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct8BitUnsignedAccelerated << "," << std::endl;
/* integerDotProduct8BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct8BitSignedAccelerated << "," << std::endl;
/* integerDotProduct8BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProduct8BitMixedSignednessAccelerated << "," << std::endl;
/* integerDotProduct4x8BitPackedUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct4x8BitPackedUnsignedAccelerated << "," << std::endl;
/* integerDotProduct4x8BitPackedSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct4x8BitPackedSignedAccelerated << "," << std::endl;
/* integerDotProduct4x8BitPackedMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProduct4x8BitPackedMixedSignednessAccelerated << "," << std::endl;
/* integerDotProduct16BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct16BitUnsignedAccelerated << "," << std::endl;
/* integerDotProduct16BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct16BitSignedAccelerated << "," << std::endl;
/* integerDotProduct16BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProduct16BitMixedSignednessAccelerated << "," << std::endl;
/* integerDotProduct32BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct32BitUnsignedAccelerated << "," << std::endl;
/* integerDotProduct32BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct32BitSignedAccelerated << "," << std::endl;
/* integerDotProduct32BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProduct32BitMixedSignednessAccelerated << "," << std::endl;
/* integerDotProduct64BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct64BitUnsignedAccelerated << "," << std::endl;
/* integerDotProduct64BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct64BitSignedAccelerated << "," << std::endl;
/* integerDotProduct64BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProduct64BitMixedSignednessAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating8BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating8BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating8BitSignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating16BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating16BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating16BitSignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating32BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating32BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating32BitSignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating64BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating64BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating64BitSignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated << "," << std::endl;
/* storageTexelBufferOffsetAlignmentBytes */
    structBody << "\t" << structInfo->storageTexelBufferOffsetAlignmentBytes << "UL" << "," << std::endl;
/* storageTexelBufferOffsetSingleTexelAlignment */
    structBody << "\t" << structInfo->storageTexelBufferOffsetSingleTexelAlignment << "," << std::endl;
/* uniformTexelBufferOffsetAlignmentBytes */
    structBody << "\t" << structInfo->uniformTexelBufferOffsetAlignmentBytes << "UL" << "," << std::endl;
/* uniformTexelBufferOffsetSingleTexelAlignment */
    structBody << "\t" << structInfo->uniformTexelBufferOffsetSingleTexelAlignment << "," << std::endl;
/* maxBufferSize */
    structBody << "\t" << structInfo->maxBufferSize << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceVulkan13Properties");
    out << "VkPhysicalDeviceVulkan13Properties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineCreationFeedback(std::ostream &out, const VkPipelineCreationFeedback* structInfo, Decoded_VkPipelineCreationFeedback* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* flags */
    structBody << "\t" << "VkPipelineCreationFeedbackFlags(" << structInfo->flags << ")" << "," << std::endl;
/* duration */
    structBody << "\t" << structInfo->duration << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineCreationFeedback");
    out << "VkPipelineCreationFeedback " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineCreationFeedbackCreateInfo(std::ostream &out, const VkPipelineCreationFeedbackCreateInfo* structInfo, Decoded_VkPipelineCreationFeedbackCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pPipelineStageCreationFeedbacksArray = "NULL";
    if (structInfo->pPipelineStageCreationFeedbacks != NULL) {
        pPipelineStageCreationFeedbacksArray = "pPipelineStageCreationFeedbacks_" + std::to_string(consumer.getNextId());
        std::string pPipelineStageCreationFeedbacksNames;
        for (uint32_t idx = 0; idx < structInfo->pipelineStageCreationFeedbackCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pPipelineStageCreationFeedbacks + idx != NULL) {
                varName = GenerateStruct_VkPipelineCreationFeedback(out,
                                                         structInfo->pPipelineStageCreationFeedbacks + idx,
                                                         metainfo->pPipelineStageCreationFeedbacks->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pPipelineStageCreationFeedbacksNames += varName + ", ";
        }
        out << "VkPipelineCreationFeedback " << pPipelineStageCreationFeedbacksArray << "[] = {" << pPipelineStageCreationFeedbacksNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pPipelineCreationFeedback */
    out << "// TODO: Support pPipelineCreationFeedback (output?) argument." << std::endl;
/* pipelineStageCreationFeedbackCount */
    structBody << "\t" << structInfo->pipelineStageCreationFeedbackCount << "," << std::endl;
/* pPipelineStageCreationFeedbacks */
    structBody << "\t" << pPipelineStageCreationFeedbacksArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineCreationFeedbackCreateInfo");
    out << "VkPipelineCreationFeedbackCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderTerminateInvocationFeatures(std::ostream &out, const VkPhysicalDeviceShaderTerminateInvocationFeatures* structInfo, Decoded_VkPhysicalDeviceShaderTerminateInvocationFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderTerminateInvocation */
    structBody << "\t" << structInfo->shaderTerminateInvocation << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderTerminateInvocationFeatures");
    out << "VkPhysicalDeviceShaderTerminateInvocationFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceToolProperties(std::ostream &out, const VkPhysicalDeviceToolProperties* structInfo, Decoded_VkPhysicalDeviceToolProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* name */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->name) << "," << std::endl;
/* version */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->version) << "," << std::endl;
/* purposes */
    structBody << "\t" << "VkToolPurposeFlags(" << structInfo->purposes << ")" << "," << std::endl;
/* description */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->description) << "," << std::endl;
/* layer */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->layer) << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceToolProperties");
    out << "VkPhysicalDeviceToolProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures(std::ostream &out, const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* structInfo, Decoded_VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderDemoteToHelperInvocation */
    structBody << "\t" << structInfo->shaderDemoteToHelperInvocation << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderDemoteToHelperInvocationFeatures");
    out << "VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePrivateDataFeatures(std::ostream &out, const VkPhysicalDevicePrivateDataFeatures* structInfo, Decoded_VkPhysicalDevicePrivateDataFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* privateData */
    structBody << "\t" << structInfo->privateData << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePrivateDataFeatures");
    out << "VkPhysicalDevicePrivateDataFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDevicePrivateDataCreateInfo(std::ostream &out, const VkDevicePrivateDataCreateInfo* structInfo, Decoded_VkDevicePrivateDataCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* privateDataSlotRequestCount */
    structBody << "\t" << structInfo->privateDataSlotRequestCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "devicePrivateDataCreateInfo");
    out << "VkDevicePrivateDataCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPrivateDataSlotCreateInfo(std::ostream &out, const VkPrivateDataSlotCreateInfo* structInfo, Decoded_VkPrivateDataSlotCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPrivateDataSlotCreateFlags(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "privateDataSlotCreateInfo");
    out << "VkPrivateDataSlotCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePipelineCreationCacheControlFeatures(std::ostream &out, const VkPhysicalDevicePipelineCreationCacheControlFeatures* structInfo, Decoded_VkPhysicalDevicePipelineCreationCacheControlFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pipelineCreationCacheControl */
    structBody << "\t" << structInfo->pipelineCreationCacheControl << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePipelineCreationCacheControlFeatures");
    out << "VkPhysicalDevicePipelineCreationCacheControlFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryBarrier2(std::ostream &out, const VkMemoryBarrier2* structInfo, Decoded_VkMemoryBarrier2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcStageMask */
    structBody << "\t" << "VkPipelineStageFlags2(" << structInfo->srcStageMask << ")" << "," << std::endl;
/* srcAccessMask */
    structBody << "\t" << "VkAccessFlags2(" << structInfo->srcAccessMask << ")" << "," << std::endl;
/* dstStageMask */
    structBody << "\t" << "VkPipelineStageFlags2(" << structInfo->dstStageMask << ")" << "," << std::endl;
/* dstAccessMask */
    structBody << "\t" << "VkAccessFlags2(" << structInfo->dstAccessMask << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryBarrier2");
    out << "VkMemoryBarrier2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBufferMemoryBarrier2(std::ostream &out, const VkBufferMemoryBarrier2* structInfo, Decoded_VkBufferMemoryBarrier2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcStageMask */
    structBody << "\t" << "VkPipelineStageFlags2(" << structInfo->srcStageMask << ")" << "," << std::endl;
/* srcAccessMask */
    structBody << "\t" << "VkAccessFlags2(" << structInfo->srcAccessMask << ")" << "," << std::endl;
/* dstStageMask */
    structBody << "\t" << "VkPipelineStageFlags2(" << structInfo->dstStageMask << ")" << "," << std::endl;
/* dstAccessMask */
    structBody << "\t" << "VkAccessFlags2(" << structInfo->dstAccessMask << ")" << "," << std::endl;
/* srcQueueFamilyIndex */
    structBody << "\t" << structInfo->srcQueueFamilyIndex << "," << std::endl;
/* dstQueueFamilyIndex */
    structBody << "\t" << structInfo->dstQueueFamilyIndex << "," << std::endl;
/* buffer */
    structBody << "\t" << consumer.GetHandle(metainfo->buffer) << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "bufferMemoryBarrier2");
    out << "VkBufferMemoryBarrier2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageMemoryBarrier2(std::ostream &out, const VkImageMemoryBarrier2* structInfo, Decoded_VkImageMemoryBarrier2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string subresourceRangeInfoVar = GenerateStruct_VkImageSubresourceRange(out,
                                                                         &structInfo->subresourceRange,
                                                                         metainfo->subresourceRange,
                                                                         consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcStageMask */
    structBody << "\t" << "VkPipelineStageFlags2(" << structInfo->srcStageMask << ")" << "," << std::endl;
/* srcAccessMask */
    structBody << "\t" << "VkAccessFlags2(" << structInfo->srcAccessMask << ")" << "," << std::endl;
/* dstStageMask */
    structBody << "\t" << "VkPipelineStageFlags2(" << structInfo->dstStageMask << ")" << "," << std::endl;
/* dstAccessMask */
    structBody << "\t" << "VkAccessFlags2(" << structInfo->dstAccessMask << ")" << "," << std::endl;
/* oldLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->oldLayout << ")" << "," << std::endl;
/* newLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->newLayout << ")" << "," << std::endl;
/* srcQueueFamilyIndex */
    structBody << "\t" << structInfo->srcQueueFamilyIndex << "," << std::endl;
/* dstQueueFamilyIndex */
    structBody << "\t" << structInfo->dstQueueFamilyIndex << "," << std::endl;
/* image */
    structBody << "\t" << consumer.GetHandle(metainfo->image) << "," << std::endl;
/* subresourceRange */
    structBody << "\t" << subresourceRangeInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageMemoryBarrier2");
    out << "VkImageMemoryBarrier2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDependencyInfo(std::ostream &out, const VkDependencyInfo* structInfo, Decoded_VkDependencyInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pMemoryBarriersArray = "NULL";
    if (structInfo->pMemoryBarriers != NULL) {
        pMemoryBarriersArray = "pMemoryBarriers_" + std::to_string(consumer.getNextId());
        std::string pMemoryBarriersNames;
        for (uint32_t idx = 0; idx < structInfo->memoryBarrierCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pMemoryBarriers + idx != NULL) {
                varName = GenerateStruct_VkMemoryBarrier2(out,
                                                         structInfo->pMemoryBarriers + idx,
                                                         metainfo->pMemoryBarriers->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pMemoryBarriersNames += varName + ", ";
        }
        out << "VkMemoryBarrier2 " << pMemoryBarriersArray << "[] = {" << pMemoryBarriersNames << "};" << std::endl;
    }
    std::string pBufferMemoryBarriersArray = "NULL";
    if (structInfo->pBufferMemoryBarriers != NULL) {
        pBufferMemoryBarriersArray = "pBufferMemoryBarriers_" + std::to_string(consumer.getNextId());
        std::string pBufferMemoryBarriersNames;
        for (uint32_t idx = 0; idx < structInfo->bufferMemoryBarrierCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pBufferMemoryBarriers + idx != NULL) {
                varName = GenerateStruct_VkBufferMemoryBarrier2(out,
                                                         structInfo->pBufferMemoryBarriers + idx,
                                                         metainfo->pBufferMemoryBarriers->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pBufferMemoryBarriersNames += varName + ", ";
        }
        out << "VkBufferMemoryBarrier2 " << pBufferMemoryBarriersArray << "[] = {" << pBufferMemoryBarriersNames << "};" << std::endl;
    }
    std::string pImageMemoryBarriersArray = "NULL";
    if (structInfo->pImageMemoryBarriers != NULL) {
        pImageMemoryBarriersArray = "pImageMemoryBarriers_" + std::to_string(consumer.getNextId());
        std::string pImageMemoryBarriersNames;
        for (uint32_t idx = 0; idx < structInfo->imageMemoryBarrierCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pImageMemoryBarriers + idx != NULL) {
                varName = GenerateStruct_VkImageMemoryBarrier2(out,
                                                         structInfo->pImageMemoryBarriers + idx,
                                                         metainfo->pImageMemoryBarriers->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pImageMemoryBarriersNames += varName + ", ";
        }
        out << "VkImageMemoryBarrier2 " << pImageMemoryBarriersArray << "[] = {" << pImageMemoryBarriersNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* dependencyFlags */
    structBody << "\t" << "VkDependencyFlags(" << structInfo->dependencyFlags << ")" << "," << std::endl;
/* memoryBarrierCount */
    structBody << "\t" << structInfo->memoryBarrierCount << "," << std::endl;
/* pMemoryBarriers */
    structBody << "\t" << pMemoryBarriersArray << "," << std::endl;
/* bufferMemoryBarrierCount */
    structBody << "\t" << structInfo->bufferMemoryBarrierCount << "," << std::endl;
/* pBufferMemoryBarriers */
    structBody << "\t" << pBufferMemoryBarriersArray << "," << std::endl;
/* imageMemoryBarrierCount */
    structBody << "\t" << structInfo->imageMemoryBarrierCount << "," << std::endl;
/* pImageMemoryBarriers */
    structBody << "\t" << pImageMemoryBarriersArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "dependencyInfo");
    out << "VkDependencyInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSemaphoreSubmitInfo(std::ostream &out, const VkSemaphoreSubmitInfo* structInfo, Decoded_VkSemaphoreSubmitInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* semaphore */
    structBody << "\t" << consumer.GetHandle(metainfo->semaphore) << "," << std::endl;
/* value */
    structBody << "\t" << structInfo->value << "UL" << "," << std::endl;
/* stageMask */
    structBody << "\t" << "VkPipelineStageFlags2(" << structInfo->stageMask << ")" << "," << std::endl;
/* deviceIndex */
    structBody << "\t" << structInfo->deviceIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "semaphoreSubmitInfo");
    out << "VkSemaphoreSubmitInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCommandBufferSubmitInfo(std::ostream &out, const VkCommandBufferSubmitInfo* structInfo, Decoded_VkCommandBufferSubmitInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* commandBuffer */
    structBody << "\t" << consumer.GetHandle(metainfo->commandBuffer) << "," << std::endl;
/* deviceMask */
    structBody << "\t" << structInfo->deviceMask << "," ;
    std::string varname = consumer.AddStruct(structBody, "commandBufferSubmitInfo");
    out << "VkCommandBufferSubmitInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubmitInfo2(std::ostream &out, const VkSubmitInfo2* structInfo, Decoded_VkSubmitInfo2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pWaitSemaphoreInfosArray = "NULL";
    if (structInfo->pWaitSemaphoreInfos != NULL) {
        pWaitSemaphoreInfosArray = "pWaitSemaphoreInfos_" + std::to_string(consumer.getNextId());
        std::string pWaitSemaphoreInfosNames;
        for (uint32_t idx = 0; idx < structInfo->waitSemaphoreInfoCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pWaitSemaphoreInfos + idx != NULL) {
                varName = GenerateStruct_VkSemaphoreSubmitInfo(out,
                                                         structInfo->pWaitSemaphoreInfos + idx,
                                                         metainfo->pWaitSemaphoreInfos->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pWaitSemaphoreInfosNames += varName + ", ";
        }
        out << "VkSemaphoreSubmitInfo " << pWaitSemaphoreInfosArray << "[] = {" << pWaitSemaphoreInfosNames << "};" << std::endl;
    }
    std::string pCommandBufferInfosArray = "NULL";
    if (structInfo->pCommandBufferInfos != NULL) {
        pCommandBufferInfosArray = "pCommandBufferInfos_" + std::to_string(consumer.getNextId());
        std::string pCommandBufferInfosNames;
        for (uint32_t idx = 0; idx < structInfo->commandBufferInfoCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pCommandBufferInfos + idx != NULL) {
                varName = GenerateStruct_VkCommandBufferSubmitInfo(out,
                                                         structInfo->pCommandBufferInfos + idx,
                                                         metainfo->pCommandBufferInfos->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pCommandBufferInfosNames += varName + ", ";
        }
        out << "VkCommandBufferSubmitInfo " << pCommandBufferInfosArray << "[] = {" << pCommandBufferInfosNames << "};" << std::endl;
    }
    std::string pSignalSemaphoreInfosArray = "NULL";
    if (structInfo->pSignalSemaphoreInfos != NULL) {
        pSignalSemaphoreInfosArray = "pSignalSemaphoreInfos_" + std::to_string(consumer.getNextId());
        std::string pSignalSemaphoreInfosNames;
        for (uint32_t idx = 0; idx < structInfo->signalSemaphoreInfoCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pSignalSemaphoreInfos + idx != NULL) {
                varName = GenerateStruct_VkSemaphoreSubmitInfo(out,
                                                         structInfo->pSignalSemaphoreInfos + idx,
                                                         metainfo->pSignalSemaphoreInfos->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pSignalSemaphoreInfosNames += varName + ", ";
        }
        out << "VkSemaphoreSubmitInfo " << pSignalSemaphoreInfosArray << "[] = {" << pSignalSemaphoreInfosNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkSubmitFlags(" << structInfo->flags << ")" << "," << std::endl;
/* waitSemaphoreInfoCount */
    structBody << "\t" << structInfo->waitSemaphoreInfoCount << "," << std::endl;
/* pWaitSemaphoreInfos */
    structBody << "\t" << pWaitSemaphoreInfosArray << "," << std::endl;
/* commandBufferInfoCount */
    structBody << "\t" << structInfo->commandBufferInfoCount << "," << std::endl;
/* pCommandBufferInfos */
    structBody << "\t" << pCommandBufferInfosArray << "," << std::endl;
/* signalSemaphoreInfoCount */
    structBody << "\t" << structInfo->signalSemaphoreInfoCount << "," << std::endl;
/* pSignalSemaphoreInfos */
    structBody << "\t" << pSignalSemaphoreInfosArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "submitInfo2");
    out << "VkSubmitInfo2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceSynchronization2Features(std::ostream &out, const VkPhysicalDeviceSynchronization2Features* structInfo, Decoded_VkPhysicalDeviceSynchronization2Features* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* synchronization2 */
    structBody << "\t" << structInfo->synchronization2 << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceSynchronization2Features");
    out << "VkPhysicalDeviceSynchronization2Features " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures(std::ostream &out, const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* structInfo, Decoded_VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderZeroInitializeWorkgroupMemory */
    structBody << "\t" << structInfo->shaderZeroInitializeWorkgroupMemory << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceZeroInitializeWorkgroupMemoryFeatures");
    out << "VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceImageRobustnessFeatures(std::ostream &out, const VkPhysicalDeviceImageRobustnessFeatures* structInfo, Decoded_VkPhysicalDeviceImageRobustnessFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* robustImageAccess */
    structBody << "\t" << structInfo->robustImageAccess << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceImageRobustnessFeatures");
    out << "VkPhysicalDeviceImageRobustnessFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBufferCopy2(std::ostream &out, const VkBufferCopy2* structInfo, Decoded_VkBufferCopy2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcOffset */
    structBody << "\t" << structInfo->srcOffset << "UL" << "," << std::endl;
/* dstOffset */
    structBody << "\t" << structInfo->dstOffset << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "bufferCopy2");
    out << "VkBufferCopy2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyBufferInfo2(std::ostream &out, const VkCopyBufferInfo2* structInfo, Decoded_VkCopyBufferInfo2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pRegionsArray = "NULL";
    if (structInfo->pRegions != NULL) {
        pRegionsArray = "pRegions_" + std::to_string(consumer.getNextId());
        std::string pRegionsNames;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                varName = GenerateStruct_VkBufferCopy2(out,
                                                         structInfo->pRegions + idx,
                                                         metainfo->pRegions->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pRegionsNames += varName + ", ";
        }
        out << "VkBufferCopy2 " << pRegionsArray << "[] = {" << pRegionsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcBuffer */
    structBody << "\t" << consumer.GetHandle(metainfo->srcBuffer) << "," << std::endl;
/* dstBuffer */
    structBody << "\t" << consumer.GetHandle(metainfo->dstBuffer) << "," << std::endl;
/* regionCount */
    structBody << "\t" << structInfo->regionCount << "," << std::endl;
/* pRegions */
    structBody << "\t" << pRegionsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyBufferInfo2");
    out << "VkCopyBufferInfo2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageCopy2(std::ostream &out, const VkImageCopy2* structInfo, Decoded_VkImageCopy2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string srcSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                       &structInfo->srcSubresource,
                                                                       metainfo->srcSubresource,
                                                                       consumer);
    std::string srcOffsetInfoVar = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->srcOffset,
                                                                  metainfo->srcOffset,
                                                                  consumer);
    std::string dstSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                       &structInfo->dstSubresource,
                                                                       metainfo->dstSubresource,
                                                                       consumer);
    std::string dstOffsetInfoVar = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->dstOffset,
                                                                  metainfo->dstOffset,
                                                                  consumer);
    std::string extentInfoVar = GenerateStruct_VkExtent3D(out,
                                                               &structInfo->extent,
                                                               metainfo->extent,
                                                               consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcSubresource */
    structBody << "\t" << srcSubresourceInfoVar << "," << std::endl;
/* srcOffset */
    structBody << "\t" << srcOffsetInfoVar << "," << std::endl;
/* dstSubresource */
    structBody << "\t" << dstSubresourceInfoVar << "," << std::endl;
/* dstOffset */
    structBody << "\t" << dstOffsetInfoVar << "," << std::endl;
/* extent */
    structBody << "\t" << extentInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageCopy2");
    out << "VkImageCopy2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyImageInfo2(std::ostream &out, const VkCopyImageInfo2* structInfo, Decoded_VkCopyImageInfo2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pRegionsArray = "NULL";
    if (structInfo->pRegions != NULL) {
        pRegionsArray = "pRegions_" + std::to_string(consumer.getNextId());
        std::string pRegionsNames;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                varName = GenerateStruct_VkImageCopy2(out,
                                                         structInfo->pRegions + idx,
                                                         metainfo->pRegions->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pRegionsNames += varName + ", ";
        }
        out << "VkImageCopy2 " << pRegionsArray << "[] = {" << pRegionsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcImage */
    structBody << "\t" << consumer.GetHandle(metainfo->srcImage) << "," << std::endl;
/* srcImageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
/* dstImage */
    structBody << "\t" << consumer.GetHandle(metainfo->dstImage) << "," << std::endl;
/* dstImageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
/* regionCount */
    structBody << "\t" << structInfo->regionCount << "," << std::endl;
/* pRegions */
    structBody << "\t" << pRegionsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyImageInfo2");
    out << "VkCopyImageInfo2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBufferImageCopy2(std::ostream &out, const VkBufferImageCopy2* structInfo, Decoded_VkBufferImageCopy2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string imageSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                         &structInfo->imageSubresource,
                                                                         metainfo->imageSubresource,
                                                                         consumer);
    std::string imageOffsetInfoVar = GenerateStruct_VkOffset3D(out,
                                                                    &structInfo->imageOffset,
                                                                    metainfo->imageOffset,
                                                                    consumer);
    std::string imageExtentInfoVar = GenerateStruct_VkExtent3D(out,
                                                                    &structInfo->imageExtent,
                                                                    metainfo->imageExtent,
                                                                    consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* bufferOffset */
    structBody << "\t" << structInfo->bufferOffset << "UL" << "," << std::endl;
/* bufferRowLength */
    structBody << "\t" << structInfo->bufferRowLength << "," << std::endl;
/* bufferImageHeight */
    structBody << "\t" << structInfo->bufferImageHeight << "," << std::endl;
/* imageSubresource */
    structBody << "\t" << imageSubresourceInfoVar << "," << std::endl;
/* imageOffset */
    structBody << "\t" << imageOffsetInfoVar << "," << std::endl;
/* imageExtent */
    structBody << "\t" << imageExtentInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "bufferImageCopy2");
    out << "VkBufferImageCopy2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyBufferToImageInfo2(std::ostream &out, const VkCopyBufferToImageInfo2* structInfo, Decoded_VkCopyBufferToImageInfo2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pRegionsArray = "NULL";
    if (structInfo->pRegions != NULL) {
        pRegionsArray = "pRegions_" + std::to_string(consumer.getNextId());
        std::string pRegionsNames;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                varName = GenerateStruct_VkBufferImageCopy2(out,
                                                         structInfo->pRegions + idx,
                                                         metainfo->pRegions->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pRegionsNames += varName + ", ";
        }
        out << "VkBufferImageCopy2 " << pRegionsArray << "[] = {" << pRegionsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcBuffer */
    structBody << "\t" << consumer.GetHandle(metainfo->srcBuffer) << "," << std::endl;
/* dstImage */
    structBody << "\t" << consumer.GetHandle(metainfo->dstImage) << "," << std::endl;
/* dstImageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
/* regionCount */
    structBody << "\t" << structInfo->regionCount << "," << std::endl;
/* pRegions */
    structBody << "\t" << pRegionsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyBufferToImageInfo2");
    out << "VkCopyBufferToImageInfo2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyImageToBufferInfo2(std::ostream &out, const VkCopyImageToBufferInfo2* structInfo, Decoded_VkCopyImageToBufferInfo2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pRegionsArray = "NULL";
    if (structInfo->pRegions != NULL) {
        pRegionsArray = "pRegions_" + std::to_string(consumer.getNextId());
        std::string pRegionsNames;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                varName = GenerateStruct_VkBufferImageCopy2(out,
                                                         structInfo->pRegions + idx,
                                                         metainfo->pRegions->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pRegionsNames += varName + ", ";
        }
        out << "VkBufferImageCopy2 " << pRegionsArray << "[] = {" << pRegionsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcImage */
    structBody << "\t" << consumer.GetHandle(metainfo->srcImage) << "," << std::endl;
/* srcImageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
/* dstBuffer */
    structBody << "\t" << consumer.GetHandle(metainfo->dstBuffer) << "," << std::endl;
/* regionCount */
    structBody << "\t" << structInfo->regionCount << "," << std::endl;
/* pRegions */
    structBody << "\t" << pRegionsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyImageToBufferInfo2");
    out << "VkCopyImageToBufferInfo2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageBlit2(std::ostream &out, const VkImageBlit2* structInfo, Decoded_VkImageBlit2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string srcSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                       &structInfo->srcSubresource,
                                                                       metainfo->srcSubresource,
                                                                       consumer);
    std::string dstSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                       &structInfo->dstSubresource,
                                                                       metainfo->dstSubresource,
                                                                       consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcSubresource */
    structBody << "\t" << srcSubresourceInfoVar << "," << std::endl;
/* srcOffsets */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkOffset3D*>(&structInfo->srcOffsets[0]), 2) << "," << std::endl;
/* dstSubresource */
    structBody << "\t" << dstSubresourceInfoVar << "," << std::endl;
/* dstOffsets */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkOffset3D*>(&structInfo->dstOffsets[0]), 2) << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageBlit2");
    out << "VkImageBlit2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBlitImageInfo2(std::ostream &out, const VkBlitImageInfo2* structInfo, Decoded_VkBlitImageInfo2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pRegionsArray = "NULL";
    if (structInfo->pRegions != NULL) {
        pRegionsArray = "pRegions_" + std::to_string(consumer.getNextId());
        std::string pRegionsNames;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                varName = GenerateStruct_VkImageBlit2(out,
                                                         structInfo->pRegions + idx,
                                                         metainfo->pRegions->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pRegionsNames += varName + ", ";
        }
        out << "VkImageBlit2 " << pRegionsArray << "[] = {" << pRegionsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcImage */
    structBody << "\t" << consumer.GetHandle(metainfo->srcImage) << "," << std::endl;
/* srcImageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
/* dstImage */
    structBody << "\t" << consumer.GetHandle(metainfo->dstImage) << "," << std::endl;
/* dstImageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
/* regionCount */
    structBody << "\t" << structInfo->regionCount << "," << std::endl;
/* pRegions */
    structBody << "\t" << pRegionsArray << "," << std::endl;
/* filter */
    structBody << "\t" << "VkFilter(" << structInfo->filter << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "blitImageInfo2");
    out << "VkBlitImageInfo2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageResolve2(std::ostream &out, const VkImageResolve2* structInfo, Decoded_VkImageResolve2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string srcSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                       &structInfo->srcSubresource,
                                                                       metainfo->srcSubresource,
                                                                       consumer);
    std::string srcOffsetInfoVar = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->srcOffset,
                                                                  metainfo->srcOffset,
                                                                  consumer);
    std::string dstSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                       &structInfo->dstSubresource,
                                                                       metainfo->dstSubresource,
                                                                       consumer);
    std::string dstOffsetInfoVar = GenerateStruct_VkOffset3D(out,
                                                                  &structInfo->dstOffset,
                                                                  metainfo->dstOffset,
                                                                  consumer);
    std::string extentInfoVar = GenerateStruct_VkExtent3D(out,
                                                               &structInfo->extent,
                                                               metainfo->extent,
                                                               consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcSubresource */
    structBody << "\t" << srcSubresourceInfoVar << "," << std::endl;
/* srcOffset */
    structBody << "\t" << srcOffsetInfoVar << "," << std::endl;
/* dstSubresource */
    structBody << "\t" << dstSubresourceInfoVar << "," << std::endl;
/* dstOffset */
    structBody << "\t" << dstOffsetInfoVar << "," << std::endl;
/* extent */
    structBody << "\t" << extentInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageResolve2");
    out << "VkImageResolve2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkResolveImageInfo2(std::ostream &out, const VkResolveImageInfo2* structInfo, Decoded_VkResolveImageInfo2* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pRegionsArray = "NULL";
    if (structInfo->pRegions != NULL) {
        pRegionsArray = "pRegions_" + std::to_string(consumer.getNextId());
        std::string pRegionsNames;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                varName = GenerateStruct_VkImageResolve2(out,
                                                         structInfo->pRegions + idx,
                                                         metainfo->pRegions->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pRegionsNames += varName + ", ";
        }
        out << "VkImageResolve2 " << pRegionsArray << "[] = {" << pRegionsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcImage */
    structBody << "\t" << consumer.GetHandle(metainfo->srcImage) << "," << std::endl;
/* srcImageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
/* dstImage */
    structBody << "\t" << consumer.GetHandle(metainfo->dstImage) << "," << std::endl;
/* dstImageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
/* regionCount */
    structBody << "\t" << structInfo->regionCount << "," << std::endl;
/* pRegions */
    structBody << "\t" << pRegionsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "resolveImageInfo2");
    out << "VkResolveImageInfo2 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceSubgroupSizeControlFeatures(std::ostream &out, const VkPhysicalDeviceSubgroupSizeControlFeatures* structInfo, Decoded_VkPhysicalDeviceSubgroupSizeControlFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* subgroupSizeControl */
    structBody << "\t" << structInfo->subgroupSizeControl << "," << std::endl;
/* computeFullSubgroups */
    structBody << "\t" << structInfo->computeFullSubgroups << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceSubgroupSizeControlFeatures");
    out << "VkPhysicalDeviceSubgroupSizeControlFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceSubgroupSizeControlProperties(std::ostream &out, const VkPhysicalDeviceSubgroupSizeControlProperties* structInfo, Decoded_VkPhysicalDeviceSubgroupSizeControlProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* minSubgroupSize */
    structBody << "\t" << structInfo->minSubgroupSize << "," << std::endl;
/* maxSubgroupSize */
    structBody << "\t" << structInfo->maxSubgroupSize << "," << std::endl;
/* maxComputeWorkgroupSubgroups */
    structBody << "\t" << structInfo->maxComputeWorkgroupSubgroups << "," << std::endl;
/* requiredSubgroupSizeStages */
    structBody << "\t" << "VkShaderStageFlags(" << structInfo->requiredSubgroupSizeStages << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceSubgroupSizeControlProperties");
    out << "VkPhysicalDeviceSubgroupSizeControlProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo(std::ostream &out, const VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* structInfo, Decoded_VkPipelineShaderStageRequiredSubgroupSizeCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* requiredSubgroupSize */
    structBody << "\t" << structInfo->requiredSubgroupSize << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineShaderStageRequiredSubgroupSizeCreateInfo");
    out << "VkPipelineShaderStageRequiredSubgroupSizeCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceInlineUniformBlockFeatures(std::ostream &out, const VkPhysicalDeviceInlineUniformBlockFeatures* structInfo, Decoded_VkPhysicalDeviceInlineUniformBlockFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* inlineUniformBlock */
    structBody << "\t" << structInfo->inlineUniformBlock << "," << std::endl;
/* descriptorBindingInlineUniformBlockUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingInlineUniformBlockUpdateAfterBind << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceInlineUniformBlockFeatures");
    out << "VkPhysicalDeviceInlineUniformBlockFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceInlineUniformBlockProperties(std::ostream &out, const VkPhysicalDeviceInlineUniformBlockProperties* structInfo, Decoded_VkPhysicalDeviceInlineUniformBlockProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxInlineUniformBlockSize */
    structBody << "\t" << structInfo->maxInlineUniformBlockSize << "," << std::endl;
/* maxPerStageDescriptorInlineUniformBlocks */
    structBody << "\t" << structInfo->maxPerStageDescriptorInlineUniformBlocks << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindInlineUniformBlocks << "," << std::endl;
/* maxDescriptorSetInlineUniformBlocks */
    structBody << "\t" << structInfo->maxDescriptorSetInlineUniformBlocks << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindInlineUniformBlocks */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindInlineUniformBlocks << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceInlineUniformBlockProperties");
    out << "VkPhysicalDeviceInlineUniformBlockProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkWriteDescriptorSetInlineUniformBlock(std::ostream &out, const VkWriteDescriptorSetInlineUniformBlock* structInfo, Decoded_VkWriteDescriptorSetInlineUniformBlock* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDataArray = "NULL";
    if (structInfo->pData != NULL) {
        std::string pDataValues;
        for (uint32_t idx0 = 0; idx0 < structInfo->dataSize; ++idx0) {
            pDataValues += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pData)[idx0]) + ", ";
        }
        pDataArray = "pData_" + std::to_string(consumer.getNextId());
        out << "uint8_t " << pDataArray << "[] = {" << pDataValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* dataSize */
    structBody << "\t" << structInfo->dataSize << "," << std::endl;
/* pData */
    structBody << "\t" << pDataArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "writeDescriptorSetInlineUniformBlock");
    out << "VkWriteDescriptorSetInlineUniformBlock " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDescriptorPoolInlineUniformBlockCreateInfo(std::ostream &out, const VkDescriptorPoolInlineUniformBlockCreateInfo* structInfo, Decoded_VkDescriptorPoolInlineUniformBlockCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxInlineUniformBlockBindings */
    structBody << "\t" << structInfo->maxInlineUniformBlockBindings << "," ;
    std::string varname = consumer.AddStruct(structBody, "descriptorPoolInlineUniformBlockCreateInfo");
    out << "VkDescriptorPoolInlineUniformBlockCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceTextureCompressionASTCHDRFeatures(std::ostream &out, const VkPhysicalDeviceTextureCompressionASTCHDRFeatures* structInfo, Decoded_VkPhysicalDeviceTextureCompressionASTCHDRFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* textureCompressionASTC_HDR */
    structBody << "\t" << structInfo->textureCompressionASTC_HDR << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceTextureCompressionASTCHDRFeatures");
    out << "VkPhysicalDeviceTextureCompressionASTCHDRFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderingAttachmentInfo(std::ostream &out, const VkRenderingAttachmentInfo* structInfo, Decoded_VkRenderingAttachmentInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string colorInfoVar = GenerateStruct_VkClearColorValue(out,
                                                                       &structInfo->clearValue.color,
                                                                       metainfo->clearValue->color,
                                                                       consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* imageView */
    structBody << "\t" << consumer.GetHandle(metainfo->imageView) << "," << std::endl;
/* imageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->imageLayout << ")" << "," << std::endl;
/* resolveMode */
    structBody << "\t" << "VkResolveModeFlagBits(" << structInfo->resolveMode << ")" << "," << std::endl;
/* resolveImageView */
    structBody << "\t" << consumer.GetHandle(metainfo->resolveImageView) << "," << std::endl;
/* resolveImageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->resolveImageLayout << ")" << "," << std::endl;
/* loadOp */
    structBody << "\t" << "VkAttachmentLoadOp(" << structInfo->loadOp << ")" << "," << std::endl;
/* storeOp */
    structBody << "\t" << "VkAttachmentStoreOp(" << structInfo->storeOp << ")" << "," << std::endl;
/* clearValue */
    structBody << "\t" << colorInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderingAttachmentInfo");
    out << "VkRenderingAttachmentInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderingInfo(std::ostream &out, const VkRenderingInfo* structInfo, Decoded_VkRenderingInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string renderAreaInfoVar = GenerateStruct_VkRect2D(out,
                                                                   &structInfo->renderArea,
                                                                   metainfo->renderArea,
                                                                   consumer);
    std::string pColorAttachmentsArray = "NULL";
    if (structInfo->pColorAttachments != NULL) {
        pColorAttachmentsArray = "pColorAttachments_" + std::to_string(consumer.getNextId());
        std::string pColorAttachmentsNames;
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pColorAttachments + idx != NULL) {
                varName = GenerateStruct_VkRenderingAttachmentInfo(out,
                                                         structInfo->pColorAttachments + idx,
                                                         metainfo->pColorAttachments->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pColorAttachmentsNames += varName + ", ";
        }
        out << "VkRenderingAttachmentInfo " << pColorAttachmentsArray << "[] = {" << pColorAttachmentsNames << "};" << std::endl;
    }
    std::string pDepthAttachmentStruct = "NULL";
    if (structInfo->pDepthAttachment != NULL) {
        pDepthAttachmentStruct = GenerateStruct_VkRenderingAttachmentInfo(out,
                                                                structInfo->pDepthAttachment,
                                                                metainfo->pDepthAttachment->GetMetaStructPointer(),
                                                                consumer);
        pDepthAttachmentStruct.insert(0, "&");
    }
    std::string pStencilAttachmentStruct = "NULL";
    if (structInfo->pStencilAttachment != NULL) {
        pStencilAttachmentStruct = GenerateStruct_VkRenderingAttachmentInfo(out,
                                                                  structInfo->pStencilAttachment,
                                                                  metainfo->pStencilAttachment->GetMetaStructPointer(),
                                                                  consumer);
        pStencilAttachmentStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkRenderingFlags(" << structInfo->flags << ")" << "," << std::endl;
/* renderArea */
    structBody << "\t" << renderAreaInfoVar << "," << std::endl;
/* layerCount */
    structBody << "\t" << structInfo->layerCount << "," << std::endl;
/* viewMask */
    structBody << "\t" << structInfo->viewMask << "," << std::endl;
/* colorAttachmentCount */
    structBody << "\t" << structInfo->colorAttachmentCount << "," << std::endl;
/* pColorAttachments */
    structBody << "\t" << pColorAttachmentsArray << "," << std::endl;
/* pDepthAttachment */
    structBody << "\t" << pDepthAttachmentStruct << "," << std::endl;
/* pStencilAttachment */
    structBody << "\t" << pStencilAttachmentStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderingInfo");
    out << "VkRenderingInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineRenderingCreateInfo(std::ostream &out, const VkPipelineRenderingCreateInfo* structInfo, Decoded_VkPipelineRenderingCreateInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pColorAttachmentFormatsValues;
    std::string pColorAttachmentFormatsArray = "NULL";
    if (structInfo->pColorAttachmentFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            pColorAttachmentFormatsValues += util::ToString<VkFormat>(structInfo->pColorAttachmentFormats[idx]) + ", ";
        }
        pColorAttachmentFormatsArray = "pColorAttachmentFormats_" + std::to_string(consumer.getNextId());
        out << "VkFormat " << pColorAttachmentFormatsArray << "[] = {" << pColorAttachmentFormatsValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* viewMask */
    structBody << "\t" << structInfo->viewMask << "," << std::endl;
/* colorAttachmentCount */
    structBody << "\t" << structInfo->colorAttachmentCount << "," << std::endl;
/* pColorAttachmentFormats */
    structBody << "\t" << pColorAttachmentFormatsArray << "," << std::endl;
/* depthAttachmentFormat */
    structBody << "\t" << "VkFormat(" << structInfo->depthAttachmentFormat << ")" << "," << std::endl;
/* stencilAttachmentFormat */
    structBody << "\t" << "VkFormat(" << structInfo->stencilAttachmentFormat << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineRenderingCreateInfo");
    out << "VkPipelineRenderingCreateInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDynamicRenderingFeatures(std::ostream &out, const VkPhysicalDeviceDynamicRenderingFeatures* structInfo, Decoded_VkPhysicalDeviceDynamicRenderingFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* dynamicRendering */
    structBody << "\t" << structInfo->dynamicRendering << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDynamicRenderingFeatures");
    out << "VkPhysicalDeviceDynamicRenderingFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCommandBufferInheritanceRenderingInfo(std::ostream &out, const VkCommandBufferInheritanceRenderingInfo* structInfo, Decoded_VkCommandBufferInheritanceRenderingInfo* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pColorAttachmentFormatsValues;
    std::string pColorAttachmentFormatsArray = "NULL";
    if (structInfo->pColorAttachmentFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            pColorAttachmentFormatsValues += util::ToString<VkFormat>(structInfo->pColorAttachmentFormats[idx]) + ", ";
        }
        pColorAttachmentFormatsArray = "pColorAttachmentFormats_" + std::to_string(consumer.getNextId());
        out << "VkFormat " << pColorAttachmentFormatsArray << "[] = {" << pColorAttachmentFormatsValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkRenderingFlags(" << structInfo->flags << ")" << "," << std::endl;
/* viewMask */
    structBody << "\t" << structInfo->viewMask << "," << std::endl;
/* colorAttachmentCount */
    structBody << "\t" << structInfo->colorAttachmentCount << "," << std::endl;
/* pColorAttachmentFormats */
    structBody << "\t" << pColorAttachmentFormatsArray << "," << std::endl;
/* depthAttachmentFormat */
    structBody << "\t" << "VkFormat(" << structInfo->depthAttachmentFormat << ")" << "," << std::endl;
/* stencilAttachmentFormat */
    structBody << "\t" << "VkFormat(" << structInfo->stencilAttachmentFormat << ")" << "," << std::endl;
/* rasterizationSamples */
    structBody << "\t" << "VkSampleCountFlagBits(" << structInfo->rasterizationSamples << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "commandBufferInheritanceRenderingInfo");
    out << "VkCommandBufferInheritanceRenderingInfo " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderIntegerDotProductFeatures(std::ostream &out, const VkPhysicalDeviceShaderIntegerDotProductFeatures* structInfo, Decoded_VkPhysicalDeviceShaderIntegerDotProductFeatures* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderIntegerDotProduct */
    structBody << "\t" << structInfo->shaderIntegerDotProduct << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderIntegerDotProductFeatures");
    out << "VkPhysicalDeviceShaderIntegerDotProductFeatures " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderIntegerDotProductProperties(std::ostream &out, const VkPhysicalDeviceShaderIntegerDotProductProperties* structInfo, Decoded_VkPhysicalDeviceShaderIntegerDotProductProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* integerDotProduct8BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct8BitUnsignedAccelerated << "," << std::endl;
/* integerDotProduct8BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct8BitSignedAccelerated << "," << std::endl;
/* integerDotProduct8BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProduct8BitMixedSignednessAccelerated << "," << std::endl;
/* integerDotProduct4x8BitPackedUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct4x8BitPackedUnsignedAccelerated << "," << std::endl;
/* integerDotProduct4x8BitPackedSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct4x8BitPackedSignedAccelerated << "," << std::endl;
/* integerDotProduct4x8BitPackedMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProduct4x8BitPackedMixedSignednessAccelerated << "," << std::endl;
/* integerDotProduct16BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct16BitUnsignedAccelerated << "," << std::endl;
/* integerDotProduct16BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct16BitSignedAccelerated << "," << std::endl;
/* integerDotProduct16BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProduct16BitMixedSignednessAccelerated << "," << std::endl;
/* integerDotProduct32BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct32BitUnsignedAccelerated << "," << std::endl;
/* integerDotProduct32BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct32BitSignedAccelerated << "," << std::endl;
/* integerDotProduct32BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProduct32BitMixedSignednessAccelerated << "," << std::endl;
/* integerDotProduct64BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct64BitUnsignedAccelerated << "," << std::endl;
/* integerDotProduct64BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProduct64BitSignedAccelerated << "," << std::endl;
/* integerDotProduct64BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProduct64BitMixedSignednessAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating8BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating8BitUnsignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating8BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating8BitSignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating8BitMixedSignednessAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedUnsignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedSignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating4x8BitPackedMixedSignednessAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating16BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating16BitUnsignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating16BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating16BitSignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating16BitMixedSignednessAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating32BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating32BitUnsignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating32BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating32BitSignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating32BitMixedSignednessAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating64BitUnsignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating64BitUnsignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating64BitSignedAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating64BitSignedAccelerated << "," << std::endl;
/* integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated */
    structBody << "\t" << structInfo->integerDotProductAccumulatingSaturating64BitMixedSignednessAccelerated << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderIntegerDotProductProperties");
    out << "VkPhysicalDeviceShaderIntegerDotProductProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceTexelBufferAlignmentProperties(std::ostream &out, const VkPhysicalDeviceTexelBufferAlignmentProperties* structInfo, Decoded_VkPhysicalDeviceTexelBufferAlignmentProperties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* storageTexelBufferOffsetAlignmentBytes */
    structBody << "\t" << structInfo->storageTexelBufferOffsetAlignmentBytes << "UL" << "," << std::endl;
/* storageTexelBufferOffsetSingleTexelAlignment */
    structBody << "\t" << structInfo->storageTexelBufferOffsetSingleTexelAlignment << "," << std::endl;
/* uniformTexelBufferOffsetAlignmentBytes */
    structBody << "\t" << structInfo->uniformTexelBufferOffsetAlignmentBytes << "UL" << "," << std::endl;
/* uniformTexelBufferOffsetSingleTexelAlignment */
    structBody << "\t" << structInfo->uniformTexelBufferOffsetSingleTexelAlignment << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceTexelBufferAlignmentProperties");
    out << "VkPhysicalDeviceTexelBufferAlignmentProperties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkFormatProperties3(std::ostream &out, const VkFormatProperties3* structInfo, Decoded_VkFormatProperties3* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* linearTilingFeatures */
    structBody << "\t" << "VkFormatFeatureFlags2(" << structInfo->linearTilingFeatures << ")" << "," << std::endl;
/* optimalTilingFeatures */
    structBody << "\t" << "VkFormatFeatureFlags2(" << structInfo->optimalTilingFeatures << ")" << "," << std::endl;
/* bufferFeatures */
    structBody << "\t" << "VkFormatFeatureFlags2(" << structInfo->bufferFeatures << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "formatProperties3");
    out << "VkFormatProperties3 " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance4Features(std::ostream &out, const VkPhysicalDeviceMaintenance4Features* structInfo, Decoded_VkPhysicalDeviceMaintenance4Features* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maintenance4 */
    structBody << "\t" << structInfo->maintenance4 << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMaintenance4Features");
    out << "VkPhysicalDeviceMaintenance4Features " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance4Properties(std::ostream &out, const VkPhysicalDeviceMaintenance4Properties* structInfo, Decoded_VkPhysicalDeviceMaintenance4Properties* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxBufferSize */
    structBody << "\t" << structInfo->maxBufferSize << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMaintenance4Properties");
    out << "VkPhysicalDeviceMaintenance4Properties " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceBufferMemoryRequirements(std::ostream &out, const VkDeviceBufferMemoryRequirements* structInfo, Decoded_VkDeviceBufferMemoryRequirements* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pCreateInfoStruct = "NULL";
    if (structInfo->pCreateInfo != NULL) {
        pCreateInfoStruct = GenerateStruct_VkBufferCreateInfo(out,
                                                           structInfo->pCreateInfo,
                                                           metainfo->pCreateInfo->GetMetaStructPointer(),
                                                           consumer);
        pCreateInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pCreateInfo */
    structBody << "\t" << pCreateInfoStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceBufferMemoryRequirements");
    out << "VkDeviceBufferMemoryRequirements " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceImageMemoryRequirements(std::ostream &out, const VkDeviceImageMemoryRequirements* structInfo, Decoded_VkDeviceImageMemoryRequirements* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pCreateInfoStruct = "NULL";
    if (structInfo->pCreateInfo != NULL) {
        pCreateInfoStruct = GenerateStruct_VkImageCreateInfo(out,
                                                           structInfo->pCreateInfo,
                                                           metainfo->pCreateInfo->GetMetaStructPointer(),
                                                           consumer);
        pCreateInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pCreateInfo */
    structBody << "\t" << pCreateInfoStruct << "," << std::endl;
/* planeAspect */
    structBody << "\t" << "VkImageAspectFlagBits(" << structInfo->planeAspect << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceImageMemoryRequirements");
    out << "VkDeviceImageMemoryRequirements " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSurfaceCapabilitiesKHR(std::ostream &out, const VkSurfaceCapabilitiesKHR* structInfo, Decoded_VkSurfaceCapabilitiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string currentExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->currentExtent,
                                                                      metainfo->currentExtent,
                                                                      consumer);
    std::string minImageExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                       &structInfo->minImageExtent,
                                                                       metainfo->minImageExtent,
                                                                       consumer);
    std::string maxImageExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                       &structInfo->maxImageExtent,
                                                                       metainfo->maxImageExtent,
                                                                       consumer);
/* minImageCount */
    structBody << "\t" << structInfo->minImageCount << "," << std::endl;
/* maxImageCount */
    structBody << "\t" << structInfo->maxImageCount << "," << std::endl;
/* currentExtent */
    structBody << "\t" << currentExtentInfoVar << "," << std::endl;
/* minImageExtent */
    structBody << "\t" << minImageExtentInfoVar << "," << std::endl;
/* maxImageExtent */
    structBody << "\t" << maxImageExtentInfoVar << "," << std::endl;
/* maxImageArrayLayers */
    structBody << "\t" << structInfo->maxImageArrayLayers << "," << std::endl;
/* supportedTransforms */
    structBody << "\t" << "VkSurfaceTransformFlagsKHR(" << structInfo->supportedTransforms << ")" << "," << std::endl;
/* currentTransform */
    structBody << "\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->currentTransform << ")" << "," << std::endl;
/* supportedCompositeAlpha */
    structBody << "\t" << "VkCompositeAlphaFlagsKHR(" << structInfo->supportedCompositeAlpha << ")" << "," << std::endl;
/* supportedUsageFlags */
    structBody << "\t" << "VkImageUsageFlags(" << structInfo->supportedUsageFlags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "surfaceCapabilitiesKHR");
    out << "VkSurfaceCapabilitiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSurfaceFormatKHR(std::ostream &out, const VkSurfaceFormatKHR* structInfo, Decoded_VkSurfaceFormatKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
/* colorSpace */
    structBody << "\t" << "VkColorSpaceKHR(" << structInfo->colorSpace << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "surfaceFormatKHR");
    out << "VkSurfaceFormatKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSwapchainCreateInfoKHR(std::ostream &out, const VkSwapchainCreateInfoKHR* structInfo, Decoded_VkSwapchainCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string imageExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->imageExtent,
                                                                    metainfo->imageExtent,
                                                                    consumer);
    std::string pQueueFamilyIndicesArray = "NULL";
    if (structInfo->pQueueFamilyIndices != NULL) {
        pQueueFamilyIndicesArray = "pQueueFamilyIndices_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pQueueFamilyIndicesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pQueueFamilyIndices, structInfo->queueFamilyIndexCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkSwapchainCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* surface */
    structBody << "\t" << consumer.GetHandle(metainfo->surface) << "," << std::endl;
/* minImageCount */
    structBody << "\t" << structInfo->minImageCount << "," << std::endl;
/* imageFormat */
    structBody << "\t" << "VkFormat(" << structInfo->imageFormat << ")" << "," << std::endl;
/* imageColorSpace */
    structBody << "\t" << "VkColorSpaceKHR(" << structInfo->imageColorSpace << ")" << "," << std::endl;
/* imageExtent */
    structBody << "\t" << imageExtentInfoVar << "," << std::endl;
/* imageArrayLayers */
    structBody << "\t" << structInfo->imageArrayLayers << "," << std::endl;
/* imageUsage */
    structBody << "\t" << "VkImageUsageFlags(" << structInfo->imageUsage << ")" << "," << std::endl;
/* imageSharingMode */
    structBody << "\t" << "VkSharingMode(" << structInfo->imageSharingMode << ")" << "," << std::endl;
/* queueFamilyIndexCount */
    structBody << "\t" << structInfo->queueFamilyIndexCount << "," << std::endl;
/* pQueueFamilyIndices */
    structBody << "\t" << pQueueFamilyIndicesArray << "," << std::endl;
/* preTransform */
    structBody << "\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->preTransform << ")" << "," << std::endl;
/* compositeAlpha */
    structBody << "\t" << "VkCompositeAlphaFlagBitsKHR(" << structInfo->compositeAlpha << ")" << "," << std::endl;
/* presentMode */
    structBody << "\t" << "VkPresentModeKHR(" << structInfo->presentMode << ")" << "," << std::endl;
/* clipped */
    structBody << "\t" << structInfo->clipped << "," << std::endl;
/* oldSwapchain */
    structBody << "\t" << consumer.GetHandle(metainfo->oldSwapchain) << "," ;
    std::string varname = consumer.AddStruct(structBody, "swapchainCreateInfoKHR");
    out << "VkSwapchainCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageSwapchainCreateInfoKHR(std::ostream &out, const VkImageSwapchainCreateInfoKHR* structInfo, Decoded_VkImageSwapchainCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* swapchain */
    structBody << "\t" << consumer.GetHandle(metainfo->swapchain) << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageSwapchainCreateInfoKHR");
    out << "VkImageSwapchainCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBindImageMemorySwapchainInfoKHR(std::ostream &out, const VkBindImageMemorySwapchainInfoKHR* structInfo, Decoded_VkBindImageMemorySwapchainInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* swapchain */
    structBody << "\t" << consumer.GetHandle(metainfo->swapchain) << "," << std::endl;
/* imageIndex */
    structBody << "\t" << structInfo->imageIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "bindImageMemorySwapchainInfoKHR");
    out << "VkBindImageMemorySwapchainInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAcquireNextImageInfoKHR(std::ostream &out, const VkAcquireNextImageInfoKHR* structInfo, Decoded_VkAcquireNextImageInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* swapchain */
    structBody << "\t" << consumer.GetHandle(metainfo->swapchain) << "," << std::endl;
/* timeout */
    structBody << "\t" << structInfo->timeout << "UL" << "," << std::endl;
/* semaphore */
    structBody << "\t" << consumer.GetHandle(metainfo->semaphore) << "," << std::endl;
/* fence */
    structBody << "\t" << consumer.GetHandle(metainfo->fence) << "," << std::endl;
/* deviceMask */
    structBody << "\t" << structInfo->deviceMask << "," ;
    std::string varname = consumer.AddStruct(structBody, "acquireNextImageInfoKHR");
    out << "VkAcquireNextImageInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceGroupPresentCapabilitiesKHR(std::ostream &out, const VkDeviceGroupPresentCapabilitiesKHR* structInfo, Decoded_VkDeviceGroupPresentCapabilitiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* presentMask */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->presentMask[0]), VK_MAX_DEVICE_GROUP_SIZE) << "," << std::endl;
/* modes */
    structBody << "\t" << "VkDeviceGroupPresentModeFlagsKHR(" << structInfo->modes << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceGroupPresentCapabilitiesKHR");
    out << "VkDeviceGroupPresentCapabilitiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceGroupPresentInfoKHR(std::ostream &out, const VkDeviceGroupPresentInfoKHR* structInfo, Decoded_VkDeviceGroupPresentInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDeviceMasksArray = "NULL";
    if (structInfo->pDeviceMasks != NULL) {
        pDeviceMasksArray = "pDeviceMasks_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pDeviceMasksArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceMasks, structInfo->swapchainCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* swapchainCount */
    structBody << "\t" << structInfo->swapchainCount << "," << std::endl;
/* pDeviceMasks */
    structBody << "\t" << pDeviceMasksArray << "," << std::endl;
/* mode */
    structBody << "\t" << "VkDeviceGroupPresentModeFlagBitsKHR(" << structInfo->mode << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceGroupPresentInfoKHR");
    out << "VkDeviceGroupPresentInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceGroupSwapchainCreateInfoKHR(std::ostream &out, const VkDeviceGroupSwapchainCreateInfoKHR* structInfo, Decoded_VkDeviceGroupSwapchainCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* modes */
    structBody << "\t" << "VkDeviceGroupPresentModeFlagsKHR(" << structInfo->modes << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceGroupSwapchainCreateInfoKHR");
    out << "VkDeviceGroupSwapchainCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayModeParametersKHR(std::ostream &out, const VkDisplayModeParametersKHR* structInfo, Decoded_VkDisplayModeParametersKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string visibleRegionInfoVar = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->visibleRegion,
                                                                      metainfo->visibleRegion,
                                                                      consumer);
/* visibleRegion */
    structBody << "\t" << visibleRegionInfoVar << "," << std::endl;
/* refreshRate */
    structBody << "\t" << structInfo->refreshRate << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayModeParametersKHR");
    out << "VkDisplayModeParametersKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayModeCreateInfoKHR(std::ostream &out, const VkDisplayModeCreateInfoKHR* structInfo, Decoded_VkDisplayModeCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string parametersInfoVar = GenerateStruct_VkDisplayModeParametersKHR(out,
                                                                   &structInfo->parameters,
                                                                   metainfo->parameters,
                                                                   consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDisplayModeCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* parameters */
    structBody << "\t" << parametersInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayModeCreateInfoKHR");
    out << "VkDisplayModeCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayModePropertiesKHR(std::ostream &out, const VkDisplayModePropertiesKHR* structInfo, Decoded_VkDisplayModePropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string parametersInfoVar = GenerateStruct_VkDisplayModeParametersKHR(out,
                                                                   &structInfo->parameters,
                                                                   metainfo->parameters,
                                                                   consumer);
/* displayMode */
    structBody << "\t" << consumer.GetHandle(metainfo->displayMode) << "," << std::endl;
/* parameters */
    structBody << "\t" << parametersInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayModePropertiesKHR");
    out << "VkDisplayModePropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayPlaneCapabilitiesKHR(std::ostream &out, const VkDisplayPlaneCapabilitiesKHR* structInfo, Decoded_VkDisplayPlaneCapabilitiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string minSrcPositionInfoVar = GenerateStruct_VkOffset2D(out,
                                                                       &structInfo->minSrcPosition,
                                                                       metainfo->minSrcPosition,
                                                                       consumer);
    std::string maxSrcPositionInfoVar = GenerateStruct_VkOffset2D(out,
                                                                       &structInfo->maxSrcPosition,
                                                                       metainfo->maxSrcPosition,
                                                                       consumer);
    std::string minSrcExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                     &structInfo->minSrcExtent,
                                                                     metainfo->minSrcExtent,
                                                                     consumer);
    std::string maxSrcExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                     &structInfo->maxSrcExtent,
                                                                     metainfo->maxSrcExtent,
                                                                     consumer);
    std::string minDstPositionInfoVar = GenerateStruct_VkOffset2D(out,
                                                                       &structInfo->minDstPosition,
                                                                       metainfo->minDstPosition,
                                                                       consumer);
    std::string maxDstPositionInfoVar = GenerateStruct_VkOffset2D(out,
                                                                       &structInfo->maxDstPosition,
                                                                       metainfo->maxDstPosition,
                                                                       consumer);
    std::string minDstExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                     &structInfo->minDstExtent,
                                                                     metainfo->minDstExtent,
                                                                     consumer);
    std::string maxDstExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                     &structInfo->maxDstExtent,
                                                                     metainfo->maxDstExtent,
                                                                     consumer);
/* supportedAlpha */
    structBody << "\t" << "VkDisplayPlaneAlphaFlagsKHR(" << structInfo->supportedAlpha << ")" << "," << std::endl;
/* minSrcPosition */
    structBody << "\t" << minSrcPositionInfoVar << "," << std::endl;
/* maxSrcPosition */
    structBody << "\t" << maxSrcPositionInfoVar << "," << std::endl;
/* minSrcExtent */
    structBody << "\t" << minSrcExtentInfoVar << "," << std::endl;
/* maxSrcExtent */
    structBody << "\t" << maxSrcExtentInfoVar << "," << std::endl;
/* minDstPosition */
    structBody << "\t" << minDstPositionInfoVar << "," << std::endl;
/* maxDstPosition */
    structBody << "\t" << maxDstPositionInfoVar << "," << std::endl;
/* minDstExtent */
    structBody << "\t" << minDstExtentInfoVar << "," << std::endl;
/* maxDstExtent */
    structBody << "\t" << maxDstExtentInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayPlaneCapabilitiesKHR");
    out << "VkDisplayPlaneCapabilitiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayPlanePropertiesKHR(std::ostream &out, const VkDisplayPlanePropertiesKHR* structInfo, Decoded_VkDisplayPlanePropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* currentDisplay */
    structBody << "\t" << consumer.GetHandle(metainfo->currentDisplay) << "," << std::endl;
/* currentStackIndex */
    structBody << "\t" << structInfo->currentStackIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayPlanePropertiesKHR");
    out << "VkDisplayPlanePropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayPropertiesKHR(std::ostream &out, const VkDisplayPropertiesKHR* structInfo, Decoded_VkDisplayPropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string physicalDimensionsInfoVar = GenerateStruct_VkExtent2D(out,
                                                                           &structInfo->physicalDimensions,
                                                                           metainfo->physicalDimensions,
                                                                           consumer);
    std::string physicalResolutionInfoVar = GenerateStruct_VkExtent2D(out,
                                                                           &structInfo->physicalResolution,
                                                                           metainfo->physicalResolution,
                                                                           consumer);
/* display */
    structBody << "\t" << consumer.GetHandle(metainfo->display) << "," << std::endl;
/* displayName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->displayName) << "," << std::endl;
/* physicalDimensions */
    structBody << "\t" << physicalDimensionsInfoVar << "," << std::endl;
/* physicalResolution */
    structBody << "\t" << physicalResolutionInfoVar << "," << std::endl;
/* supportedTransforms */
    structBody << "\t" << "VkSurfaceTransformFlagsKHR(" << structInfo->supportedTransforms << ")" << "," << std::endl;
/* planeReorderPossible */
    structBody << "\t" << structInfo->planeReorderPossible << "," << std::endl;
/* persistentContent */
    structBody << "\t" << structInfo->persistentContent << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayPropertiesKHR");
    out << "VkDisplayPropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplaySurfaceCreateInfoKHR(std::ostream &out, const VkDisplaySurfaceCreateInfoKHR* structInfo, Decoded_VkDisplaySurfaceCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string imageExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->imageExtent,
                                                                    metainfo->imageExtent,
                                                                    consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDisplaySurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* displayMode */
    structBody << "\t" << consumer.GetHandle(metainfo->displayMode) << "," << std::endl;
/* planeIndex */
    structBody << "\t" << structInfo->planeIndex << "," << std::endl;
/* planeStackIndex */
    structBody << "\t" << structInfo->planeStackIndex << "," << std::endl;
/* transform */
    structBody << "\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->transform << ")" << "," << std::endl;
/* globalAlpha */
    structBody << "\t" << structInfo->globalAlpha << "," << std::endl;
/* alphaMode */
    structBody << "\t" << "VkDisplayPlaneAlphaFlagBitsKHR(" << structInfo->alphaMode << ")" << "," << std::endl;
/* imageExtent */
    structBody << "\t" << imageExtentInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "displaySurfaceCreateInfoKHR");
    out << "VkDisplaySurfaceCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayPresentInfoKHR(std::ostream &out, const VkDisplayPresentInfoKHR* structInfo, Decoded_VkDisplayPresentInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string srcRectInfoVar = GenerateStruct_VkRect2D(out,
                                                                &structInfo->srcRect,
                                                                metainfo->srcRect,
                                                                consumer);
    std::string dstRectInfoVar = GenerateStruct_VkRect2D(out,
                                                                &structInfo->dstRect,
                                                                metainfo->dstRect,
                                                                consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcRect */
    structBody << "\t" << srcRectInfoVar << "," << std::endl;
/* dstRect */
    structBody << "\t" << dstRectInfoVar << "," << std::endl;
/* persistent */
    structBody << "\t" << structInfo->persistent << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayPresentInfoKHR");
    out << "VkDisplayPresentInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkXlibSurfaceCreateInfoKHR(std::ostream &out, const VkXlibSurfaceCreateInfoKHR* structInfo, Decoded_VkXlibSurfaceCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkXlibSurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* dpy */
    structBody << "\t" << structInfo->dpy << "," << std::endl;
/* window */
    structBody << "\t" << structInfo->window << "," ;
    std::string varname = consumer.AddStruct(structBody, "xlibSurfaceCreateInfoKHR");
    out << "VkXlibSurfaceCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkXcbSurfaceCreateInfoKHR(std::ostream &out, const VkXcbSurfaceCreateInfoKHR* structInfo, Decoded_VkXcbSurfaceCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::string varname = "override_" + std::to_string(consumer.getNextId());
    out << "VkXcbSurfaceCreateInfoKHR " << varname << " {};" << std::endl;
    out << "OverrideVkXcbSurfaceCreateInfoKHR(&" << varname << ", " << "appdata" << ");" << std::endl;
    return varname;
}


std::string GenerateStruct_VkWaylandSurfaceCreateInfoKHR(std::ostream &out, const VkWaylandSurfaceCreateInfoKHR* structInfo, Decoded_VkWaylandSurfaceCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::string varname = "override_" + std::to_string(consumer.getNextId());
    out << "VkWaylandSurfaceCreateInfoKHR " << varname << " {};" << std::endl;
    out << "OverrideVkWaylandSurfaceCreateInfoKHR(&" << varname << ", " << "appdata" << ");" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAndroidSurfaceCreateInfoKHR(std::ostream &out, const VkAndroidSurfaceCreateInfoKHR* structInfo, Decoded_VkAndroidSurfaceCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::string varname = "override_" + std::to_string(consumer.getNextId());
    out << "VkAndroidSurfaceCreateInfoKHR " << varname << " {};" << std::endl;
    out << "OverrideVkAndroidSurfaceCreateInfoKHR(&" << varname << ", " << "appdata" << ");" << std::endl;
    return varname;
}


std::string GenerateStruct_VkWin32SurfaceCreateInfoKHR(std::ostream &out, const VkWin32SurfaceCreateInfoKHR* structInfo, Decoded_VkWin32SurfaceCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkWin32SurfaceCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* hinstance */
    structBody << "\t" << structInfo->hinstance << "," << std::endl;
/* hwnd */
    structBody << "\t" << structInfo->hwnd << "," ;
    std::string varname = consumer.AddStruct(structBody, "win32SurfaceCreateInfoKHR");
    out << "VkWin32SurfaceCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkQueueFamilyQueryResultStatusPropertiesKHR(std::ostream &out, const VkQueueFamilyQueryResultStatusPropertiesKHR* structInfo, Decoded_VkQueueFamilyQueryResultStatusPropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* queryResultStatusSupport */
    structBody << "\t" << structInfo->queryResultStatusSupport << "," ;
    std::string varname = consumer.AddStruct(structBody, "queueFamilyQueryResultStatusPropertiesKHR");
    out << "VkQueueFamilyQueryResultStatusPropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkQueueFamilyVideoPropertiesKHR(std::ostream &out, const VkQueueFamilyVideoPropertiesKHR* structInfo, Decoded_VkQueueFamilyVideoPropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* videoCodecOperations */
    structBody << "\t" << "VkVideoCodecOperationFlagsKHR(" << structInfo->videoCodecOperations << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "queueFamilyVideoPropertiesKHR");
    out << "VkQueueFamilyVideoPropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoProfileInfoKHR(std::ostream &out, const VkVideoProfileInfoKHR* structInfo, Decoded_VkVideoProfileInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* videoCodecOperation */
    structBody << "\t" << "VkVideoCodecOperationFlagBitsKHR(" << structInfo->videoCodecOperation << ")" << "," << std::endl;
/* chromaSubsampling */
    structBody << "\t" << "VkVideoChromaSubsamplingFlagsKHR(" << structInfo->chromaSubsampling << ")" << "," << std::endl;
/* lumaBitDepth */
    structBody << "\t" << "VkVideoComponentBitDepthFlagsKHR(" << structInfo->lumaBitDepth << ")" << "," << std::endl;
/* chromaBitDepth */
    structBody << "\t" << "VkVideoComponentBitDepthFlagsKHR(" << structInfo->chromaBitDepth << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoProfileInfoKHR");
    out << "VkVideoProfileInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoProfileListInfoKHR(std::ostream &out, const VkVideoProfileListInfoKHR* structInfo, Decoded_VkVideoProfileListInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pProfilesArray = "NULL";
    if (structInfo->pProfiles != NULL) {
        pProfilesArray = "pProfiles_" + std::to_string(consumer.getNextId());
        std::string pProfilesNames;
        for (uint32_t idx = 0; idx < structInfo->profileCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pProfiles + idx != NULL) {
                varName = GenerateStruct_VkVideoProfileInfoKHR(out,
                                                         structInfo->pProfiles + idx,
                                                         metainfo->pProfiles->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pProfilesNames += varName + ", ";
        }
        out << "VkVideoProfileInfoKHR " << pProfilesArray << "[] = {" << pProfilesNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* profileCount */
    structBody << "\t" << structInfo->profileCount << "," << std::endl;
/* pProfiles */
    structBody << "\t" << pProfilesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoProfileListInfoKHR");
    out << "VkVideoProfileListInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoCapabilitiesKHR(std::ostream &out, const VkVideoCapabilitiesKHR* structInfo, Decoded_VkVideoCapabilitiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pictureAccessGranularityInfoVar = GenerateStruct_VkExtent2D(out,
                                                                                 &structInfo->pictureAccessGranularity,
                                                                                 metainfo->pictureAccessGranularity,
                                                                                 consumer);
    std::string minCodedExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                       &structInfo->minCodedExtent,
                                                                       metainfo->minCodedExtent,
                                                                       consumer);
    std::string maxCodedExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                       &structInfo->maxCodedExtent,
                                                                       metainfo->maxCodedExtent,
                                                                       consumer);
    std::string stdHeaderVersionInfoVar = GenerateStruct_VkExtensionProperties(out,
                                                                         &structInfo->stdHeaderVersion,
                                                                         metainfo->stdHeaderVersion,
                                                                         consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoCapabilityFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* minBitstreamBufferOffsetAlignment */
    structBody << "\t" << structInfo->minBitstreamBufferOffsetAlignment << "UL" << "," << std::endl;
/* minBitstreamBufferSizeAlignment */
    structBody << "\t" << structInfo->minBitstreamBufferSizeAlignment << "UL" << "," << std::endl;
/* pictureAccessGranularity */
    structBody << "\t" << pictureAccessGranularityInfoVar << "," << std::endl;
/* minCodedExtent */
    structBody << "\t" << minCodedExtentInfoVar << "," << std::endl;
/* maxCodedExtent */
    structBody << "\t" << maxCodedExtentInfoVar << "," << std::endl;
/* maxDpbSlots */
    structBody << "\t" << structInfo->maxDpbSlots << "," << std::endl;
/* maxActiveReferencePictures */
    structBody << "\t" << structInfo->maxActiveReferencePictures << "," << std::endl;
/* stdHeaderVersion */
    structBody << "\t" << stdHeaderVersionInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoCapabilitiesKHR");
    out << "VkVideoCapabilitiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceVideoFormatInfoKHR(std::ostream &out, const VkPhysicalDeviceVideoFormatInfoKHR* structInfo, Decoded_VkPhysicalDeviceVideoFormatInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* imageUsage */
    structBody << "\t" << "VkImageUsageFlags(" << structInfo->imageUsage << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceVideoFormatInfoKHR");
    out << "VkPhysicalDeviceVideoFormatInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoFormatPropertiesKHR(std::ostream &out, const VkVideoFormatPropertiesKHR* structInfo, Decoded_VkVideoFormatPropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string componentMappingInfoVar = GenerateStruct_VkComponentMapping(out,
                                                                         &structInfo->componentMapping,
                                                                         metainfo->componentMapping,
                                                                         consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
/* componentMapping */
    structBody << "\t" << componentMappingInfoVar << "," << std::endl;
/* imageCreateFlags */
    structBody << "\t" << "VkImageCreateFlags(" << structInfo->imageCreateFlags << ")" << "," << std::endl;
/* imageType */
    structBody << "\t" << "VkImageType(" << structInfo->imageType << ")" << "," << std::endl;
/* imageTiling */
    structBody << "\t" << "VkImageTiling(" << structInfo->imageTiling << ")" << "," << std::endl;
/* imageUsageFlags */
    structBody << "\t" << "VkImageUsageFlags(" << structInfo->imageUsageFlags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoFormatPropertiesKHR");
    out << "VkVideoFormatPropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoPictureResourceInfoKHR(std::ostream &out, const VkVideoPictureResourceInfoKHR* structInfo, Decoded_VkVideoPictureResourceInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string codedOffsetInfoVar = GenerateStruct_VkOffset2D(out,
                                                                    &structInfo->codedOffset,
                                                                    metainfo->codedOffset,
                                                                    consumer);
    std::string codedExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                    &structInfo->codedExtent,
                                                                    metainfo->codedExtent,
                                                                    consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* codedOffset */
    structBody << "\t" << codedOffsetInfoVar << "," << std::endl;
/* codedExtent */
    structBody << "\t" << codedExtentInfoVar << "," << std::endl;
/* baseArrayLayer */
    structBody << "\t" << structInfo->baseArrayLayer << "," << std::endl;
/* imageViewBinding */
    structBody << "\t" << consumer.GetHandle(metainfo->imageViewBinding) << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoPictureResourceInfoKHR");
    out << "VkVideoPictureResourceInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoReferenceSlotInfoKHR(std::ostream &out, const VkVideoReferenceSlotInfoKHR* structInfo, Decoded_VkVideoReferenceSlotInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pPictureResourceStruct = "NULL";
    if (structInfo->pPictureResource != NULL) {
        pPictureResourceStruct = GenerateStruct_VkVideoPictureResourceInfoKHR(out,
                                                                structInfo->pPictureResource,
                                                                metainfo->pPictureResource->GetMetaStructPointer(),
                                                                consumer);
        pPictureResourceStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* slotIndex */
    structBody << "\t" << structInfo->slotIndex << "," << std::endl;
/* pPictureResource */
    structBody << "\t" << pPictureResourceStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoReferenceSlotInfoKHR");
    out << "VkVideoReferenceSlotInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoSessionMemoryRequirementsKHR(std::ostream &out, const VkVideoSessionMemoryRequirementsKHR* structInfo, Decoded_VkVideoSessionMemoryRequirementsKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string memoryRequirementsInfoVar = GenerateStruct_VkMemoryRequirements(out,
                                                                           &structInfo->memoryRequirements,
                                                                           metainfo->memoryRequirements,
                                                                           consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memoryBindIndex */
    structBody << "\t" << structInfo->memoryBindIndex << "," << std::endl;
/* memoryRequirements */
    structBody << "\t" << memoryRequirementsInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoSessionMemoryRequirementsKHR");
    out << "VkVideoSessionMemoryRequirementsKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBindVideoSessionMemoryInfoKHR(std::ostream &out, const VkBindVideoSessionMemoryInfoKHR* structInfo, Decoded_VkBindVideoSessionMemoryInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memoryBindIndex */
    structBody << "\t" << structInfo->memoryBindIndex << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," << std::endl;
/* memoryOffset */
    structBody << "\t" << structInfo->memoryOffset << "UL" << "," << std::endl;
/* memorySize */
    structBody << "\t" << structInfo->memorySize << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "bindVideoSessionMemoryInfoKHR");
    out << "VkBindVideoSessionMemoryInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoSessionCreateInfoKHR(std::ostream &out, const VkVideoSessionCreateInfoKHR* structInfo, Decoded_VkVideoSessionCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pVideoProfileStruct = "NULL";
    if (structInfo->pVideoProfile != NULL) {
        pVideoProfileStruct = GenerateStruct_VkVideoProfileInfoKHR(out,
                                                             structInfo->pVideoProfile,
                                                             metainfo->pVideoProfile->GetMetaStructPointer(),
                                                             consumer);
        pVideoProfileStruct.insert(0, "&");
    }
    std::string maxCodedExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                       &structInfo->maxCodedExtent,
                                                                       metainfo->maxCodedExtent,
                                                                       consumer);
    std::string pStdHeaderVersionStruct = "NULL";
    if (structInfo->pStdHeaderVersion != NULL) {
        pStdHeaderVersionStruct = GenerateStruct_VkExtensionProperties(out,
                                                                 structInfo->pStdHeaderVersion,
                                                                 metainfo->pStdHeaderVersion->GetMetaStructPointer(),
                                                                 consumer);
        pStdHeaderVersionStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* queueFamilyIndex */
    structBody << "\t" << structInfo->queueFamilyIndex << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoSessionCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* pVideoProfile */
    structBody << "\t" << pVideoProfileStruct << "," << std::endl;
/* pictureFormat */
    structBody << "\t" << "VkFormat(" << structInfo->pictureFormat << ")" << "," << std::endl;
/* maxCodedExtent */
    structBody << "\t" << maxCodedExtentInfoVar << "," << std::endl;
/* referencePictureFormat */
    structBody << "\t" << "VkFormat(" << structInfo->referencePictureFormat << ")" << "," << std::endl;
/* maxDpbSlots */
    structBody << "\t" << structInfo->maxDpbSlots << "," << std::endl;
/* maxActiveReferencePictures */
    structBody << "\t" << structInfo->maxActiveReferencePictures << "," << std::endl;
/* pStdHeaderVersion */
    structBody << "\t" << pStdHeaderVersionStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoSessionCreateInfoKHR");
    out << "VkVideoSessionCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoSessionParametersCreateInfoKHR(std::ostream &out, const VkVideoSessionParametersCreateInfoKHR* structInfo, Decoded_VkVideoSessionParametersCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoSessionParametersCreateFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* videoSessionParametersTemplate */
    structBody << "\t" << consumer.GetHandle(metainfo->videoSessionParametersTemplate) << "," << std::endl;
/* videoSession */
    structBody << "\t" << consumer.GetHandle(metainfo->videoSession) << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoSessionParametersCreateInfoKHR");
    out << "VkVideoSessionParametersCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoSessionParametersUpdateInfoKHR(std::ostream &out, const VkVideoSessionParametersUpdateInfoKHR* structInfo, Decoded_VkVideoSessionParametersUpdateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* updateSequenceCount */
    structBody << "\t" << structInfo->updateSequenceCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoSessionParametersUpdateInfoKHR");
    out << "VkVideoSessionParametersUpdateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoBeginCodingInfoKHR(std::ostream &out, const VkVideoBeginCodingInfoKHR* structInfo, Decoded_VkVideoBeginCodingInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pReferenceSlotsArray = "NULL";
    if (structInfo->pReferenceSlots != NULL) {
        pReferenceSlotsArray = "pReferenceSlots_" + std::to_string(consumer.getNextId());
        std::string pReferenceSlotsNames;
        for (uint32_t idx = 0; idx < structInfo->referenceSlotCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pReferenceSlots + idx != NULL) {
                varName = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                         structInfo->pReferenceSlots + idx,
                                                         metainfo->pReferenceSlots->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pReferenceSlotsNames += varName + ", ";
        }
        out << "VkVideoReferenceSlotInfoKHR " << pReferenceSlotsArray << "[] = {" << pReferenceSlotsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoBeginCodingFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* videoSession */
    structBody << "\t" << consumer.GetHandle(metainfo->videoSession) << "," << std::endl;
/* videoSessionParameters */
    structBody << "\t" << consumer.GetHandle(metainfo->videoSessionParameters) << "," << std::endl;
/* referenceSlotCount */
    structBody << "\t" << structInfo->referenceSlotCount << "," << std::endl;
/* pReferenceSlots */
    structBody << "\t" << pReferenceSlotsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoBeginCodingInfoKHR");
    out << "VkVideoBeginCodingInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEndCodingInfoKHR(std::ostream &out, const VkVideoEndCodingInfoKHR* structInfo, Decoded_VkVideoEndCodingInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoEndCodingFlagsKHR(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEndCodingInfoKHR");
    out << "VkVideoEndCodingInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoCodingControlInfoKHR(std::ostream &out, const VkVideoCodingControlInfoKHR* structInfo, Decoded_VkVideoCodingControlInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoCodingControlFlagsKHR(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoCodingControlInfoKHR");
    out << "VkVideoCodingControlInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeCapabilitiesKHR(std::ostream &out, const VkVideoDecodeCapabilitiesKHR* structInfo, Decoded_VkVideoDecodeCapabilitiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoDecodeCapabilityFlagsKHR(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeCapabilitiesKHR");
    out << "VkVideoDecodeCapabilitiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeUsageInfoKHR(std::ostream &out, const VkVideoDecodeUsageInfoKHR* structInfo, Decoded_VkVideoDecodeUsageInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* videoUsageHints */
    structBody << "\t" << "VkVideoDecodeUsageFlagsKHR(" << structInfo->videoUsageHints << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeUsageInfoKHR");
    out << "VkVideoDecodeUsageInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeInfoKHR(std::ostream &out, const VkVideoDecodeInfoKHR* structInfo, Decoded_VkVideoDecodeInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string dstPictureResourceInfoVar = GenerateStruct_VkVideoPictureResourceInfoKHR(out,
                                                                           &structInfo->dstPictureResource,
                                                                           metainfo->dstPictureResource,
                                                                           consumer);
    std::string pSetupReferenceSlotStruct = "NULL";
    if (structInfo->pSetupReferenceSlot != NULL) {
        pSetupReferenceSlotStruct = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                                   structInfo->pSetupReferenceSlot,
                                                                   metainfo->pSetupReferenceSlot->GetMetaStructPointer(),
                                                                   consumer);
        pSetupReferenceSlotStruct.insert(0, "&");
    }
    std::string pReferenceSlotsArray = "NULL";
    if (structInfo->pReferenceSlots != NULL) {
        pReferenceSlotsArray = "pReferenceSlots_" + std::to_string(consumer.getNextId());
        std::string pReferenceSlotsNames;
        for (uint32_t idx = 0; idx < structInfo->referenceSlotCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pReferenceSlots + idx != NULL) {
                varName = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                         structInfo->pReferenceSlots + idx,
                                                         metainfo->pReferenceSlots->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pReferenceSlotsNames += varName + ", ";
        }
        out << "VkVideoReferenceSlotInfoKHR " << pReferenceSlotsArray << "[] = {" << pReferenceSlotsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoDecodeFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* srcBuffer */
    structBody << "\t" << consumer.GetHandle(metainfo->srcBuffer) << "," << std::endl;
/* srcBufferOffset */
    structBody << "\t" << structInfo->srcBufferOffset << "UL" << "," << std::endl;
/* srcBufferRange */
    structBody << "\t" << structInfo->srcBufferRange << "UL" << "," << std::endl;
/* dstPictureResource */
    structBody << "\t" << dstPictureResourceInfoVar << "," << std::endl;
/* pSetupReferenceSlot */
    structBody << "\t" << pSetupReferenceSlotStruct << "," << std::endl;
/* referenceSlotCount */
    structBody << "\t" << structInfo->referenceSlotCount << "," << std::endl;
/* pReferenceSlots */
    structBody << "\t" << pReferenceSlotsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeInfoKHR");
    out << "VkVideoDecodeInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeH264ProfileInfoKHR(std::ostream &out, const VkVideoDecodeH264ProfileInfoKHR* structInfo, Decoded_VkVideoDecodeH264ProfileInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stdProfileIdc */
    structBody << "\t" << "StdVideoH264ProfileIdc(" << structInfo->stdProfileIdc << ")" << "," << std::endl;
/* pictureLayout */
    structBody << "\t" << "VkVideoDecodeH264PictureLayoutFlagBitsKHR(" << structInfo->pictureLayout << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeH264ProfileInfoKHR");
    out << "VkVideoDecodeH264ProfileInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeH264CapabilitiesKHR(std::ostream &out, const VkVideoDecodeH264CapabilitiesKHR* structInfo, Decoded_VkVideoDecodeH264CapabilitiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string fieldOffsetGranularityInfoVar = GenerateStruct_VkOffset2D(out,
                                                                               &structInfo->fieldOffsetGranularity,
                                                                               metainfo->fieldOffsetGranularity,
                                                                               consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxLevelIdc */
    structBody << "\t" << "StdVideoH264LevelIdc(" << structInfo->maxLevelIdc << ")" << "," << std::endl;
/* fieldOffsetGranularity */
    structBody << "\t" << fieldOffsetGranularityInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeH264CapabilitiesKHR");
    out << "VkVideoDecodeH264CapabilitiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeH264SessionParametersAddInfoKHR(std::ostream &out, const VkVideoDecodeH264SessionParametersAddInfoKHR* structInfo, Decoded_VkVideoDecodeH264SessionParametersAddInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStdSPSsArray = "NULL";
    if (structInfo->pStdSPSs != NULL) {
        pStdSPSsArray = "pStdSPSs_" + std::to_string(consumer.getNextId());
        std::string pStdSPSsNames;
        for (uint32_t idx = 0; idx < structInfo->stdSPSCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStdSPSs + idx != NULL) {
                varName = GenerateStruct_StdVideoH264SequenceParameterSet(out,
                                                         structInfo->pStdSPSs + idx,
                                                         metainfo->pStdSPSs->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStdSPSsNames += varName + ", ";
        }
        out << "StdVideoH264SequenceParameterSet " << pStdSPSsArray << "[] = {" << pStdSPSsNames << "};" << std::endl;
    }
    std::string pStdPPSsArray = "NULL";
    if (structInfo->pStdPPSs != NULL) {
        pStdPPSsArray = "pStdPPSs_" + std::to_string(consumer.getNextId());
        std::string pStdPPSsNames;
        for (uint32_t idx = 0; idx < structInfo->stdPPSCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStdPPSs + idx != NULL) {
                varName = GenerateStruct_StdVideoH264PictureParameterSet(out,
                                                         structInfo->pStdPPSs + idx,
                                                         metainfo->pStdPPSs->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStdPPSsNames += varName + ", ";
        }
        out << "StdVideoH264PictureParameterSet " << pStdPPSsArray << "[] = {" << pStdPPSsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stdSPSCount */
    structBody << "\t" << structInfo->stdSPSCount << "," << std::endl;
/* pStdSPSs */
    structBody << "\t" << pStdSPSsArray << "," << std::endl;
/* stdPPSCount */
    structBody << "\t" << structInfo->stdPPSCount << "," << std::endl;
/* pStdPPSs */
    structBody << "\t" << pStdPPSsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeH264SessionParametersAddInfoKHR");
    out << "VkVideoDecodeH264SessionParametersAddInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeH264SessionParametersCreateInfoKHR(std::ostream &out, const VkVideoDecodeH264SessionParametersCreateInfoKHR* structInfo, Decoded_VkVideoDecodeH264SessionParametersCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pParametersAddInfoStruct = "NULL";
    if (structInfo->pParametersAddInfo != NULL) {
        pParametersAddInfoStruct = GenerateStruct_VkVideoDecodeH264SessionParametersAddInfoKHR(out,
                                                                  structInfo->pParametersAddInfo,
                                                                  metainfo->pParametersAddInfo->GetMetaStructPointer(),
                                                                  consumer);
        pParametersAddInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxStdSPSCount */
    structBody << "\t" << structInfo->maxStdSPSCount << "," << std::endl;
/* maxStdPPSCount */
    structBody << "\t" << structInfo->maxStdPPSCount << "," << std::endl;
/* pParametersAddInfo */
    structBody << "\t" << pParametersAddInfoStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeH264SessionParametersCreateInfoKHR");
    out << "VkVideoDecodeH264SessionParametersCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeH264PictureInfoKHR(std::ostream &out, const VkVideoDecodeH264PictureInfoKHR* structInfo, Decoded_VkVideoDecodeH264PictureInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStdPictureInfoStruct = "NULL";
    if (structInfo->pStdPictureInfo != NULL) {
        pStdPictureInfoStruct = GenerateStruct_StdVideoDecodeH264PictureInfo(out,
                                                               structInfo->pStdPictureInfo,
                                                               metainfo->pStdPictureInfo->GetMetaStructPointer(),
                                                               consumer);
        pStdPictureInfoStruct.insert(0, "&");
    }
    std::string pSliceOffsetsArray = "NULL";
    if (structInfo->pSliceOffsets != NULL) {
        pSliceOffsetsArray = "pSliceOffsets_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pSliceOffsetsArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pSliceOffsets, structInfo->sliceCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pStdPictureInfo */
    structBody << "\t" << pStdPictureInfoStruct << "," << std::endl;
/* sliceCount */
    structBody << "\t" << structInfo->sliceCount << "," << std::endl;
/* pSliceOffsets */
    structBody << "\t" << pSliceOffsetsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeH264PictureInfoKHR");
    out << "VkVideoDecodeH264PictureInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeH264DpbSlotInfoKHR(std::ostream &out, const VkVideoDecodeH264DpbSlotInfoKHR* structInfo, Decoded_VkVideoDecodeH264DpbSlotInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStdReferenceInfoStruct = "NULL";
    if (structInfo->pStdReferenceInfo != NULL) {
        pStdReferenceInfoStruct = GenerateStruct_StdVideoDecodeH264ReferenceInfo(out,
                                                                 structInfo->pStdReferenceInfo,
                                                                 metainfo->pStdReferenceInfo->GetMetaStructPointer(),
                                                                 consumer);
        pStdReferenceInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pStdReferenceInfo */
    structBody << "\t" << pStdReferenceInfoStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeH264DpbSlotInfoKHR");
    out << "VkVideoDecodeH264DpbSlotInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderingFragmentShadingRateAttachmentInfoKHR(std::ostream &out, const VkRenderingFragmentShadingRateAttachmentInfoKHR* structInfo, Decoded_VkRenderingFragmentShadingRateAttachmentInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string shadingRateAttachmentTexelSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                                       &structInfo->shadingRateAttachmentTexelSize,
                                                                                       metainfo->shadingRateAttachmentTexelSize,
                                                                                       consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* imageView */
    structBody << "\t" << consumer.GetHandle(metainfo->imageView) << "," << std::endl;
/* imageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->imageLayout << ")" << "," << std::endl;
/* shadingRateAttachmentTexelSize */
    structBody << "\t" << shadingRateAttachmentTexelSizeInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderingFragmentShadingRateAttachmentInfoKHR");
    out << "VkRenderingFragmentShadingRateAttachmentInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderingFragmentDensityMapAttachmentInfoEXT(std::ostream &out, const VkRenderingFragmentDensityMapAttachmentInfoEXT* structInfo, Decoded_VkRenderingFragmentDensityMapAttachmentInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* imageView */
    structBody << "\t" << consumer.GetHandle(metainfo->imageView) << "," << std::endl;
/* imageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->imageLayout << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderingFragmentDensityMapAttachmentInfoEXT");
    out << "VkRenderingFragmentDensityMapAttachmentInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAttachmentSampleCountInfoAMD(std::ostream &out, const VkAttachmentSampleCountInfoAMD* structInfo, Decoded_VkAttachmentSampleCountInfoAMD* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pColorAttachmentSamplesValues;
    std::string pColorAttachmentSamplesArray = "NULL";
    if (structInfo->pColorAttachmentSamples != NULL) {
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            pColorAttachmentSamplesValues += util::ToString<VkSampleCountFlagBits>(structInfo->pColorAttachmentSamples[idx]) + ", ";
        }
        pColorAttachmentSamplesArray = "pColorAttachmentSamples_" + std::to_string(consumer.getNextId());
        out << "VkSampleCountFlagBits " << pColorAttachmentSamplesArray << "[] = {" << pColorAttachmentSamplesValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* colorAttachmentCount */
    structBody << "\t" << structInfo->colorAttachmentCount << "," << std::endl;
/* pColorAttachmentSamples */
    structBody << "\t" << pColorAttachmentSamplesArray << "," << std::endl;
/* depthStencilAttachmentSamples */
    structBody << "\t" << "VkSampleCountFlagBits(" << structInfo->depthStencilAttachmentSamples << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "attachmentSampleCountInfoAMD");
    out << "VkAttachmentSampleCountInfoAMD " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMultiviewPerViewAttributesInfoNVX(std::ostream &out, const VkMultiviewPerViewAttributesInfoNVX* structInfo, Decoded_VkMultiviewPerViewAttributesInfoNVX* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* perViewAttributes */
    structBody << "\t" << structInfo->perViewAttributes << "," << std::endl;
/* perViewAttributesPositionXOnly */
    structBody << "\t" << structInfo->perViewAttributesPositionXOnly << "," ;
    std::string varname = consumer.AddStruct(structBody, "multiviewPerViewAttributesInfoNVX");
    out << "VkMultiviewPerViewAttributesInfoNVX " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImportMemoryWin32HandleInfoKHR(std::ostream &out, const VkImportMemoryWin32HandleInfoKHR* structInfo, Decoded_VkImportMemoryWin32HandleInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
/* handle */
    structBody << "\t" << structInfo->handle << "," << std::endl;
/* name */
    structBody << "\t" << structInfo->name << "," ;
    std::string varname = consumer.AddStruct(structBody, "importMemoryWin32HandleInfoKHR");
    out << "VkImportMemoryWin32HandleInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExportMemoryWin32HandleInfoKHR(std::ostream &out, const VkExportMemoryWin32HandleInfoKHR* structInfo, Decoded_VkExportMemoryWin32HandleInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pAttributes */
    structBody << "\t" << structInfo->pAttributes << "," << std::endl;
/* dwAccess */
    structBody << "\t" << structInfo->dwAccess << "," << std::endl;
/* name */
    structBody << "\t" << structInfo->name << "," ;
    std::string varname = consumer.AddStruct(structBody, "exportMemoryWin32HandleInfoKHR");
    out << "VkExportMemoryWin32HandleInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryWin32HandlePropertiesKHR(std::ostream &out, const VkMemoryWin32HandlePropertiesKHR* structInfo, Decoded_VkMemoryWin32HandlePropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memoryTypeBits */
    structBody << "\t" << structInfo->memoryTypeBits << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryWin32HandlePropertiesKHR");
    out << "VkMemoryWin32HandlePropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryGetWin32HandleInfoKHR(std::ostream &out, const VkMemoryGetWin32HandleInfoKHR* structInfo, Decoded_VkMemoryGetWin32HandleInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryGetWin32HandleInfoKHR");
    out << "VkMemoryGetWin32HandleInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImportMemoryFdInfoKHR(std::ostream &out, const VkImportMemoryFdInfoKHR* structInfo, Decoded_VkImportMemoryFdInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
/* fd */
    structBody << "\t" << structInfo->fd << "," ;
    std::string varname = consumer.AddStruct(structBody, "importMemoryFdInfoKHR");
    out << "VkImportMemoryFdInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryFdPropertiesKHR(std::ostream &out, const VkMemoryFdPropertiesKHR* structInfo, Decoded_VkMemoryFdPropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memoryTypeBits */
    structBody << "\t" << structInfo->memoryTypeBits << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryFdPropertiesKHR");
    out << "VkMemoryFdPropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryGetFdInfoKHR(std::ostream &out, const VkMemoryGetFdInfoKHR* structInfo, Decoded_VkMemoryGetFdInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryGetFdInfoKHR");
    out << "VkMemoryGetFdInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkWin32KeyedMutexAcquireReleaseInfoKHR(std::ostream &out, const VkWin32KeyedMutexAcquireReleaseInfoKHR* structInfo, Decoded_VkWin32KeyedMutexAcquireReleaseInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pAcquireSyncsArray = "NULL";
    if (metainfo->pAcquireSyncs.GetPointer() != NULL && structInfo->acquireCount > 0) {
        pAcquireSyncsArray = "pAcquireSyncsArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_DEVICE_MEMORY));
        std::string pAcquireSyncsValues = toStringJoin(metainfo->pAcquireSyncs.GetPointer(),
                                                       metainfo->pAcquireSyncs.GetPointer() + structInfo->acquireCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->acquireCount == 1) {
            pAcquireSyncsArray = "&" + pAcquireSyncsValues;
        } else if (structInfo->acquireCount > 1) {
            out << "VkDeviceMemory " << pAcquireSyncsArray << "[] = {" << pAcquireSyncsValues << "};" << std::endl;
        }
    }
    std::string pAcquireKeysArray = "pAcquireKeysArray_" + std::to_string(consumer.getNextId());
    if (structInfo->acquireCount > 0) {
        std::string pAcquireKeysValues = toStringJoin(structInfo->pAcquireKeys,
                                                      structInfo->pAcquireKeys + structInfo->acquireCount,
                                                      [](uint64_t current) { return std::to_string(current); },
                                                      ", ");
        if (structInfo->acquireCount == 1) {
            pAcquireKeysArray = "&" + pAcquireKeysValues;
        } else if (structInfo->acquireCount > 1) {
            out << "uint64_t " << pAcquireKeysArray << "[] = {" << pAcquireKeysValues << "};" << std::endl;
        }
    }
    std::string pAcquireTimeoutsArray = "NULL";
    if (structInfo->pAcquireTimeouts != NULL) {
        pAcquireTimeoutsArray = "pAcquireTimeouts_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pAcquireTimeoutsArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pAcquireTimeouts, structInfo->acquireCount) << ";" << std::endl;
    }
    std::string pReleaseSyncsArray = "NULL";
    if (metainfo->pReleaseSyncs.GetPointer() != NULL && structInfo->releaseCount > 0) {
        pReleaseSyncsArray = "pReleaseSyncsArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_DEVICE_MEMORY));
        std::string pReleaseSyncsValues = toStringJoin(metainfo->pReleaseSyncs.GetPointer(),
                                                       metainfo->pReleaseSyncs.GetPointer() + structInfo->releaseCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->releaseCount == 1) {
            pReleaseSyncsArray = "&" + pReleaseSyncsValues;
        } else if (structInfo->releaseCount > 1) {
            out << "VkDeviceMemory " << pReleaseSyncsArray << "[] = {" << pReleaseSyncsValues << "};" << std::endl;
        }
    }
    std::string pReleaseKeysArray = "pReleaseKeysArray_" + std::to_string(consumer.getNextId());
    if (structInfo->releaseCount > 0) {
        std::string pReleaseKeysValues = toStringJoin(structInfo->pReleaseKeys,
                                                      structInfo->pReleaseKeys + structInfo->releaseCount,
                                                      [](uint64_t current) { return std::to_string(current); },
                                                      ", ");
        if (structInfo->releaseCount == 1) {
            pReleaseKeysArray = "&" + pReleaseKeysValues;
        } else if (structInfo->releaseCount > 1) {
            out << "uint64_t " << pReleaseKeysArray << "[] = {" << pReleaseKeysValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* acquireCount */
    structBody << "\t" << structInfo->acquireCount << "," << std::endl;
/* pAcquireSyncs */
    structBody << "\t" << pAcquireSyncsArray << "," << std::endl;
/* pAcquireKeys */
    structBody << "\t" << "{ *" << pAcquireKeysArray << " }" << "," << std::endl;
/* pAcquireTimeouts */
    structBody << "\t" << pAcquireTimeoutsArray << "," << std::endl;
/* releaseCount */
    structBody << "\t" << structInfo->releaseCount << "," << std::endl;
/* pReleaseSyncs */
    structBody << "\t" << pReleaseSyncsArray << "," << std::endl;
/* pReleaseKeys */
    structBody << "\t" << "{ *" << pReleaseKeysArray << " }" << "," ;
    std::string varname = consumer.AddStruct(structBody, "win32KeyedMutexAcquireReleaseInfoKHR");
    out << "VkWin32KeyedMutexAcquireReleaseInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImportSemaphoreWin32HandleInfoKHR(std::ostream &out, const VkImportSemaphoreWin32HandleInfoKHR* structInfo, Decoded_VkImportSemaphoreWin32HandleInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* semaphore */
    structBody << "\t" << consumer.GetHandle(metainfo->semaphore) << "," << std::endl;
/* flags */
    structBody << "\t" << "VkSemaphoreImportFlags(" << structInfo->flags << ")" << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
/* handle */
    structBody << "\t" << structInfo->handle << "," << std::endl;
/* name */
    structBody << "\t" << structInfo->name << "," ;
    std::string varname = consumer.AddStruct(structBody, "importSemaphoreWin32HandleInfoKHR");
    out << "VkImportSemaphoreWin32HandleInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExportSemaphoreWin32HandleInfoKHR(std::ostream &out, const VkExportSemaphoreWin32HandleInfoKHR* structInfo, Decoded_VkExportSemaphoreWin32HandleInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pAttributes */
    structBody << "\t" << structInfo->pAttributes << "," << std::endl;
/* dwAccess */
    structBody << "\t" << structInfo->dwAccess << "," << std::endl;
/* name */
    structBody << "\t" << structInfo->name << "," ;
    std::string varname = consumer.AddStruct(structBody, "exportSemaphoreWin32HandleInfoKHR");
    out << "VkExportSemaphoreWin32HandleInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkD3D12FenceSubmitInfoKHR(std::ostream &out, const VkD3D12FenceSubmitInfoKHR* structInfo, Decoded_VkD3D12FenceSubmitInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pWaitSemaphoreValuesArray = "pWaitSemaphoreValuesArray_" + std::to_string(consumer.getNextId());
    if (structInfo->waitSemaphoreValuesCount > 0) {
        std::string pWaitSemaphoreValuesValues = toStringJoin(structInfo->pWaitSemaphoreValues,
                                                              structInfo->pWaitSemaphoreValues + structInfo->waitSemaphoreValuesCount,
                                                              [](uint64_t current) { return std::to_string(current); },
                                                              ", ");
        if (structInfo->waitSemaphoreValuesCount == 1) {
            pWaitSemaphoreValuesArray = "&" + pWaitSemaphoreValuesValues;
        } else if (structInfo->waitSemaphoreValuesCount > 1) {
            out << "uint64_t " << pWaitSemaphoreValuesArray << "[] = {" << pWaitSemaphoreValuesValues << "};" << std::endl;
        }
    }
    std::string pSignalSemaphoreValuesArray = "pSignalSemaphoreValuesArray_" + std::to_string(consumer.getNextId());
    if (structInfo->signalSemaphoreValuesCount > 0) {
        std::string pSignalSemaphoreValuesValues = toStringJoin(structInfo->pSignalSemaphoreValues,
                                                                structInfo->pSignalSemaphoreValues + structInfo->signalSemaphoreValuesCount,
                                                                [](uint64_t current) { return std::to_string(current); },
                                                                ", ");
        if (structInfo->signalSemaphoreValuesCount == 1) {
            pSignalSemaphoreValuesArray = "&" + pSignalSemaphoreValuesValues;
        } else if (structInfo->signalSemaphoreValuesCount > 1) {
            out << "uint64_t " << pSignalSemaphoreValuesArray << "[] = {" << pSignalSemaphoreValuesValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* waitSemaphoreValuesCount */
    structBody << "\t" << structInfo->waitSemaphoreValuesCount << "," << std::endl;
/* pWaitSemaphoreValues */
    structBody << "\t" << "{ *" << pWaitSemaphoreValuesArray << " }" << "," << std::endl;
/* signalSemaphoreValuesCount */
    structBody << "\t" << structInfo->signalSemaphoreValuesCount << "," << std::endl;
/* pSignalSemaphoreValues */
    structBody << "\t" << "{ *" << pSignalSemaphoreValuesArray << " }" << "," ;
    std::string varname = consumer.AddStruct(structBody, "d3D12FenceSubmitInfoKHR");
    out << "VkD3D12FenceSubmitInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSemaphoreGetWin32HandleInfoKHR(std::ostream &out, const VkSemaphoreGetWin32HandleInfoKHR* structInfo, Decoded_VkSemaphoreGetWin32HandleInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* semaphore */
    structBody << "\t" << consumer.GetHandle(metainfo->semaphore) << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "semaphoreGetWin32HandleInfoKHR");
    out << "VkSemaphoreGetWin32HandleInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImportSemaphoreFdInfoKHR(std::ostream &out, const VkImportSemaphoreFdInfoKHR* structInfo, Decoded_VkImportSemaphoreFdInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* semaphore */
    structBody << "\t" << consumer.GetHandle(metainfo->semaphore) << "," << std::endl;
/* flags */
    structBody << "\t" << "VkSemaphoreImportFlags(" << structInfo->flags << ")" << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
/* fd */
    structBody << "\t" << structInfo->fd << "," ;
    std::string varname = consumer.AddStruct(structBody, "importSemaphoreFdInfoKHR");
    out << "VkImportSemaphoreFdInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSemaphoreGetFdInfoKHR(std::ostream &out, const VkSemaphoreGetFdInfoKHR* structInfo, Decoded_VkSemaphoreGetFdInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* semaphore */
    structBody << "\t" << consumer.GetHandle(metainfo->semaphore) << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "semaphoreGetFdInfoKHR");
    out << "VkSemaphoreGetFdInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePushDescriptorPropertiesKHR(std::ostream &out, const VkPhysicalDevicePushDescriptorPropertiesKHR* structInfo, Decoded_VkPhysicalDevicePushDescriptorPropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxPushDescriptors */
    structBody << "\t" << structInfo->maxPushDescriptors << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePushDescriptorPropertiesKHR");
    out << "VkPhysicalDevicePushDescriptorPropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRectLayerKHR(std::ostream &out, const VkRectLayerKHR* structInfo, Decoded_VkRectLayerKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string offsetInfoVar = GenerateStruct_VkOffset2D(out,
                                                               &structInfo->offset,
                                                               metainfo->offset,
                                                               consumer);
    std::string extentInfoVar = GenerateStruct_VkExtent2D(out,
                                                               &structInfo->extent,
                                                               metainfo->extent,
                                                               consumer);
/* offset */
    structBody << "\t" << offsetInfoVar << "," << std::endl;
/* extent */
    structBody << "\t" << extentInfoVar << "," << std::endl;
/* layer */
    structBody << "\t" << structInfo->layer << "," ;
    std::string varname = consumer.AddStruct(structBody, "rectLayerKHR");
    out << "VkRectLayerKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPresentRegionKHR(std::ostream &out, const VkPresentRegionKHR* structInfo, Decoded_VkPresentRegionKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pRectanglesArray = "NULL";
    if (structInfo->pRectangles != NULL) {
        pRectanglesArray = "pRectangles_" + std::to_string(consumer.getNextId());
        std::string pRectanglesNames;
        for (uint32_t idx = 0; idx < structInfo->rectangleCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pRectangles + idx != NULL) {
                varName = GenerateStruct_VkRectLayerKHR(out,
                                                         structInfo->pRectangles + idx,
                                                         metainfo->pRectangles->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pRectanglesNames += varName + ", ";
        }
        out << "VkRectLayerKHR " << pRectanglesArray << "[] = {" << pRectanglesNames << "};" << std::endl;
    }
/* rectangleCount */
    structBody << "\t" << structInfo->rectangleCount << "," << std::endl;
/* pRectangles */
    structBody << "\t" << pRectanglesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "presentRegionKHR");
    out << "VkPresentRegionKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPresentRegionsKHR(std::ostream &out, const VkPresentRegionsKHR* structInfo, Decoded_VkPresentRegionsKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pRegionsArray = "NULL";
    if (structInfo->pRegions != NULL) {
        pRegionsArray = "pRegions_" + std::to_string(consumer.getNextId());
        std::string pRegionsNames;
        for (uint32_t idx = 0; idx < structInfo->swapchainCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                varName = GenerateStruct_VkPresentRegionKHR(out,
                                                         structInfo->pRegions + idx,
                                                         metainfo->pRegions->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pRegionsNames += varName + ", ";
        }
        out << "VkPresentRegionKHR " << pRegionsArray << "[] = {" << pRegionsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* swapchainCount */
    structBody << "\t" << structInfo->swapchainCount << "," << std::endl;
/* pRegions */
    structBody << "\t" << pRegionsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "presentRegionsKHR");
    out << "VkPresentRegionsKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSharedPresentSurfaceCapabilitiesKHR(std::ostream &out, const VkSharedPresentSurfaceCapabilitiesKHR* structInfo, Decoded_VkSharedPresentSurfaceCapabilitiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* sharedPresentSupportedUsageFlags */
    structBody << "\t" << "VkImageUsageFlags(" << structInfo->sharedPresentSupportedUsageFlags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "sharedPresentSurfaceCapabilitiesKHR");
    out << "VkSharedPresentSurfaceCapabilitiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImportFenceWin32HandleInfoKHR(std::ostream &out, const VkImportFenceWin32HandleInfoKHR* structInfo, Decoded_VkImportFenceWin32HandleInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fence */
    structBody << "\t" << consumer.GetHandle(metainfo->fence) << "," << std::endl;
/* flags */
    structBody << "\t" << "VkFenceImportFlags(" << structInfo->flags << ")" << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
/* handle */
    structBody << "\t" << structInfo->handle << "," << std::endl;
/* name */
    structBody << "\t" << structInfo->name << "," ;
    std::string varname = consumer.AddStruct(structBody, "importFenceWin32HandleInfoKHR");
    out << "VkImportFenceWin32HandleInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExportFenceWin32HandleInfoKHR(std::ostream &out, const VkExportFenceWin32HandleInfoKHR* structInfo, Decoded_VkExportFenceWin32HandleInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pAttributes */
    structBody << "\t" << structInfo->pAttributes << "," << std::endl;
/* dwAccess */
    structBody << "\t" << structInfo->dwAccess << "," << std::endl;
/* name */
    structBody << "\t" << structInfo->name << "," ;
    std::string varname = consumer.AddStruct(structBody, "exportFenceWin32HandleInfoKHR");
    out << "VkExportFenceWin32HandleInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkFenceGetWin32HandleInfoKHR(std::ostream &out, const VkFenceGetWin32HandleInfoKHR* structInfo, Decoded_VkFenceGetWin32HandleInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fence */
    structBody << "\t" << consumer.GetHandle(metainfo->fence) << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "fenceGetWin32HandleInfoKHR");
    out << "VkFenceGetWin32HandleInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImportFenceFdInfoKHR(std::ostream &out, const VkImportFenceFdInfoKHR* structInfo, Decoded_VkImportFenceFdInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fence */
    structBody << "\t" << consumer.GetHandle(metainfo->fence) << "," << std::endl;
/* flags */
    structBody << "\t" << "VkFenceImportFlags(" << structInfo->flags << ")" << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
/* fd */
    structBody << "\t" << structInfo->fd << "," ;
    std::string varname = consumer.AddStruct(structBody, "importFenceFdInfoKHR");
    out << "VkImportFenceFdInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkFenceGetFdInfoKHR(std::ostream &out, const VkFenceGetFdInfoKHR* structInfo, Decoded_VkFenceGetFdInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fence */
    structBody << "\t" << consumer.GetHandle(metainfo->fence) << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalFenceHandleTypeFlagBits(" << structInfo->handleType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "fenceGetFdInfoKHR");
    out << "VkFenceGetFdInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePerformanceQueryFeaturesKHR(std::ostream &out, const VkPhysicalDevicePerformanceQueryFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePerformanceQueryFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* performanceCounterQueryPools */
    structBody << "\t" << structInfo->performanceCounterQueryPools << "," << std::endl;
/* performanceCounterMultipleQueryPools */
    structBody << "\t" << structInfo->performanceCounterMultipleQueryPools << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePerformanceQueryFeaturesKHR");
    out << "VkPhysicalDevicePerformanceQueryFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePerformanceQueryPropertiesKHR(std::ostream &out, const VkPhysicalDevicePerformanceQueryPropertiesKHR* structInfo, Decoded_VkPhysicalDevicePerformanceQueryPropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* allowCommandBufferQueryCopies */
    structBody << "\t" << structInfo->allowCommandBufferQueryCopies << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePerformanceQueryPropertiesKHR");
    out << "VkPhysicalDevicePerformanceQueryPropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPerformanceCounterKHR(std::ostream &out, const VkPerformanceCounterKHR* structInfo, Decoded_VkPerformanceCounterKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* unit */
    structBody << "\t" << "VkPerformanceCounterUnitKHR(" << structInfo->unit << ")" << "," << std::endl;
/* scope */
    structBody << "\t" << "VkPerformanceCounterScopeKHR(" << structInfo->scope << ")" << "," << std::endl;
/* storage */
    structBody << "\t" << "VkPerformanceCounterStorageKHR(" << structInfo->storage << ")" << "," << std::endl;
/* uuid */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->uuid[0]), VK_UUID_SIZE) << "," ;
    std::string varname = consumer.AddStruct(structBody, "performanceCounterKHR");
    out << "VkPerformanceCounterKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPerformanceCounterDescriptionKHR(std::ostream &out, const VkPerformanceCounterDescriptionKHR* structInfo, Decoded_VkPerformanceCounterDescriptionKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPerformanceCounterDescriptionFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* name */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->name) << "," << std::endl;
/* category */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->category) << "," << std::endl;
/* description */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->description) << "," ;
    std::string varname = consumer.AddStruct(structBody, "performanceCounterDescriptionKHR");
    out << "VkPerformanceCounterDescriptionKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkQueryPoolPerformanceCreateInfoKHR(std::ostream &out, const VkQueryPoolPerformanceCreateInfoKHR* structInfo, Decoded_VkQueryPoolPerformanceCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pCounterIndicesArray = "NULL";
    if (structInfo->pCounterIndices != NULL) {
        pCounterIndicesArray = "pCounterIndices_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pCounterIndicesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCounterIndices, structInfo->counterIndexCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* queueFamilyIndex */
    structBody << "\t" << structInfo->queueFamilyIndex << "," << std::endl;
/* counterIndexCount */
    structBody << "\t" << structInfo->counterIndexCount << "," << std::endl;
/* pCounterIndices */
    structBody << "\t" << pCounterIndicesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "queryPoolPerformanceCreateInfoKHR");
    out << "VkQueryPoolPerformanceCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAcquireProfilingLockInfoKHR(std::ostream &out, const VkAcquireProfilingLockInfoKHR* structInfo, Decoded_VkAcquireProfilingLockInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkAcquireProfilingLockFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* timeout */
    structBody << "\t" << structInfo->timeout << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "acquireProfilingLockInfoKHR");
    out << "VkAcquireProfilingLockInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPerformanceQuerySubmitInfoKHR(std::ostream &out, const VkPerformanceQuerySubmitInfoKHR* structInfo, Decoded_VkPerformanceQuerySubmitInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* counterPassIndex */
    structBody << "\t" << structInfo->counterPassIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "performanceQuerySubmitInfoKHR");
    out << "VkPerformanceQuerySubmitInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceSurfaceInfo2KHR(std::ostream &out, const VkPhysicalDeviceSurfaceInfo2KHR* structInfo, Decoded_VkPhysicalDeviceSurfaceInfo2KHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* surface */
    structBody << "\t" << consumer.GetHandle(metainfo->surface) << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceSurfaceInfo2KHR");
    out << "VkPhysicalDeviceSurfaceInfo2KHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSurfaceCapabilities2KHR(std::ostream &out, const VkSurfaceCapabilities2KHR* structInfo, Decoded_VkSurfaceCapabilities2KHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string surfaceCapabilitiesInfoVar = GenerateStruct_VkSurfaceCapabilitiesKHR(out,
                                                                            &structInfo->surfaceCapabilities,
                                                                            metainfo->surfaceCapabilities,
                                                                            consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* surfaceCapabilities */
    structBody << "\t" << surfaceCapabilitiesInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "surfaceCapabilities2KHR");
    out << "VkSurfaceCapabilities2KHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSurfaceFormat2KHR(std::ostream &out, const VkSurfaceFormat2KHR* structInfo, Decoded_VkSurfaceFormat2KHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string surfaceFormatInfoVar = GenerateStruct_VkSurfaceFormatKHR(out,
                                                                      &structInfo->surfaceFormat,
                                                                      metainfo->surfaceFormat,
                                                                      consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* surfaceFormat */
    structBody << "\t" << surfaceFormatInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "surfaceFormat2KHR");
    out << "VkSurfaceFormat2KHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayProperties2KHR(std::ostream &out, const VkDisplayProperties2KHR* structInfo, Decoded_VkDisplayProperties2KHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string displayPropertiesInfoVar = GenerateStruct_VkDisplayPropertiesKHR(out,
                                                                          &structInfo->displayProperties,
                                                                          metainfo->displayProperties,
                                                                          consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* displayProperties */
    structBody << "\t" << displayPropertiesInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayProperties2KHR");
    out << "VkDisplayProperties2KHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayPlaneProperties2KHR(std::ostream &out, const VkDisplayPlaneProperties2KHR* structInfo, Decoded_VkDisplayPlaneProperties2KHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string displayPlanePropertiesInfoVar = GenerateStruct_VkDisplayPlanePropertiesKHR(out,
                                                                               &structInfo->displayPlaneProperties,
                                                                               metainfo->displayPlaneProperties,
                                                                               consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* displayPlaneProperties */
    structBody << "\t" << displayPlanePropertiesInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayPlaneProperties2KHR");
    out << "VkDisplayPlaneProperties2KHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayModeProperties2KHR(std::ostream &out, const VkDisplayModeProperties2KHR* structInfo, Decoded_VkDisplayModeProperties2KHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string displayModePropertiesInfoVar = GenerateStruct_VkDisplayModePropertiesKHR(out,
                                                                              &structInfo->displayModeProperties,
                                                                              metainfo->displayModeProperties,
                                                                              consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* displayModeProperties */
    structBody << "\t" << displayModePropertiesInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayModeProperties2KHR");
    out << "VkDisplayModeProperties2KHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayPlaneInfo2KHR(std::ostream &out, const VkDisplayPlaneInfo2KHR* structInfo, Decoded_VkDisplayPlaneInfo2KHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* mode */
    structBody << "\t" << consumer.GetHandle(metainfo->mode) << "," << std::endl;
/* planeIndex */
    structBody << "\t" << structInfo->planeIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayPlaneInfo2KHR");
    out << "VkDisplayPlaneInfo2KHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayPlaneCapabilities2KHR(std::ostream &out, const VkDisplayPlaneCapabilities2KHR* structInfo, Decoded_VkDisplayPlaneCapabilities2KHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string capabilitiesInfoVar = GenerateStruct_VkDisplayPlaneCapabilitiesKHR(out,
                                                                     &structInfo->capabilities,
                                                                     metainfo->capabilities,
                                                                     consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* capabilities */
    structBody << "\t" << capabilitiesInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayPlaneCapabilities2KHR");
    out << "VkDisplayPlaneCapabilities2KHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePortabilitySubsetFeaturesKHR(std::ostream &out, const VkPhysicalDevicePortabilitySubsetFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePortabilitySubsetFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* constantAlphaColorBlendFactors */
    structBody << "\t" << structInfo->constantAlphaColorBlendFactors << "," << std::endl;
/* events */
    structBody << "\t" << structInfo->events << "," << std::endl;
/* imageViewFormatReinterpretation */
    structBody << "\t" << structInfo->imageViewFormatReinterpretation << "," << std::endl;
/* imageViewFormatSwizzle */
    structBody << "\t" << structInfo->imageViewFormatSwizzle << "," << std::endl;
/* imageView2DOn3DImage */
    structBody << "\t" << structInfo->imageView2DOn3DImage << "," << std::endl;
/* multisampleArrayImage */
    structBody << "\t" << structInfo->multisampleArrayImage << "," << std::endl;
/* mutableComparisonSamplers */
    structBody << "\t" << structInfo->mutableComparisonSamplers << "," << std::endl;
/* pointPolygons */
    structBody << "\t" << structInfo->pointPolygons << "," << std::endl;
/* samplerMipLodBias */
    structBody << "\t" << structInfo->samplerMipLodBias << "," << std::endl;
/* separateStencilMaskRef */
    structBody << "\t" << structInfo->separateStencilMaskRef << "," << std::endl;
/* shaderSampleRateInterpolationFunctions */
    structBody << "\t" << structInfo->shaderSampleRateInterpolationFunctions << "," << std::endl;
/* tessellationIsolines */
    structBody << "\t" << structInfo->tessellationIsolines << "," << std::endl;
/* tessellationPointMode */
    structBody << "\t" << structInfo->tessellationPointMode << "," << std::endl;
/* triangleFans */
    structBody << "\t" << structInfo->triangleFans << "," << std::endl;
/* vertexAttributeAccessBeyondStride */
    structBody << "\t" << structInfo->vertexAttributeAccessBeyondStride << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePortabilitySubsetFeaturesKHR");
    out << "VkPhysicalDevicePortabilitySubsetFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePortabilitySubsetPropertiesKHR(std::ostream &out, const VkPhysicalDevicePortabilitySubsetPropertiesKHR* structInfo, Decoded_VkPhysicalDevicePortabilitySubsetPropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* minVertexInputBindingStrideAlignment */
    structBody << "\t" << structInfo->minVertexInputBindingStrideAlignment << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePortabilitySubsetPropertiesKHR");
    out << "VkPhysicalDevicePortabilitySubsetPropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderClockFeaturesKHR(std::ostream &out, const VkPhysicalDeviceShaderClockFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceShaderClockFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderSubgroupClock */
    structBody << "\t" << structInfo->shaderSubgroupClock << "," << std::endl;
/* shaderDeviceClock */
    structBody << "\t" << structInfo->shaderDeviceClock << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderClockFeaturesKHR");
    out << "VkPhysicalDeviceShaderClockFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeH265ProfileInfoKHR(std::ostream &out, const VkVideoDecodeH265ProfileInfoKHR* structInfo, Decoded_VkVideoDecodeH265ProfileInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stdProfileIdc */
    structBody << "\t" << "StdVideoH265ProfileIdc(" << structInfo->stdProfileIdc << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeH265ProfileInfoKHR");
    out << "VkVideoDecodeH265ProfileInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeH265CapabilitiesKHR(std::ostream &out, const VkVideoDecodeH265CapabilitiesKHR* structInfo, Decoded_VkVideoDecodeH265CapabilitiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxLevelIdc */
    structBody << "\t" << "StdVideoH265LevelIdc(" << structInfo->maxLevelIdc << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeH265CapabilitiesKHR");
    out << "VkVideoDecodeH265CapabilitiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeH265SessionParametersAddInfoKHR(std::ostream &out, const VkVideoDecodeH265SessionParametersAddInfoKHR* structInfo, Decoded_VkVideoDecodeH265SessionParametersAddInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStdVPSsArray = "NULL";
    if (structInfo->pStdVPSs != NULL) {
        pStdVPSsArray = "pStdVPSs_" + std::to_string(consumer.getNextId());
        std::string pStdVPSsNames;
        for (uint32_t idx = 0; idx < structInfo->stdVPSCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStdVPSs + idx != NULL) {
                varName = GenerateStruct_StdVideoH265VideoParameterSet(out,
                                                         structInfo->pStdVPSs + idx,
                                                         metainfo->pStdVPSs->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStdVPSsNames += varName + ", ";
        }
        out << "StdVideoH265VideoParameterSet " << pStdVPSsArray << "[] = {" << pStdVPSsNames << "};" << std::endl;
    }
    std::string pStdSPSsArray = "NULL";
    if (structInfo->pStdSPSs != NULL) {
        pStdSPSsArray = "pStdSPSs_" + std::to_string(consumer.getNextId());
        std::string pStdSPSsNames;
        for (uint32_t idx = 0; idx < structInfo->stdSPSCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStdSPSs + idx != NULL) {
                varName = GenerateStruct_StdVideoH265SequenceParameterSet(out,
                                                         structInfo->pStdSPSs + idx,
                                                         metainfo->pStdSPSs->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStdSPSsNames += varName + ", ";
        }
        out << "StdVideoH265SequenceParameterSet " << pStdSPSsArray << "[] = {" << pStdSPSsNames << "};" << std::endl;
    }
    std::string pStdPPSsArray = "NULL";
    if (structInfo->pStdPPSs != NULL) {
        pStdPPSsArray = "pStdPPSs_" + std::to_string(consumer.getNextId());
        std::string pStdPPSsNames;
        for (uint32_t idx = 0; idx < structInfo->stdPPSCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStdPPSs + idx != NULL) {
                varName = GenerateStruct_StdVideoH265PictureParameterSet(out,
                                                         structInfo->pStdPPSs + idx,
                                                         metainfo->pStdPPSs->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStdPPSsNames += varName + ", ";
        }
        out << "StdVideoH265PictureParameterSet " << pStdPPSsArray << "[] = {" << pStdPPSsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stdVPSCount */
    structBody << "\t" << structInfo->stdVPSCount << "," << std::endl;
/* pStdVPSs */
    structBody << "\t" << pStdVPSsArray << "," << std::endl;
/* stdSPSCount */
    structBody << "\t" << structInfo->stdSPSCount << "," << std::endl;
/* pStdSPSs */
    structBody << "\t" << pStdSPSsArray << "," << std::endl;
/* stdPPSCount */
    structBody << "\t" << structInfo->stdPPSCount << "," << std::endl;
/* pStdPPSs */
    structBody << "\t" << pStdPPSsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeH265SessionParametersAddInfoKHR");
    out << "VkVideoDecodeH265SessionParametersAddInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeH265SessionParametersCreateInfoKHR(std::ostream &out, const VkVideoDecodeH265SessionParametersCreateInfoKHR* structInfo, Decoded_VkVideoDecodeH265SessionParametersCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pParametersAddInfoStruct = "NULL";
    if (structInfo->pParametersAddInfo != NULL) {
        pParametersAddInfoStruct = GenerateStruct_VkVideoDecodeH265SessionParametersAddInfoKHR(out,
                                                                  structInfo->pParametersAddInfo,
                                                                  metainfo->pParametersAddInfo->GetMetaStructPointer(),
                                                                  consumer);
        pParametersAddInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxStdVPSCount */
    structBody << "\t" << structInfo->maxStdVPSCount << "," << std::endl;
/* maxStdSPSCount */
    structBody << "\t" << structInfo->maxStdSPSCount << "," << std::endl;
/* maxStdPPSCount */
    structBody << "\t" << structInfo->maxStdPPSCount << "," << std::endl;
/* pParametersAddInfo */
    structBody << "\t" << pParametersAddInfoStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeH265SessionParametersCreateInfoKHR");
    out << "VkVideoDecodeH265SessionParametersCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeH265PictureInfoKHR(std::ostream &out, const VkVideoDecodeH265PictureInfoKHR* structInfo, Decoded_VkVideoDecodeH265PictureInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStdPictureInfoStruct = "NULL";
    if (structInfo->pStdPictureInfo != NULL) {
        pStdPictureInfoStruct = GenerateStruct_StdVideoDecodeH265PictureInfo(out,
                                                               structInfo->pStdPictureInfo,
                                                               metainfo->pStdPictureInfo->GetMetaStructPointer(),
                                                               consumer);
        pStdPictureInfoStruct.insert(0, "&");
    }
    std::string pSliceSegmentOffsetsArray = "NULL";
    if (structInfo->pSliceSegmentOffsets != NULL) {
        pSliceSegmentOffsetsArray = "pSliceSegmentOffsets_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pSliceSegmentOffsetsArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pSliceSegmentOffsets, structInfo->sliceSegmentCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pStdPictureInfo */
    structBody << "\t" << pStdPictureInfoStruct << "," << std::endl;
/* sliceSegmentCount */
    structBody << "\t" << structInfo->sliceSegmentCount << "," << std::endl;
/* pSliceSegmentOffsets */
    structBody << "\t" << pSliceSegmentOffsetsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeH265PictureInfoKHR");
    out << "VkVideoDecodeH265PictureInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoDecodeH265DpbSlotInfoKHR(std::ostream &out, const VkVideoDecodeH265DpbSlotInfoKHR* structInfo, Decoded_VkVideoDecodeH265DpbSlotInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStdReferenceInfoStruct = "NULL";
    if (structInfo->pStdReferenceInfo != NULL) {
        pStdReferenceInfoStruct = GenerateStruct_StdVideoDecodeH265ReferenceInfo(out,
                                                                 structInfo->pStdReferenceInfo,
                                                                 metainfo->pStdReferenceInfo->GetMetaStructPointer(),
                                                                 consumer);
        pStdReferenceInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pStdReferenceInfo */
    structBody << "\t" << pStdReferenceInfoStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoDecodeH265DpbSlotInfoKHR");
    out << "VkVideoDecodeH265DpbSlotInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceQueueGlobalPriorityCreateInfoKHR(std::ostream &out, const VkDeviceQueueGlobalPriorityCreateInfoKHR* structInfo, Decoded_VkDeviceQueueGlobalPriorityCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* globalPriority */
    structBody << "\t" << "VkQueueGlobalPriorityKHR(" << structInfo->globalPriority << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceQueueGlobalPriorityCreateInfoKHR");
    out << "VkDeviceQueueGlobalPriorityCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR(std::ostream &out, const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* globalPriorityQuery */
    structBody << "\t" << structInfo->globalPriorityQuery << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceGlobalPriorityQueryFeaturesKHR");
    out << "VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkQueueFamilyGlobalPriorityPropertiesKHR(std::ostream &out, const VkQueueFamilyGlobalPriorityPropertiesKHR* structInfo, Decoded_VkQueueFamilyGlobalPriorityPropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* priorityCount */
    structBody << "\t" << structInfo->priorityCount << "," << std::endl;
/* priorities */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkQueueGlobalPriorityKHR*>(&structInfo->priorities[0]), VK_MAX_GLOBAL_PRIORITY_SIZE_KHR) << "," ;
    std::string varname = consumer.AddStruct(structBody, "queueFamilyGlobalPriorityPropertiesKHR");
    out << "VkQueueFamilyGlobalPriorityPropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkFragmentShadingRateAttachmentInfoKHR(std::ostream &out, const VkFragmentShadingRateAttachmentInfoKHR* structInfo, Decoded_VkFragmentShadingRateAttachmentInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pFragmentShadingRateAttachmentStruct = "NULL";
    if (structInfo->pFragmentShadingRateAttachment != NULL) {
        pFragmentShadingRateAttachmentStruct = GenerateStruct_VkAttachmentReference2(out,
                                                                              structInfo->pFragmentShadingRateAttachment,
                                                                              metainfo->pFragmentShadingRateAttachment->GetMetaStructPointer(),
                                                                              consumer);
        pFragmentShadingRateAttachmentStruct.insert(0, "&");
    }
    std::string shadingRateAttachmentTexelSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                                       &structInfo->shadingRateAttachmentTexelSize,
                                                                                       metainfo->shadingRateAttachmentTexelSize,
                                                                                       consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pFragmentShadingRateAttachment */
    structBody << "\t" << pFragmentShadingRateAttachmentStruct << "," << std::endl;
/* shadingRateAttachmentTexelSize */
    structBody << "\t" << shadingRateAttachmentTexelSizeInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "fragmentShadingRateAttachmentInfoKHR");
    out << "VkFragmentShadingRateAttachmentInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineFragmentShadingRateStateCreateInfoKHR(std::ostream &out, const VkPipelineFragmentShadingRateStateCreateInfoKHR* structInfo, Decoded_VkPipelineFragmentShadingRateStateCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string fragmentSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                     &structInfo->fragmentSize,
                                                                     metainfo->fragmentSize,
                                                                     consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fragmentSize */
    structBody << "\t" << fragmentSizeInfoVar << "," << std::endl;
/* combinerOps */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkFragmentShadingRateCombinerOpKHR*>(&structInfo->combinerOps[0]), 2) << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineFragmentShadingRateStateCreateInfoKHR");
    out << "VkPipelineFragmentShadingRateStateCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRateFeaturesKHR(std::ostream &out, const VkPhysicalDeviceFragmentShadingRateFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRateFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pipelineFragmentShadingRate */
    structBody << "\t" << structInfo->pipelineFragmentShadingRate << "," << std::endl;
/* primitiveFragmentShadingRate */
    structBody << "\t" << structInfo->primitiveFragmentShadingRate << "," << std::endl;
/* attachmentFragmentShadingRate */
    structBody << "\t" << structInfo->attachmentFragmentShadingRate << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFragmentShadingRateFeaturesKHR");
    out << "VkPhysicalDeviceFragmentShadingRateFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRatePropertiesKHR(std::ostream &out, const VkPhysicalDeviceFragmentShadingRatePropertiesKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRatePropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string minFragmentShadingRateAttachmentTexelSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                                                  &structInfo->minFragmentShadingRateAttachmentTexelSize,
                                                                                                  metainfo->minFragmentShadingRateAttachmentTexelSize,
                                                                                                  consumer);
    std::string maxFragmentShadingRateAttachmentTexelSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                                                  &structInfo->maxFragmentShadingRateAttachmentTexelSize,
                                                                                                  metainfo->maxFragmentShadingRateAttachmentTexelSize,
                                                                                                  consumer);
    std::string maxFragmentSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                        &structInfo->maxFragmentSize,
                                                                        metainfo->maxFragmentSize,
                                                                        consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* minFragmentShadingRateAttachmentTexelSize */
    structBody << "\t" << minFragmentShadingRateAttachmentTexelSizeInfoVar << "," << std::endl;
/* maxFragmentShadingRateAttachmentTexelSize */
    structBody << "\t" << maxFragmentShadingRateAttachmentTexelSizeInfoVar << "," << std::endl;
/* maxFragmentShadingRateAttachmentTexelSizeAspectRatio */
    structBody << "\t" << structInfo->maxFragmentShadingRateAttachmentTexelSizeAspectRatio << "," << std::endl;
/* primitiveFragmentShadingRateWithMultipleViewports */
    structBody << "\t" << structInfo->primitiveFragmentShadingRateWithMultipleViewports << "," << std::endl;
/* layeredShadingRateAttachments */
    structBody << "\t" << structInfo->layeredShadingRateAttachments << "," << std::endl;
/* fragmentShadingRateNonTrivialCombinerOps */
    structBody << "\t" << structInfo->fragmentShadingRateNonTrivialCombinerOps << "," << std::endl;
/* maxFragmentSize */
    structBody << "\t" << maxFragmentSizeInfoVar << "," << std::endl;
/* maxFragmentSizeAspectRatio */
    structBody << "\t" << structInfo->maxFragmentSizeAspectRatio << "," << std::endl;
/* maxFragmentShadingRateCoverageSamples */
    structBody << "\t" << structInfo->maxFragmentShadingRateCoverageSamples << "," << std::endl;
/* maxFragmentShadingRateRasterizationSamples */
    structBody << "\t" << "VkSampleCountFlagBits(" << structInfo->maxFragmentShadingRateRasterizationSamples << ")" << "," << std::endl;
/* fragmentShadingRateWithShaderDepthStencilWrites */
    structBody << "\t" << structInfo->fragmentShadingRateWithShaderDepthStencilWrites << "," << std::endl;
/* fragmentShadingRateWithSampleMask */
    structBody << "\t" << structInfo->fragmentShadingRateWithSampleMask << "," << std::endl;
/* fragmentShadingRateWithShaderSampleMask */
    structBody << "\t" << structInfo->fragmentShadingRateWithShaderSampleMask << "," << std::endl;
/* fragmentShadingRateWithConservativeRasterization */
    structBody << "\t" << structInfo->fragmentShadingRateWithConservativeRasterization << "," << std::endl;
/* fragmentShadingRateWithFragmentShaderInterlock */
    structBody << "\t" << structInfo->fragmentShadingRateWithFragmentShaderInterlock << "," << std::endl;
/* fragmentShadingRateWithCustomSampleLocations */
    structBody << "\t" << structInfo->fragmentShadingRateWithCustomSampleLocations << "," << std::endl;
/* fragmentShadingRateStrictMultiplyCombiner */
    structBody << "\t" << structInfo->fragmentShadingRateStrictMultiplyCombiner << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFragmentShadingRatePropertiesKHR");
    out << "VkPhysicalDeviceFragmentShadingRatePropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRateKHR(std::ostream &out, const VkPhysicalDeviceFragmentShadingRateKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRateKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string fragmentSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                     &structInfo->fragmentSize,
                                                                     metainfo->fragmentSize,
                                                                     consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* sampleCounts */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->sampleCounts << ")" << "," << std::endl;
/* fragmentSize */
    structBody << "\t" << fragmentSizeInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFragmentShadingRateKHR");
    out << "VkPhysicalDeviceFragmentShadingRateKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSurfaceProtectedCapabilitiesKHR(std::ostream &out, const VkSurfaceProtectedCapabilitiesKHR* structInfo, Decoded_VkSurfaceProtectedCapabilitiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* supportsProtected */
    structBody << "\t" << structInfo->supportsProtected << "," ;
    std::string varname = consumer.AddStruct(structBody, "surfaceProtectedCapabilitiesKHR");
    out << "VkSurfaceProtectedCapabilitiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePresentWaitFeaturesKHR(std::ostream &out, const VkPhysicalDevicePresentWaitFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePresentWaitFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* presentWait */
    structBody << "\t" << structInfo->presentWait << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePresentWaitFeaturesKHR");
    out << "VkPhysicalDevicePresentWaitFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR(std::ostream &out, const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pipelineExecutableInfo */
    structBody << "\t" << structInfo->pipelineExecutableInfo << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePipelineExecutablePropertiesFeaturesKHR");
    out << "VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineInfoKHR(std::ostream &out, const VkPipelineInfoKHR* structInfo, Decoded_VkPipelineInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pipeline */
    structBody << "\t" << consumer.GetHandle(metainfo->pipeline) << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineInfoKHR");
    out << "VkPipelineInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineExecutablePropertiesKHR(std::ostream &out, const VkPipelineExecutablePropertiesKHR* structInfo, Decoded_VkPipelineExecutablePropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stages */
    structBody << "\t" << "VkShaderStageFlags(" << structInfo->stages << ")" << "," << std::endl;
/* name */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->name) << "," << std::endl;
/* description */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->description) << "," << std::endl;
/* subgroupSize */
    structBody << "\t" << structInfo->subgroupSize << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineExecutablePropertiesKHR");
    out << "VkPipelineExecutablePropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineExecutableInfoKHR(std::ostream &out, const VkPipelineExecutableInfoKHR* structInfo, Decoded_VkPipelineExecutableInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pipeline */
    structBody << "\t" << consumer.GetHandle(metainfo->pipeline) << "," << std::endl;
/* executableIndex */
    structBody << "\t" << structInfo->executableIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineExecutableInfoKHR");
    out << "VkPipelineExecutableInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineExecutableStatisticKHR(std::ostream &out, const VkPipelineExecutableStatisticKHR* structInfo, Decoded_VkPipelineExecutableStatisticKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* name */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->name) << "," << std::endl;
/* description */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->description) << "," << std::endl;
/* format */
    structBody << "\t" << "VkPipelineExecutableStatisticFormatKHR(" << structInfo->format << ")" << "," << std::endl;
/* value */
    structBody << "\t" << structInfo->value.b32 << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineExecutableStatisticKHR");
    out << "VkPipelineExecutableStatisticKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineExecutableInternalRepresentationKHR(std::ostream &out, const VkPipelineExecutableInternalRepresentationKHR* structInfo, Decoded_VkPipelineExecutableInternalRepresentationKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* name */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->name) << "," << std::endl;
/* description */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->description) << "," << std::endl;
/* isText */
    structBody << "\t" << structInfo->isText << "," << std::endl;
/* dataSize */
    structBody << "\t" << structInfo->dataSize << "," << std::endl;
/* pData */
    out << "// TODO: Support pData (output with array length value?) argument." << std::endl;
    std::string varname = consumer.AddStruct(structBody, "pipelineExecutableInternalRepresentationKHR");
    out << "VkPipelineExecutableInternalRepresentationKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryMapInfoKHR(std::ostream &out, const VkMemoryMapInfoKHR* structInfo, Decoded_VkMemoryMapInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkMemoryMapFlags(" << structInfo->flags << ")" << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryMapInfoKHR");
    out << "VkMemoryMapInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryUnmapInfoKHR(std::ostream &out, const VkMemoryUnmapInfoKHR* structInfo, Decoded_VkMemoryUnmapInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkMemoryUnmapFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryUnmapInfoKHR");
    out << "VkMemoryUnmapInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineLibraryCreateInfoKHR(std::ostream &out, const VkPipelineLibraryCreateInfoKHR* structInfo, Decoded_VkPipelineLibraryCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pLibrariesArray = "NULL";
    if (metainfo->pLibraries.GetPointer() != NULL && structInfo->libraryCount > 0) {
        pLibrariesArray = "pLibrariesArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_PIPELINE));
        std::string pLibrariesValues = toStringJoin(metainfo->pLibraries.GetPointer(),
                                                    metainfo->pLibraries.GetPointer() + structInfo->libraryCount,
                                                    [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                    ", ");
        if (structInfo->libraryCount == 1) {
            pLibrariesArray = "&" + pLibrariesValues;
        } else if (structInfo->libraryCount > 1) {
            out << "VkPipeline " << pLibrariesArray << "[] = {" << pLibrariesValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* libraryCount */
    structBody << "\t" << structInfo->libraryCount << "," << std::endl;
/* pLibraries */
    structBody << "\t" << pLibrariesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineLibraryCreateInfoKHR");
    out << "VkPipelineLibraryCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPresentIdKHR(std::ostream &out, const VkPresentIdKHR* structInfo, Decoded_VkPresentIdKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pPresentIdsArray = "pPresentIdsArray_" + std::to_string(consumer.getNextId());
    if (structInfo->swapchainCount > 0) {
        std::string pPresentIdsValues = toStringJoin(structInfo->pPresentIds,
                                                     structInfo->pPresentIds + structInfo->swapchainCount,
                                                     [](uint64_t current) { return std::to_string(current); },
                                                     ", ");
        if (structInfo->swapchainCount == 1) {
            pPresentIdsArray = "&" + pPresentIdsValues;
        } else if (structInfo->swapchainCount > 1) {
            out << "uint64_t " << pPresentIdsArray << "[] = {" << pPresentIdsValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* swapchainCount */
    structBody << "\t" << structInfo->swapchainCount << "," << std::endl;
/* pPresentIds */
    structBody << "\t" << "{ *" << pPresentIdsArray << " }" << "," ;
    std::string varname = consumer.AddStruct(structBody, "presentIdKHR");
    out << "VkPresentIdKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePresentIdFeaturesKHR(std::ostream &out, const VkPhysicalDevicePresentIdFeaturesKHR* structInfo, Decoded_VkPhysicalDevicePresentIdFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* presentId */
    structBody << "\t" << structInfo->presentId << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePresentIdFeaturesKHR");
    out << "VkPhysicalDevicePresentIdFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeInfoKHR(std::ostream &out, const VkVideoEncodeInfoKHR* structInfo, Decoded_VkVideoEncodeInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string srcPictureResourceInfoVar = GenerateStruct_VkVideoPictureResourceInfoKHR(out,
                                                                           &structInfo->srcPictureResource,
                                                                           metainfo->srcPictureResource,
                                                                           consumer);
    std::string pSetupReferenceSlotStruct = "NULL";
    if (structInfo->pSetupReferenceSlot != NULL) {
        pSetupReferenceSlotStruct = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                                   structInfo->pSetupReferenceSlot,
                                                                   metainfo->pSetupReferenceSlot->GetMetaStructPointer(),
                                                                   consumer);
        pSetupReferenceSlotStruct.insert(0, "&");
    }
    std::string pReferenceSlotsArray = "NULL";
    if (structInfo->pReferenceSlots != NULL) {
        pReferenceSlotsArray = "pReferenceSlots_" + std::to_string(consumer.getNextId());
        std::string pReferenceSlotsNames;
        for (uint32_t idx = 0; idx < structInfo->referenceSlotCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pReferenceSlots + idx != NULL) {
                varName = GenerateStruct_VkVideoReferenceSlotInfoKHR(out,
                                                         structInfo->pReferenceSlots + idx,
                                                         metainfo->pReferenceSlots->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pReferenceSlotsNames += varName + ", ";
        }
        out << "VkVideoReferenceSlotInfoKHR " << pReferenceSlotsArray << "[] = {" << pReferenceSlotsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoEncodeFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* dstBuffer */
    structBody << "\t" << consumer.GetHandle(metainfo->dstBuffer) << "," << std::endl;
/* dstBufferOffset */
    structBody << "\t" << structInfo->dstBufferOffset << "UL" << "," << std::endl;
/* dstBufferRange */
    structBody << "\t" << structInfo->dstBufferRange << "UL" << "," << std::endl;
/* srcPictureResource */
    structBody << "\t" << srcPictureResourceInfoVar << "," << std::endl;
/* pSetupReferenceSlot */
    structBody << "\t" << pSetupReferenceSlotStruct << "," << std::endl;
/* referenceSlotCount */
    structBody << "\t" << structInfo->referenceSlotCount << "," << std::endl;
/* pReferenceSlots */
    structBody << "\t" << pReferenceSlotsArray << "," << std::endl;
/* precedingExternallyEncodedBytes */
    structBody << "\t" << structInfo->precedingExternallyEncodedBytes << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeInfoKHR");
    out << "VkVideoEncodeInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeCapabilitiesKHR(std::ostream &out, const VkVideoEncodeCapabilitiesKHR* structInfo, Decoded_VkVideoEncodeCapabilitiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string encodeInputPictureGranularityInfoVar = GenerateStruct_VkExtent2D(out,
                                                                                      &structInfo->encodeInputPictureGranularity,
                                                                                      metainfo->encodeInputPictureGranularity,
                                                                                      consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoEncodeCapabilityFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* rateControlModes */
    structBody << "\t" << "VkVideoEncodeRateControlModeFlagsKHR(" << structInfo->rateControlModes << ")" << "," << std::endl;
/* maxRateControlLayers */
    structBody << "\t" << structInfo->maxRateControlLayers << "," << std::endl;
/* maxBitrate */
    structBody << "\t" << structInfo->maxBitrate << "UL" << "," << std::endl;
/* maxQualityLevels */
    structBody << "\t" << structInfo->maxQualityLevels << "," << std::endl;
/* encodeInputPictureGranularity */
    structBody << "\t" << encodeInputPictureGranularityInfoVar << "," << std::endl;
/* supportedEncodeFeedbackFlags */
    structBody << "\t" << "VkVideoEncodeFeedbackFlagsKHR(" << structInfo->supportedEncodeFeedbackFlags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeCapabilitiesKHR");
    out << "VkVideoEncodeCapabilitiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR(std::ostream &out, const VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* structInfo, Decoded_VkQueryPoolVideoEncodeFeedbackCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* encodeFeedbackFlags */
    structBody << "\t" << "VkVideoEncodeFeedbackFlagsKHR(" << structInfo->encodeFeedbackFlags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "queryPoolVideoEncodeFeedbackCreateInfoKHR");
    out << "VkQueryPoolVideoEncodeFeedbackCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeUsageInfoKHR(std::ostream &out, const VkVideoEncodeUsageInfoKHR* structInfo, Decoded_VkVideoEncodeUsageInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* videoUsageHints */
    structBody << "\t" << "VkVideoEncodeUsageFlagsKHR(" << structInfo->videoUsageHints << ")" << "," << std::endl;
/* videoContentHints */
    structBody << "\t" << "VkVideoEncodeContentFlagsKHR(" << structInfo->videoContentHints << ")" << "," << std::endl;
/* tuningMode */
    structBody << "\t" << "VkVideoEncodeTuningModeKHR(" << structInfo->tuningMode << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeUsageInfoKHR");
    out << "VkVideoEncodeUsageInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeRateControlLayerInfoKHR(std::ostream &out, const VkVideoEncodeRateControlLayerInfoKHR* structInfo, Decoded_VkVideoEncodeRateControlLayerInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* averageBitrate */
    structBody << "\t" << structInfo->averageBitrate << "UL" << "," << std::endl;
/* maxBitrate */
    structBody << "\t" << structInfo->maxBitrate << "UL" << "," << std::endl;
/* frameRateNumerator */
    structBody << "\t" << structInfo->frameRateNumerator << "," << std::endl;
/* frameRateDenominator */
    structBody << "\t" << structInfo->frameRateDenominator << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeRateControlLayerInfoKHR");
    out << "VkVideoEncodeRateControlLayerInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeRateControlInfoKHR(std::ostream &out, const VkVideoEncodeRateControlInfoKHR* structInfo, Decoded_VkVideoEncodeRateControlInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pLayersArray = "NULL";
    if (structInfo->pLayers != NULL) {
        pLayersArray = "pLayers_" + std::to_string(consumer.getNextId());
        std::string pLayersNames;
        for (uint32_t idx = 0; idx < structInfo->layerCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pLayers + idx != NULL) {
                varName = GenerateStruct_VkVideoEncodeRateControlLayerInfoKHR(out,
                                                         structInfo->pLayers + idx,
                                                         metainfo->pLayers->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pLayersNames += varName + ", ";
        }
        out << "VkVideoEncodeRateControlLayerInfoKHR " << pLayersArray << "[] = {" << pLayersNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoEncodeRateControlFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* rateControlMode */
    structBody << "\t" << "VkVideoEncodeRateControlModeFlagBitsKHR(" << structInfo->rateControlMode << ")" << "," << std::endl;
/* layerCount */
    structBody << "\t" << structInfo->layerCount << "," << std::endl;
/* pLayers */
    structBody << "\t" << pLayersArray << "," << std::endl;
/* virtualBufferSizeInMs */
    structBody << "\t" << structInfo->virtualBufferSizeInMs << "," << std::endl;
/* initialVirtualBufferSizeInMs */
    structBody << "\t" << structInfo->initialVirtualBufferSizeInMs << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeRateControlInfoKHR");
    out << "VkVideoEncodeRateControlInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR(std::ostream &out, const VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* structInfo, Decoded_VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pVideoProfileStruct = "NULL";
    if (structInfo->pVideoProfile != NULL) {
        pVideoProfileStruct = GenerateStruct_VkVideoProfileInfoKHR(out,
                                                             structInfo->pVideoProfile,
                                                             metainfo->pVideoProfile->GetMetaStructPointer(),
                                                             consumer);
        pVideoProfileStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pVideoProfile */
    structBody << "\t" << pVideoProfileStruct << "," << std::endl;
/* qualityLevel */
    structBody << "\t" << structInfo->qualityLevel << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceVideoEncodeQualityLevelInfoKHR");
    out << "VkPhysicalDeviceVideoEncodeQualityLevelInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeQualityLevelPropertiesKHR(std::ostream &out, const VkVideoEncodeQualityLevelPropertiesKHR* structInfo, Decoded_VkVideoEncodeQualityLevelPropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* preferredRateControlMode */
    structBody << "\t" << "VkVideoEncodeRateControlModeFlagBitsKHR(" << structInfo->preferredRateControlMode << ")" << "," << std::endl;
/* preferredRateControlLayerCount */
    structBody << "\t" << structInfo->preferredRateControlLayerCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeQualityLevelPropertiesKHR");
    out << "VkVideoEncodeQualityLevelPropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeQualityLevelInfoKHR(std::ostream &out, const VkVideoEncodeQualityLevelInfoKHR* structInfo, Decoded_VkVideoEncodeQualityLevelInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* qualityLevel */
    structBody << "\t" << structInfo->qualityLevel << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeQualityLevelInfoKHR");
    out << "VkVideoEncodeQualityLevelInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeSessionParametersGetInfoKHR(std::ostream &out, const VkVideoEncodeSessionParametersGetInfoKHR* structInfo, Decoded_VkVideoEncodeSessionParametersGetInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* videoSessionParameters */
    structBody << "\t" << consumer.GetHandle(metainfo->videoSessionParameters) << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeSessionParametersGetInfoKHR");
    out << "VkVideoEncodeSessionParametersGetInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeSessionParametersFeedbackInfoKHR(std::ostream &out, const VkVideoEncodeSessionParametersFeedbackInfoKHR* structInfo, Decoded_VkVideoEncodeSessionParametersFeedbackInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* hasOverrides */
    structBody << "\t" << structInfo->hasOverrides << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeSessionParametersFeedbackInfoKHR");
    out << "VkVideoEncodeSessionParametersFeedbackInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkQueueFamilyCheckpointProperties2NV(std::ostream &out, const VkQueueFamilyCheckpointProperties2NV* structInfo, Decoded_VkQueueFamilyCheckpointProperties2NV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* checkpointExecutionStageMask */
    structBody << "\t" << "VkPipelineStageFlags2(" << structInfo->checkpointExecutionStageMask << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "queueFamilyCheckpointProperties2NV");
    out << "VkQueueFamilyCheckpointProperties2NV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCheckpointData2NV(std::ostream &out, const VkCheckpointData2NV* structInfo, Decoded_VkCheckpointData2NV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stage */
    structBody << "\t" << "VkPipelineStageFlags2(" << structInfo->stage << ")" << "," << std::endl;
/* pCheckpointMarker */
    out << "// TODO: Support pCheckpointMarker (output?) argument." << std::endl;
    std::string varname = consumer.AddStruct(structBody, "checkpointData2NV");
    out << "VkCheckpointData2NV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR(std::ostream &out, const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fragmentShaderBarycentric */
    structBody << "\t" << structInfo->fragmentShaderBarycentric << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFragmentShaderBarycentricFeaturesKHR");
    out << "VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR(std::ostream &out, const VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* structInfo, Decoded_VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* triStripVertexOrderIndependentOfProvokingVertex */
    structBody << "\t" << structInfo->triStripVertexOrderIndependentOfProvokingVertex << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFragmentShaderBarycentricPropertiesKHR");
    out << "VkPhysicalDeviceFragmentShaderBarycentricPropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR(std::ostream &out, const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderSubgroupUniformControlFlow */
    structBody << "\t" << structInfo->shaderSubgroupUniformControlFlow << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR");
    out << "VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR(std::ostream &out, const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* workgroupMemoryExplicitLayout */
    structBody << "\t" << structInfo->workgroupMemoryExplicitLayout << "," << std::endl;
/* workgroupMemoryExplicitLayoutScalarBlockLayout */
    structBody << "\t" << structInfo->workgroupMemoryExplicitLayoutScalarBlockLayout << "," << std::endl;
/* workgroupMemoryExplicitLayout8BitAccess */
    structBody << "\t" << structInfo->workgroupMemoryExplicitLayout8BitAccess << "," << std::endl;
/* workgroupMemoryExplicitLayout16BitAccess */
    structBody << "\t" << structInfo->workgroupMemoryExplicitLayout16BitAccess << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR");
    out << "VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR(std::ostream &out, const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* rayTracingMaintenance1 */
    structBody << "\t" << structInfo->rayTracingMaintenance1 << "," << std::endl;
/* rayTracingPipelineTraceRaysIndirect2 */
    structBody << "\t" << structInfo->rayTracingPipelineTraceRaysIndirect2 << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceRayTracingMaintenance1FeaturesKHR");
    out << "VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkTraceRaysIndirectCommand2KHR(std::ostream &out, const VkTraceRaysIndirectCommand2KHR* structInfo, Decoded_VkTraceRaysIndirectCommand2KHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* raygenShaderRecordAddress */
    structBody << "\t" << structInfo->raygenShaderRecordAddress << "UL" << "," << std::endl;
/* raygenShaderRecordSize */
    structBody << "\t" << structInfo->raygenShaderRecordSize << "UL" << "," << std::endl;
/* missShaderBindingTableAddress */
    structBody << "\t" << structInfo->missShaderBindingTableAddress << "UL" << "," << std::endl;
/* missShaderBindingTableSize */
    structBody << "\t" << structInfo->missShaderBindingTableSize << "UL" << "," << std::endl;
/* missShaderBindingTableStride */
    structBody << "\t" << structInfo->missShaderBindingTableStride << "UL" << "," << std::endl;
/* hitShaderBindingTableAddress */
    structBody << "\t" << structInfo->hitShaderBindingTableAddress << "UL" << "," << std::endl;
/* hitShaderBindingTableSize */
    structBody << "\t" << structInfo->hitShaderBindingTableSize << "UL" << "," << std::endl;
/* hitShaderBindingTableStride */
    structBody << "\t" << structInfo->hitShaderBindingTableStride << "UL" << "," << std::endl;
/* callableShaderBindingTableAddress */
    structBody << "\t" << structInfo->callableShaderBindingTableAddress << "UL" << "," << std::endl;
/* callableShaderBindingTableSize */
    structBody << "\t" << structInfo->callableShaderBindingTableSize << "UL" << "," << std::endl;
/* callableShaderBindingTableStride */
    structBody << "\t" << structInfo->callableShaderBindingTableStride << "UL" << "," << std::endl;
/* width */
    structBody << "\t" << structInfo->width << "," << std::endl;
/* height */
    structBody << "\t" << structInfo->height << "," << std::endl;
/* depth */
    structBody << "\t" << structInfo->depth << "," ;
    std::string varname = consumer.AddStruct(structBody, "traceRaysIndirectCommand2KHR");
    out << "VkTraceRaysIndirectCommand2KHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance5FeaturesKHR(std::ostream &out, const VkPhysicalDeviceMaintenance5FeaturesKHR* structInfo, Decoded_VkPhysicalDeviceMaintenance5FeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maintenance5 */
    structBody << "\t" << structInfo->maintenance5 << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMaintenance5FeaturesKHR");
    out << "VkPhysicalDeviceMaintenance5FeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMaintenance5PropertiesKHR(std::ostream &out, const VkPhysicalDeviceMaintenance5PropertiesKHR* structInfo, Decoded_VkPhysicalDeviceMaintenance5PropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* earlyFragmentMultisampleCoverageAfterSampleCounting */
    structBody << "\t" << structInfo->earlyFragmentMultisampleCoverageAfterSampleCounting << "," << std::endl;
/* earlyFragmentSampleMaskTestBeforeSampleCounting */
    structBody << "\t" << structInfo->earlyFragmentSampleMaskTestBeforeSampleCounting << "," << std::endl;
/* depthStencilSwizzleOneSupport */
    structBody << "\t" << structInfo->depthStencilSwizzleOneSupport << "," << std::endl;
/* polygonModePointSize */
    structBody << "\t" << structInfo->polygonModePointSize << "," << std::endl;
/* nonStrictSinglePixelWideLinesUseParallelogram */
    structBody << "\t" << structInfo->nonStrictSinglePixelWideLinesUseParallelogram << "," << std::endl;
/* nonStrictWideLinesUseParallelogram */
    structBody << "\t" << structInfo->nonStrictWideLinesUseParallelogram << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMaintenance5PropertiesKHR");
    out << "VkPhysicalDeviceMaintenance5PropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderingAreaInfoKHR(std::ostream &out, const VkRenderingAreaInfoKHR* structInfo, Decoded_VkRenderingAreaInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pColorAttachmentFormatsValues;
    std::string pColorAttachmentFormatsArray = "NULL";
    if (structInfo->pColorAttachmentFormats != NULL) {
        for (uint32_t idx = 0; idx < structInfo->colorAttachmentCount; idx++) {
            pColorAttachmentFormatsValues += util::ToString<VkFormat>(structInfo->pColorAttachmentFormats[idx]) + ", ";
        }
        pColorAttachmentFormatsArray = "pColorAttachmentFormats_" + std::to_string(consumer.getNextId());
        out << "VkFormat " << pColorAttachmentFormatsArray << "[] = {" << pColorAttachmentFormatsValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* viewMask */
    structBody << "\t" << structInfo->viewMask << "," << std::endl;
/* colorAttachmentCount */
    structBody << "\t" << structInfo->colorAttachmentCount << "," << std::endl;
/* pColorAttachmentFormats */
    structBody << "\t" << pColorAttachmentFormatsArray << "," << std::endl;
/* depthAttachmentFormat */
    structBody << "\t" << "VkFormat(" << structInfo->depthAttachmentFormat << ")" << "," << std::endl;
/* stencilAttachmentFormat */
    structBody << "\t" << "VkFormat(" << structInfo->stencilAttachmentFormat << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderingAreaInfoKHR");
    out << "VkRenderingAreaInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageSubresource2KHR(std::ostream &out, const VkImageSubresource2KHR* structInfo, Decoded_VkImageSubresource2KHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string imageSubresourceInfoVar = GenerateStruct_VkImageSubresource(out,
                                                                         &structInfo->imageSubresource,
                                                                         metainfo->imageSubresource,
                                                                         consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* imageSubresource */
    structBody << "\t" << imageSubresourceInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageSubresource2KHR");
    out << "VkImageSubresource2KHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceImageSubresourceInfoKHR(std::ostream &out, const VkDeviceImageSubresourceInfoKHR* structInfo, Decoded_VkDeviceImageSubresourceInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pCreateInfoStruct = "NULL";
    if (structInfo->pCreateInfo != NULL) {
        pCreateInfoStruct = GenerateStruct_VkImageCreateInfo(out,
                                                           structInfo->pCreateInfo,
                                                           metainfo->pCreateInfo->GetMetaStructPointer(),
                                                           consumer);
        pCreateInfoStruct.insert(0, "&");
    }
    std::string pSubresourceStruct = "NULL";
    if (structInfo->pSubresource != NULL) {
        pSubresourceStruct = GenerateStruct_VkImageSubresource2KHR(out,
                                                            structInfo->pSubresource,
                                                            metainfo->pSubresource->GetMetaStructPointer(),
                                                            consumer);
        pSubresourceStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pCreateInfo */
    structBody << "\t" << pCreateInfoStruct << "," << std::endl;
/* pSubresource */
    structBody << "\t" << pSubresourceStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceImageSubresourceInfoKHR");
    out << "VkDeviceImageSubresourceInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubresourceLayout2KHR(std::ostream &out, const VkSubresourceLayout2KHR* structInfo, Decoded_VkSubresourceLayout2KHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string subresourceLayoutInfoVar = GenerateStruct_VkSubresourceLayout(out,
                                                                          &structInfo->subresourceLayout,
                                                                          metainfo->subresourceLayout,
                                                                          consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* subresourceLayout */
    structBody << "\t" << subresourceLayoutInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "subresourceLayout2KHR");
    out << "VkSubresourceLayout2KHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineCreateFlags2CreateInfoKHR(std::ostream &out, const VkPipelineCreateFlags2CreateInfoKHR* structInfo, Decoded_VkPipelineCreateFlags2CreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineCreateFlags2KHR(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineCreateFlags2CreateInfoKHR");
    out << "VkPipelineCreateFlags2CreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBufferUsageFlags2CreateInfoKHR(std::ostream &out, const VkBufferUsageFlags2CreateInfoKHR* structInfo, Decoded_VkBufferUsageFlags2CreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* usage */
    structBody << "\t" << "VkBufferUsageFlags2KHR(" << structInfo->usage << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "bufferUsageFlags2CreateInfoKHR");
    out << "VkBufferUsageFlags2CreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR(std::ostream &out, const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* rayTracingPositionFetch */
    structBody << "\t" << structInfo->rayTracingPositionFetch << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceRayTracingPositionFetchFeaturesKHR");
    out << "VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCooperativeMatrixPropertiesKHR(std::ostream &out, const VkCooperativeMatrixPropertiesKHR* structInfo, Decoded_VkCooperativeMatrixPropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* MSize */
    structBody << "\t" << structInfo->MSize << "," << std::endl;
/* NSize */
    structBody << "\t" << structInfo->NSize << "," << std::endl;
/* KSize */
    structBody << "\t" << structInfo->KSize << "," << std::endl;
/* AType */
    structBody << "\t" << "VkComponentTypeKHR(" << structInfo->AType << ")" << "," << std::endl;
/* BType */
    structBody << "\t" << "VkComponentTypeKHR(" << structInfo->BType << ")" << "," << std::endl;
/* CType */
    structBody << "\t" << "VkComponentTypeKHR(" << structInfo->CType << ")" << "," << std::endl;
/* ResultType */
    structBody << "\t" << "VkComponentTypeKHR(" << structInfo->ResultType << ")" << "," << std::endl;
/* saturatingAccumulation */
    structBody << "\t" << structInfo->saturatingAccumulation << "," << std::endl;
/* scope */
    structBody << "\t" << "VkScopeKHR(" << structInfo->scope << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "cooperativeMatrixPropertiesKHR");
    out << "VkCooperativeMatrixPropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeMatrixFeaturesKHR(std::ostream &out, const VkPhysicalDeviceCooperativeMatrixFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* cooperativeMatrix */
    structBody << "\t" << structInfo->cooperativeMatrix << "," << std::endl;
/* cooperativeMatrixRobustBufferAccess */
    structBody << "\t" << structInfo->cooperativeMatrixRobustBufferAccess << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceCooperativeMatrixFeaturesKHR");
    out << "VkPhysicalDeviceCooperativeMatrixFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeMatrixPropertiesKHR(std::ostream &out, const VkPhysicalDeviceCooperativeMatrixPropertiesKHR* structInfo, Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* cooperativeMatrixSupportedStages */
    structBody << "\t" << "VkShaderStageFlags(" << structInfo->cooperativeMatrixSupportedStages << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceCooperativeMatrixPropertiesKHR");
    out << "VkPhysicalDeviceCooperativeMatrixPropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDebugReportCallbackCreateInfoEXT(std::ostream &out, const VkDebugReportCallbackCreateInfoEXT* structInfo, Decoded_VkDebugReportCallbackCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDebugReportFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* pfnCallback */
    structBody << "\t" << structInfo->pfnCallback << "," << std::endl;
/* pUserData */
    out << "// TODO: Support pUserData (output?) argument." << std::endl;
    std::string varname = consumer.AddStruct(structBody, "debugReportCallbackCreateInfoEXT");
    out << "VkDebugReportCallbackCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineRasterizationStateRasterizationOrderAMD(std::ostream &out, const VkPipelineRasterizationStateRasterizationOrderAMD* structInfo, Decoded_VkPipelineRasterizationStateRasterizationOrderAMD* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* rasterizationOrder */
    structBody << "\t" << "VkRasterizationOrderAMD(" << structInfo->rasterizationOrder << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineRasterizationStateRasterizationOrderAMD");
    out << "VkPipelineRasterizationStateRasterizationOrderAMD " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDebugMarkerObjectNameInfoEXT(std::ostream &out, const VkDebugMarkerObjectNameInfoEXT* structInfo, Decoded_VkDebugMarkerObjectNameInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* objectType */
    structBody << "\t" << "VkDebugReportObjectTypeEXT(" << structInfo->objectType << ")" << "," << std::endl;
/* object */
    structBody << "\t" << structInfo->object << "UL" << "," << std::endl;
/* pObjectName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->pObjectName) << "," ;
    std::string varname = consumer.AddStruct(structBody, "debugMarkerObjectNameInfoEXT");
    out << "VkDebugMarkerObjectNameInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDebugMarkerObjectTagInfoEXT(std::ostream &out, const VkDebugMarkerObjectTagInfoEXT* structInfo, Decoded_VkDebugMarkerObjectTagInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pTagArray = "NULL";
    if (structInfo->pTag != NULL) {
        std::string pTagValues;
        for (uint32_t idx0 = 0; idx0 < structInfo->tagSize; ++idx0) {
            pTagValues += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pTag)[idx0]) + ", ";
        }
        pTagArray = "pTag_" + std::to_string(consumer.getNextId());
        out << "uint8_t " << pTagArray << "[] = {" << pTagValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* objectType */
    structBody << "\t" << "VkDebugReportObjectTypeEXT(" << structInfo->objectType << ")" << "," << std::endl;
/* object */
    structBody << "\t" << structInfo->object << "UL" << "," << std::endl;
/* tagName */
    structBody << "\t" << structInfo->tagName << "UL" << "," << std::endl;
/* tagSize */
    structBody << "\t" << structInfo->tagSize << "," << std::endl;
/* pTag */
    structBody << "\t" << pTagArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "debugMarkerObjectTagInfoEXT");
    out << "VkDebugMarkerObjectTagInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDebugMarkerMarkerInfoEXT(std::ostream &out, const VkDebugMarkerMarkerInfoEXT* structInfo, Decoded_VkDebugMarkerMarkerInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pMarkerName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->pMarkerName) << "," << std::endl;
/* color */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->color[0]), 4) << "," ;
    std::string varname = consumer.AddStruct(structBody, "debugMarkerMarkerInfoEXT");
    out << "VkDebugMarkerMarkerInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDedicatedAllocationImageCreateInfoNV(std::ostream &out, const VkDedicatedAllocationImageCreateInfoNV* structInfo, Decoded_VkDedicatedAllocationImageCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* dedicatedAllocation */
    structBody << "\t" << structInfo->dedicatedAllocation << "," ;
    std::string varname = consumer.AddStruct(structBody, "dedicatedAllocationImageCreateInfoNV");
    out << "VkDedicatedAllocationImageCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDedicatedAllocationBufferCreateInfoNV(std::ostream &out, const VkDedicatedAllocationBufferCreateInfoNV* structInfo, Decoded_VkDedicatedAllocationBufferCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* dedicatedAllocation */
    structBody << "\t" << structInfo->dedicatedAllocation << "," ;
    std::string varname = consumer.AddStruct(structBody, "dedicatedAllocationBufferCreateInfoNV");
    out << "VkDedicatedAllocationBufferCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDedicatedAllocationMemoryAllocateInfoNV(std::ostream &out, const VkDedicatedAllocationMemoryAllocateInfoNV* structInfo, Decoded_VkDedicatedAllocationMemoryAllocateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* image */
    structBody << "\t" << consumer.GetHandle(metainfo->image) << "," << std::endl;
/* buffer */
    structBody << "\t" << consumer.GetHandle(metainfo->buffer) << "," ;
    std::string varname = consumer.AddStruct(structBody, "dedicatedAllocationMemoryAllocateInfoNV");
    out << "VkDedicatedAllocationMemoryAllocateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceTransformFeedbackFeaturesEXT(std::ostream &out, const VkPhysicalDeviceTransformFeedbackFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceTransformFeedbackFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* transformFeedback */
    structBody << "\t" << structInfo->transformFeedback << "," << std::endl;
/* geometryStreams */
    structBody << "\t" << structInfo->geometryStreams << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceTransformFeedbackFeaturesEXT");
    out << "VkPhysicalDeviceTransformFeedbackFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceTransformFeedbackPropertiesEXT(std::ostream &out, const VkPhysicalDeviceTransformFeedbackPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceTransformFeedbackPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxTransformFeedbackStreams */
    structBody << "\t" << structInfo->maxTransformFeedbackStreams << "," << std::endl;
/* maxTransformFeedbackBuffers */
    structBody << "\t" << structInfo->maxTransformFeedbackBuffers << "," << std::endl;
/* maxTransformFeedbackBufferSize */
    structBody << "\t" << structInfo->maxTransformFeedbackBufferSize << "UL" << "," << std::endl;
/* maxTransformFeedbackStreamDataSize */
    structBody << "\t" << structInfo->maxTransformFeedbackStreamDataSize << "," << std::endl;
/* maxTransformFeedbackBufferDataSize */
    structBody << "\t" << structInfo->maxTransformFeedbackBufferDataSize << "," << std::endl;
/* maxTransformFeedbackBufferDataStride */
    structBody << "\t" << structInfo->maxTransformFeedbackBufferDataStride << "," << std::endl;
/* transformFeedbackQueries */
    structBody << "\t" << structInfo->transformFeedbackQueries << "," << std::endl;
/* transformFeedbackStreamsLinesTriangles */
    structBody << "\t" << structInfo->transformFeedbackStreamsLinesTriangles << "," << std::endl;
/* transformFeedbackRasterizationStreamSelect */
    structBody << "\t" << structInfo->transformFeedbackRasterizationStreamSelect << "," << std::endl;
/* transformFeedbackDraw */
    structBody << "\t" << structInfo->transformFeedbackDraw << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceTransformFeedbackPropertiesEXT");
    out << "VkPhysicalDeviceTransformFeedbackPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineRasterizationStateStreamCreateInfoEXT(std::ostream &out, const VkPipelineRasterizationStateStreamCreateInfoEXT* structInfo, Decoded_VkPipelineRasterizationStateStreamCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineRasterizationStateStreamCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* rasterizationStream */
    structBody << "\t" << structInfo->rasterizationStream << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineRasterizationStateStreamCreateInfoEXT");
    out << "VkPipelineRasterizationStateStreamCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageViewHandleInfoNVX(std::ostream &out, const VkImageViewHandleInfoNVX* structInfo, Decoded_VkImageViewHandleInfoNVX* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* imageView */
    structBody << "\t" << consumer.GetHandle(metainfo->imageView) << "," << std::endl;
/* descriptorType */
    structBody << "\t" << "VkDescriptorType(" << structInfo->descriptorType << ")" << "," << std::endl;
/* sampler */
    structBody << "\t" << consumer.GetHandle(metainfo->sampler) << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageViewHandleInfoNVX");
    out << "VkImageViewHandleInfoNVX " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageViewAddressPropertiesNVX(std::ostream &out, const VkImageViewAddressPropertiesNVX* structInfo, Decoded_VkImageViewAddressPropertiesNVX* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceAddress */
    structBody << "\t" << structInfo->deviceAddress << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageViewAddressPropertiesNVX");
    out << "VkImageViewAddressPropertiesNVX " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264CapabilitiesEXT(std::ostream &out, const VkVideoEncodeH264CapabilitiesEXT* structInfo, Decoded_VkVideoEncodeH264CapabilitiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoEncodeH264CapabilityFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* maxLevelIdc */
    structBody << "\t" << "StdVideoH264LevelIdc(" << structInfo->maxLevelIdc << ")" << "," << std::endl;
/* maxSliceCount */
    structBody << "\t" << structInfo->maxSliceCount << "," << std::endl;
/* maxPPictureL0ReferenceCount */
    structBody << "\t" << structInfo->maxPPictureL0ReferenceCount << "," << std::endl;
/* maxBPictureL0ReferenceCount */
    structBody << "\t" << structInfo->maxBPictureL0ReferenceCount << "," << std::endl;
/* maxL1ReferenceCount */
    structBody << "\t" << structInfo->maxL1ReferenceCount << "," << std::endl;
/* maxTemporalLayerCount */
    structBody << "\t" << structInfo->maxTemporalLayerCount << "," << std::endl;
/* expectDyadicTemporalLayerPattern */
    structBody << "\t" << structInfo->expectDyadicTemporalLayerPattern << "," << std::endl;
/* minQp */
    structBody << "\t" << structInfo->minQp << "," << std::endl;
/* maxQp */
    structBody << "\t" << structInfo->maxQp << "," << std::endl;
/* prefersGopRemainingFrames */
    structBody << "\t" << structInfo->prefersGopRemainingFrames << "," << std::endl;
/* requiresGopRemainingFrames */
    structBody << "\t" << structInfo->requiresGopRemainingFrames << "," << std::endl;
/* stdSyntaxFlags */
    structBody << "\t" << "VkVideoEncodeH264StdFlagsEXT(" << structInfo->stdSyntaxFlags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264CapabilitiesEXT");
    out << "VkVideoEncodeH264CapabilitiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264QpEXT(std::ostream &out, const VkVideoEncodeH264QpEXT* structInfo, Decoded_VkVideoEncodeH264QpEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* qpI */
    structBody << "\t" << structInfo->qpI << "," << std::endl;
/* qpP */
    structBody << "\t" << structInfo->qpP << "," << std::endl;
/* qpB */
    structBody << "\t" << structInfo->qpB << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264QpEXT");
    out << "VkVideoEncodeH264QpEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264QualityLevelPropertiesEXT(std::ostream &out, const VkVideoEncodeH264QualityLevelPropertiesEXT* structInfo, Decoded_VkVideoEncodeH264QualityLevelPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string preferredConstantQpInfoVar = GenerateStruct_VkVideoEncodeH264QpEXT(out,
                                                                            &structInfo->preferredConstantQp,
                                                                            metainfo->preferredConstantQp,
                                                                            consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* preferredRateControlFlags */
    structBody << "\t" << "VkVideoEncodeH264RateControlFlagsEXT(" << structInfo->preferredRateControlFlags << ")" << "," << std::endl;
/* preferredGopFrameCount */
    structBody << "\t" << structInfo->preferredGopFrameCount << "," << std::endl;
/* preferredIdrPeriod */
    structBody << "\t" << structInfo->preferredIdrPeriod << "," << std::endl;
/* preferredConsecutiveBFrameCount */
    structBody << "\t" << structInfo->preferredConsecutiveBFrameCount << "," << std::endl;
/* preferredTemporalLayerCount */
    structBody << "\t" << structInfo->preferredTemporalLayerCount << "," << std::endl;
/* preferredConstantQp */
    structBody << "\t" << preferredConstantQpInfoVar << "," << std::endl;
/* preferredMaxL0ReferenceCount */
    structBody << "\t" << structInfo->preferredMaxL0ReferenceCount << "," << std::endl;
/* preferredMaxL1ReferenceCount */
    structBody << "\t" << structInfo->preferredMaxL1ReferenceCount << "," << std::endl;
/* preferredStdEntropyCodingModeFlag */
    structBody << "\t" << structInfo->preferredStdEntropyCodingModeFlag << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264QualityLevelPropertiesEXT");
    out << "VkVideoEncodeH264QualityLevelPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264SessionCreateInfoEXT(std::ostream &out, const VkVideoEncodeH264SessionCreateInfoEXT* structInfo, Decoded_VkVideoEncodeH264SessionCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* useMaxLevelIdc */
    structBody << "\t" << structInfo->useMaxLevelIdc << "," << std::endl;
/* maxLevelIdc */
    structBody << "\t" << "StdVideoH264LevelIdc(" << structInfo->maxLevelIdc << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264SessionCreateInfoEXT");
    out << "VkVideoEncodeH264SessionCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264SessionParametersAddInfoEXT(std::ostream &out, const VkVideoEncodeH264SessionParametersAddInfoEXT* structInfo, Decoded_VkVideoEncodeH264SessionParametersAddInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStdSPSsArray = "NULL";
    if (structInfo->pStdSPSs != NULL) {
        pStdSPSsArray = "pStdSPSs_" + std::to_string(consumer.getNextId());
        std::string pStdSPSsNames;
        for (uint32_t idx = 0; idx < structInfo->stdSPSCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStdSPSs + idx != NULL) {
                varName = GenerateStruct_StdVideoH264SequenceParameterSet(out,
                                                         structInfo->pStdSPSs + idx,
                                                         metainfo->pStdSPSs->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStdSPSsNames += varName + ", ";
        }
        out << "StdVideoH264SequenceParameterSet " << pStdSPSsArray << "[] = {" << pStdSPSsNames << "};" << std::endl;
    }
    std::string pStdPPSsArray = "NULL";
    if (structInfo->pStdPPSs != NULL) {
        pStdPPSsArray = "pStdPPSs_" + std::to_string(consumer.getNextId());
        std::string pStdPPSsNames;
        for (uint32_t idx = 0; idx < structInfo->stdPPSCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStdPPSs + idx != NULL) {
                varName = GenerateStruct_StdVideoH264PictureParameterSet(out,
                                                         structInfo->pStdPPSs + idx,
                                                         metainfo->pStdPPSs->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStdPPSsNames += varName + ", ";
        }
        out << "StdVideoH264PictureParameterSet " << pStdPPSsArray << "[] = {" << pStdPPSsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stdSPSCount */
    structBody << "\t" << structInfo->stdSPSCount << "," << std::endl;
/* pStdSPSs */
    structBody << "\t" << pStdSPSsArray << "," << std::endl;
/* stdPPSCount */
    structBody << "\t" << structInfo->stdPPSCount << "," << std::endl;
/* pStdPPSs */
    structBody << "\t" << pStdPPSsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264SessionParametersAddInfoEXT");
    out << "VkVideoEncodeH264SessionParametersAddInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264SessionParametersCreateInfoEXT(std::ostream &out, const VkVideoEncodeH264SessionParametersCreateInfoEXT* structInfo, Decoded_VkVideoEncodeH264SessionParametersCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pParametersAddInfoStruct = "NULL";
    if (structInfo->pParametersAddInfo != NULL) {
        pParametersAddInfoStruct = GenerateStruct_VkVideoEncodeH264SessionParametersAddInfoEXT(out,
                                                                  structInfo->pParametersAddInfo,
                                                                  metainfo->pParametersAddInfo->GetMetaStructPointer(),
                                                                  consumer);
        pParametersAddInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxStdSPSCount */
    structBody << "\t" << structInfo->maxStdSPSCount << "," << std::endl;
/* maxStdPPSCount */
    structBody << "\t" << structInfo->maxStdPPSCount << "," << std::endl;
/* pParametersAddInfo */
    structBody << "\t" << pParametersAddInfoStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264SessionParametersCreateInfoEXT");
    out << "VkVideoEncodeH264SessionParametersCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264SessionParametersGetInfoEXT(std::ostream &out, const VkVideoEncodeH264SessionParametersGetInfoEXT* structInfo, Decoded_VkVideoEncodeH264SessionParametersGetInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* writeStdSPS */
    structBody << "\t" << structInfo->writeStdSPS << "," << std::endl;
/* writeStdPPS */
    structBody << "\t" << structInfo->writeStdPPS << "," << std::endl;
/* stdSPSId */
    structBody << "\t" << structInfo->stdSPSId << "," << std::endl;
/* stdPPSId */
    structBody << "\t" << structInfo->stdPPSId << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264SessionParametersGetInfoEXT");
    out << "VkVideoEncodeH264SessionParametersGetInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264SessionParametersFeedbackInfoEXT(std::ostream &out, const VkVideoEncodeH264SessionParametersFeedbackInfoEXT* structInfo, Decoded_VkVideoEncodeH264SessionParametersFeedbackInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* hasStdSPSOverrides */
    structBody << "\t" << structInfo->hasStdSPSOverrides << "," << std::endl;
/* hasStdPPSOverrides */
    structBody << "\t" << structInfo->hasStdPPSOverrides << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264SessionParametersFeedbackInfoEXT");
    out << "VkVideoEncodeH264SessionParametersFeedbackInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264NaluSliceInfoEXT(std::ostream &out, const VkVideoEncodeH264NaluSliceInfoEXT* structInfo, Decoded_VkVideoEncodeH264NaluSliceInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStdSliceHeaderStruct = "NULL";
    if (structInfo->pStdSliceHeader != NULL) {
        pStdSliceHeaderStruct = GenerateStruct_StdVideoEncodeH264SliceHeader(out,
                                                               structInfo->pStdSliceHeader,
                                                               metainfo->pStdSliceHeader->GetMetaStructPointer(),
                                                               consumer);
        pStdSliceHeaderStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* constantQp */
    structBody << "\t" << structInfo->constantQp << "," << std::endl;
/* pStdSliceHeader */
    structBody << "\t" << pStdSliceHeaderStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264NaluSliceInfoEXT");
    out << "VkVideoEncodeH264NaluSliceInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264PictureInfoEXT(std::ostream &out, const VkVideoEncodeH264PictureInfoEXT* structInfo, Decoded_VkVideoEncodeH264PictureInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pNaluSliceEntriesArray = "NULL";
    if (structInfo->pNaluSliceEntries != NULL) {
        pNaluSliceEntriesArray = "pNaluSliceEntries_" + std::to_string(consumer.getNextId());
        std::string pNaluSliceEntriesNames;
        for (uint32_t idx = 0; idx < structInfo->naluSliceEntryCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pNaluSliceEntries + idx != NULL) {
                varName = GenerateStruct_VkVideoEncodeH264NaluSliceInfoEXT(out,
                                                         structInfo->pNaluSliceEntries + idx,
                                                         metainfo->pNaluSliceEntries->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pNaluSliceEntriesNames += varName + ", ";
        }
        out << "VkVideoEncodeH264NaluSliceInfoEXT " << pNaluSliceEntriesArray << "[] = {" << pNaluSliceEntriesNames << "};" << std::endl;
    }
    std::string pStdPictureInfoStruct = "NULL";
    if (structInfo->pStdPictureInfo != NULL) {
        pStdPictureInfoStruct = GenerateStruct_StdVideoEncodeH264PictureInfo(out,
                                                               structInfo->pStdPictureInfo,
                                                               metainfo->pStdPictureInfo->GetMetaStructPointer(),
                                                               consumer);
        pStdPictureInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* naluSliceEntryCount */
    structBody << "\t" << structInfo->naluSliceEntryCount << "," << std::endl;
/* pNaluSliceEntries */
    structBody << "\t" << pNaluSliceEntriesArray << "," << std::endl;
/* pStdPictureInfo */
    structBody << "\t" << pStdPictureInfoStruct << "," << std::endl;
/* generatePrefixNalu */
    structBody << "\t" << structInfo->generatePrefixNalu << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264PictureInfoEXT");
    out << "VkVideoEncodeH264PictureInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264DpbSlotInfoEXT(std::ostream &out, const VkVideoEncodeH264DpbSlotInfoEXT* structInfo, Decoded_VkVideoEncodeH264DpbSlotInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStdReferenceInfoStruct = "NULL";
    if (structInfo->pStdReferenceInfo != NULL) {
        pStdReferenceInfoStruct = GenerateStruct_StdVideoEncodeH264ReferenceInfo(out,
                                                                 structInfo->pStdReferenceInfo,
                                                                 metainfo->pStdReferenceInfo->GetMetaStructPointer(),
                                                                 consumer);
        pStdReferenceInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pStdReferenceInfo */
    structBody << "\t" << pStdReferenceInfoStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264DpbSlotInfoEXT");
    out << "VkVideoEncodeH264DpbSlotInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264ProfileInfoEXT(std::ostream &out, const VkVideoEncodeH264ProfileInfoEXT* structInfo, Decoded_VkVideoEncodeH264ProfileInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stdProfileIdc */
    structBody << "\t" << "StdVideoH264ProfileIdc(" << structInfo->stdProfileIdc << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264ProfileInfoEXT");
    out << "VkVideoEncodeH264ProfileInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264RateControlInfoEXT(std::ostream &out, const VkVideoEncodeH264RateControlInfoEXT* structInfo, Decoded_VkVideoEncodeH264RateControlInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoEncodeH264RateControlFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* gopFrameCount */
    structBody << "\t" << structInfo->gopFrameCount << "," << std::endl;
/* idrPeriod */
    structBody << "\t" << structInfo->idrPeriod << "," << std::endl;
/* consecutiveBFrameCount */
    structBody << "\t" << structInfo->consecutiveBFrameCount << "," << std::endl;
/* temporalLayerCount */
    structBody << "\t" << structInfo->temporalLayerCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264RateControlInfoEXT");
    out << "VkVideoEncodeH264RateControlInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264FrameSizeEXT(std::ostream &out, const VkVideoEncodeH264FrameSizeEXT* structInfo, Decoded_VkVideoEncodeH264FrameSizeEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* frameISize */
    structBody << "\t" << structInfo->frameISize << "," << std::endl;
/* framePSize */
    structBody << "\t" << structInfo->framePSize << "," << std::endl;
/* frameBSize */
    structBody << "\t" << structInfo->frameBSize << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264FrameSizeEXT");
    out << "VkVideoEncodeH264FrameSizeEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264RateControlLayerInfoEXT(std::ostream &out, const VkVideoEncodeH264RateControlLayerInfoEXT* structInfo, Decoded_VkVideoEncodeH264RateControlLayerInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string minQpInfoVar = GenerateStruct_VkVideoEncodeH264QpEXT(out,
                                                              &structInfo->minQp,
                                                              metainfo->minQp,
                                                              consumer);
    std::string maxQpInfoVar = GenerateStruct_VkVideoEncodeH264QpEXT(out,
                                                              &structInfo->maxQp,
                                                              metainfo->maxQp,
                                                              consumer);
    std::string maxFrameSizeInfoVar = GenerateStruct_VkVideoEncodeH264FrameSizeEXT(out,
                                                                     &structInfo->maxFrameSize,
                                                                     metainfo->maxFrameSize,
                                                                     consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* useMinQp */
    structBody << "\t" << structInfo->useMinQp << "," << std::endl;
/* minQp */
    structBody << "\t" << minQpInfoVar << "," << std::endl;
/* useMaxQp */
    structBody << "\t" << structInfo->useMaxQp << "," << std::endl;
/* maxQp */
    structBody << "\t" << maxQpInfoVar << "," << std::endl;
/* useMaxFrameSize */
    structBody << "\t" << structInfo->useMaxFrameSize << "," << std::endl;
/* maxFrameSize */
    structBody << "\t" << maxFrameSizeInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264RateControlLayerInfoEXT");
    out << "VkVideoEncodeH264RateControlLayerInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH264GopRemainingFrameInfoEXT(std::ostream &out, const VkVideoEncodeH264GopRemainingFrameInfoEXT* structInfo, Decoded_VkVideoEncodeH264GopRemainingFrameInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* useGopRemainingFrames */
    structBody << "\t" << structInfo->useGopRemainingFrames << "," << std::endl;
/* gopRemainingI */
    structBody << "\t" << structInfo->gopRemainingI << "," << std::endl;
/* gopRemainingP */
    structBody << "\t" << structInfo->gopRemainingP << "," << std::endl;
/* gopRemainingB */
    structBody << "\t" << structInfo->gopRemainingB << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH264GopRemainingFrameInfoEXT");
    out << "VkVideoEncodeH264GopRemainingFrameInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265CapabilitiesEXT(std::ostream &out, const VkVideoEncodeH265CapabilitiesEXT* structInfo, Decoded_VkVideoEncodeH265CapabilitiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string maxTilesInfoVar = GenerateStruct_VkExtent2D(out,
                                                                 &structInfo->maxTiles,
                                                                 metainfo->maxTiles,
                                                                 consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoEncodeH265CapabilityFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* maxLevelIdc */
    structBody << "\t" << "StdVideoH265LevelIdc(" << structInfo->maxLevelIdc << ")" << "," << std::endl;
/* maxSliceSegmentCount */
    structBody << "\t" << structInfo->maxSliceSegmentCount << "," << std::endl;
/* maxTiles */
    structBody << "\t" << maxTilesInfoVar << "," << std::endl;
/* ctbSizes */
    structBody << "\t" << "VkVideoEncodeH265CtbSizeFlagsEXT(" << structInfo->ctbSizes << ")" << "," << std::endl;
/* transformBlockSizes */
    structBody << "\t" << "VkVideoEncodeH265TransformBlockSizeFlagsEXT(" << structInfo->transformBlockSizes << ")" << "," << std::endl;
/* maxPPictureL0ReferenceCount */
    structBody << "\t" << structInfo->maxPPictureL0ReferenceCount << "," << std::endl;
/* maxBPictureL0ReferenceCount */
    structBody << "\t" << structInfo->maxBPictureL0ReferenceCount << "," << std::endl;
/* maxL1ReferenceCount */
    structBody << "\t" << structInfo->maxL1ReferenceCount << "," << std::endl;
/* maxSubLayerCount */
    structBody << "\t" << structInfo->maxSubLayerCount << "," << std::endl;
/* expectDyadicTemporalSubLayerPattern */
    structBody << "\t" << structInfo->expectDyadicTemporalSubLayerPattern << "," << std::endl;
/* minQp */
    structBody << "\t" << structInfo->minQp << "," << std::endl;
/* maxQp */
    structBody << "\t" << structInfo->maxQp << "," << std::endl;
/* prefersGopRemainingFrames */
    structBody << "\t" << structInfo->prefersGopRemainingFrames << "," << std::endl;
/* requiresGopRemainingFrames */
    structBody << "\t" << structInfo->requiresGopRemainingFrames << "," << std::endl;
/* stdSyntaxFlags */
    structBody << "\t" << "VkVideoEncodeH265StdFlagsEXT(" << structInfo->stdSyntaxFlags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265CapabilitiesEXT");
    out << "VkVideoEncodeH265CapabilitiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265SessionCreateInfoEXT(std::ostream &out, const VkVideoEncodeH265SessionCreateInfoEXT* structInfo, Decoded_VkVideoEncodeH265SessionCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* useMaxLevelIdc */
    structBody << "\t" << structInfo->useMaxLevelIdc << "," << std::endl;
/* maxLevelIdc */
    structBody << "\t" << "StdVideoH265LevelIdc(" << structInfo->maxLevelIdc << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265SessionCreateInfoEXT");
    out << "VkVideoEncodeH265SessionCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265QpEXT(std::ostream &out, const VkVideoEncodeH265QpEXT* structInfo, Decoded_VkVideoEncodeH265QpEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* qpI */
    structBody << "\t" << structInfo->qpI << "," << std::endl;
/* qpP */
    structBody << "\t" << structInfo->qpP << "," << std::endl;
/* qpB */
    structBody << "\t" << structInfo->qpB << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265QpEXT");
    out << "VkVideoEncodeH265QpEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265QualityLevelPropertiesEXT(std::ostream &out, const VkVideoEncodeH265QualityLevelPropertiesEXT* structInfo, Decoded_VkVideoEncodeH265QualityLevelPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string preferredConstantQpInfoVar = GenerateStruct_VkVideoEncodeH265QpEXT(out,
                                                                            &structInfo->preferredConstantQp,
                                                                            metainfo->preferredConstantQp,
                                                                            consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* preferredRateControlFlags */
    structBody << "\t" << "VkVideoEncodeH265RateControlFlagsEXT(" << structInfo->preferredRateControlFlags << ")" << "," << std::endl;
/* preferredGopFrameCount */
    structBody << "\t" << structInfo->preferredGopFrameCount << "," << std::endl;
/* preferredIdrPeriod */
    structBody << "\t" << structInfo->preferredIdrPeriod << "," << std::endl;
/* preferredConsecutiveBFrameCount */
    structBody << "\t" << structInfo->preferredConsecutiveBFrameCount << "," << std::endl;
/* preferredSubLayerCount */
    structBody << "\t" << structInfo->preferredSubLayerCount << "," << std::endl;
/* preferredConstantQp */
    structBody << "\t" << preferredConstantQpInfoVar << "," << std::endl;
/* preferredMaxL0ReferenceCount */
    structBody << "\t" << structInfo->preferredMaxL0ReferenceCount << "," << std::endl;
/* preferredMaxL1ReferenceCount */
    structBody << "\t" << structInfo->preferredMaxL1ReferenceCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265QualityLevelPropertiesEXT");
    out << "VkVideoEncodeH265QualityLevelPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265SessionParametersAddInfoEXT(std::ostream &out, const VkVideoEncodeH265SessionParametersAddInfoEXT* structInfo, Decoded_VkVideoEncodeH265SessionParametersAddInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStdVPSsArray = "NULL";
    if (structInfo->pStdVPSs != NULL) {
        pStdVPSsArray = "pStdVPSs_" + std::to_string(consumer.getNextId());
        std::string pStdVPSsNames;
        for (uint32_t idx = 0; idx < structInfo->stdVPSCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStdVPSs + idx != NULL) {
                varName = GenerateStruct_StdVideoH265VideoParameterSet(out,
                                                         structInfo->pStdVPSs + idx,
                                                         metainfo->pStdVPSs->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStdVPSsNames += varName + ", ";
        }
        out << "StdVideoH265VideoParameterSet " << pStdVPSsArray << "[] = {" << pStdVPSsNames << "};" << std::endl;
    }
    std::string pStdSPSsArray = "NULL";
    if (structInfo->pStdSPSs != NULL) {
        pStdSPSsArray = "pStdSPSs_" + std::to_string(consumer.getNextId());
        std::string pStdSPSsNames;
        for (uint32_t idx = 0; idx < structInfo->stdSPSCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStdSPSs + idx != NULL) {
                varName = GenerateStruct_StdVideoH265SequenceParameterSet(out,
                                                         structInfo->pStdSPSs + idx,
                                                         metainfo->pStdSPSs->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStdSPSsNames += varName + ", ";
        }
        out << "StdVideoH265SequenceParameterSet " << pStdSPSsArray << "[] = {" << pStdSPSsNames << "};" << std::endl;
    }
    std::string pStdPPSsArray = "NULL";
    if (structInfo->pStdPPSs != NULL) {
        pStdPPSsArray = "pStdPPSs_" + std::to_string(consumer.getNextId());
        std::string pStdPPSsNames;
        for (uint32_t idx = 0; idx < structInfo->stdPPSCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStdPPSs + idx != NULL) {
                varName = GenerateStruct_StdVideoH265PictureParameterSet(out,
                                                         structInfo->pStdPPSs + idx,
                                                         metainfo->pStdPPSs->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStdPPSsNames += varName + ", ";
        }
        out << "StdVideoH265PictureParameterSet " << pStdPPSsArray << "[] = {" << pStdPPSsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stdVPSCount */
    structBody << "\t" << structInfo->stdVPSCount << "," << std::endl;
/* pStdVPSs */
    structBody << "\t" << pStdVPSsArray << "," << std::endl;
/* stdSPSCount */
    structBody << "\t" << structInfo->stdSPSCount << "," << std::endl;
/* pStdSPSs */
    structBody << "\t" << pStdSPSsArray << "," << std::endl;
/* stdPPSCount */
    structBody << "\t" << structInfo->stdPPSCount << "," << std::endl;
/* pStdPPSs */
    structBody << "\t" << pStdPPSsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265SessionParametersAddInfoEXT");
    out << "VkVideoEncodeH265SessionParametersAddInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265SessionParametersCreateInfoEXT(std::ostream &out, const VkVideoEncodeH265SessionParametersCreateInfoEXT* structInfo, Decoded_VkVideoEncodeH265SessionParametersCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pParametersAddInfoStruct = "NULL";
    if (structInfo->pParametersAddInfo != NULL) {
        pParametersAddInfoStruct = GenerateStruct_VkVideoEncodeH265SessionParametersAddInfoEXT(out,
                                                                  structInfo->pParametersAddInfo,
                                                                  metainfo->pParametersAddInfo->GetMetaStructPointer(),
                                                                  consumer);
        pParametersAddInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxStdVPSCount */
    structBody << "\t" << structInfo->maxStdVPSCount << "," << std::endl;
/* maxStdSPSCount */
    structBody << "\t" << structInfo->maxStdSPSCount << "," << std::endl;
/* maxStdPPSCount */
    structBody << "\t" << structInfo->maxStdPPSCount << "," << std::endl;
/* pParametersAddInfo */
    structBody << "\t" << pParametersAddInfoStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265SessionParametersCreateInfoEXT");
    out << "VkVideoEncodeH265SessionParametersCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265SessionParametersGetInfoEXT(std::ostream &out, const VkVideoEncodeH265SessionParametersGetInfoEXT* structInfo, Decoded_VkVideoEncodeH265SessionParametersGetInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* writeStdVPS */
    structBody << "\t" << structInfo->writeStdVPS << "," << std::endl;
/* writeStdSPS */
    structBody << "\t" << structInfo->writeStdSPS << "," << std::endl;
/* writeStdPPS */
    structBody << "\t" << structInfo->writeStdPPS << "," << std::endl;
/* stdVPSId */
    structBody << "\t" << structInfo->stdVPSId << "," << std::endl;
/* stdSPSId */
    structBody << "\t" << structInfo->stdSPSId << "," << std::endl;
/* stdPPSId */
    structBody << "\t" << structInfo->stdPPSId << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265SessionParametersGetInfoEXT");
    out << "VkVideoEncodeH265SessionParametersGetInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265SessionParametersFeedbackInfoEXT(std::ostream &out, const VkVideoEncodeH265SessionParametersFeedbackInfoEXT* structInfo, Decoded_VkVideoEncodeH265SessionParametersFeedbackInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* hasStdVPSOverrides */
    structBody << "\t" << structInfo->hasStdVPSOverrides << "," << std::endl;
/* hasStdSPSOverrides */
    structBody << "\t" << structInfo->hasStdSPSOverrides << "," << std::endl;
/* hasStdPPSOverrides */
    structBody << "\t" << structInfo->hasStdPPSOverrides << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265SessionParametersFeedbackInfoEXT");
    out << "VkVideoEncodeH265SessionParametersFeedbackInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265NaluSliceSegmentInfoEXT(std::ostream &out, const VkVideoEncodeH265NaluSliceSegmentInfoEXT* structInfo, Decoded_VkVideoEncodeH265NaluSliceSegmentInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStdSliceSegmentHeaderStruct = "NULL";
    if (structInfo->pStdSliceSegmentHeader != NULL) {
        pStdSliceSegmentHeaderStruct = GenerateStruct_StdVideoEncodeH265SliceSegmentHeader(out,
                                                                      structInfo->pStdSliceSegmentHeader,
                                                                      metainfo->pStdSliceSegmentHeader->GetMetaStructPointer(),
                                                                      consumer);
        pStdSliceSegmentHeaderStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* constantQp */
    structBody << "\t" << structInfo->constantQp << "," << std::endl;
/* pStdSliceSegmentHeader */
    structBody << "\t" << pStdSliceSegmentHeaderStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265NaluSliceSegmentInfoEXT");
    out << "VkVideoEncodeH265NaluSliceSegmentInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265PictureInfoEXT(std::ostream &out, const VkVideoEncodeH265PictureInfoEXT* structInfo, Decoded_VkVideoEncodeH265PictureInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pNaluSliceSegmentEntriesArray = "NULL";
    if (structInfo->pNaluSliceSegmentEntries != NULL) {
        pNaluSliceSegmentEntriesArray = "pNaluSliceSegmentEntries_" + std::to_string(consumer.getNextId());
        std::string pNaluSliceSegmentEntriesNames;
        for (uint32_t idx = 0; idx < structInfo->naluSliceSegmentEntryCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pNaluSliceSegmentEntries + idx != NULL) {
                varName = GenerateStruct_VkVideoEncodeH265NaluSliceSegmentInfoEXT(out,
                                                         structInfo->pNaluSliceSegmentEntries + idx,
                                                         metainfo->pNaluSliceSegmentEntries->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pNaluSliceSegmentEntriesNames += varName + ", ";
        }
        out << "VkVideoEncodeH265NaluSliceSegmentInfoEXT " << pNaluSliceSegmentEntriesArray << "[] = {" << pNaluSliceSegmentEntriesNames << "};" << std::endl;
    }
    std::string pStdPictureInfoStruct = "NULL";
    if (structInfo->pStdPictureInfo != NULL) {
        pStdPictureInfoStruct = GenerateStruct_StdVideoEncodeH265PictureInfo(out,
                                                               structInfo->pStdPictureInfo,
                                                               metainfo->pStdPictureInfo->GetMetaStructPointer(),
                                                               consumer);
        pStdPictureInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* naluSliceSegmentEntryCount */
    structBody << "\t" << structInfo->naluSliceSegmentEntryCount << "," << std::endl;
/* pNaluSliceSegmentEntries */
    structBody << "\t" << pNaluSliceSegmentEntriesArray << "," << std::endl;
/* pStdPictureInfo */
    structBody << "\t" << pStdPictureInfoStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265PictureInfoEXT");
    out << "VkVideoEncodeH265PictureInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265DpbSlotInfoEXT(std::ostream &out, const VkVideoEncodeH265DpbSlotInfoEXT* structInfo, Decoded_VkVideoEncodeH265DpbSlotInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStdReferenceInfoStruct = "NULL";
    if (structInfo->pStdReferenceInfo != NULL) {
        pStdReferenceInfoStruct = GenerateStruct_StdVideoEncodeH265ReferenceInfo(out,
                                                                 structInfo->pStdReferenceInfo,
                                                                 metainfo->pStdReferenceInfo->GetMetaStructPointer(),
                                                                 consumer);
        pStdReferenceInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pStdReferenceInfo */
    structBody << "\t" << pStdReferenceInfoStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265DpbSlotInfoEXT");
    out << "VkVideoEncodeH265DpbSlotInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265ProfileInfoEXT(std::ostream &out, const VkVideoEncodeH265ProfileInfoEXT* structInfo, Decoded_VkVideoEncodeH265ProfileInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stdProfileIdc */
    structBody << "\t" << "StdVideoH265ProfileIdc(" << structInfo->stdProfileIdc << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265ProfileInfoEXT");
    out << "VkVideoEncodeH265ProfileInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265RateControlInfoEXT(std::ostream &out, const VkVideoEncodeH265RateControlInfoEXT* structInfo, Decoded_VkVideoEncodeH265RateControlInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkVideoEncodeH265RateControlFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* gopFrameCount */
    structBody << "\t" << structInfo->gopFrameCount << "," << std::endl;
/* idrPeriod */
    structBody << "\t" << structInfo->idrPeriod << "," << std::endl;
/* consecutiveBFrameCount */
    structBody << "\t" << structInfo->consecutiveBFrameCount << "," << std::endl;
/* subLayerCount */
    structBody << "\t" << structInfo->subLayerCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265RateControlInfoEXT");
    out << "VkVideoEncodeH265RateControlInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265FrameSizeEXT(std::ostream &out, const VkVideoEncodeH265FrameSizeEXT* structInfo, Decoded_VkVideoEncodeH265FrameSizeEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* frameISize */
    structBody << "\t" << structInfo->frameISize << "," << std::endl;
/* framePSize */
    structBody << "\t" << structInfo->framePSize << "," << std::endl;
/* frameBSize */
    structBody << "\t" << structInfo->frameBSize << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265FrameSizeEXT");
    out << "VkVideoEncodeH265FrameSizeEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265RateControlLayerInfoEXT(std::ostream &out, const VkVideoEncodeH265RateControlLayerInfoEXT* structInfo, Decoded_VkVideoEncodeH265RateControlLayerInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string minQpInfoVar = GenerateStruct_VkVideoEncodeH265QpEXT(out,
                                                              &structInfo->minQp,
                                                              metainfo->minQp,
                                                              consumer);
    std::string maxQpInfoVar = GenerateStruct_VkVideoEncodeH265QpEXT(out,
                                                              &structInfo->maxQp,
                                                              metainfo->maxQp,
                                                              consumer);
    std::string maxFrameSizeInfoVar = GenerateStruct_VkVideoEncodeH265FrameSizeEXT(out,
                                                                     &structInfo->maxFrameSize,
                                                                     metainfo->maxFrameSize,
                                                                     consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* useMinQp */
    structBody << "\t" << structInfo->useMinQp << "," << std::endl;
/* minQp */
    structBody << "\t" << minQpInfoVar << "," << std::endl;
/* useMaxQp */
    structBody << "\t" << structInfo->useMaxQp << "," << std::endl;
/* maxQp */
    structBody << "\t" << maxQpInfoVar << "," << std::endl;
/* useMaxFrameSize */
    structBody << "\t" << structInfo->useMaxFrameSize << "," << std::endl;
/* maxFrameSize */
    structBody << "\t" << maxFrameSizeInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265RateControlLayerInfoEXT");
    out << "VkVideoEncodeH265RateControlLayerInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVideoEncodeH265GopRemainingFrameInfoEXT(std::ostream &out, const VkVideoEncodeH265GopRemainingFrameInfoEXT* structInfo, Decoded_VkVideoEncodeH265GopRemainingFrameInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* useGopRemainingFrames */
    structBody << "\t" << structInfo->useGopRemainingFrames << "," << std::endl;
/* gopRemainingI */
    structBody << "\t" << structInfo->gopRemainingI << "," << std::endl;
/* gopRemainingP */
    structBody << "\t" << structInfo->gopRemainingP << "," << std::endl;
/* gopRemainingB */
    structBody << "\t" << structInfo->gopRemainingB << "," ;
    std::string varname = consumer.AddStruct(structBody, "videoEncodeH265GopRemainingFrameInfoEXT");
    out << "VkVideoEncodeH265GopRemainingFrameInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkTextureLODGatherFormatPropertiesAMD(std::ostream &out, const VkTextureLODGatherFormatPropertiesAMD* structInfo, Decoded_VkTextureLODGatherFormatPropertiesAMD* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* supportsTextureGatherLODBiasAMD */
    structBody << "\t" << structInfo->supportsTextureGatherLODBiasAMD << "," ;
    std::string varname = consumer.AddStruct(structBody, "textureLODGatherFormatPropertiesAMD");
    out << "VkTextureLODGatherFormatPropertiesAMD " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkShaderResourceUsageAMD(std::ostream &out, const VkShaderResourceUsageAMD* structInfo, Decoded_VkShaderResourceUsageAMD* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* numUsedVgprs */
    structBody << "\t" << structInfo->numUsedVgprs << "," << std::endl;
/* numUsedSgprs */
    structBody << "\t" << structInfo->numUsedSgprs << "," << std::endl;
/* ldsSizePerLocalWorkGroup */
    structBody << "\t" << structInfo->ldsSizePerLocalWorkGroup << "," << std::endl;
/* ldsUsageSizeInBytes */
    structBody << "\t" << structInfo->ldsUsageSizeInBytes << "," << std::endl;
/* scratchMemUsageInBytes */
    structBody << "\t" << structInfo->scratchMemUsageInBytes << "," ;
    std::string varname = consumer.AddStruct(structBody, "shaderResourceUsageAMD");
    out << "VkShaderResourceUsageAMD " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkShaderStatisticsInfoAMD(std::ostream &out, const VkShaderStatisticsInfoAMD* structInfo, Decoded_VkShaderStatisticsInfoAMD* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string resourceUsageInfoVar = GenerateStruct_VkShaderResourceUsageAMD(out,
                                                                      &structInfo->resourceUsage,
                                                                      metainfo->resourceUsage,
                                                                      consumer);
/* shaderStageMask */
    structBody << "\t" << "VkShaderStageFlags(" << structInfo->shaderStageMask << ")" << "," << std::endl;
/* resourceUsage */
    structBody << "\t" << resourceUsageInfoVar << "," << std::endl;
/* numPhysicalVgprs */
    structBody << "\t" << structInfo->numPhysicalVgprs << "," << std::endl;
/* numPhysicalSgprs */
    structBody << "\t" << structInfo->numPhysicalSgprs << "," << std::endl;
/* numAvailableVgprs */
    structBody << "\t" << structInfo->numAvailableVgprs << "," << std::endl;
/* numAvailableSgprs */
    structBody << "\t" << structInfo->numAvailableSgprs << "," << std::endl;
/* computeWorkGroupSize */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->computeWorkGroupSize[0]), 3) << "," ;
    std::string varname = consumer.AddStruct(structBody, "shaderStatisticsInfoAMD");
    out << "VkShaderStatisticsInfoAMD " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkStreamDescriptorSurfaceCreateInfoGGP(std::ostream &out, const VkStreamDescriptorSurfaceCreateInfoGGP* structInfo, Decoded_VkStreamDescriptorSurfaceCreateInfoGGP* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkStreamDescriptorSurfaceCreateFlagsGGP(" << structInfo->flags << ")" << "," << std::endl;
/* streamDescriptor */
    structBody << "\t" << structInfo->streamDescriptor << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "streamDescriptorSurfaceCreateInfoGGP");
    out << "VkStreamDescriptorSurfaceCreateInfoGGP " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceCornerSampledImageFeaturesNV(std::ostream &out, const VkPhysicalDeviceCornerSampledImageFeaturesNV* structInfo, Decoded_VkPhysicalDeviceCornerSampledImageFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* cornerSampledImage */
    structBody << "\t" << structInfo->cornerSampledImage << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceCornerSampledImageFeaturesNV");
    out << "VkPhysicalDeviceCornerSampledImageFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExternalImageFormatPropertiesNV(std::ostream &out, const VkExternalImageFormatPropertiesNV* structInfo, Decoded_VkExternalImageFormatPropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string imageFormatPropertiesInfoVar = GenerateStruct_VkImageFormatProperties(out,
                                                                              &structInfo->imageFormatProperties,
                                                                              metainfo->imageFormatProperties,
                                                                              consumer);
/* imageFormatProperties */
    structBody << "\t" << imageFormatPropertiesInfoVar << "," << std::endl;
/* externalMemoryFeatures */
    structBody << "\t" << "VkExternalMemoryFeatureFlagsNV(" << structInfo->externalMemoryFeatures << ")" << "," << std::endl;
/* exportFromImportedHandleTypes */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->exportFromImportedHandleTypes << ")" << "," << std::endl;
/* compatibleHandleTypes */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->compatibleHandleTypes << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "externalImageFormatPropertiesNV");
    out << "VkExternalImageFormatPropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExternalMemoryImageCreateInfoNV(std::ostream &out, const VkExternalMemoryImageCreateInfoNV* structInfo, Decoded_VkExternalMemoryImageCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleTypes */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->handleTypes << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "externalMemoryImageCreateInfoNV");
    out << "VkExternalMemoryImageCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExportMemoryAllocateInfoNV(std::ostream &out, const VkExportMemoryAllocateInfoNV* structInfo, Decoded_VkExportMemoryAllocateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleTypes */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->handleTypes << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "exportMemoryAllocateInfoNV");
    out << "VkExportMemoryAllocateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImportMemoryWin32HandleInfoNV(std::ostream &out, const VkImportMemoryWin32HandleInfoNV* structInfo, Decoded_VkImportMemoryWin32HandleInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagsNV(" << structInfo->handleType << ")" << "," << std::endl;
/* handle */
    structBody << "\t" << structInfo->handle << "," ;
    std::string varname = consumer.AddStruct(structBody, "importMemoryWin32HandleInfoNV");
    out << "VkImportMemoryWin32HandleInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExportMemoryWin32HandleInfoNV(std::ostream &out, const VkExportMemoryWin32HandleInfoNV* structInfo, Decoded_VkExportMemoryWin32HandleInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pAttributes */
    structBody << "\t" << structInfo->pAttributes << "," << std::endl;
/* dwAccess */
    structBody << "\t" << structInfo->dwAccess << "," ;
    std::string varname = consumer.AddStruct(structBody, "exportMemoryWin32HandleInfoNV");
    out << "VkExportMemoryWin32HandleInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkWin32KeyedMutexAcquireReleaseInfoNV(std::ostream &out, const VkWin32KeyedMutexAcquireReleaseInfoNV* structInfo, Decoded_VkWin32KeyedMutexAcquireReleaseInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pAcquireSyncsArray = "NULL";
    if (metainfo->pAcquireSyncs.GetPointer() != NULL && structInfo->acquireCount > 0) {
        pAcquireSyncsArray = "pAcquireSyncsArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_DEVICE_MEMORY));
        std::string pAcquireSyncsValues = toStringJoin(metainfo->pAcquireSyncs.GetPointer(),
                                                       metainfo->pAcquireSyncs.GetPointer() + structInfo->acquireCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->acquireCount == 1) {
            pAcquireSyncsArray = "&" + pAcquireSyncsValues;
        } else if (structInfo->acquireCount > 1) {
            out << "VkDeviceMemory " << pAcquireSyncsArray << "[] = {" << pAcquireSyncsValues << "};" << std::endl;
        }
    }
    std::string pAcquireKeysArray = "pAcquireKeysArray_" + std::to_string(consumer.getNextId());
    if (structInfo->acquireCount > 0) {
        std::string pAcquireKeysValues = toStringJoin(structInfo->pAcquireKeys,
                                                      structInfo->pAcquireKeys + structInfo->acquireCount,
                                                      [](uint64_t current) { return std::to_string(current); },
                                                      ", ");
        if (structInfo->acquireCount == 1) {
            pAcquireKeysArray = "&" + pAcquireKeysValues;
        } else if (structInfo->acquireCount > 1) {
            out << "uint64_t " << pAcquireKeysArray << "[] = {" << pAcquireKeysValues << "};" << std::endl;
        }
    }
    std::string pAcquireTimeoutMillisecondsArray = "NULL";
    if (structInfo->pAcquireTimeoutMilliseconds != NULL) {
        pAcquireTimeoutMillisecondsArray = "pAcquireTimeoutMilliseconds_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pAcquireTimeoutMillisecondsArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pAcquireTimeoutMilliseconds, structInfo->acquireCount) << ";" << std::endl;
    }
    std::string pReleaseSyncsArray = "NULL";
    if (metainfo->pReleaseSyncs.GetPointer() != NULL && structInfo->releaseCount > 0) {
        pReleaseSyncsArray = "pReleaseSyncsArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_DEVICE_MEMORY));
        std::string pReleaseSyncsValues = toStringJoin(metainfo->pReleaseSyncs.GetPointer(),
                                                       metainfo->pReleaseSyncs.GetPointer() + structInfo->releaseCount,
                                                       [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                       ", ");
        if (structInfo->releaseCount == 1) {
            pReleaseSyncsArray = "&" + pReleaseSyncsValues;
        } else if (structInfo->releaseCount > 1) {
            out << "VkDeviceMemory " << pReleaseSyncsArray << "[] = {" << pReleaseSyncsValues << "};" << std::endl;
        }
    }
    std::string pReleaseKeysArray = "pReleaseKeysArray_" + std::to_string(consumer.getNextId());
    if (structInfo->releaseCount > 0) {
        std::string pReleaseKeysValues = toStringJoin(structInfo->pReleaseKeys,
                                                      structInfo->pReleaseKeys + structInfo->releaseCount,
                                                      [](uint64_t current) { return std::to_string(current); },
                                                      ", ");
        if (structInfo->releaseCount == 1) {
            pReleaseKeysArray = "&" + pReleaseKeysValues;
        } else if (structInfo->releaseCount > 1) {
            out << "uint64_t " << pReleaseKeysArray << "[] = {" << pReleaseKeysValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* acquireCount */
    structBody << "\t" << structInfo->acquireCount << "," << std::endl;
/* pAcquireSyncs */
    structBody << "\t" << pAcquireSyncsArray << "," << std::endl;
/* pAcquireKeys */
    structBody << "\t" << "{ *" << pAcquireKeysArray << " }" << "," << std::endl;
/* pAcquireTimeoutMilliseconds */
    structBody << "\t" << pAcquireTimeoutMillisecondsArray << "," << std::endl;
/* releaseCount */
    structBody << "\t" << structInfo->releaseCount << "," << std::endl;
/* pReleaseSyncs */
    structBody << "\t" << pReleaseSyncsArray << "," << std::endl;
/* pReleaseKeys */
    structBody << "\t" << "{ *" << pReleaseKeysArray << " }" << "," ;
    std::string varname = consumer.AddStruct(structBody, "win32KeyedMutexAcquireReleaseInfoNV");
    out << "VkWin32KeyedMutexAcquireReleaseInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkValidationFlagsEXT(std::ostream &out, const VkValidationFlagsEXT* structInfo, Decoded_VkValidationFlagsEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDisabledValidationChecksValues;
    std::string pDisabledValidationChecksArray = "NULL";
    if (structInfo->pDisabledValidationChecks != NULL) {
        for (uint32_t idx = 0; idx < structInfo->disabledValidationCheckCount; idx++) {
            pDisabledValidationChecksValues += util::ToString<VkValidationCheckEXT>(structInfo->pDisabledValidationChecks[idx]) + ", ";
        }
        pDisabledValidationChecksArray = "pDisabledValidationChecks_" + std::to_string(consumer.getNextId());
        out << "VkValidationCheckEXT " << pDisabledValidationChecksArray << "[] = {" << pDisabledValidationChecksValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* disabledValidationCheckCount */
    structBody << "\t" << structInfo->disabledValidationCheckCount << "," << std::endl;
/* pDisabledValidationChecks */
    structBody << "\t" << pDisabledValidationChecksArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "validationFlagsEXT");
    out << "VkValidationFlagsEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkViSurfaceCreateInfoNN(std::ostream &out, const VkViSurfaceCreateInfoNN* structInfo, Decoded_VkViSurfaceCreateInfoNN* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkViSurfaceCreateFlagsNN(" << structInfo->flags << ")" << "," << std::endl;
/* window */
    out << "// TODO: Support window (output?) argument." << std::endl;
    std::string varname = consumer.AddStruct(structBody, "viSurfaceCreateInfoNN");
    out << "VkViSurfaceCreateInfoNN " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageViewASTCDecodeModeEXT(std::ostream &out, const VkImageViewASTCDecodeModeEXT* structInfo, Decoded_VkImageViewASTCDecodeModeEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* decodeMode */
    structBody << "\t" << "VkFormat(" << structInfo->decodeMode << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageViewASTCDecodeModeEXT");
    out << "VkImageViewASTCDecodeModeEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceASTCDecodeFeaturesEXT(std::ostream &out, const VkPhysicalDeviceASTCDecodeFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceASTCDecodeFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* decodeModeSharedExponent */
    structBody << "\t" << structInfo->decodeModeSharedExponent << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceASTCDecodeFeaturesEXT");
    out << "VkPhysicalDeviceASTCDecodeFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePipelineRobustnessFeaturesEXT(std::ostream &out, const VkPhysicalDevicePipelineRobustnessFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePipelineRobustnessFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pipelineRobustness */
    structBody << "\t" << structInfo->pipelineRobustness << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePipelineRobustnessFeaturesEXT");
    out << "VkPhysicalDevicePipelineRobustnessFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePipelineRobustnessPropertiesEXT(std::ostream &out, const VkPhysicalDevicePipelineRobustnessPropertiesEXT* structInfo, Decoded_VkPhysicalDevicePipelineRobustnessPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* defaultRobustnessStorageBuffers */
    structBody << "\t" << "VkPipelineRobustnessBufferBehaviorEXT(" << structInfo->defaultRobustnessStorageBuffers << ")" << "," << std::endl;
/* defaultRobustnessUniformBuffers */
    structBody << "\t" << "VkPipelineRobustnessBufferBehaviorEXT(" << structInfo->defaultRobustnessUniformBuffers << ")" << "," << std::endl;
/* defaultRobustnessVertexInputs */
    structBody << "\t" << "VkPipelineRobustnessBufferBehaviorEXT(" << structInfo->defaultRobustnessVertexInputs << ")" << "," << std::endl;
/* defaultRobustnessImages */
    structBody << "\t" << "VkPipelineRobustnessImageBehaviorEXT(" << structInfo->defaultRobustnessImages << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePipelineRobustnessPropertiesEXT");
    out << "VkPhysicalDevicePipelineRobustnessPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineRobustnessCreateInfoEXT(std::ostream &out, const VkPipelineRobustnessCreateInfoEXT* structInfo, Decoded_VkPipelineRobustnessCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* storageBuffers */
    structBody << "\t" << "VkPipelineRobustnessBufferBehaviorEXT(" << structInfo->storageBuffers << ")" << "," << std::endl;
/* uniformBuffers */
    structBody << "\t" << "VkPipelineRobustnessBufferBehaviorEXT(" << structInfo->uniformBuffers << ")" << "," << std::endl;
/* vertexInputs */
    structBody << "\t" << "VkPipelineRobustnessBufferBehaviorEXT(" << structInfo->vertexInputs << ")" << "," << std::endl;
/* images */
    structBody << "\t" << "VkPipelineRobustnessImageBehaviorEXT(" << structInfo->images << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineRobustnessCreateInfoEXT");
    out << "VkPipelineRobustnessCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkConditionalRenderingBeginInfoEXT(std::ostream &out, const VkConditionalRenderingBeginInfoEXT* structInfo, Decoded_VkConditionalRenderingBeginInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* buffer */
    structBody << "\t" << consumer.GetHandle(metainfo->buffer) << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "UL" << "," << std::endl;
/* flags */
    structBody << "\t" << "VkConditionalRenderingFlagsEXT(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "conditionalRenderingBeginInfoEXT");
    out << "VkConditionalRenderingBeginInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceConditionalRenderingFeaturesEXT(std::ostream &out, const VkPhysicalDeviceConditionalRenderingFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceConditionalRenderingFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* conditionalRendering */
    structBody << "\t" << structInfo->conditionalRendering << "," << std::endl;
/* inheritedConditionalRendering */
    structBody << "\t" << structInfo->inheritedConditionalRendering << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceConditionalRenderingFeaturesEXT");
    out << "VkPhysicalDeviceConditionalRenderingFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCommandBufferInheritanceConditionalRenderingInfoEXT(std::ostream &out, const VkCommandBufferInheritanceConditionalRenderingInfoEXT* structInfo, Decoded_VkCommandBufferInheritanceConditionalRenderingInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* conditionalRenderingEnable */
    structBody << "\t" << structInfo->conditionalRenderingEnable << "," ;
    std::string varname = consumer.AddStruct(structBody, "commandBufferInheritanceConditionalRenderingInfoEXT");
    out << "VkCommandBufferInheritanceConditionalRenderingInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkViewportWScalingNV(std::ostream &out, const VkViewportWScalingNV* structInfo, Decoded_VkViewportWScalingNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* xcoeff */
    structBody << "\t" << structInfo->xcoeff << "," << std::endl;
/* ycoeff */
    structBody << "\t" << structInfo->ycoeff << "," ;
    std::string varname = consumer.AddStruct(structBody, "viewportWScalingNV");
    out << "VkViewportWScalingNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineViewportWScalingStateCreateInfoNV(std::ostream &out, const VkPipelineViewportWScalingStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportWScalingStateCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pViewportWScalingsArray = "NULL";
    if (structInfo->pViewportWScalings != NULL) {
        pViewportWScalingsArray = "pViewportWScalings_" + std::to_string(consumer.getNextId());
        std::string pViewportWScalingsNames;
        for (uint32_t idx = 0; idx < structInfo->viewportCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pViewportWScalings + idx != NULL) {
                varName = GenerateStruct_VkViewportWScalingNV(out,
                                                         structInfo->pViewportWScalings + idx,
                                                         metainfo->pViewportWScalings->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pViewportWScalingsNames += varName + ", ";
        }
        out << "VkViewportWScalingNV " << pViewportWScalingsArray << "[] = {" << pViewportWScalingsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* viewportWScalingEnable */
    structBody << "\t" << structInfo->viewportWScalingEnable << "," << std::endl;
/* viewportCount */
    structBody << "\t" << structInfo->viewportCount << "," << std::endl;
/* pViewportWScalings */
    structBody << "\t" << pViewportWScalingsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineViewportWScalingStateCreateInfoNV");
    out << "VkPipelineViewportWScalingStateCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSurfaceCapabilities2EXT(std::ostream &out, const VkSurfaceCapabilities2EXT* structInfo, Decoded_VkSurfaceCapabilities2EXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string currentExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                      &structInfo->currentExtent,
                                                                      metainfo->currentExtent,
                                                                      consumer);
    std::string minImageExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                       &structInfo->minImageExtent,
                                                                       metainfo->minImageExtent,
                                                                       consumer);
    std::string maxImageExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                       &structInfo->maxImageExtent,
                                                                       metainfo->maxImageExtent,
                                                                       consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* minImageCount */
    structBody << "\t" << structInfo->minImageCount << "," << std::endl;
/* maxImageCount */
    structBody << "\t" << structInfo->maxImageCount << "," << std::endl;
/* currentExtent */
    structBody << "\t" << currentExtentInfoVar << "," << std::endl;
/* minImageExtent */
    structBody << "\t" << minImageExtentInfoVar << "," << std::endl;
/* maxImageExtent */
    structBody << "\t" << maxImageExtentInfoVar << "," << std::endl;
/* maxImageArrayLayers */
    structBody << "\t" << structInfo->maxImageArrayLayers << "," << std::endl;
/* supportedTransforms */
    structBody << "\t" << "VkSurfaceTransformFlagsKHR(" << structInfo->supportedTransforms << ")" << "," << std::endl;
/* currentTransform */
    structBody << "\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->currentTransform << ")" << "," << std::endl;
/* supportedCompositeAlpha */
    structBody << "\t" << "VkCompositeAlphaFlagsKHR(" << structInfo->supportedCompositeAlpha << ")" << "," << std::endl;
/* supportedUsageFlags */
    structBody << "\t" << "VkImageUsageFlags(" << structInfo->supportedUsageFlags << ")" << "," << std::endl;
/* supportedSurfaceCounters */
    structBody << "\t" << "VkSurfaceCounterFlagsEXT(" << structInfo->supportedSurfaceCounters << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "surfaceCapabilities2EXT");
    out << "VkSurfaceCapabilities2EXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayPowerInfoEXT(std::ostream &out, const VkDisplayPowerInfoEXT* structInfo, Decoded_VkDisplayPowerInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* powerState */
    structBody << "\t" << "VkDisplayPowerStateEXT(" << structInfo->powerState << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayPowerInfoEXT");
    out << "VkDisplayPowerInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceEventInfoEXT(std::ostream &out, const VkDeviceEventInfoEXT* structInfo, Decoded_VkDeviceEventInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceEvent */
    structBody << "\t" << "VkDeviceEventTypeEXT(" << structInfo->deviceEvent << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceEventInfoEXT");
    out << "VkDeviceEventInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayEventInfoEXT(std::ostream &out, const VkDisplayEventInfoEXT* structInfo, Decoded_VkDisplayEventInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* displayEvent */
    structBody << "\t" << "VkDisplayEventTypeEXT(" << structInfo->displayEvent << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayEventInfoEXT");
    out << "VkDisplayEventInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSwapchainCounterCreateInfoEXT(std::ostream &out, const VkSwapchainCounterCreateInfoEXT* structInfo, Decoded_VkSwapchainCounterCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* surfaceCounters */
    structBody << "\t" << "VkSurfaceCounterFlagsEXT(" << structInfo->surfaceCounters << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "swapchainCounterCreateInfoEXT");
    out << "VkSwapchainCounterCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRefreshCycleDurationGOOGLE(std::ostream &out, const VkRefreshCycleDurationGOOGLE* structInfo, Decoded_VkRefreshCycleDurationGOOGLE* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* refreshDuration */
    structBody << "\t" << structInfo->refreshDuration << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "refreshCycleDurationGOOGLE");
    out << "VkRefreshCycleDurationGOOGLE " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPastPresentationTimingGOOGLE(std::ostream &out, const VkPastPresentationTimingGOOGLE* structInfo, Decoded_VkPastPresentationTimingGOOGLE* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* presentID */
    structBody << "\t" << structInfo->presentID << "," << std::endl;
/* desiredPresentTime */
    structBody << "\t" << structInfo->desiredPresentTime << "UL" << "," << std::endl;
/* actualPresentTime */
    structBody << "\t" << structInfo->actualPresentTime << "UL" << "," << std::endl;
/* earliestPresentTime */
    structBody << "\t" << structInfo->earliestPresentTime << "UL" << "," << std::endl;
/* presentMargin */
    structBody << "\t" << structInfo->presentMargin << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "pastPresentationTimingGOOGLE");
    out << "VkPastPresentationTimingGOOGLE " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPresentTimeGOOGLE(std::ostream &out, const VkPresentTimeGOOGLE* structInfo, Decoded_VkPresentTimeGOOGLE* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* presentID */
    structBody << "\t" << structInfo->presentID << "," << std::endl;
/* desiredPresentTime */
    structBody << "\t" << structInfo->desiredPresentTime << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "presentTimeGOOGLE");
    out << "VkPresentTimeGOOGLE " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPresentTimesInfoGOOGLE(std::ostream &out, const VkPresentTimesInfoGOOGLE* structInfo, Decoded_VkPresentTimesInfoGOOGLE* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pTimesArray = "NULL";
    if (structInfo->pTimes != NULL) {
        pTimesArray = "pTimes_" + std::to_string(consumer.getNextId());
        std::string pTimesNames;
        for (uint32_t idx = 0; idx < structInfo->swapchainCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pTimes + idx != NULL) {
                varName = GenerateStruct_VkPresentTimeGOOGLE(out,
                                                         structInfo->pTimes + idx,
                                                         metainfo->pTimes->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pTimesNames += varName + ", ";
        }
        out << "VkPresentTimeGOOGLE " << pTimesArray << "[] = {" << pTimesNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* swapchainCount */
    structBody << "\t" << structInfo->swapchainCount << "," << std::endl;
/* pTimes */
    structBody << "\t" << pTimesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "presentTimesInfoGOOGLE");
    out << "VkPresentTimesInfoGOOGLE " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX(std::ostream &out, const VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* structInfo, Decoded_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* perViewPositionAllComponents */
    structBody << "\t" << structInfo->perViewPositionAllComponents << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMultiviewPerViewAttributesPropertiesNVX");
    out << "VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkViewportSwizzleNV(std::ostream &out, const VkViewportSwizzleNV* structInfo, Decoded_VkViewportSwizzleNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* x */
    structBody << "\t" << "VkViewportCoordinateSwizzleNV(" << structInfo->x << ")" << "," << std::endl;
/* y */
    structBody << "\t" << "VkViewportCoordinateSwizzleNV(" << structInfo->y << ")" << "," << std::endl;
/* z */
    structBody << "\t" << "VkViewportCoordinateSwizzleNV(" << structInfo->z << ")" << "," << std::endl;
/* w */
    structBody << "\t" << "VkViewportCoordinateSwizzleNV(" << structInfo->w << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "viewportSwizzleNV");
    out << "VkViewportSwizzleNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineViewportSwizzleStateCreateInfoNV(std::ostream &out, const VkPipelineViewportSwizzleStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportSwizzleStateCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pViewportSwizzlesArray = "NULL";
    if (structInfo->pViewportSwizzles != NULL) {
        pViewportSwizzlesArray = "pViewportSwizzles_" + std::to_string(consumer.getNextId());
        std::string pViewportSwizzlesNames;
        for (uint32_t idx = 0; idx < structInfo->viewportCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pViewportSwizzles + idx != NULL) {
                varName = GenerateStruct_VkViewportSwizzleNV(out,
                                                         structInfo->pViewportSwizzles + idx,
                                                         metainfo->pViewportSwizzles->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pViewportSwizzlesNames += varName + ", ";
        }
        out << "VkViewportSwizzleNV " << pViewportSwizzlesArray << "[] = {" << pViewportSwizzlesNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineViewportSwizzleStateCreateFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
/* viewportCount */
    structBody << "\t" << structInfo->viewportCount << "," << std::endl;
/* pViewportSwizzles */
    structBody << "\t" << pViewportSwizzlesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineViewportSwizzleStateCreateInfoNV");
    out << "VkPipelineViewportSwizzleStateCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDiscardRectanglePropertiesEXT(std::ostream &out, const VkPhysicalDeviceDiscardRectanglePropertiesEXT* structInfo, Decoded_VkPhysicalDeviceDiscardRectanglePropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxDiscardRectangles */
    structBody << "\t" << structInfo->maxDiscardRectangles << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDiscardRectanglePropertiesEXT");
    out << "VkPhysicalDeviceDiscardRectanglePropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineDiscardRectangleStateCreateInfoEXT(std::ostream &out, const VkPipelineDiscardRectangleStateCreateInfoEXT* structInfo, Decoded_VkPipelineDiscardRectangleStateCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDiscardRectanglesArray = "NULL";
    if (structInfo->pDiscardRectangles != NULL) {
        pDiscardRectanglesArray = "pDiscardRectangles_" + std::to_string(consumer.getNextId());
        out << "VkRect2D " << pDiscardRectanglesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDiscardRectangles, structInfo->discardRectangleCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineDiscardRectangleStateCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* discardRectangleMode */
    structBody << "\t" << "VkDiscardRectangleModeEXT(" << structInfo->discardRectangleMode << ")" << "," << std::endl;
/* discardRectangleCount */
    structBody << "\t" << structInfo->discardRectangleCount << "," << std::endl;
/* pDiscardRectangles */
    structBody << "\t" << pDiscardRectanglesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineDiscardRectangleStateCreateInfoEXT");
    out << "VkPipelineDiscardRectangleStateCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceConservativeRasterizationPropertiesEXT(std::ostream &out, const VkPhysicalDeviceConservativeRasterizationPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceConservativeRasterizationPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* primitiveOverestimationSize */
    structBody << "\t" << structInfo->primitiveOverestimationSize << "," << std::endl;
/* maxExtraPrimitiveOverestimationSize */
    structBody << "\t" << structInfo->maxExtraPrimitiveOverestimationSize << "," << std::endl;
/* extraPrimitiveOverestimationSizeGranularity */
    structBody << "\t" << structInfo->extraPrimitiveOverestimationSizeGranularity << "," << std::endl;
/* primitiveUnderestimation */
    structBody << "\t" << structInfo->primitiveUnderestimation << "," << std::endl;
/* conservativePointAndLineRasterization */
    structBody << "\t" << structInfo->conservativePointAndLineRasterization << "," << std::endl;
/* degenerateTrianglesRasterized */
    structBody << "\t" << structInfo->degenerateTrianglesRasterized << "," << std::endl;
/* degenerateLinesRasterized */
    structBody << "\t" << structInfo->degenerateLinesRasterized << "," << std::endl;
/* fullyCoveredFragmentShaderInputVariable */
    structBody << "\t" << structInfo->fullyCoveredFragmentShaderInputVariable << "," << std::endl;
/* conservativeRasterizationPostDepthCoverage */
    structBody << "\t" << structInfo->conservativeRasterizationPostDepthCoverage << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceConservativeRasterizationPropertiesEXT");
    out << "VkPhysicalDeviceConservativeRasterizationPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineRasterizationConservativeStateCreateInfoEXT(std::ostream &out, const VkPipelineRasterizationConservativeStateCreateInfoEXT* structInfo, Decoded_VkPipelineRasterizationConservativeStateCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineRasterizationConservativeStateCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* conservativeRasterizationMode */
    structBody << "\t" << "VkConservativeRasterizationModeEXT(" << structInfo->conservativeRasterizationMode << ")" << "," << std::endl;
/* extraPrimitiveOverestimationSize */
    structBody << "\t" << structInfo->extraPrimitiveOverestimationSize << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineRasterizationConservativeStateCreateInfoEXT");
    out << "VkPipelineRasterizationConservativeStateCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDepthClipEnableFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDepthClipEnableFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDepthClipEnableFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* depthClipEnable */
    structBody << "\t" << structInfo->depthClipEnable << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDepthClipEnableFeaturesEXT");
    out << "VkPhysicalDeviceDepthClipEnableFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineRasterizationDepthClipStateCreateInfoEXT(std::ostream &out, const VkPipelineRasterizationDepthClipStateCreateInfoEXT* structInfo, Decoded_VkPipelineRasterizationDepthClipStateCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineRasterizationDepthClipStateCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* depthClipEnable */
    structBody << "\t" << structInfo->depthClipEnable << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineRasterizationDepthClipStateCreateInfoEXT");
    out << "VkPipelineRasterizationDepthClipStateCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkXYColorEXT(std::ostream &out, const VkXYColorEXT* structInfo, Decoded_VkXYColorEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* x */
    structBody << "\t" << structInfo->x << "," << std::endl;
/* y */
    structBody << "\t" << structInfo->y << "," ;
    std::string varname = consumer.AddStruct(structBody, "xYColorEXT");
    out << "VkXYColorEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkHdrMetadataEXT(std::ostream &out, const VkHdrMetadataEXT* structInfo, Decoded_VkHdrMetadataEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string displayPrimaryRedInfoVar = GenerateStruct_VkXYColorEXT(out,
                                                                          &structInfo->displayPrimaryRed,
                                                                          metainfo->displayPrimaryRed,
                                                                          consumer);
    std::string displayPrimaryGreenInfoVar = GenerateStruct_VkXYColorEXT(out,
                                                                            &structInfo->displayPrimaryGreen,
                                                                            metainfo->displayPrimaryGreen,
                                                                            consumer);
    std::string displayPrimaryBlueInfoVar = GenerateStruct_VkXYColorEXT(out,
                                                                           &structInfo->displayPrimaryBlue,
                                                                           metainfo->displayPrimaryBlue,
                                                                           consumer);
    std::string whitePointInfoVar = GenerateStruct_VkXYColorEXT(out,
                                                                   &structInfo->whitePoint,
                                                                   metainfo->whitePoint,
                                                                   consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* displayPrimaryRed */
    structBody << "\t" << displayPrimaryRedInfoVar << "," << std::endl;
/* displayPrimaryGreen */
    structBody << "\t" << displayPrimaryGreenInfoVar << "," << std::endl;
/* displayPrimaryBlue */
    structBody << "\t" << displayPrimaryBlueInfoVar << "," << std::endl;
/* whitePoint */
    structBody << "\t" << whitePointInfoVar << "," << std::endl;
/* maxLuminance */
    structBody << "\t" << structInfo->maxLuminance << "," << std::endl;
/* minLuminance */
    structBody << "\t" << structInfo->minLuminance << "," << std::endl;
/* maxContentLightLevel */
    structBody << "\t" << structInfo->maxContentLightLevel << "," << std::endl;
/* maxFrameAverageLightLevel */
    structBody << "\t" << structInfo->maxFrameAverageLightLevel << "," ;
    std::string varname = consumer.AddStruct(structBody, "hdrMetadataEXT");
    out << "VkHdrMetadataEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkIOSSurfaceCreateInfoMVK(std::ostream &out, const VkIOSSurfaceCreateInfoMVK* structInfo, Decoded_VkIOSSurfaceCreateInfoMVK* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkIOSSurfaceCreateFlagsMVK(" << structInfo->flags << ")" << "," << std::endl;
/* pView */
    structBody << "\t" << structInfo->pView << "," ;
    std::string varname = consumer.AddStruct(structBody, "iOSSurfaceCreateInfoMVK");
    out << "VkIOSSurfaceCreateInfoMVK " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMacOSSurfaceCreateInfoMVK(std::ostream &out, const VkMacOSSurfaceCreateInfoMVK* structInfo, Decoded_VkMacOSSurfaceCreateInfoMVK* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkMacOSSurfaceCreateFlagsMVK(" << structInfo->flags << ")" << "," << std::endl;
/* pView */
    structBody << "\t" << structInfo->pView << "," ;
    std::string varname = consumer.AddStruct(structBody, "macOSSurfaceCreateInfoMVK");
    out << "VkMacOSSurfaceCreateInfoMVK " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDebugUtilsLabelEXT(std::ostream &out, const VkDebugUtilsLabelEXT* structInfo, Decoded_VkDebugUtilsLabelEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pLabelName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->pLabelName) << "," << std::endl;
/* color */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->color[0]), 4) << "," ;
    std::string varname = consumer.AddStruct(structBody, "debugUtilsLabelEXT");
    out << "VkDebugUtilsLabelEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDebugUtilsObjectNameInfoEXT(std::ostream &out, const VkDebugUtilsObjectNameInfoEXT* structInfo, Decoded_VkDebugUtilsObjectNameInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* objectType */
    structBody << "\t" << "VkObjectType(" << structInfo->objectType << ")" << "," << std::endl;
/* objectHandle */
    structBody << "\t" << structInfo->objectHandle << "UL" << "," << std::endl;
/* pObjectName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->pObjectName) << "," ;
    std::string varname = consumer.AddStruct(structBody, "debugUtilsObjectNameInfoEXT");
    out << "VkDebugUtilsObjectNameInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDebugUtilsMessengerCallbackDataEXT(std::ostream &out, const VkDebugUtilsMessengerCallbackDataEXT* structInfo, Decoded_VkDebugUtilsMessengerCallbackDataEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pQueueLabelsArray = "NULL";
    if (structInfo->pQueueLabels != NULL) {
        pQueueLabelsArray = "pQueueLabels_" + std::to_string(consumer.getNextId());
        std::string pQueueLabelsNames;
        for (uint32_t idx = 0; idx < structInfo->queueLabelCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pQueueLabels + idx != NULL) {
                varName = GenerateStruct_VkDebugUtilsLabelEXT(out,
                                                         structInfo->pQueueLabels + idx,
                                                         metainfo->pQueueLabels->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pQueueLabelsNames += varName + ", ";
        }
        out << "VkDebugUtilsLabelEXT " << pQueueLabelsArray << "[] = {" << pQueueLabelsNames << "};" << std::endl;
    }
    std::string pCmdBufLabelsArray = "NULL";
    if (structInfo->pCmdBufLabels != NULL) {
        pCmdBufLabelsArray = "pCmdBufLabels_" + std::to_string(consumer.getNextId());
        std::string pCmdBufLabelsNames;
        for (uint32_t idx = 0; idx < structInfo->cmdBufLabelCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pCmdBufLabels + idx != NULL) {
                varName = GenerateStruct_VkDebugUtilsLabelEXT(out,
                                                         structInfo->pCmdBufLabels + idx,
                                                         metainfo->pCmdBufLabels->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pCmdBufLabelsNames += varName + ", ";
        }
        out << "VkDebugUtilsLabelEXT " << pCmdBufLabelsArray << "[] = {" << pCmdBufLabelsNames << "};" << std::endl;
    }
    std::string pObjectsArray = "NULL";
    if (structInfo->pObjects != NULL) {
        pObjectsArray = "pObjects_" + std::to_string(consumer.getNextId());
        std::string pObjectsNames;
        for (uint32_t idx = 0; idx < structInfo->objectCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pObjects + idx != NULL) {
                varName = GenerateStruct_VkDebugUtilsObjectNameInfoEXT(out,
                                                         structInfo->pObjects + idx,
                                                         metainfo->pObjects->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pObjectsNames += varName + ", ";
        }
        out << "VkDebugUtilsObjectNameInfoEXT " << pObjectsArray << "[] = {" << pObjectsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDebugUtilsMessengerCallbackDataFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* pMessageIdName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->pMessageIdName) << "," << std::endl;
/* messageIdNumber */
    structBody << "\t" << structInfo->messageIdNumber << "," << std::endl;
/* pMessage */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->pMessage) << "," << std::endl;
/* queueLabelCount */
    structBody << "\t" << structInfo->queueLabelCount << "," << std::endl;
/* pQueueLabels */
    structBody << "\t" << pQueueLabelsArray << "," << std::endl;
/* cmdBufLabelCount */
    structBody << "\t" << structInfo->cmdBufLabelCount << "," << std::endl;
/* pCmdBufLabels */
    structBody << "\t" << pCmdBufLabelsArray << "," << std::endl;
/* objectCount */
    structBody << "\t" << structInfo->objectCount << "," << std::endl;
/* pObjects */
    structBody << "\t" << pObjectsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "debugUtilsMessengerCallbackDataEXT");
    out << "VkDebugUtilsMessengerCallbackDataEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDebugUtilsObjectTagInfoEXT(std::ostream &out, const VkDebugUtilsObjectTagInfoEXT* structInfo, Decoded_VkDebugUtilsObjectTagInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pTagArray = "NULL";
    if (structInfo->pTag != NULL) {
        std::string pTagValues;
        for (uint32_t idx0 = 0; idx0 < structInfo->tagSize; ++idx0) {
            pTagValues += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pTag)[idx0]) + ", ";
        }
        pTagArray = "pTag_" + std::to_string(consumer.getNextId());
        out << "uint8_t " << pTagArray << "[] = {" << pTagValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* objectType */
    structBody << "\t" << "VkObjectType(" << structInfo->objectType << ")" << "," << std::endl;
/* objectHandle */
    structBody << "\t" << structInfo->objectHandle << "UL" << "," << std::endl;
/* tagName */
    structBody << "\t" << structInfo->tagName << "UL" << "," << std::endl;
/* tagSize */
    structBody << "\t" << structInfo->tagSize << "," << std::endl;
/* pTag */
    structBody << "\t" << pTagArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "debugUtilsObjectTagInfoEXT");
    out << "VkDebugUtilsObjectTagInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAndroidHardwareBufferUsageANDROID(std::ostream &out, const VkAndroidHardwareBufferUsageANDROID* structInfo, Decoded_VkAndroidHardwareBufferUsageANDROID* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* androidHardwareBufferUsage */
    structBody << "\t" << structInfo->androidHardwareBufferUsage << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "androidHardwareBufferUsageANDROID");
    out << "VkAndroidHardwareBufferUsageANDROID " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAndroidHardwareBufferPropertiesANDROID(std::ostream &out, const VkAndroidHardwareBufferPropertiesANDROID* structInfo, Decoded_VkAndroidHardwareBufferPropertiesANDROID* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* allocationSize */
    structBody << "\t" << structInfo->allocationSize << "UL" << "," << std::endl;
/* memoryTypeBits */
    structBody << "\t" << structInfo->memoryTypeBits << "," ;
    std::string varname = consumer.AddStruct(structBody, "androidHardwareBufferPropertiesANDROID");
    out << "VkAndroidHardwareBufferPropertiesANDROID " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAndroidHardwareBufferFormatPropertiesANDROID(std::ostream &out, const VkAndroidHardwareBufferFormatPropertiesANDROID* structInfo, Decoded_VkAndroidHardwareBufferFormatPropertiesANDROID* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string samplerYcbcrConversionComponentsInfoVar = GenerateStruct_VkComponentMapping(out,
                                                                                         &structInfo->samplerYcbcrConversionComponents,
                                                                                         metainfo->samplerYcbcrConversionComponents,
                                                                                         consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
/* externalFormat */
    structBody << "\t" << structInfo->externalFormat << "UL" << "," << std::endl;
/* formatFeatures */
    structBody << "\t" << "VkFormatFeatureFlags(" << structInfo->formatFeatures << ")" << "," << std::endl;
/* samplerYcbcrConversionComponents */
    structBody << "\t" << samplerYcbcrConversionComponentsInfoVar << "," << std::endl;
/* suggestedYcbcrModel */
    structBody << "\t" << "VkSamplerYcbcrModelConversion(" << structInfo->suggestedYcbcrModel << ")" << "," << std::endl;
/* suggestedYcbcrRange */
    structBody << "\t" << "VkSamplerYcbcrRange(" << structInfo->suggestedYcbcrRange << ")" << "," << std::endl;
/* suggestedXChromaOffset */
    structBody << "\t" << "VkChromaLocation(" << structInfo->suggestedXChromaOffset << ")" << "," << std::endl;
/* suggestedYChromaOffset */
    structBody << "\t" << "VkChromaLocation(" << structInfo->suggestedYChromaOffset << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "androidHardwareBufferFormatPropertiesANDROID");
    out << "VkAndroidHardwareBufferFormatPropertiesANDROID " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImportAndroidHardwareBufferInfoANDROID(std::ostream &out, const VkImportAndroidHardwareBufferInfoANDROID* structInfo, Decoded_VkImportAndroidHardwareBufferInfoANDROID* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* buffer */
    structBody << "\t" << structInfo->buffer << "," ;
    std::string varname = consumer.AddStruct(structBody, "importAndroidHardwareBufferInfoANDROID");
    out << "VkImportAndroidHardwareBufferInfoANDROID " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryGetAndroidHardwareBufferInfoANDROID(std::ostream &out, const VkMemoryGetAndroidHardwareBufferInfoANDROID* structInfo, Decoded_VkMemoryGetAndroidHardwareBufferInfoANDROID* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryGetAndroidHardwareBufferInfoANDROID");
    out << "VkMemoryGetAndroidHardwareBufferInfoANDROID " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExternalFormatANDROID(std::ostream &out, const VkExternalFormatANDROID* structInfo, Decoded_VkExternalFormatANDROID* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* externalFormat */
    structBody << "\t" << structInfo->externalFormat << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "externalFormatANDROID");
    out << "VkExternalFormatANDROID " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAndroidHardwareBufferFormatProperties2ANDROID(std::ostream &out, const VkAndroidHardwareBufferFormatProperties2ANDROID* structInfo, Decoded_VkAndroidHardwareBufferFormatProperties2ANDROID* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string samplerYcbcrConversionComponentsInfoVar = GenerateStruct_VkComponentMapping(out,
                                                                                         &structInfo->samplerYcbcrConversionComponents,
                                                                                         metainfo->samplerYcbcrConversionComponents,
                                                                                         consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
/* externalFormat */
    structBody << "\t" << structInfo->externalFormat << "UL" << "," << std::endl;
/* formatFeatures */
    structBody << "\t" << "VkFormatFeatureFlags2(" << structInfo->formatFeatures << ")" << "," << std::endl;
/* samplerYcbcrConversionComponents */
    structBody << "\t" << samplerYcbcrConversionComponentsInfoVar << "," << std::endl;
/* suggestedYcbcrModel */
    structBody << "\t" << "VkSamplerYcbcrModelConversion(" << structInfo->suggestedYcbcrModel << ")" << "," << std::endl;
/* suggestedYcbcrRange */
    structBody << "\t" << "VkSamplerYcbcrRange(" << structInfo->suggestedYcbcrRange << ")" << "," << std::endl;
/* suggestedXChromaOffset */
    structBody << "\t" << "VkChromaLocation(" << structInfo->suggestedXChromaOffset << ")" << "," << std::endl;
/* suggestedYChromaOffset */
    structBody << "\t" << "VkChromaLocation(" << structInfo->suggestedYChromaOffset << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "androidHardwareBufferFormatProperties2ANDROID");
    out << "VkAndroidHardwareBufferFormatProperties2ANDROID " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSampleLocationEXT(std::ostream &out, const VkSampleLocationEXT* structInfo, Decoded_VkSampleLocationEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* x */
    structBody << "\t" << structInfo->x << "," << std::endl;
/* y */
    structBody << "\t" << structInfo->y << "," ;
    std::string varname = consumer.AddStruct(structBody, "sampleLocationEXT");
    out << "VkSampleLocationEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSampleLocationsInfoEXT(std::ostream &out, const VkSampleLocationsInfoEXT* structInfo, Decoded_VkSampleLocationsInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string sampleLocationGridSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                               &structInfo->sampleLocationGridSize,
                                                                               metainfo->sampleLocationGridSize,
                                                                               consumer);
    std::string pSampleLocationsArray = "NULL";
    if (structInfo->pSampleLocations != NULL) {
        pSampleLocationsArray = "pSampleLocations_" + std::to_string(consumer.getNextId());
        std::string pSampleLocationsNames;
        for (uint32_t idx = 0; idx < structInfo->sampleLocationsCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pSampleLocations + idx != NULL) {
                varName = GenerateStruct_VkSampleLocationEXT(out,
                                                         structInfo->pSampleLocations + idx,
                                                         metainfo->pSampleLocations->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pSampleLocationsNames += varName + ", ";
        }
        out << "VkSampleLocationEXT " << pSampleLocationsArray << "[] = {" << pSampleLocationsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* sampleLocationsPerPixel */
    structBody << "\t" << "VkSampleCountFlagBits(" << structInfo->sampleLocationsPerPixel << ")" << "," << std::endl;
/* sampleLocationGridSize */
    structBody << "\t" << sampleLocationGridSizeInfoVar << "," << std::endl;
/* sampleLocationsCount */
    structBody << "\t" << structInfo->sampleLocationsCount << "," << std::endl;
/* pSampleLocations */
    structBody << "\t" << pSampleLocationsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "sampleLocationsInfoEXT");
    out << "VkSampleLocationsInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAttachmentSampleLocationsEXT(std::ostream &out, const VkAttachmentSampleLocationsEXT* structInfo, Decoded_VkAttachmentSampleLocationsEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string sampleLocationsInfoInfoVar = GenerateStruct_VkSampleLocationsInfoEXT(out,
                                                                            &structInfo->sampleLocationsInfo,
                                                                            metainfo->sampleLocationsInfo,
                                                                            consumer);
/* attachmentIndex */
    structBody << "\t" << structInfo->attachmentIndex << "," << std::endl;
/* sampleLocationsInfo */
    structBody << "\t" << sampleLocationsInfoInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "attachmentSampleLocationsEXT");
    out << "VkAttachmentSampleLocationsEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubpassSampleLocationsEXT(std::ostream &out, const VkSubpassSampleLocationsEXT* structInfo, Decoded_VkSubpassSampleLocationsEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string sampleLocationsInfoInfoVar = GenerateStruct_VkSampleLocationsInfoEXT(out,
                                                                            &structInfo->sampleLocationsInfo,
                                                                            metainfo->sampleLocationsInfo,
                                                                            consumer);
/* subpassIndex */
    structBody << "\t" << structInfo->subpassIndex << "," << std::endl;
/* sampleLocationsInfo */
    structBody << "\t" << sampleLocationsInfoInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "subpassSampleLocationsEXT");
    out << "VkSubpassSampleLocationsEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderPassSampleLocationsBeginInfoEXT(std::ostream &out, const VkRenderPassSampleLocationsBeginInfoEXT* structInfo, Decoded_VkRenderPassSampleLocationsBeginInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pAttachmentInitialSampleLocationsArray = "NULL";
    if (structInfo->pAttachmentInitialSampleLocations != NULL) {
        pAttachmentInitialSampleLocationsArray = "pAttachmentInitialSampleLocations_" + std::to_string(consumer.getNextId());
        std::string pAttachmentInitialSampleLocationsNames;
        for (uint32_t idx = 0; idx < structInfo->attachmentInitialSampleLocationsCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pAttachmentInitialSampleLocations + idx != NULL) {
                varName = GenerateStruct_VkAttachmentSampleLocationsEXT(out,
                                                         structInfo->pAttachmentInitialSampleLocations + idx,
                                                         metainfo->pAttachmentInitialSampleLocations->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pAttachmentInitialSampleLocationsNames += varName + ", ";
        }
        out << "VkAttachmentSampleLocationsEXT " << pAttachmentInitialSampleLocationsArray << "[] = {" << pAttachmentInitialSampleLocationsNames << "};" << std::endl;
    }
    std::string pPostSubpassSampleLocationsArray = "NULL";
    if (structInfo->pPostSubpassSampleLocations != NULL) {
        pPostSubpassSampleLocationsArray = "pPostSubpassSampleLocations_" + std::to_string(consumer.getNextId());
        std::string pPostSubpassSampleLocationsNames;
        for (uint32_t idx = 0; idx < structInfo->postSubpassSampleLocationsCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pPostSubpassSampleLocations + idx != NULL) {
                varName = GenerateStruct_VkSubpassSampleLocationsEXT(out,
                                                         structInfo->pPostSubpassSampleLocations + idx,
                                                         metainfo->pPostSubpassSampleLocations->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pPostSubpassSampleLocationsNames += varName + ", ";
        }
        out << "VkSubpassSampleLocationsEXT " << pPostSubpassSampleLocationsArray << "[] = {" << pPostSubpassSampleLocationsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* attachmentInitialSampleLocationsCount */
    structBody << "\t" << structInfo->attachmentInitialSampleLocationsCount << "," << std::endl;
/* pAttachmentInitialSampleLocations */
    structBody << "\t" << pAttachmentInitialSampleLocationsArray << "," << std::endl;
/* postSubpassSampleLocationsCount */
    structBody << "\t" << structInfo->postSubpassSampleLocationsCount << "," << std::endl;
/* pPostSubpassSampleLocations */
    structBody << "\t" << pPostSubpassSampleLocationsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderPassSampleLocationsBeginInfoEXT");
    out << "VkRenderPassSampleLocationsBeginInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineSampleLocationsStateCreateInfoEXT(std::ostream &out, const VkPipelineSampleLocationsStateCreateInfoEXT* structInfo, Decoded_VkPipelineSampleLocationsStateCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string sampleLocationsInfoInfoVar = GenerateStruct_VkSampleLocationsInfoEXT(out,
                                                                            &structInfo->sampleLocationsInfo,
                                                                            metainfo->sampleLocationsInfo,
                                                                            consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* sampleLocationsEnable */
    structBody << "\t" << structInfo->sampleLocationsEnable << "," << std::endl;
/* sampleLocationsInfo */
    structBody << "\t" << sampleLocationsInfoInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineSampleLocationsStateCreateInfoEXT");
    out << "VkPipelineSampleLocationsStateCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceSampleLocationsPropertiesEXT(std::ostream &out, const VkPhysicalDeviceSampleLocationsPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceSampleLocationsPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string maxSampleLocationGridSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                                  &structInfo->maxSampleLocationGridSize,
                                                                                  metainfo->maxSampleLocationGridSize,
                                                                                  consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* sampleLocationSampleCounts */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->sampleLocationSampleCounts << ")" << "," << std::endl;
/* maxSampleLocationGridSize */
    structBody << "\t" << maxSampleLocationGridSizeInfoVar << "," << std::endl;
/* sampleLocationCoordinateRange */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->sampleLocationCoordinateRange[0]), 2) << "," << std::endl;
/* sampleLocationSubPixelBits */
    structBody << "\t" << structInfo->sampleLocationSubPixelBits << "," << std::endl;
/* variableSampleLocations */
    structBody << "\t" << structInfo->variableSampleLocations << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceSampleLocationsPropertiesEXT");
    out << "VkPhysicalDeviceSampleLocationsPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMultisamplePropertiesEXT(std::ostream &out, const VkMultisamplePropertiesEXT* structInfo, Decoded_VkMultisamplePropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string maxSampleLocationGridSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                                  &structInfo->maxSampleLocationGridSize,
                                                                                  metainfo->maxSampleLocationGridSize,
                                                                                  consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxSampleLocationGridSize */
    structBody << "\t" << maxSampleLocationGridSizeInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "multisamplePropertiesEXT");
    out << "VkMultisamplePropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT(std::ostream &out, const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* advancedBlendCoherentOperations */
    structBody << "\t" << structInfo->advancedBlendCoherentOperations << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceBlendOperationAdvancedFeaturesEXT");
    out << "VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT(std::ostream &out, const VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* advancedBlendMaxColorAttachments */
    structBody << "\t" << structInfo->advancedBlendMaxColorAttachments << "," << std::endl;
/* advancedBlendIndependentBlend */
    structBody << "\t" << structInfo->advancedBlendIndependentBlend << "," << std::endl;
/* advancedBlendNonPremultipliedSrcColor */
    structBody << "\t" << structInfo->advancedBlendNonPremultipliedSrcColor << "," << std::endl;
/* advancedBlendNonPremultipliedDstColor */
    structBody << "\t" << structInfo->advancedBlendNonPremultipliedDstColor << "," << std::endl;
/* advancedBlendCorrelatedOverlap */
    structBody << "\t" << structInfo->advancedBlendCorrelatedOverlap << "," << std::endl;
/* advancedBlendAllOperations */
    structBody << "\t" << structInfo->advancedBlendAllOperations << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceBlendOperationAdvancedPropertiesEXT");
    out << "VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineColorBlendAdvancedStateCreateInfoEXT(std::ostream &out, const VkPipelineColorBlendAdvancedStateCreateInfoEXT* structInfo, Decoded_VkPipelineColorBlendAdvancedStateCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* srcPremultiplied */
    structBody << "\t" << structInfo->srcPremultiplied << "," << std::endl;
/* dstPremultiplied */
    structBody << "\t" << structInfo->dstPremultiplied << "," << std::endl;
/* blendOverlap */
    structBody << "\t" << "VkBlendOverlapEXT(" << structInfo->blendOverlap << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineColorBlendAdvancedStateCreateInfoEXT");
    out << "VkPipelineColorBlendAdvancedStateCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineCoverageToColorStateCreateInfoNV(std::ostream &out, const VkPipelineCoverageToColorStateCreateInfoNV* structInfo, Decoded_VkPipelineCoverageToColorStateCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineCoverageToColorStateCreateFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
/* coverageToColorEnable */
    structBody << "\t" << structInfo->coverageToColorEnable << "," << std::endl;
/* coverageToColorLocation */
    structBody << "\t" << structInfo->coverageToColorLocation << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineCoverageToColorStateCreateInfoNV");
    out << "VkPipelineCoverageToColorStateCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineCoverageModulationStateCreateInfoNV(std::ostream &out, const VkPipelineCoverageModulationStateCreateInfoNV* structInfo, Decoded_VkPipelineCoverageModulationStateCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pCoverageModulationTableArray = "NULL";
    if (structInfo->pCoverageModulationTable != NULL) {
        pCoverageModulationTableArray = "pCoverageModulationTable_" + std::to_string(consumer.getNextId());
        out << "float " << pCoverageModulationTableArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pCoverageModulationTable, structInfo->coverageModulationTableCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineCoverageModulationStateCreateFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
/* coverageModulationMode */
    structBody << "\t" << "VkCoverageModulationModeNV(" << structInfo->coverageModulationMode << ")" << "," << std::endl;
/* coverageModulationTableEnable */
    structBody << "\t" << structInfo->coverageModulationTableEnable << "," << std::endl;
/* coverageModulationTableCount */
    structBody << "\t" << structInfo->coverageModulationTableCount << "," << std::endl;
/* pCoverageModulationTable */
    structBody << "\t" << pCoverageModulationTableArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineCoverageModulationStateCreateInfoNV");
    out << "VkPipelineCoverageModulationStateCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV(std::ostream &out, const VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* structInfo, Decoded_VkPhysicalDeviceShaderSMBuiltinsPropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderSMCount */
    structBody << "\t" << structInfo->shaderSMCount << "," << std::endl;
/* shaderWarpsPerSM */
    structBody << "\t" << structInfo->shaderWarpsPerSM << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderSMBuiltinsPropertiesNV");
    out << "VkPhysicalDeviceShaderSMBuiltinsPropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV(std::ostream &out, const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* structInfo, Decoded_VkPhysicalDeviceShaderSMBuiltinsFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderSMBuiltins */
    structBody << "\t" << structInfo->shaderSMBuiltins << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderSMBuiltinsFeaturesNV");
    out << "VkPhysicalDeviceShaderSMBuiltinsFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDrmFormatModifierPropertiesEXT(std::ostream &out, const VkDrmFormatModifierPropertiesEXT* structInfo, Decoded_VkDrmFormatModifierPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* drmFormatModifier */
    structBody << "\t" << structInfo->drmFormatModifier << "UL" << "," << std::endl;
/* drmFormatModifierPlaneCount */
    structBody << "\t" << structInfo->drmFormatModifierPlaneCount << "," << std::endl;
/* drmFormatModifierTilingFeatures */
    structBody << "\t" << "VkFormatFeatureFlags(" << structInfo->drmFormatModifierTilingFeatures << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "drmFormatModifierPropertiesEXT");
    out << "VkDrmFormatModifierPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDrmFormatModifierPropertiesListEXT(std::ostream &out, const VkDrmFormatModifierPropertiesListEXT* structInfo, Decoded_VkDrmFormatModifierPropertiesListEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDrmFormatModifierPropertiesArray = "NULL";
    if (structInfo->pDrmFormatModifierProperties != NULL) {
        pDrmFormatModifierPropertiesArray = "pDrmFormatModifierProperties_" + std::to_string(consumer.getNextId());
        std::string pDrmFormatModifierPropertiesNames;
        for (uint32_t idx = 0; idx < structInfo->drmFormatModifierCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pDrmFormatModifierProperties + idx != NULL) {
                varName = GenerateStruct_VkDrmFormatModifierPropertiesEXT(out,
                                                         structInfo->pDrmFormatModifierProperties + idx,
                                                         metainfo->pDrmFormatModifierProperties->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pDrmFormatModifierPropertiesNames += varName + ", ";
        }
        out << "VkDrmFormatModifierPropertiesEXT " << pDrmFormatModifierPropertiesArray << "[] = {" << pDrmFormatModifierPropertiesNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* drmFormatModifierCount */
    structBody << "\t" << structInfo->drmFormatModifierCount << "," << std::endl;
/* pDrmFormatModifierProperties */
    structBody << "\t" << pDrmFormatModifierPropertiesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "drmFormatModifierPropertiesListEXT");
    out << "VkDrmFormatModifierPropertiesListEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceImageDrmFormatModifierInfoEXT(std::ostream &out, const VkPhysicalDeviceImageDrmFormatModifierInfoEXT* structInfo, Decoded_VkPhysicalDeviceImageDrmFormatModifierInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pQueueFamilyIndicesArray = "NULL";
    if (structInfo->pQueueFamilyIndices != NULL) {
        pQueueFamilyIndicesArray = "pQueueFamilyIndices_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pQueueFamilyIndicesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pQueueFamilyIndices, structInfo->queueFamilyIndexCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* drmFormatModifier */
    structBody << "\t" << structInfo->drmFormatModifier << "UL" << "," << std::endl;
/* sharingMode */
    structBody << "\t" << "VkSharingMode(" << structInfo->sharingMode << ")" << "," << std::endl;
/* queueFamilyIndexCount */
    structBody << "\t" << structInfo->queueFamilyIndexCount << "," << std::endl;
/* pQueueFamilyIndices */
    structBody << "\t" << pQueueFamilyIndicesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceImageDrmFormatModifierInfoEXT");
    out << "VkPhysicalDeviceImageDrmFormatModifierInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageDrmFormatModifierListCreateInfoEXT(std::ostream &out, const VkImageDrmFormatModifierListCreateInfoEXT* structInfo, Decoded_VkImageDrmFormatModifierListCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDrmFormatModifiersArray = "pDrmFormatModifiersArray_" + std::to_string(consumer.getNextId());
    if (structInfo->drmFormatModifierCount > 0) {
        std::string pDrmFormatModifiersValues = toStringJoin(structInfo->pDrmFormatModifiers,
                                                             structInfo->pDrmFormatModifiers + structInfo->drmFormatModifierCount,
                                                             [](uint64_t current) { return std::to_string(current); },
                                                             ", ");
        if (structInfo->drmFormatModifierCount == 1) {
            pDrmFormatModifiersArray = "&" + pDrmFormatModifiersValues;
        } else if (structInfo->drmFormatModifierCount > 1) {
            out << "uint64_t " << pDrmFormatModifiersArray << "[] = {" << pDrmFormatModifiersValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* drmFormatModifierCount */
    structBody << "\t" << structInfo->drmFormatModifierCount << "," << std::endl;
/* pDrmFormatModifiers */
    structBody << "\t" << "{ *" << pDrmFormatModifiersArray << " }" << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageDrmFormatModifierListCreateInfoEXT");
    out << "VkImageDrmFormatModifierListCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageDrmFormatModifierExplicitCreateInfoEXT(std::ostream &out, const VkImageDrmFormatModifierExplicitCreateInfoEXT* structInfo, Decoded_VkImageDrmFormatModifierExplicitCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pPlaneLayoutsArray = "NULL";
    if (structInfo->pPlaneLayouts != NULL) {
        pPlaneLayoutsArray = "pPlaneLayouts_" + std::to_string(consumer.getNextId());
        std::string pPlaneLayoutsNames;
        for (uint32_t idx = 0; idx < structInfo->drmFormatModifierPlaneCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pPlaneLayouts + idx != NULL) {
                varName = GenerateStruct_VkSubresourceLayout(out,
                                                         structInfo->pPlaneLayouts + idx,
                                                         metainfo->pPlaneLayouts->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pPlaneLayoutsNames += varName + ", ";
        }
        out << "VkSubresourceLayout " << pPlaneLayoutsArray << "[] = {" << pPlaneLayoutsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* drmFormatModifier */
    structBody << "\t" << structInfo->drmFormatModifier << "UL" << "," << std::endl;
/* drmFormatModifierPlaneCount */
    structBody << "\t" << structInfo->drmFormatModifierPlaneCount << "," << std::endl;
/* pPlaneLayouts */
    structBody << "\t" << pPlaneLayoutsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageDrmFormatModifierExplicitCreateInfoEXT");
    out << "VkImageDrmFormatModifierExplicitCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageDrmFormatModifierPropertiesEXT(std::ostream &out, const VkImageDrmFormatModifierPropertiesEXT* structInfo, Decoded_VkImageDrmFormatModifierPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* drmFormatModifier */
    structBody << "\t" << structInfo->drmFormatModifier << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageDrmFormatModifierPropertiesEXT");
    out << "VkImageDrmFormatModifierPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDrmFormatModifierProperties2EXT(std::ostream &out, const VkDrmFormatModifierProperties2EXT* structInfo, Decoded_VkDrmFormatModifierProperties2EXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* drmFormatModifier */
    structBody << "\t" << structInfo->drmFormatModifier << "UL" << "," << std::endl;
/* drmFormatModifierPlaneCount */
    structBody << "\t" << structInfo->drmFormatModifierPlaneCount << "," << std::endl;
/* drmFormatModifierTilingFeatures */
    structBody << "\t" << "VkFormatFeatureFlags2(" << structInfo->drmFormatModifierTilingFeatures << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "drmFormatModifierProperties2EXT");
    out << "VkDrmFormatModifierProperties2EXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDrmFormatModifierPropertiesList2EXT(std::ostream &out, const VkDrmFormatModifierPropertiesList2EXT* structInfo, Decoded_VkDrmFormatModifierPropertiesList2EXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDrmFormatModifierPropertiesArray = "NULL";
    if (structInfo->pDrmFormatModifierProperties != NULL) {
        pDrmFormatModifierPropertiesArray = "pDrmFormatModifierProperties_" + std::to_string(consumer.getNextId());
        std::string pDrmFormatModifierPropertiesNames;
        for (uint32_t idx = 0; idx < structInfo->drmFormatModifierCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pDrmFormatModifierProperties + idx != NULL) {
                varName = GenerateStruct_VkDrmFormatModifierProperties2EXT(out,
                                                         structInfo->pDrmFormatModifierProperties + idx,
                                                         metainfo->pDrmFormatModifierProperties->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pDrmFormatModifierPropertiesNames += varName + ", ";
        }
        out << "VkDrmFormatModifierProperties2EXT " << pDrmFormatModifierPropertiesArray << "[] = {" << pDrmFormatModifierPropertiesNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* drmFormatModifierCount */
    structBody << "\t" << structInfo->drmFormatModifierCount << "," << std::endl;
/* pDrmFormatModifierProperties */
    structBody << "\t" << pDrmFormatModifierPropertiesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "drmFormatModifierPropertiesList2EXT");
    out << "VkDrmFormatModifierPropertiesList2EXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkValidationCacheCreateInfoEXT(std::ostream &out, const VkValidationCacheCreateInfoEXT* structInfo, Decoded_VkValidationCacheCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pInitialDataArray = "NULL";
    if (structInfo->pInitialData != NULL) {
        std::string pInitialDataValues;
        for (uint32_t idx0 = 0; idx0 < structInfo->initialDataSize; ++idx0) {
            pInitialDataValues += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pInitialData)[idx0]) + ", ";
        }
        pInitialDataArray = "pInitialData_" + std::to_string(consumer.getNextId());
        out << "uint8_t " << pInitialDataArray << "[] = {" << pInitialDataValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkValidationCacheCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* initialDataSize */
    structBody << "\t" << structInfo->initialDataSize << "," << std::endl;
/* pInitialData */
    structBody << "\t" << pInitialDataArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "validationCacheCreateInfoEXT");
    out << "VkValidationCacheCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkShaderModuleValidationCacheCreateInfoEXT(std::ostream &out, const VkShaderModuleValidationCacheCreateInfoEXT* structInfo, Decoded_VkShaderModuleValidationCacheCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* validationCache */
    structBody << "\t" << consumer.GetHandle(metainfo->validationCache) << "," ;
    std::string varname = consumer.AddStruct(structBody, "shaderModuleValidationCacheCreateInfoEXT");
    out << "VkShaderModuleValidationCacheCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkShadingRatePaletteNV(std::ostream &out, const VkShadingRatePaletteNV* structInfo, Decoded_VkShadingRatePaletteNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pShadingRatePaletteEntriesValues;
    std::string pShadingRatePaletteEntriesArray = "NULL";
    if (structInfo->pShadingRatePaletteEntries != NULL) {
        for (uint32_t idx = 0; idx < structInfo->shadingRatePaletteEntryCount; idx++) {
            pShadingRatePaletteEntriesValues += util::ToString<VkShadingRatePaletteEntryNV>(structInfo->pShadingRatePaletteEntries[idx]) + ", ";
        }
        pShadingRatePaletteEntriesArray = "pShadingRatePaletteEntries_" + std::to_string(consumer.getNextId());
        out << "VkShadingRatePaletteEntryNV " << pShadingRatePaletteEntriesArray << "[] = {" << pShadingRatePaletteEntriesValues << "};" << std::endl;
    }
/* shadingRatePaletteEntryCount */
    structBody << "\t" << structInfo->shadingRatePaletteEntryCount << "," << std::endl;
/* pShadingRatePaletteEntries */
    structBody << "\t" << pShadingRatePaletteEntriesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "shadingRatePaletteNV");
    out << "VkShadingRatePaletteNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineViewportShadingRateImageStateCreateInfoNV(std::ostream &out, const VkPipelineViewportShadingRateImageStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportShadingRateImageStateCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pShadingRatePalettesArray = "NULL";
    if (structInfo->pShadingRatePalettes != NULL) {
        pShadingRatePalettesArray = "pShadingRatePalettes_" + std::to_string(consumer.getNextId());
        std::string pShadingRatePalettesNames;
        for (uint32_t idx = 0; idx < structInfo->viewportCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pShadingRatePalettes + idx != NULL) {
                varName = GenerateStruct_VkShadingRatePaletteNV(out,
                                                         structInfo->pShadingRatePalettes + idx,
                                                         metainfo->pShadingRatePalettes->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pShadingRatePalettesNames += varName + ", ";
        }
        out << "VkShadingRatePaletteNV " << pShadingRatePalettesArray << "[] = {" << pShadingRatePalettesNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shadingRateImageEnable */
    structBody << "\t" << structInfo->shadingRateImageEnable << "," << std::endl;
/* viewportCount */
    structBody << "\t" << structInfo->viewportCount << "," << std::endl;
/* pShadingRatePalettes */
    structBody << "\t" << pShadingRatePalettesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineViewportShadingRateImageStateCreateInfoNV");
    out << "VkPipelineViewportShadingRateImageStateCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShadingRateImageFeaturesNV(std::ostream &out, const VkPhysicalDeviceShadingRateImageFeaturesNV* structInfo, Decoded_VkPhysicalDeviceShadingRateImageFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shadingRateImage */
    structBody << "\t" << structInfo->shadingRateImage << "," << std::endl;
/* shadingRateCoarseSampleOrder */
    structBody << "\t" << structInfo->shadingRateCoarseSampleOrder << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShadingRateImageFeaturesNV");
    out << "VkPhysicalDeviceShadingRateImageFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShadingRateImagePropertiesNV(std::ostream &out, const VkPhysicalDeviceShadingRateImagePropertiesNV* structInfo, Decoded_VkPhysicalDeviceShadingRateImagePropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string shadingRateTexelSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                             &structInfo->shadingRateTexelSize,
                                                                             metainfo->shadingRateTexelSize,
                                                                             consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shadingRateTexelSize */
    structBody << "\t" << shadingRateTexelSizeInfoVar << "," << std::endl;
/* shadingRatePaletteSize */
    structBody << "\t" << structInfo->shadingRatePaletteSize << "," << std::endl;
/* shadingRateMaxCoarseSamples */
    structBody << "\t" << structInfo->shadingRateMaxCoarseSamples << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShadingRateImagePropertiesNV");
    out << "VkPhysicalDeviceShadingRateImagePropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCoarseSampleLocationNV(std::ostream &out, const VkCoarseSampleLocationNV* structInfo, Decoded_VkCoarseSampleLocationNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* pixelX */
    structBody << "\t" << structInfo->pixelX << "," << std::endl;
/* pixelY */
    structBody << "\t" << structInfo->pixelY << "," << std::endl;
/* sample */
    structBody << "\t" << structInfo->sample << "," ;
    std::string varname = consumer.AddStruct(structBody, "coarseSampleLocationNV");
    out << "VkCoarseSampleLocationNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCoarseSampleOrderCustomNV(std::ostream &out, const VkCoarseSampleOrderCustomNV* structInfo, Decoded_VkCoarseSampleOrderCustomNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pSampleLocationsArray = "NULL";
    if (structInfo->pSampleLocations != NULL) {
        pSampleLocationsArray = "pSampleLocations_" + std::to_string(consumer.getNextId());
        std::string pSampleLocationsNames;
        for (uint32_t idx = 0; idx < structInfo->sampleLocationCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pSampleLocations + idx != NULL) {
                varName = GenerateStruct_VkCoarseSampleLocationNV(out,
                                                         structInfo->pSampleLocations + idx,
                                                         metainfo->pSampleLocations->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pSampleLocationsNames += varName + ", ";
        }
        out << "VkCoarseSampleLocationNV " << pSampleLocationsArray << "[] = {" << pSampleLocationsNames << "};" << std::endl;
    }
/* shadingRate */
    structBody << "\t" << "VkShadingRatePaletteEntryNV(" << structInfo->shadingRate << ")" << "," << std::endl;
/* sampleCount */
    structBody << "\t" << structInfo->sampleCount << "," << std::endl;
/* sampleLocationCount */
    structBody << "\t" << structInfo->sampleLocationCount << "," << std::endl;
/* pSampleLocations */
    structBody << "\t" << pSampleLocationsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "coarseSampleOrderCustomNV");
    out << "VkCoarseSampleOrderCustomNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV(std::ostream &out, const VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportCoarseSampleOrderStateCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pCustomSampleOrdersArray = "NULL";
    if (structInfo->pCustomSampleOrders != NULL) {
        pCustomSampleOrdersArray = "pCustomSampleOrders_" + std::to_string(consumer.getNextId());
        std::string pCustomSampleOrdersNames;
        for (uint32_t idx = 0; idx < structInfo->customSampleOrderCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pCustomSampleOrders + idx != NULL) {
                varName = GenerateStruct_VkCoarseSampleOrderCustomNV(out,
                                                         structInfo->pCustomSampleOrders + idx,
                                                         metainfo->pCustomSampleOrders->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pCustomSampleOrdersNames += varName + ", ";
        }
        out << "VkCoarseSampleOrderCustomNV " << pCustomSampleOrdersArray << "[] = {" << pCustomSampleOrdersNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* sampleOrderType */
    structBody << "\t" << "VkCoarseSampleOrderTypeNV(" << structInfo->sampleOrderType << ")" << "," << std::endl;
/* customSampleOrderCount */
    structBody << "\t" << structInfo->customSampleOrderCount << "," << std::endl;
/* pCustomSampleOrders */
    structBody << "\t" << pCustomSampleOrdersArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineViewportCoarseSampleOrderStateCreateInfoNV");
    out << "VkPipelineViewportCoarseSampleOrderStateCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRayTracingShaderGroupCreateInfoNV(std::ostream &out, const VkRayTracingShaderGroupCreateInfoNV* structInfo, Decoded_VkRayTracingShaderGroupCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* type */
    structBody << "\t" << "VkRayTracingShaderGroupTypeKHR(" << structInfo->type << ")" << "," << std::endl;
/* generalShader */
    structBody << "\t" << structInfo->generalShader << "," << std::endl;
/* closestHitShader */
    structBody << "\t" << structInfo->closestHitShader << "," << std::endl;
/* anyHitShader */
    structBody << "\t" << structInfo->anyHitShader << "," << std::endl;
/* intersectionShader */
    structBody << "\t" << structInfo->intersectionShader << "," ;
    std::string varname = consumer.AddStruct(structBody, "rayTracingShaderGroupCreateInfoNV");
    out << "VkRayTracingShaderGroupCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRayTracingPipelineCreateInfoNV(std::ostream &out, const VkRayTracingPipelineCreateInfoNV* structInfo, Decoded_VkRayTracingPipelineCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStagesArray = "NULL";
    if (structInfo->pStages != NULL) {
        pStagesArray = "pStages_" + std::to_string(consumer.getNextId());
        std::string pStagesNames;
        for (uint32_t idx = 0; idx < structInfo->stageCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStages + idx != NULL) {
                varName = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                         structInfo->pStages + idx,
                                                         metainfo->pStages->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStagesNames += varName + ", ";
        }
        out << "VkPipelineShaderStageCreateInfo " << pStagesArray << "[] = {" << pStagesNames << "};" << std::endl;
    }
    std::string pGroupsArray = "NULL";
    if (structInfo->pGroups != NULL) {
        pGroupsArray = "pGroups_" + std::to_string(consumer.getNextId());
        std::string pGroupsNames;
        for (uint32_t idx = 0; idx < structInfo->groupCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pGroups + idx != NULL) {
                varName = GenerateStruct_VkRayTracingShaderGroupCreateInfoNV(out,
                                                         structInfo->pGroups + idx,
                                                         metainfo->pGroups->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pGroupsNames += varName + ", ";
        }
        out << "VkRayTracingShaderGroupCreateInfoNV " << pGroupsArray << "[] = {" << pGroupsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* stageCount */
    structBody << "\t" << structInfo->stageCount << "," << std::endl;
/* pStages */
    structBody << "\t" << pStagesArray << "," << std::endl;
/* groupCount */
    structBody << "\t" << structInfo->groupCount << "," << std::endl;
/* pGroups */
    structBody << "\t" << pGroupsArray << "," << std::endl;
/* maxRecursionDepth */
    structBody << "\t" << structInfo->maxRecursionDepth << "," << std::endl;
/* layout */
    structBody << "\t" << consumer.GetHandle(metainfo->layout) << "," << std::endl;
/* basePipelineHandle */
    structBody << "\t" << consumer.GetHandle(metainfo->basePipelineHandle) << "," << std::endl;
/* basePipelineIndex */
    structBody << "\t" << structInfo->basePipelineIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "rayTracingPipelineCreateInfoNV");
    out << "VkRayTracingPipelineCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkGeometryTrianglesNV(std::ostream &out, const VkGeometryTrianglesNV* structInfo, Decoded_VkGeometryTrianglesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* vertexData */
    structBody << "\t" << consumer.GetHandle(metainfo->vertexData) << "," << std::endl;
/* vertexOffset */
    structBody << "\t" << structInfo->vertexOffset << "UL" << "," << std::endl;
/* vertexCount */
    structBody << "\t" << structInfo->vertexCount << "," << std::endl;
/* vertexStride */
    structBody << "\t" << structInfo->vertexStride << "UL" << "," << std::endl;
/* vertexFormat */
    structBody << "\t" << "VkFormat(" << structInfo->vertexFormat << ")" << "," << std::endl;
/* indexData */
    structBody << "\t" << consumer.GetHandle(metainfo->indexData) << "," << std::endl;
/* indexOffset */
    structBody << "\t" << structInfo->indexOffset << "UL" << "," << std::endl;
/* indexCount */
    structBody << "\t" << structInfo->indexCount << "," << std::endl;
/* indexType */
    structBody << "\t" << "VkIndexType(" << structInfo->indexType << ")" << "," << std::endl;
/* transformData */
    structBody << "\t" << consumer.GetHandle(metainfo->transformData) << "," << std::endl;
/* transformOffset */
    structBody << "\t" << structInfo->transformOffset << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "geometryTrianglesNV");
    out << "VkGeometryTrianglesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkGeometryAABBNV(std::ostream &out, const VkGeometryAABBNV* structInfo, Decoded_VkGeometryAABBNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* aabbData */
    structBody << "\t" << consumer.GetHandle(metainfo->aabbData) << "," << std::endl;
/* numAABBs */
    structBody << "\t" << structInfo->numAABBs << "," << std::endl;
/* stride */
    structBody << "\t" << structInfo->stride << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "geometryAABBNV");
    out << "VkGeometryAABBNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkGeometryDataNV(std::ostream &out, const VkGeometryDataNV* structInfo, Decoded_VkGeometryDataNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string trianglesInfoVar = GenerateStruct_VkGeometryTrianglesNV(out,
                                                                  &structInfo->triangles,
                                                                  metainfo->triangles,
                                                                  consumer);
    std::string aabbsInfoVar = GenerateStruct_VkGeometryAABBNV(out,
                                                              &structInfo->aabbs,
                                                              metainfo->aabbs,
                                                              consumer);
/* triangles */
    structBody << "\t" << trianglesInfoVar << "," << std::endl;
/* aabbs */
    structBody << "\t" << aabbsInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "geometryDataNV");
    out << "VkGeometryDataNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkGeometryNV(std::ostream &out, const VkGeometryNV* structInfo, Decoded_VkGeometryNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string geometryInfoVar = GenerateStruct_VkGeometryDataNV(out,
                                                                 &structInfo->geometry,
                                                                 metainfo->geometry,
                                                                 consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* geometryType */
    structBody << "\t" << "VkGeometryTypeKHR(" << structInfo->geometryType << ")" << "," << std::endl;
/* geometry */
    structBody << "\t" << geometryInfoVar << "," << std::endl;
/* flags */
    structBody << "\t" << "VkGeometryFlagsKHR(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "geometryNV");
    out << "VkGeometryNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureInfoNV(std::ostream &out, const VkAccelerationStructureInfoNV* structInfo, Decoded_VkAccelerationStructureInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pGeometriesArray = "NULL";
    if (structInfo->pGeometries != NULL) {
        pGeometriesArray = "pGeometries_" + std::to_string(consumer.getNextId());
        std::string pGeometriesNames;
        for (uint32_t idx = 0; idx < structInfo->geometryCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pGeometries + idx != NULL) {
                varName = GenerateStruct_VkGeometryNV(out,
                                                         structInfo->pGeometries + idx,
                                                         metainfo->pGeometries->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pGeometriesNames += varName + ", ";
        }
        out << "VkGeometryNV " << pGeometriesArray << "[] = {" << pGeometriesNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* type */
    structBody << "\t" << "VkAccelerationStructureTypeNV(" << structInfo->type << ")" << "," << std::endl;
/* flags */
    structBody << "\t" << "VkBuildAccelerationStructureFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
/* instanceCount */
    structBody << "\t" << structInfo->instanceCount << "," << std::endl;
/* geometryCount */
    structBody << "\t" << structInfo->geometryCount << "," << std::endl;
/* pGeometries */
    structBody << "\t" << pGeometriesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureInfoNV");
    out << "VkAccelerationStructureInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureCreateInfoNV(std::ostream &out, const VkAccelerationStructureCreateInfoNV* structInfo, Decoded_VkAccelerationStructureCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string infoInfoVar = GenerateStruct_VkAccelerationStructureInfoNV(out,
                                                             &structInfo->info,
                                                             metainfo->info,
                                                             consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* compactedSize */
    structBody << "\t" << structInfo->compactedSize << "UL" << "," << std::endl;
/* info */
    structBody << "\t" << infoInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureCreateInfoNV");
    out << "VkAccelerationStructureCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBindAccelerationStructureMemoryInfoNV(std::ostream &out, const VkBindAccelerationStructureMemoryInfoNV* structInfo, Decoded_VkBindAccelerationStructureMemoryInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDeviceIndicesArray = "NULL";
    if (structInfo->pDeviceIndices != NULL) {
        pDeviceIndicesArray = "pDeviceIndices_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pDeviceIndicesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pDeviceIndices, structInfo->deviceIndexCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* accelerationStructure */
    structBody << "\t" << consumer.GetHandle(metainfo->accelerationStructure) << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," << std::endl;
/* memoryOffset */
    structBody << "\t" << structInfo->memoryOffset << "UL" << "," << std::endl;
/* deviceIndexCount */
    structBody << "\t" << structInfo->deviceIndexCount << "," << std::endl;
/* pDeviceIndices */
    structBody << "\t" << pDeviceIndicesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "bindAccelerationStructureMemoryInfoNV");
    out << "VkBindAccelerationStructureMemoryInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkWriteDescriptorSetAccelerationStructureNV(std::ostream &out, const VkWriteDescriptorSetAccelerationStructureNV* structInfo, Decoded_VkWriteDescriptorSetAccelerationStructureNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pAccelerationStructuresArray = "NULL";
    if (metainfo->pAccelerationStructures.GetPointer() != NULL && structInfo->accelerationStructureCount > 0) {
        pAccelerationStructuresArray = "pAccelerationStructuresArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_NV));
        std::string pAccelerationStructuresValues = toStringJoin(metainfo->pAccelerationStructures.GetPointer(),
                                                                 metainfo->pAccelerationStructures.GetPointer() + structInfo->accelerationStructureCount,
                                                                 [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                                 ", ");
        if (structInfo->accelerationStructureCount == 1) {
            pAccelerationStructuresArray = "&" + pAccelerationStructuresValues;
        } else if (structInfo->accelerationStructureCount > 1) {
            out << "VkAccelerationStructureNV " << pAccelerationStructuresArray << "[] = {" << pAccelerationStructuresValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* accelerationStructureCount */
    structBody << "\t" << structInfo->accelerationStructureCount << "," << std::endl;
/* pAccelerationStructures */
    structBody << "\t" << pAccelerationStructuresArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "writeDescriptorSetAccelerationStructureNV");
    out << "VkWriteDescriptorSetAccelerationStructureNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureMemoryRequirementsInfoNV(std::ostream &out, const VkAccelerationStructureMemoryRequirementsInfoNV* structInfo, Decoded_VkAccelerationStructureMemoryRequirementsInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* type */
    structBody << "\t" << "VkAccelerationStructureMemoryRequirementsTypeNV(" << structInfo->type << ")" << "," << std::endl;
/* accelerationStructure */
    structBody << "\t" << consumer.GetHandle(metainfo->accelerationStructure) << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureMemoryRequirementsInfoNV");
    out << "VkAccelerationStructureMemoryRequirementsInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingPropertiesNV(std::ostream &out, const VkPhysicalDeviceRayTracingPropertiesNV* structInfo, Decoded_VkPhysicalDeviceRayTracingPropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderGroupHandleSize */
    structBody << "\t" << structInfo->shaderGroupHandleSize << "," << std::endl;
/* maxRecursionDepth */
    structBody << "\t" << structInfo->maxRecursionDepth << "," << std::endl;
/* maxShaderGroupStride */
    structBody << "\t" << structInfo->maxShaderGroupStride << "," << std::endl;
/* shaderGroupBaseAlignment */
    structBody << "\t" << structInfo->shaderGroupBaseAlignment << "," << std::endl;
/* maxGeometryCount */
    structBody << "\t" << structInfo->maxGeometryCount << "UL" << "," << std::endl;
/* maxInstanceCount */
    structBody << "\t" << structInfo->maxInstanceCount << "UL" << "," << std::endl;
/* maxTriangleCount */
    structBody << "\t" << structInfo->maxTriangleCount << "UL" << "," << std::endl;
/* maxDescriptorSetAccelerationStructures */
    structBody << "\t" << structInfo->maxDescriptorSetAccelerationStructures << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceRayTracingPropertiesNV");
    out << "VkPhysicalDeviceRayTracingPropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkTransformMatrixKHR(std::ostream &out, const VkTransformMatrixKHR* structInfo, Decoded_VkTransformMatrixKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* matrix */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const float*>(&structInfo->matrix[0][0]), 3) << "," ;
    std::string varname = consumer.AddStruct(structBody, "transformMatrixKHR");
    out << "VkTransformMatrixKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAabbPositionsKHR(std::ostream &out, const VkAabbPositionsKHR* structInfo, Decoded_VkAabbPositionsKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* minX */
    structBody << "\t" << structInfo->minX << "," << std::endl;
/* minY */
    structBody << "\t" << structInfo->minY << "," << std::endl;
/* minZ */
    structBody << "\t" << structInfo->minZ << "," << std::endl;
/* maxX */
    structBody << "\t" << structInfo->maxX << "," << std::endl;
/* maxY */
    structBody << "\t" << structInfo->maxY << "," << std::endl;
/* maxZ */
    structBody << "\t" << structInfo->maxZ << "," ;
    std::string varname = consumer.AddStruct(structBody, "aabbPositionsKHR");
    out << "VkAabbPositionsKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureInstanceKHR(std::ostream &out, const VkAccelerationStructureInstanceKHR* structInfo, Decoded_VkAccelerationStructureInstanceKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string transformInfoVar = GenerateStruct_VkTransformMatrixKHR(out,
                                                                  &structInfo->transform,
                                                                  metainfo->transform,
                                                                  consumer);
/* transform */
    structBody << "\t" << transformInfoVar << "," << std::endl;
/* instanceCustomIndex */
    structBody << "\t" << structInfo->instanceCustomIndex << "," << std::endl;
/* mask */
    structBody << "\t" << structInfo->mask << "," << std::endl;
/* instanceShaderBindingTableRecordOffset */
    structBody << "\t" << structInfo->instanceShaderBindingTableRecordOffset << "," << std::endl;
/* flags */
    structBody << "\t" << "VkGeometryInstanceFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* accelerationStructureReference */
    structBody << "\t" << structInfo->accelerationStructureReference << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureInstanceKHR");
    out << "VkAccelerationStructureInstanceKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV(std::ostream &out, const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* structInfo, Decoded_VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* representativeFragmentTest */
    structBody << "\t" << structInfo->representativeFragmentTest << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceRepresentativeFragmentTestFeaturesNV");
    out << "VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineRepresentativeFragmentTestStateCreateInfoNV(std::ostream &out, const VkPipelineRepresentativeFragmentTestStateCreateInfoNV* structInfo, Decoded_VkPipelineRepresentativeFragmentTestStateCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* representativeFragmentTestEnable */
    structBody << "\t" << structInfo->representativeFragmentTestEnable << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineRepresentativeFragmentTestStateCreateInfoNV");
    out << "VkPipelineRepresentativeFragmentTestStateCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceImageViewImageFormatInfoEXT(std::ostream &out, const VkPhysicalDeviceImageViewImageFormatInfoEXT* structInfo, Decoded_VkPhysicalDeviceImageViewImageFormatInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* imageViewType */
    structBody << "\t" << "VkImageViewType(" << structInfo->imageViewType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceImageViewImageFormatInfoEXT");
    out << "VkPhysicalDeviceImageViewImageFormatInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkFilterCubicImageViewImageFormatPropertiesEXT(std::ostream &out, const VkFilterCubicImageViewImageFormatPropertiesEXT* structInfo, Decoded_VkFilterCubicImageViewImageFormatPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* filterCubic */
    structBody << "\t" << structInfo->filterCubic << "," << std::endl;
/* filterCubicMinmax */
    structBody << "\t" << structInfo->filterCubicMinmax << "," ;
    std::string varname = consumer.AddStruct(structBody, "filterCubicImageViewImageFormatPropertiesEXT");
    out << "VkFilterCubicImageViewImageFormatPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImportMemoryHostPointerInfoEXT(std::ostream &out, const VkImportMemoryHostPointerInfoEXT* structInfo, Decoded_VkImportMemoryHostPointerInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
/* pHostPointer */
    out << "// TODO: Support pHostPointer (output?) argument." << std::endl;
    std::string varname = consumer.AddStruct(structBody, "importMemoryHostPointerInfoEXT");
    out << "VkImportMemoryHostPointerInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryHostPointerPropertiesEXT(std::ostream &out, const VkMemoryHostPointerPropertiesEXT* structInfo, Decoded_VkMemoryHostPointerPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memoryTypeBits */
    structBody << "\t" << structInfo->memoryTypeBits << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryHostPointerPropertiesEXT");
    out << "VkMemoryHostPointerPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExternalMemoryHostPropertiesEXT(std::ostream &out, const VkPhysicalDeviceExternalMemoryHostPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceExternalMemoryHostPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* minImportedHostPointerAlignment */
    structBody << "\t" << structInfo->minImportedHostPointerAlignment << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExternalMemoryHostPropertiesEXT");
    out << "VkPhysicalDeviceExternalMemoryHostPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineCompilerControlCreateInfoAMD(std::ostream &out, const VkPipelineCompilerControlCreateInfoAMD* structInfo, Decoded_VkPipelineCompilerControlCreateInfoAMD* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* compilerControlFlags */
    structBody << "\t" << "VkPipelineCompilerControlFlagsAMD(" << structInfo->compilerControlFlags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineCompilerControlCreateInfoAMD");
    out << "VkPipelineCompilerControlCreateInfoAMD " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCalibratedTimestampInfoEXT(std::ostream &out, const VkCalibratedTimestampInfoEXT* structInfo, Decoded_VkCalibratedTimestampInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* timeDomain */
    structBody << "\t" << "VkTimeDomainEXT(" << structInfo->timeDomain << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "calibratedTimestampInfoEXT");
    out << "VkCalibratedTimestampInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCorePropertiesAMD(std::ostream &out, const VkPhysicalDeviceShaderCorePropertiesAMD* structInfo, Decoded_VkPhysicalDeviceShaderCorePropertiesAMD* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderEngineCount */
    structBody << "\t" << structInfo->shaderEngineCount << "," << std::endl;
/* shaderArraysPerEngineCount */
    structBody << "\t" << structInfo->shaderArraysPerEngineCount << "," << std::endl;
/* computeUnitsPerShaderArray */
    structBody << "\t" << structInfo->computeUnitsPerShaderArray << "," << std::endl;
/* simdPerComputeUnit */
    structBody << "\t" << structInfo->simdPerComputeUnit << "," << std::endl;
/* wavefrontsPerSimd */
    structBody << "\t" << structInfo->wavefrontsPerSimd << "," << std::endl;
/* wavefrontSize */
    structBody << "\t" << structInfo->wavefrontSize << "," << std::endl;
/* sgprsPerSimd */
    structBody << "\t" << structInfo->sgprsPerSimd << "," << std::endl;
/* minSgprAllocation */
    structBody << "\t" << structInfo->minSgprAllocation << "," << std::endl;
/* maxSgprAllocation */
    structBody << "\t" << structInfo->maxSgprAllocation << "," << std::endl;
/* sgprAllocationGranularity */
    structBody << "\t" << structInfo->sgprAllocationGranularity << "," << std::endl;
/* vgprsPerSimd */
    structBody << "\t" << structInfo->vgprsPerSimd << "," << std::endl;
/* minVgprAllocation */
    structBody << "\t" << structInfo->minVgprAllocation << "," << std::endl;
/* maxVgprAllocation */
    structBody << "\t" << structInfo->maxVgprAllocation << "," << std::endl;
/* vgprAllocationGranularity */
    structBody << "\t" << structInfo->vgprAllocationGranularity << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderCorePropertiesAMD");
    out << "VkPhysicalDeviceShaderCorePropertiesAMD " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceMemoryOverallocationCreateInfoAMD(std::ostream &out, const VkDeviceMemoryOverallocationCreateInfoAMD* structInfo, Decoded_VkDeviceMemoryOverallocationCreateInfoAMD* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* overallocationBehavior */
    structBody << "\t" << "VkMemoryOverallocationBehaviorAMD(" << structInfo->overallocationBehavior << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceMemoryOverallocationCreateInfoAMD");
    out << "VkDeviceMemoryOverallocationCreateInfoAMD " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT(std::ostream &out, const VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxVertexAttribDivisor */
    structBody << "\t" << structInfo->maxVertexAttribDivisor << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceVertexAttributeDivisorPropertiesEXT");
    out << "VkPhysicalDeviceVertexAttributeDivisorPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVertexInputBindingDivisorDescriptionEXT(std::ostream &out, const VkVertexInputBindingDivisorDescriptionEXT* structInfo, Decoded_VkVertexInputBindingDivisorDescriptionEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* binding */
    structBody << "\t" << structInfo->binding << "," << std::endl;
/* divisor */
    structBody << "\t" << structInfo->divisor << "," ;
    std::string varname = consumer.AddStruct(structBody, "vertexInputBindingDivisorDescriptionEXT");
    out << "VkVertexInputBindingDivisorDescriptionEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineVertexInputDivisorStateCreateInfoEXT(std::ostream &out, const VkPipelineVertexInputDivisorStateCreateInfoEXT* structInfo, Decoded_VkPipelineVertexInputDivisorStateCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pVertexBindingDivisorsArray = "NULL";
    if (structInfo->pVertexBindingDivisors != NULL) {
        pVertexBindingDivisorsArray = "pVertexBindingDivisors_" + std::to_string(consumer.getNextId());
        std::string pVertexBindingDivisorsNames;
        for (uint32_t idx = 0; idx < structInfo->vertexBindingDivisorCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pVertexBindingDivisors + idx != NULL) {
                varName = GenerateStruct_VkVertexInputBindingDivisorDescriptionEXT(out,
                                                         structInfo->pVertexBindingDivisors + idx,
                                                         metainfo->pVertexBindingDivisors->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pVertexBindingDivisorsNames += varName + ", ";
        }
        out << "VkVertexInputBindingDivisorDescriptionEXT " << pVertexBindingDivisorsArray << "[] = {" << pVertexBindingDivisorsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* vertexBindingDivisorCount */
    structBody << "\t" << structInfo->vertexBindingDivisorCount << "," << std::endl;
/* pVertexBindingDivisors */
    structBody << "\t" << pVertexBindingDivisorsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineVertexInputDivisorStateCreateInfoEXT");
    out << "VkPipelineVertexInputDivisorStateCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT(std::ostream &out, const VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* vertexAttributeInstanceRateDivisor */
    structBody << "\t" << structInfo->vertexAttributeInstanceRateDivisor << "," << std::endl;
/* vertexAttributeInstanceRateZeroDivisor */
    structBody << "\t" << structInfo->vertexAttributeInstanceRateZeroDivisor << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceVertexAttributeDivisorFeaturesEXT");
    out << "VkPhysicalDeviceVertexAttributeDivisorFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPresentFrameTokenGGP(std::ostream &out, const VkPresentFrameTokenGGP* structInfo, Decoded_VkPresentFrameTokenGGP* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* frameToken */
    structBody << "\t" << structInfo->frameToken << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "presentFrameTokenGGP");
    out << "VkPresentFrameTokenGGP " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV(std::ostream &out, const VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* structInfo, Decoded_VkPhysicalDeviceComputeShaderDerivativesFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* computeDerivativeGroupQuads */
    structBody << "\t" << structInfo->computeDerivativeGroupQuads << "," << std::endl;
/* computeDerivativeGroupLinear */
    structBody << "\t" << structInfo->computeDerivativeGroupLinear << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceComputeShaderDerivativesFeaturesNV");
    out << "VkPhysicalDeviceComputeShaderDerivativesFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMeshShaderFeaturesNV(std::ostream &out, const VkPhysicalDeviceMeshShaderFeaturesNV* structInfo, Decoded_VkPhysicalDeviceMeshShaderFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* taskShader */
    structBody << "\t" << structInfo->taskShader << "," << std::endl;
/* meshShader */
    structBody << "\t" << structInfo->meshShader << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMeshShaderFeaturesNV");
    out << "VkPhysicalDeviceMeshShaderFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMeshShaderPropertiesNV(std::ostream &out, const VkPhysicalDeviceMeshShaderPropertiesNV* structInfo, Decoded_VkPhysicalDeviceMeshShaderPropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxDrawMeshTasksCount */
    structBody << "\t" << structInfo->maxDrawMeshTasksCount << "," << std::endl;
/* maxTaskWorkGroupInvocations */
    structBody << "\t" << structInfo->maxTaskWorkGroupInvocations << "," << std::endl;
/* maxTaskWorkGroupSize */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxTaskWorkGroupSize[0]), 3) << "," << std::endl;
/* maxTaskTotalMemorySize */
    structBody << "\t" << structInfo->maxTaskTotalMemorySize << "," << std::endl;
/* maxTaskOutputCount */
    structBody << "\t" << structInfo->maxTaskOutputCount << "," << std::endl;
/* maxMeshWorkGroupInvocations */
    structBody << "\t" << structInfo->maxMeshWorkGroupInvocations << "," << std::endl;
/* maxMeshWorkGroupSize */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxMeshWorkGroupSize[0]), 3) << "," << std::endl;
/* maxMeshTotalMemorySize */
    structBody << "\t" << structInfo->maxMeshTotalMemorySize << "," << std::endl;
/* maxMeshOutputVertices */
    structBody << "\t" << structInfo->maxMeshOutputVertices << "," << std::endl;
/* maxMeshOutputPrimitives */
    structBody << "\t" << structInfo->maxMeshOutputPrimitives << "," << std::endl;
/* maxMeshMultiviewViewCount */
    structBody << "\t" << structInfo->maxMeshMultiviewViewCount << "," << std::endl;
/* meshOutputPerVertexGranularity */
    structBody << "\t" << structInfo->meshOutputPerVertexGranularity << "," << std::endl;
/* meshOutputPerPrimitiveGranularity */
    structBody << "\t" << structInfo->meshOutputPerPrimitiveGranularity << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMeshShaderPropertiesNV");
    out << "VkPhysicalDeviceMeshShaderPropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDrawMeshTasksIndirectCommandNV(std::ostream &out, const VkDrawMeshTasksIndirectCommandNV* structInfo, Decoded_VkDrawMeshTasksIndirectCommandNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* taskCount */
    structBody << "\t" << structInfo->taskCount << "," << std::endl;
/* firstTask */
    structBody << "\t" << structInfo->firstTask << "," ;
    std::string varname = consumer.AddStruct(structBody, "drawMeshTasksIndirectCommandNV");
    out << "VkDrawMeshTasksIndirectCommandNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderImageFootprintFeaturesNV(std::ostream &out, const VkPhysicalDeviceShaderImageFootprintFeaturesNV* structInfo, Decoded_VkPhysicalDeviceShaderImageFootprintFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* imageFootprint */
    structBody << "\t" << structInfo->imageFootprint << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderImageFootprintFeaturesNV");
    out << "VkPhysicalDeviceShaderImageFootprintFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineViewportExclusiveScissorStateCreateInfoNV(std::ostream &out, const VkPipelineViewportExclusiveScissorStateCreateInfoNV* structInfo, Decoded_VkPipelineViewportExclusiveScissorStateCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pExclusiveScissorsArray = "NULL";
    if (structInfo->pExclusiveScissors != NULL) {
        pExclusiveScissorsArray = "pExclusiveScissors_" + std::to_string(consumer.getNextId());
        out << "VkRect2D " << pExclusiveScissorsArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pExclusiveScissors, structInfo->exclusiveScissorCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* exclusiveScissorCount */
    structBody << "\t" << structInfo->exclusiveScissorCount << "," << std::endl;
/* pExclusiveScissors */
    structBody << "\t" << pExclusiveScissorsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineViewportExclusiveScissorStateCreateInfoNV");
    out << "VkPipelineViewportExclusiveScissorStateCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExclusiveScissorFeaturesNV(std::ostream &out, const VkPhysicalDeviceExclusiveScissorFeaturesNV* structInfo, Decoded_VkPhysicalDeviceExclusiveScissorFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* exclusiveScissor */
    structBody << "\t" << structInfo->exclusiveScissor << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExclusiveScissorFeaturesNV");
    out << "VkPhysicalDeviceExclusiveScissorFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkQueueFamilyCheckpointPropertiesNV(std::ostream &out, const VkQueueFamilyCheckpointPropertiesNV* structInfo, Decoded_VkQueueFamilyCheckpointPropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* checkpointExecutionStageMask */
    structBody << "\t" << "VkPipelineStageFlags(" << structInfo->checkpointExecutionStageMask << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "queueFamilyCheckpointPropertiesNV");
    out << "VkQueueFamilyCheckpointPropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCheckpointDataNV(std::ostream &out, const VkCheckpointDataNV* structInfo, Decoded_VkCheckpointDataNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stage */
    structBody << "\t" << "VkPipelineStageFlagBits(" << structInfo->stage << ")" << "," << std::endl;
/* pCheckpointMarker */
    out << "// TODO: Support pCheckpointMarker (output?) argument." << std::endl;
    std::string varname = consumer.AddStruct(structBody, "checkpointDataNV");
    out << "VkCheckpointDataNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL(std::ostream &out, const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* structInfo, Decoded_VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderIntegerFunctions2 */
    structBody << "\t" << structInfo->shaderIntegerFunctions2 << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderIntegerFunctions2FeaturesINTEL");
    out << "VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPerformanceValueINTEL(std::ostream &out, const VkPerformanceValueINTEL* structInfo, Decoded_VkPerformanceValueINTEL* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* type */
    structBody << "\t" << "VkPerformanceValueTypeINTEL(" << structInfo->type << ")" << "," << std::endl;
/* data */
    structBody << "\t" << structInfo->data.value32 << "," ;
    std::string varname = consumer.AddStruct(structBody, "performanceValueINTEL");
    out << "VkPerformanceValueINTEL " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkInitializePerformanceApiInfoINTEL(std::ostream &out, const VkInitializePerformanceApiInfoINTEL* structInfo, Decoded_VkInitializePerformanceApiInfoINTEL* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pUserData */
    out << "// TODO: Support pUserData (output?) argument." << std::endl;
    std::string varname = consumer.AddStruct(structBody, "initializePerformanceApiInfoINTEL");
    out << "VkInitializePerformanceApiInfoINTEL " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkQueryPoolPerformanceQueryCreateInfoINTEL(std::ostream &out, const VkQueryPoolPerformanceQueryCreateInfoINTEL* structInfo, Decoded_VkQueryPoolPerformanceQueryCreateInfoINTEL* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* performanceCountersSampling */
    structBody << "\t" << "VkQueryPoolSamplingModeINTEL(" << structInfo->performanceCountersSampling << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "queryPoolPerformanceQueryCreateInfoINTEL");
    out << "VkQueryPoolPerformanceQueryCreateInfoINTEL " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPerformanceMarkerInfoINTEL(std::ostream &out, const VkPerformanceMarkerInfoINTEL* structInfo, Decoded_VkPerformanceMarkerInfoINTEL* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* marker */
    structBody << "\t" << structInfo->marker << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "performanceMarkerInfoINTEL");
    out << "VkPerformanceMarkerInfoINTEL " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPerformanceStreamMarkerInfoINTEL(std::ostream &out, const VkPerformanceStreamMarkerInfoINTEL* structInfo, Decoded_VkPerformanceStreamMarkerInfoINTEL* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* marker */
    structBody << "\t" << structInfo->marker << "," ;
    std::string varname = consumer.AddStruct(structBody, "performanceStreamMarkerInfoINTEL");
    out << "VkPerformanceStreamMarkerInfoINTEL " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPerformanceOverrideInfoINTEL(std::ostream &out, const VkPerformanceOverrideInfoINTEL* structInfo, Decoded_VkPerformanceOverrideInfoINTEL* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* type */
    structBody << "\t" << "VkPerformanceOverrideTypeINTEL(" << structInfo->type << ")" << "," << std::endl;
/* enable */
    structBody << "\t" << structInfo->enable << "," << std::endl;
/* parameter */
    structBody << "\t" << structInfo->parameter << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "performanceOverrideInfoINTEL");
    out << "VkPerformanceOverrideInfoINTEL " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPerformanceConfigurationAcquireInfoINTEL(std::ostream &out, const VkPerformanceConfigurationAcquireInfoINTEL* structInfo, Decoded_VkPerformanceConfigurationAcquireInfoINTEL* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* type */
    structBody << "\t" << "VkPerformanceConfigurationTypeINTEL(" << structInfo->type << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "performanceConfigurationAcquireInfoINTEL");
    out << "VkPerformanceConfigurationAcquireInfoINTEL " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePCIBusInfoPropertiesEXT(std::ostream &out, const VkPhysicalDevicePCIBusInfoPropertiesEXT* structInfo, Decoded_VkPhysicalDevicePCIBusInfoPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pciDomain */
    structBody << "\t" << structInfo->pciDomain << "," << std::endl;
/* pciBus */
    structBody << "\t" << structInfo->pciBus << "," << std::endl;
/* pciDevice */
    structBody << "\t" << structInfo->pciDevice << "," << std::endl;
/* pciFunction */
    structBody << "\t" << structInfo->pciFunction << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePCIBusInfoPropertiesEXT");
    out << "VkPhysicalDevicePCIBusInfoPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDisplayNativeHdrSurfaceCapabilitiesAMD(std::ostream &out, const VkDisplayNativeHdrSurfaceCapabilitiesAMD* structInfo, Decoded_VkDisplayNativeHdrSurfaceCapabilitiesAMD* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* localDimmingSupport */
    structBody << "\t" << structInfo->localDimmingSupport << "," ;
    std::string varname = consumer.AddStruct(structBody, "displayNativeHdrSurfaceCapabilitiesAMD");
    out << "VkDisplayNativeHdrSurfaceCapabilitiesAMD " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSwapchainDisplayNativeHdrCreateInfoAMD(std::ostream &out, const VkSwapchainDisplayNativeHdrCreateInfoAMD* structInfo, Decoded_VkSwapchainDisplayNativeHdrCreateInfoAMD* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* localDimmingEnable */
    structBody << "\t" << structInfo->localDimmingEnable << "," ;
    std::string varname = consumer.AddStruct(structBody, "swapchainDisplayNativeHdrCreateInfoAMD");
    out << "VkSwapchainDisplayNativeHdrCreateInfoAMD " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImagePipeSurfaceCreateInfoFUCHSIA(std::ostream &out, const VkImagePipeSurfaceCreateInfoFUCHSIA* structInfo, Decoded_VkImagePipeSurfaceCreateInfoFUCHSIA* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkImagePipeSurfaceCreateFlagsFUCHSIA(" << structInfo->flags << ")" << "," << std::endl;
/* imagePipeHandle */
    structBody << "\t" << structInfo->imagePipeHandle << "," ;
    std::string varname = consumer.AddStruct(structBody, "imagePipeSurfaceCreateInfoFUCHSIA");
    out << "VkImagePipeSurfaceCreateInfoFUCHSIA " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMetalSurfaceCreateInfoEXT(std::ostream &out, const VkMetalSurfaceCreateInfoEXT* structInfo, Decoded_VkMetalSurfaceCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkMetalSurfaceCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* pLayer */
    structBody << "\t" << structInfo->pLayer << "," ;
    std::string varname = consumer.AddStruct(structBody, "metalSurfaceCreateInfoEXT");
    out << "VkMetalSurfaceCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMapFeaturesEXT(std::ostream &out, const VkPhysicalDeviceFragmentDensityMapFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMapFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fragmentDensityMap */
    structBody << "\t" << structInfo->fragmentDensityMap << "," << std::endl;
/* fragmentDensityMapDynamic */
    structBody << "\t" << structInfo->fragmentDensityMapDynamic << "," << std::endl;
/* fragmentDensityMapNonSubsampledImages */
    structBody << "\t" << structInfo->fragmentDensityMapNonSubsampledImages << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFragmentDensityMapFeaturesEXT");
    out << "VkPhysicalDeviceFragmentDensityMapFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMapPropertiesEXT(std::ostream &out, const VkPhysicalDeviceFragmentDensityMapPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMapPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string minFragmentDensityTexelSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                                    &structInfo->minFragmentDensityTexelSize,
                                                                                    metainfo->minFragmentDensityTexelSize,
                                                                                    consumer);
    std::string maxFragmentDensityTexelSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                                    &structInfo->maxFragmentDensityTexelSize,
                                                                                    metainfo->maxFragmentDensityTexelSize,
                                                                                    consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* minFragmentDensityTexelSize */
    structBody << "\t" << minFragmentDensityTexelSizeInfoVar << "," << std::endl;
/* maxFragmentDensityTexelSize */
    structBody << "\t" << maxFragmentDensityTexelSizeInfoVar << "," << std::endl;
/* fragmentDensityInvocations */
    structBody << "\t" << structInfo->fragmentDensityInvocations << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFragmentDensityMapPropertiesEXT");
    out << "VkPhysicalDeviceFragmentDensityMapPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderPassFragmentDensityMapCreateInfoEXT(std::ostream &out, const VkRenderPassFragmentDensityMapCreateInfoEXT* structInfo, Decoded_VkRenderPassFragmentDensityMapCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string fragmentDensityMapAttachmentInfoVar = GenerateStruct_VkAttachmentReference(out,
                                                                                     &structInfo->fragmentDensityMapAttachment,
                                                                                     metainfo->fragmentDensityMapAttachment,
                                                                                     consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fragmentDensityMapAttachment */
    structBody << "\t" << fragmentDensityMapAttachmentInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderPassFragmentDensityMapCreateInfoEXT");
    out << "VkRenderPassFragmentDensityMapCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCoreProperties2AMD(std::ostream &out, const VkPhysicalDeviceShaderCoreProperties2AMD* structInfo, Decoded_VkPhysicalDeviceShaderCoreProperties2AMD* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderCoreFeatures */
    structBody << "\t" << "VkShaderCorePropertiesFlagsAMD(" << structInfo->shaderCoreFeatures << ")" << "," << std::endl;
/* activeComputeUnitCount */
    structBody << "\t" << structInfo->activeComputeUnitCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderCoreProperties2AMD");
    out << "VkPhysicalDeviceShaderCoreProperties2AMD " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceCoherentMemoryFeaturesAMD(std::ostream &out, const VkPhysicalDeviceCoherentMemoryFeaturesAMD* structInfo, Decoded_VkPhysicalDeviceCoherentMemoryFeaturesAMD* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceCoherentMemory */
    structBody << "\t" << structInfo->deviceCoherentMemory << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceCoherentMemoryFeaturesAMD");
    out << "VkPhysicalDeviceCoherentMemoryFeaturesAMD " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderImageInt64Atomics */
    structBody << "\t" << structInfo->shaderImageInt64Atomics << "," << std::endl;
/* sparseImageInt64Atomics */
    structBody << "\t" << structInfo->sparseImageInt64Atomics << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderImageAtomicInt64FeaturesEXT");
    out << "VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMemoryBudgetPropertiesEXT(std::ostream &out, const VkPhysicalDeviceMemoryBudgetPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceMemoryBudgetPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string heapBudgetArray = "heapBudgetArray_" + std::to_string(consumer.getNextId());
    if (VK_MAX_MEMORY_HEAPS > 0) {
        std::string heapBudgetValues = toStringJoin(structInfo->heapBudget,
                                                    structInfo->heapBudget + VK_MAX_MEMORY_HEAPS,
                                                    [](VkDeviceSize current) { return std::to_string(current); },
                                                    ", ");
        if (VK_MAX_MEMORY_HEAPS == 1) {
            heapBudgetArray = "&" + heapBudgetValues;
        } else if (VK_MAX_MEMORY_HEAPS > 1) {
            out << "VkDeviceSize " << heapBudgetArray << "[] = {" << heapBudgetValues << "};" << std::endl;
        }
    }
    std::string heapUsageArray = "heapUsageArray_" + std::to_string(consumer.getNextId());
    if (VK_MAX_MEMORY_HEAPS > 0) {
        std::string heapUsageValues = toStringJoin(structInfo->heapUsage,
                                                   structInfo->heapUsage + VK_MAX_MEMORY_HEAPS,
                                                   [](VkDeviceSize current) { return std::to_string(current); },
                                                   ", ");
        if (VK_MAX_MEMORY_HEAPS == 1) {
            heapUsageArray = "&" + heapUsageValues;
        } else if (VK_MAX_MEMORY_HEAPS > 1) {
            out << "VkDeviceSize " << heapUsageArray << "[] = {" << heapUsageValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* heapBudget */
    structBody << "\t" << "{ *" << heapBudgetArray << " }" << "," << std::endl;
/* heapUsage */
    structBody << "\t" << "{ *" << heapUsageArray << " }" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMemoryBudgetPropertiesEXT");
    out << "VkPhysicalDeviceMemoryBudgetPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMemoryPriorityFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMemoryPriorityFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMemoryPriorityFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memoryPriority */
    structBody << "\t" << structInfo->memoryPriority << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMemoryPriorityFeaturesEXT");
    out << "VkPhysicalDeviceMemoryPriorityFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryPriorityAllocateInfoEXT(std::ostream &out, const VkMemoryPriorityAllocateInfoEXT* structInfo, Decoded_VkMemoryPriorityAllocateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* priority */
    structBody << "\t" << structInfo->priority << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryPriorityAllocateInfoEXT");
    out << "VkMemoryPriorityAllocateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV(std::ostream &out, const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* dedicatedAllocationImageAliasing */
    structBody << "\t" << structInfo->dedicatedAllocationImageAliasing << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDedicatedAllocationImageAliasingFeaturesNV");
    out << "VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT(std::ostream &out, const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceBufferDeviceAddressFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* bufferDeviceAddress */
    structBody << "\t" << structInfo->bufferDeviceAddress << "," << std::endl;
/* bufferDeviceAddressCaptureReplay */
    structBody << "\t" << structInfo->bufferDeviceAddressCaptureReplay << "," << std::endl;
/* bufferDeviceAddressMultiDevice */
    structBody << "\t" << structInfo->bufferDeviceAddressMultiDevice << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceBufferDeviceAddressFeaturesEXT");
    out << "VkPhysicalDeviceBufferDeviceAddressFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBufferDeviceAddressCreateInfoEXT(std::ostream &out, const VkBufferDeviceAddressCreateInfoEXT* structInfo, Decoded_VkBufferDeviceAddressCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceAddress */
    structBody << "\t" << structInfo->deviceAddress << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "bufferDeviceAddressCreateInfoEXT");
    out << "VkBufferDeviceAddressCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkValidationFeaturesEXT(std::ostream &out, const VkValidationFeaturesEXT* structInfo, Decoded_VkValidationFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pEnabledValidationFeaturesValues;
    std::string pEnabledValidationFeaturesArray = "NULL";
    if (structInfo->pEnabledValidationFeatures != NULL) {
        for (uint32_t idx = 0; idx < structInfo->enabledValidationFeatureCount; idx++) {
            pEnabledValidationFeaturesValues += util::ToString<VkValidationFeatureEnableEXT>(structInfo->pEnabledValidationFeatures[idx]) + ", ";
        }
        pEnabledValidationFeaturesArray = "pEnabledValidationFeatures_" + std::to_string(consumer.getNextId());
        out << "VkValidationFeatureEnableEXT " << pEnabledValidationFeaturesArray << "[] = {" << pEnabledValidationFeaturesValues << "};" << std::endl;
    }
    std::string pDisabledValidationFeaturesValues;
    std::string pDisabledValidationFeaturesArray = "NULL";
    if (structInfo->pDisabledValidationFeatures != NULL) {
        for (uint32_t idx = 0; idx < structInfo->disabledValidationFeatureCount; idx++) {
            pDisabledValidationFeaturesValues += util::ToString<VkValidationFeatureDisableEXT>(structInfo->pDisabledValidationFeatures[idx]) + ", ";
        }
        pDisabledValidationFeaturesArray = "pDisabledValidationFeatures_" + std::to_string(consumer.getNextId());
        out << "VkValidationFeatureDisableEXT " << pDisabledValidationFeaturesArray << "[] = {" << pDisabledValidationFeaturesValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* enabledValidationFeatureCount */
    structBody << "\t" << structInfo->enabledValidationFeatureCount << "," << std::endl;
/* pEnabledValidationFeatures */
    structBody << "\t" << pEnabledValidationFeaturesArray << "," << std::endl;
/* disabledValidationFeatureCount */
    structBody << "\t" << structInfo->disabledValidationFeatureCount << "," << std::endl;
/* pDisabledValidationFeatures */
    structBody << "\t" << pDisabledValidationFeaturesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "validationFeaturesEXT");
    out << "VkValidationFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCooperativeMatrixPropertiesNV(std::ostream &out, const VkCooperativeMatrixPropertiesNV* structInfo, Decoded_VkCooperativeMatrixPropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* MSize */
    structBody << "\t" << structInfo->MSize << "," << std::endl;
/* NSize */
    structBody << "\t" << structInfo->NSize << "," << std::endl;
/* KSize */
    structBody << "\t" << structInfo->KSize << "," << std::endl;
/* AType */
    structBody << "\t" << "VkComponentTypeNV(" << structInfo->AType << ")" << "," << std::endl;
/* BType */
    structBody << "\t" << "VkComponentTypeNV(" << structInfo->BType << ")" << "," << std::endl;
/* CType */
    structBody << "\t" << "VkComponentTypeNV(" << structInfo->CType << ")" << "," << std::endl;
/* DType */
    structBody << "\t" << "VkComponentTypeNV(" << structInfo->DType << ")" << "," << std::endl;
/* scope */
    structBody << "\t" << "VkScopeNV(" << structInfo->scope << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "cooperativeMatrixPropertiesNV");
    out << "VkCooperativeMatrixPropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeMatrixFeaturesNV(std::ostream &out, const VkPhysicalDeviceCooperativeMatrixFeaturesNV* structInfo, Decoded_VkPhysicalDeviceCooperativeMatrixFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* cooperativeMatrix */
    structBody << "\t" << structInfo->cooperativeMatrix << "," << std::endl;
/* cooperativeMatrixRobustBufferAccess */
    structBody << "\t" << structInfo->cooperativeMatrixRobustBufferAccess << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceCooperativeMatrixFeaturesNV");
    out << "VkPhysicalDeviceCooperativeMatrixFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceCooperativeMatrixPropertiesNV(std::ostream &out, const VkPhysicalDeviceCooperativeMatrixPropertiesNV* structInfo, Decoded_VkPhysicalDeviceCooperativeMatrixPropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* cooperativeMatrixSupportedStages */
    structBody << "\t" << "VkShaderStageFlags(" << structInfo->cooperativeMatrixSupportedStages << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceCooperativeMatrixPropertiesNV");
    out << "VkPhysicalDeviceCooperativeMatrixPropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceCoverageReductionModeFeaturesNV(std::ostream &out, const VkPhysicalDeviceCoverageReductionModeFeaturesNV* structInfo, Decoded_VkPhysicalDeviceCoverageReductionModeFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* coverageReductionMode */
    structBody << "\t" << structInfo->coverageReductionMode << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceCoverageReductionModeFeaturesNV");
    out << "VkPhysicalDeviceCoverageReductionModeFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineCoverageReductionStateCreateInfoNV(std::ostream &out, const VkPipelineCoverageReductionStateCreateInfoNV* structInfo, Decoded_VkPipelineCoverageReductionStateCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineCoverageReductionStateCreateFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
/* coverageReductionMode */
    structBody << "\t" << "VkCoverageReductionModeNV(" << structInfo->coverageReductionMode << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineCoverageReductionStateCreateInfoNV");
    out << "VkPipelineCoverageReductionStateCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkFramebufferMixedSamplesCombinationNV(std::ostream &out, const VkFramebufferMixedSamplesCombinationNV* structInfo, Decoded_VkFramebufferMixedSamplesCombinationNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* coverageReductionMode */
    structBody << "\t" << "VkCoverageReductionModeNV(" << structInfo->coverageReductionMode << ")" << "," << std::endl;
/* rasterizationSamples */
    structBody << "\t" << "VkSampleCountFlagBits(" << structInfo->rasterizationSamples << ")" << "," << std::endl;
/* depthStencilSamples */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->depthStencilSamples << ")" << "," << std::endl;
/* colorSamples */
    structBody << "\t" << "VkSampleCountFlags(" << structInfo->colorSamples << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "framebufferMixedSamplesCombinationNV");
    out << "VkFramebufferMixedSamplesCombinationNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT(std::ostream &out, const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fragmentShaderSampleInterlock */
    structBody << "\t" << structInfo->fragmentShaderSampleInterlock << "," << std::endl;
/* fragmentShaderPixelInterlock */
    structBody << "\t" << structInfo->fragmentShaderPixelInterlock << "," << std::endl;
/* fragmentShaderShadingRateInterlock */
    structBody << "\t" << structInfo->fragmentShaderShadingRateInterlock << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFragmentShaderInterlockFeaturesEXT");
    out << "VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT(std::ostream &out, const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceYcbcrImageArraysFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* ycbcrImageArrays */
    structBody << "\t" << structInfo->ycbcrImageArrays << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceYcbcrImageArraysFeaturesEXT");
    out << "VkPhysicalDeviceYcbcrImageArraysFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceProvokingVertexFeaturesEXT(std::ostream &out, const VkPhysicalDeviceProvokingVertexFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceProvokingVertexFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* provokingVertexLast */
    structBody << "\t" << structInfo->provokingVertexLast << "," << std::endl;
/* transformFeedbackPreservesProvokingVertex */
    structBody << "\t" << structInfo->transformFeedbackPreservesProvokingVertex << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceProvokingVertexFeaturesEXT");
    out << "VkPhysicalDeviceProvokingVertexFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceProvokingVertexPropertiesEXT(std::ostream &out, const VkPhysicalDeviceProvokingVertexPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceProvokingVertexPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* provokingVertexModePerPipeline */
    structBody << "\t" << structInfo->provokingVertexModePerPipeline << "," << std::endl;
/* transformFeedbackPreservesTriangleFanProvokingVertex */
    structBody << "\t" << structInfo->transformFeedbackPreservesTriangleFanProvokingVertex << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceProvokingVertexPropertiesEXT");
    out << "VkPhysicalDeviceProvokingVertexPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT(std::ostream &out, const VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* structInfo, Decoded_VkPipelineRasterizationProvokingVertexStateCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* provokingVertexMode */
    structBody << "\t" << "VkProvokingVertexModeEXT(" << structInfo->provokingVertexMode << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineRasterizationProvokingVertexStateCreateInfoEXT");
    out << "VkPipelineRasterizationProvokingVertexStateCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSurfaceFullScreenExclusiveInfoEXT(std::ostream &out, const VkSurfaceFullScreenExclusiveInfoEXT* structInfo, Decoded_VkSurfaceFullScreenExclusiveInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fullScreenExclusive */
    structBody << "\t" << "VkFullScreenExclusiveEXT(" << structInfo->fullScreenExclusive << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "surfaceFullScreenExclusiveInfoEXT");
    out << "VkSurfaceFullScreenExclusiveInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSurfaceCapabilitiesFullScreenExclusiveEXT(std::ostream &out, const VkSurfaceCapabilitiesFullScreenExclusiveEXT* structInfo, Decoded_VkSurfaceCapabilitiesFullScreenExclusiveEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fullScreenExclusiveSupported */
    structBody << "\t" << structInfo->fullScreenExclusiveSupported << "," ;
    std::string varname = consumer.AddStruct(structBody, "surfaceCapabilitiesFullScreenExclusiveEXT");
    out << "VkSurfaceCapabilitiesFullScreenExclusiveEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSurfaceFullScreenExclusiveWin32InfoEXT(std::ostream &out, const VkSurfaceFullScreenExclusiveWin32InfoEXT* structInfo, Decoded_VkSurfaceFullScreenExclusiveWin32InfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* hmonitor */
    structBody << "\t" << structInfo->hmonitor << "," ;
    std::string varname = consumer.AddStruct(structBody, "surfaceFullScreenExclusiveWin32InfoEXT");
    out << "VkSurfaceFullScreenExclusiveWin32InfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkHeadlessSurfaceCreateInfoEXT(std::ostream &out, const VkHeadlessSurfaceCreateInfoEXT* structInfo, Decoded_VkHeadlessSurfaceCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkHeadlessSurfaceCreateFlagsEXT(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "headlessSurfaceCreateInfoEXT");
    out << "VkHeadlessSurfaceCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceLineRasterizationFeaturesEXT(std::ostream &out, const VkPhysicalDeviceLineRasterizationFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceLineRasterizationFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* rectangularLines */
    structBody << "\t" << structInfo->rectangularLines << "," << std::endl;
/* bresenhamLines */
    structBody << "\t" << structInfo->bresenhamLines << "," << std::endl;
/* smoothLines */
    structBody << "\t" << structInfo->smoothLines << "," << std::endl;
/* stippledRectangularLines */
    structBody << "\t" << structInfo->stippledRectangularLines << "," << std::endl;
/* stippledBresenhamLines */
    structBody << "\t" << structInfo->stippledBresenhamLines << "," << std::endl;
/* stippledSmoothLines */
    structBody << "\t" << structInfo->stippledSmoothLines << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceLineRasterizationFeaturesEXT");
    out << "VkPhysicalDeviceLineRasterizationFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceLineRasterizationPropertiesEXT(std::ostream &out, const VkPhysicalDeviceLineRasterizationPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceLineRasterizationPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* lineSubPixelPrecisionBits */
    structBody << "\t" << structInfo->lineSubPixelPrecisionBits << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceLineRasterizationPropertiesEXT");
    out << "VkPhysicalDeviceLineRasterizationPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineRasterizationLineStateCreateInfoEXT(std::ostream &out, const VkPipelineRasterizationLineStateCreateInfoEXT* structInfo, Decoded_VkPipelineRasterizationLineStateCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* lineRasterizationMode */
    structBody << "\t" << "VkLineRasterizationModeEXT(" << structInfo->lineRasterizationMode << ")" << "," << std::endl;
/* stippledLineEnable */
    structBody << "\t" << structInfo->stippledLineEnable << "," << std::endl;
/* lineStippleFactor */
    structBody << "\t" << structInfo->lineStippleFactor << "," << std::endl;
/* lineStipplePattern */
    structBody << "\t" << structInfo->lineStipplePattern << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineRasterizationLineStateCreateInfoEXT");
    out << "VkPipelineRasterizationLineStateCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderAtomicFloatFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderBufferFloat32Atomics */
    structBody << "\t" << structInfo->shaderBufferFloat32Atomics << "," << std::endl;
/* shaderBufferFloat32AtomicAdd */
    structBody << "\t" << structInfo->shaderBufferFloat32AtomicAdd << "," << std::endl;
/* shaderBufferFloat64Atomics */
    structBody << "\t" << structInfo->shaderBufferFloat64Atomics << "," << std::endl;
/* shaderBufferFloat64AtomicAdd */
    structBody << "\t" << structInfo->shaderBufferFloat64AtomicAdd << "," << std::endl;
/* shaderSharedFloat32Atomics */
    structBody << "\t" << structInfo->shaderSharedFloat32Atomics << "," << std::endl;
/* shaderSharedFloat32AtomicAdd */
    structBody << "\t" << structInfo->shaderSharedFloat32AtomicAdd << "," << std::endl;
/* shaderSharedFloat64Atomics */
    structBody << "\t" << structInfo->shaderSharedFloat64Atomics << "," << std::endl;
/* shaderSharedFloat64AtomicAdd */
    structBody << "\t" << structInfo->shaderSharedFloat64AtomicAdd << "," << std::endl;
/* shaderImageFloat32Atomics */
    structBody << "\t" << structInfo->shaderImageFloat32Atomics << "," << std::endl;
/* shaderImageFloat32AtomicAdd */
    structBody << "\t" << structInfo->shaderImageFloat32AtomicAdd << "," << std::endl;
/* sparseImageFloat32Atomics */
    structBody << "\t" << structInfo->sparseImageFloat32Atomics << "," << std::endl;
/* sparseImageFloat32AtomicAdd */
    structBody << "\t" << structInfo->sparseImageFloat32AtomicAdd << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderAtomicFloatFeaturesEXT");
    out << "VkPhysicalDeviceShaderAtomicFloatFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceIndexTypeUint8FeaturesEXT(std::ostream &out, const VkPhysicalDeviceIndexTypeUint8FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceIndexTypeUint8FeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* indexTypeUint8 */
    structBody << "\t" << structInfo->indexTypeUint8 << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceIndexTypeUint8FeaturesEXT");
    out << "VkPhysicalDeviceIndexTypeUint8FeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT(std::ostream &out, const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceExtendedDynamicStateFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* extendedDynamicState */
    structBody << "\t" << structInfo->extendedDynamicState << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExtendedDynamicStateFeaturesEXT");
    out << "VkPhysicalDeviceExtendedDynamicStateFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceHostImageCopyFeaturesEXT(std::ostream &out, const VkPhysicalDeviceHostImageCopyFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceHostImageCopyFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* hostImageCopy */
    structBody << "\t" << structInfo->hostImageCopy << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceHostImageCopyFeaturesEXT");
    out << "VkPhysicalDeviceHostImageCopyFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceHostImageCopyPropertiesEXT(std::ostream &out, const VkPhysicalDeviceHostImageCopyPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceHostImageCopyPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pCopySrcLayoutsArray = "NULL";
    if (structInfo->pCopySrcLayouts != NULL) {
        std::string pCopySrcLayoutsValues;
        for (uint32_t idx = 0; idx < structInfo->copySrcLayoutCount; idx++) {
            pCopySrcLayoutsValues += util::ToString<VkImageLayout>(structInfo->pCopySrcLayouts[idx]) + ", ";
        }
        pCopySrcLayoutsArray = "pCopySrcLayouts_" + std::to_string(consumer.getNextId());
        out << "VkImageLayout " << pCopySrcLayoutsArray << "[] = {" << pCopySrcLayoutsValues << "};" << std::endl;
    }
    std::string pCopyDstLayoutsArray = "NULL";
    if (structInfo->pCopyDstLayouts != NULL) {
        std::string pCopyDstLayoutsValues;
        for (uint32_t idx = 0; idx < structInfo->copyDstLayoutCount; idx++) {
            pCopyDstLayoutsValues += util::ToString<VkImageLayout>(structInfo->pCopyDstLayouts[idx]) + ", ";
        }
        pCopyDstLayoutsArray = "pCopyDstLayouts_" + std::to_string(consumer.getNextId());
        out << "VkImageLayout " << pCopyDstLayoutsArray << "[] = {" << pCopyDstLayoutsValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* copySrcLayoutCount */
    structBody << "\t" << structInfo->copySrcLayoutCount << "," << std::endl;
/* pCopySrcLayouts */
    structBody << "\t" << pCopySrcLayoutsArray << "," << std::endl;
/* copyDstLayoutCount */
    structBody << "\t" << structInfo->copyDstLayoutCount << "," << std::endl;
/* pCopyDstLayouts */
    structBody << "\t" << pCopyDstLayoutsArray << "," << std::endl;
/* optimalTilingLayoutUUID */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->optimalTilingLayoutUUID[0]), VK_UUID_SIZE) << "," << std::endl;
/* identicalMemoryTypeRequirements */
    structBody << "\t" << structInfo->identicalMemoryTypeRequirements << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceHostImageCopyPropertiesEXT");
    out << "VkPhysicalDeviceHostImageCopyPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryToImageCopyEXT(std::ostream &out, const VkMemoryToImageCopyEXT* structInfo, Decoded_VkMemoryToImageCopyEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string imageSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                         &structInfo->imageSubresource,
                                                                         metainfo->imageSubresource,
                                                                         consumer);
    std::string imageOffsetInfoVar = GenerateStruct_VkOffset3D(out,
                                                                    &structInfo->imageOffset,
                                                                    metainfo->imageOffset,
                                                                    consumer);
    std::string imageExtentInfoVar = GenerateStruct_VkExtent3D(out,
                                                                    &structInfo->imageExtent,
                                                                    metainfo->imageExtent,
                                                                    consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pHostPointer */
    structBody << "\t" << structInfo->pHostPointer << "," << std::endl;
/* memoryRowLength */
    structBody << "\t" << structInfo->memoryRowLength << "," << std::endl;
/* memoryImageHeight */
    structBody << "\t" << structInfo->memoryImageHeight << "," << std::endl;
/* imageSubresource */
    structBody << "\t" << imageSubresourceInfoVar << "," << std::endl;
/* imageOffset */
    structBody << "\t" << imageOffsetInfoVar << "," << std::endl;
/* imageExtent */
    structBody << "\t" << imageExtentInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryToImageCopyEXT");
    out << "VkMemoryToImageCopyEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageToMemoryCopyEXT(std::ostream &out, const VkImageToMemoryCopyEXT* structInfo, Decoded_VkImageToMemoryCopyEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string imageSubresourceInfoVar = GenerateStruct_VkImageSubresourceLayers(out,
                                                                         &structInfo->imageSubresource,
                                                                         metainfo->imageSubresource,
                                                                         consumer);
    std::string imageOffsetInfoVar = GenerateStruct_VkOffset3D(out,
                                                                    &structInfo->imageOffset,
                                                                    metainfo->imageOffset,
                                                                    consumer);
    std::string imageExtentInfoVar = GenerateStruct_VkExtent3D(out,
                                                                    &structInfo->imageExtent,
                                                                    metainfo->imageExtent,
                                                                    consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pHostPointer */
    out << "// TODO: Support pHostPointer (output?) argument." << std::endl;
/* memoryRowLength */
    structBody << "\t" << structInfo->memoryRowLength << "," << std::endl;
/* memoryImageHeight */
    structBody << "\t" << structInfo->memoryImageHeight << "," << std::endl;
/* imageSubresource */
    structBody << "\t" << imageSubresourceInfoVar << "," << std::endl;
/* imageOffset */
    structBody << "\t" << imageOffsetInfoVar << "," << std::endl;
/* imageExtent */
    structBody << "\t" << imageExtentInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageToMemoryCopyEXT");
    out << "VkImageToMemoryCopyEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyMemoryToImageInfoEXT(std::ostream &out, const VkCopyMemoryToImageInfoEXT* structInfo, Decoded_VkCopyMemoryToImageInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pRegionsArray = "NULL";
    if (structInfo->pRegions != NULL) {
        pRegionsArray = "pRegions_" + std::to_string(consumer.getNextId());
        std::string pRegionsNames;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                varName = GenerateStruct_VkMemoryToImageCopyEXT(out,
                                                         structInfo->pRegions + idx,
                                                         metainfo->pRegions->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pRegionsNames += varName + ", ";
        }
        out << "VkMemoryToImageCopyEXT " << pRegionsArray << "[] = {" << pRegionsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkHostImageCopyFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* dstImage */
    structBody << "\t" << consumer.GetHandle(metainfo->dstImage) << "," << std::endl;
/* dstImageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
/* regionCount */
    structBody << "\t" << structInfo->regionCount << "," << std::endl;
/* pRegions */
    structBody << "\t" << pRegionsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyMemoryToImageInfoEXT");
    out << "VkCopyMemoryToImageInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyImageToMemoryInfoEXT(std::ostream &out, const VkCopyImageToMemoryInfoEXT* structInfo, Decoded_VkCopyImageToMemoryInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pRegionsArray = "NULL";
    if (structInfo->pRegions != NULL) {
        pRegionsArray = "pRegions_" + std::to_string(consumer.getNextId());
        std::string pRegionsNames;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                varName = GenerateStruct_VkImageToMemoryCopyEXT(out,
                                                         structInfo->pRegions + idx,
                                                         metainfo->pRegions->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pRegionsNames += varName + ", ";
        }
        out << "VkImageToMemoryCopyEXT " << pRegionsArray << "[] = {" << pRegionsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkHostImageCopyFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* srcImage */
    structBody << "\t" << consumer.GetHandle(metainfo->srcImage) << "," << std::endl;
/* srcImageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
/* regionCount */
    structBody << "\t" << structInfo->regionCount << "," << std::endl;
/* pRegions */
    structBody << "\t" << pRegionsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyImageToMemoryInfoEXT");
    out << "VkCopyImageToMemoryInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyImageToImageInfoEXT(std::ostream &out, const VkCopyImageToImageInfoEXT* structInfo, Decoded_VkCopyImageToImageInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pRegionsArray = "NULL";
    if (structInfo->pRegions != NULL) {
        pRegionsArray = "pRegions_" + std::to_string(consumer.getNextId());
        std::string pRegionsNames;
        for (uint32_t idx = 0; idx < structInfo->regionCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pRegions + idx != NULL) {
                varName = GenerateStruct_VkImageCopy2(out,
                                                         structInfo->pRegions + idx,
                                                         metainfo->pRegions->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pRegionsNames += varName + ", ";
        }
        out << "VkImageCopy2 " << pRegionsArray << "[] = {" << pRegionsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkHostImageCopyFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* srcImage */
    structBody << "\t" << consumer.GetHandle(metainfo->srcImage) << "," << std::endl;
/* srcImageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->srcImageLayout << ")" << "," << std::endl;
/* dstImage */
    structBody << "\t" << consumer.GetHandle(metainfo->dstImage) << "," << std::endl;
/* dstImageLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->dstImageLayout << ")" << "," << std::endl;
/* regionCount */
    structBody << "\t" << structInfo->regionCount << "," << std::endl;
/* pRegions */
    structBody << "\t" << pRegionsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyImageToImageInfoEXT");
    out << "VkCopyImageToImageInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkHostImageLayoutTransitionInfoEXT(std::ostream &out, const VkHostImageLayoutTransitionInfoEXT* structInfo, Decoded_VkHostImageLayoutTransitionInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string subresourceRangeInfoVar = GenerateStruct_VkImageSubresourceRange(out,
                                                                         &structInfo->subresourceRange,
                                                                         metainfo->subresourceRange,
                                                                         consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* image */
    structBody << "\t" << consumer.GetHandle(metainfo->image) << "," << std::endl;
/* oldLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->oldLayout << ")" << "," << std::endl;
/* newLayout */
    structBody << "\t" << "VkImageLayout(" << structInfo->newLayout << ")" << "," << std::endl;
/* subresourceRange */
    structBody << "\t" << subresourceRangeInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "hostImageLayoutTransitionInfoEXT");
    out << "VkHostImageLayoutTransitionInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubresourceHostMemcpySizeEXT(std::ostream &out, const VkSubresourceHostMemcpySizeEXT* structInfo, Decoded_VkSubresourceHostMemcpySizeEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "subresourceHostMemcpySizeEXT");
    out << "VkSubresourceHostMemcpySizeEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkHostImageCopyDevicePerformanceQueryEXT(std::ostream &out, const VkHostImageCopyDevicePerformanceQueryEXT* structInfo, Decoded_VkHostImageCopyDevicePerformanceQueryEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* optimalDeviceAccess */
    structBody << "\t" << structInfo->optimalDeviceAccess << "," << std::endl;
/* identicalMemoryLayout */
    structBody << "\t" << structInfo->identicalMemoryLayout << "," ;
    std::string varname = consumer.AddStruct(structBody, "hostImageCopyDevicePerformanceQueryEXT");
    out << "VkHostImageCopyDevicePerformanceQueryEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderBufferFloat16Atomics */
    structBody << "\t" << structInfo->shaderBufferFloat16Atomics << "," << std::endl;
/* shaderBufferFloat16AtomicAdd */
    structBody << "\t" << structInfo->shaderBufferFloat16AtomicAdd << "," << std::endl;
/* shaderBufferFloat16AtomicMinMax */
    structBody << "\t" << structInfo->shaderBufferFloat16AtomicMinMax << "," << std::endl;
/* shaderBufferFloat32AtomicMinMax */
    structBody << "\t" << structInfo->shaderBufferFloat32AtomicMinMax << "," << std::endl;
/* shaderBufferFloat64AtomicMinMax */
    structBody << "\t" << structInfo->shaderBufferFloat64AtomicMinMax << "," << std::endl;
/* shaderSharedFloat16Atomics */
    structBody << "\t" << structInfo->shaderSharedFloat16Atomics << "," << std::endl;
/* shaderSharedFloat16AtomicAdd */
    structBody << "\t" << structInfo->shaderSharedFloat16AtomicAdd << "," << std::endl;
/* shaderSharedFloat16AtomicMinMax */
    structBody << "\t" << structInfo->shaderSharedFloat16AtomicMinMax << "," << std::endl;
/* shaderSharedFloat32AtomicMinMax */
    structBody << "\t" << structInfo->shaderSharedFloat32AtomicMinMax << "," << std::endl;
/* shaderSharedFloat64AtomicMinMax */
    structBody << "\t" << structInfo->shaderSharedFloat64AtomicMinMax << "," << std::endl;
/* shaderImageFloat32AtomicMinMax */
    structBody << "\t" << structInfo->shaderImageFloat32AtomicMinMax << "," << std::endl;
/* sparseImageFloat32AtomicMinMax */
    structBody << "\t" << structInfo->sparseImageFloat32AtomicMinMax << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderAtomicFloat2FeaturesEXT");
    out << "VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSurfacePresentModeEXT(std::ostream &out, const VkSurfacePresentModeEXT* structInfo, Decoded_VkSurfacePresentModeEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* presentMode */
    structBody << "\t" << "VkPresentModeKHR(" << structInfo->presentMode << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "surfacePresentModeEXT");
    out << "VkSurfacePresentModeEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSurfacePresentScalingCapabilitiesEXT(std::ostream &out, const VkSurfacePresentScalingCapabilitiesEXT* structInfo, Decoded_VkSurfacePresentScalingCapabilitiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string minScaledImageExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                             &structInfo->minScaledImageExtent,
                                                                             metainfo->minScaledImageExtent,
                                                                             consumer);
    std::string maxScaledImageExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                             &structInfo->maxScaledImageExtent,
                                                                             metainfo->maxScaledImageExtent,
                                                                             consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* supportedPresentScaling */
    structBody << "\t" << "VkPresentScalingFlagsEXT(" << structInfo->supportedPresentScaling << ")" << "," << std::endl;
/* supportedPresentGravityX */
    structBody << "\t" << "VkPresentGravityFlagsEXT(" << structInfo->supportedPresentGravityX << ")" << "," << std::endl;
/* supportedPresentGravityY */
    structBody << "\t" << "VkPresentGravityFlagsEXT(" << structInfo->supportedPresentGravityY << ")" << "," << std::endl;
/* minScaledImageExtent */
    structBody << "\t" << minScaledImageExtentInfoVar << "," << std::endl;
/* maxScaledImageExtent */
    structBody << "\t" << maxScaledImageExtentInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "surfacePresentScalingCapabilitiesEXT");
    out << "VkSurfacePresentScalingCapabilitiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSurfacePresentModeCompatibilityEXT(std::ostream &out, const VkSurfacePresentModeCompatibilityEXT* structInfo, Decoded_VkSurfacePresentModeCompatibilityEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pPresentModesArray = "NULL";
    if (structInfo->pPresentModes != NULL) {
        std::string pPresentModesValues;
        for (uint32_t idx = 0; idx < structInfo->presentModeCount; idx++) {
            pPresentModesValues += util::ToString<VkPresentModeKHR>(structInfo->pPresentModes[idx]) + ", ";
        }
        pPresentModesArray = "pPresentModes_" + std::to_string(consumer.getNextId());
        out << "VkPresentModeKHR " << pPresentModesArray << "[] = {" << pPresentModesValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* presentModeCount */
    structBody << "\t" << structInfo->presentModeCount << "," << std::endl;
/* pPresentModes */
    structBody << "\t" << pPresentModesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "surfacePresentModeCompatibilityEXT");
    out << "VkSurfacePresentModeCompatibilityEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT(std::ostream &out, const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* swapchainMaintenance1 */
    structBody << "\t" << structInfo->swapchainMaintenance1 << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceSwapchainMaintenance1FeaturesEXT");
    out << "VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSwapchainPresentFenceInfoEXT(std::ostream &out, const VkSwapchainPresentFenceInfoEXT* structInfo, Decoded_VkSwapchainPresentFenceInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pFencesArray = "NULL";
    if (metainfo->pFences.GetPointer() != NULL && structInfo->swapchainCount > 0) {
        pFencesArray = "pFencesArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_FENCE));
        std::string pFencesValues = toStringJoin(metainfo->pFences.GetPointer(),
                                                 metainfo->pFences.GetPointer() + structInfo->swapchainCount,
                                                 [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                 ", ");
        if (structInfo->swapchainCount == 1) {
            pFencesArray = "&" + pFencesValues;
        } else if (structInfo->swapchainCount > 1) {
            out << "VkFence " << pFencesArray << "[] = {" << pFencesValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* swapchainCount */
    structBody << "\t" << structInfo->swapchainCount << "," << std::endl;
/* pFences */
    structBody << "\t" << pFencesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "swapchainPresentFenceInfoEXT");
    out << "VkSwapchainPresentFenceInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSwapchainPresentModesCreateInfoEXT(std::ostream &out, const VkSwapchainPresentModesCreateInfoEXT* structInfo, Decoded_VkSwapchainPresentModesCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pPresentModesValues;
    std::string pPresentModesArray = "NULL";
    if (structInfo->pPresentModes != NULL) {
        for (uint32_t idx = 0; idx < structInfo->presentModeCount; idx++) {
            pPresentModesValues += util::ToString<VkPresentModeKHR>(structInfo->pPresentModes[idx]) + ", ";
        }
        pPresentModesArray = "pPresentModes_" + std::to_string(consumer.getNextId());
        out << "VkPresentModeKHR " << pPresentModesArray << "[] = {" << pPresentModesValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* presentModeCount */
    structBody << "\t" << structInfo->presentModeCount << "," << std::endl;
/* pPresentModes */
    structBody << "\t" << pPresentModesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "swapchainPresentModesCreateInfoEXT");
    out << "VkSwapchainPresentModesCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSwapchainPresentModeInfoEXT(std::ostream &out, const VkSwapchainPresentModeInfoEXT* structInfo, Decoded_VkSwapchainPresentModeInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pPresentModesValues;
    std::string pPresentModesArray = "NULL";
    if (structInfo->pPresentModes != NULL) {
        for (uint32_t idx = 0; idx < structInfo->swapchainCount; idx++) {
            pPresentModesValues += util::ToString<VkPresentModeKHR>(structInfo->pPresentModes[idx]) + ", ";
        }
        pPresentModesArray = "pPresentModes_" + std::to_string(consumer.getNextId());
        out << "VkPresentModeKHR " << pPresentModesArray << "[] = {" << pPresentModesValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* swapchainCount */
    structBody << "\t" << structInfo->swapchainCount << "," << std::endl;
/* pPresentModes */
    structBody << "\t" << pPresentModesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "swapchainPresentModeInfoEXT");
    out << "VkSwapchainPresentModeInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSwapchainPresentScalingCreateInfoEXT(std::ostream &out, const VkSwapchainPresentScalingCreateInfoEXT* structInfo, Decoded_VkSwapchainPresentScalingCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* scalingBehavior */
    structBody << "\t" << "VkPresentScalingFlagsEXT(" << structInfo->scalingBehavior << ")" << "," << std::endl;
/* presentGravityX */
    structBody << "\t" << "VkPresentGravityFlagsEXT(" << structInfo->presentGravityX << ")" << "," << std::endl;
/* presentGravityY */
    structBody << "\t" << "VkPresentGravityFlagsEXT(" << structInfo->presentGravityY << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "swapchainPresentScalingCreateInfoEXT");
    out << "VkSwapchainPresentScalingCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkReleaseSwapchainImagesInfoEXT(std::ostream &out, const VkReleaseSwapchainImagesInfoEXT* structInfo, Decoded_VkReleaseSwapchainImagesInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pImageIndicesArray = "NULL";
    if (structInfo->pImageIndices != NULL) {
        pImageIndicesArray = "pImageIndices_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pImageIndicesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pImageIndices, structInfo->imageIndexCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* swapchain */
    structBody << "\t" << consumer.GetHandle(metainfo->swapchain) << "," << std::endl;
/* imageIndexCount */
    structBody << "\t" << structInfo->imageIndexCount << "," << std::endl;
/* pImageIndices */
    structBody << "\t" << pImageIndicesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "releaseSwapchainImagesInfoEXT");
    out << "VkReleaseSwapchainImagesInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV(std::ostream &out, const VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* structInfo, Decoded_VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxGraphicsShaderGroupCount */
    structBody << "\t" << structInfo->maxGraphicsShaderGroupCount << "," << std::endl;
/* maxIndirectSequenceCount */
    structBody << "\t" << structInfo->maxIndirectSequenceCount << "," << std::endl;
/* maxIndirectCommandsTokenCount */
    structBody << "\t" << structInfo->maxIndirectCommandsTokenCount << "," << std::endl;
/* maxIndirectCommandsStreamCount */
    structBody << "\t" << structInfo->maxIndirectCommandsStreamCount << "," << std::endl;
/* maxIndirectCommandsTokenOffset */
    structBody << "\t" << structInfo->maxIndirectCommandsTokenOffset << "," << std::endl;
/* maxIndirectCommandsStreamStride */
    structBody << "\t" << structInfo->maxIndirectCommandsStreamStride << "," << std::endl;
/* minSequencesCountBufferOffsetAlignment */
    structBody << "\t" << structInfo->minSequencesCountBufferOffsetAlignment << "," << std::endl;
/* minSequencesIndexBufferOffsetAlignment */
    structBody << "\t" << structInfo->minSequencesIndexBufferOffsetAlignment << "," << std::endl;
/* minIndirectCommandsBufferOffsetAlignment */
    structBody << "\t" << structInfo->minIndirectCommandsBufferOffsetAlignment << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDeviceGeneratedCommandsPropertiesNV");
    out << "VkPhysicalDeviceDeviceGeneratedCommandsPropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV(std::ostream &out, const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceGeneratedCommands */
    structBody << "\t" << structInfo->deviceGeneratedCommands << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDeviceGeneratedCommandsFeaturesNV");
    out << "VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkGraphicsShaderGroupCreateInfoNV(std::ostream &out, const VkGraphicsShaderGroupCreateInfoNV* structInfo, Decoded_VkGraphicsShaderGroupCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStagesArray = "NULL";
    if (structInfo->pStages != NULL) {
        pStagesArray = "pStages_" + std::to_string(consumer.getNextId());
        std::string pStagesNames;
        for (uint32_t idx = 0; idx < structInfo->stageCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStages + idx != NULL) {
                varName = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                         structInfo->pStages + idx,
                                                         metainfo->pStages->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStagesNames += varName + ", ";
        }
        out << "VkPipelineShaderStageCreateInfo " << pStagesArray << "[] = {" << pStagesNames << "};" << std::endl;
    }
    std::string pVertexInputStateStruct = "NULL";
    if (structInfo->pVertexInputState != NULL) {
        pVertexInputStateStruct = GenerateStruct_VkPipelineVertexInputStateCreateInfo(out,
                                                                 structInfo->pVertexInputState,
                                                                 metainfo->pVertexInputState->GetMetaStructPointer(),
                                                                 consumer);
        pVertexInputStateStruct.insert(0, "&");
    }
    std::string pTessellationStateStruct = "NULL";
    if (structInfo->pTessellationState != NULL) {
        pTessellationStateStruct = GenerateStruct_VkPipelineTessellationStateCreateInfo(out,
                                                                  structInfo->pTessellationState,
                                                                  metainfo->pTessellationState->GetMetaStructPointer(),
                                                                  consumer);
        pTessellationStateStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* stageCount */
    structBody << "\t" << structInfo->stageCount << "," << std::endl;
/* pStages */
    structBody << "\t" << pStagesArray << "," << std::endl;
/* pVertexInputState */
    structBody << "\t" << pVertexInputStateStruct << "," << std::endl;
/* pTessellationState */
    structBody << "\t" << pTessellationStateStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "graphicsShaderGroupCreateInfoNV");
    out << "VkGraphicsShaderGroupCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkGraphicsPipelineShaderGroupsCreateInfoNV(std::ostream &out, const VkGraphicsPipelineShaderGroupsCreateInfoNV* structInfo, Decoded_VkGraphicsPipelineShaderGroupsCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pGroupsArray = "NULL";
    if (structInfo->pGroups != NULL) {
        pGroupsArray = "pGroups_" + std::to_string(consumer.getNextId());
        std::string pGroupsNames;
        for (uint32_t idx = 0; idx < structInfo->groupCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pGroups + idx != NULL) {
                varName = GenerateStruct_VkGraphicsShaderGroupCreateInfoNV(out,
                                                         structInfo->pGroups + idx,
                                                         metainfo->pGroups->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pGroupsNames += varName + ", ";
        }
        out << "VkGraphicsShaderGroupCreateInfoNV " << pGroupsArray << "[] = {" << pGroupsNames << "};" << std::endl;
    }
    std::string pPipelinesArray = "NULL";
    if (metainfo->pPipelines.GetPointer() != NULL && structInfo->pipelineCount > 0) {
        pPipelinesArray = "pPipelinesArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_PIPELINE));
        std::string pPipelinesValues = toStringJoin(metainfo->pPipelines.GetPointer(),
                                                    metainfo->pPipelines.GetPointer() + structInfo->pipelineCount,
                                                    [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                    ", ");
        if (structInfo->pipelineCount == 1) {
            pPipelinesArray = "&" + pPipelinesValues;
        } else if (structInfo->pipelineCount > 1) {
            out << "VkPipeline " << pPipelinesArray << "[] = {" << pPipelinesValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* groupCount */
    structBody << "\t" << structInfo->groupCount << "," << std::endl;
/* pGroups */
    structBody << "\t" << pGroupsArray << "," << std::endl;
/* pipelineCount */
    structBody << "\t" << structInfo->pipelineCount << "," << std::endl;
/* pPipelines */
    structBody << "\t" << pPipelinesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "graphicsPipelineShaderGroupsCreateInfoNV");
    out << "VkGraphicsPipelineShaderGroupsCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBindShaderGroupIndirectCommandNV(std::ostream &out, const VkBindShaderGroupIndirectCommandNV* structInfo, Decoded_VkBindShaderGroupIndirectCommandNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* groupIndex */
    structBody << "\t" << structInfo->groupIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "bindShaderGroupIndirectCommandNV");
    out << "VkBindShaderGroupIndirectCommandNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBindIndexBufferIndirectCommandNV(std::ostream &out, const VkBindIndexBufferIndirectCommandNV* structInfo, Decoded_VkBindIndexBufferIndirectCommandNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* bufferAddress */
    structBody << "\t" << structInfo->bufferAddress << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "," << std::endl;
/* indexType */
    structBody << "\t" << "VkIndexType(" << structInfo->indexType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "bindIndexBufferIndirectCommandNV");
    out << "VkBindIndexBufferIndirectCommandNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBindVertexBufferIndirectCommandNV(std::ostream &out, const VkBindVertexBufferIndirectCommandNV* structInfo, Decoded_VkBindVertexBufferIndirectCommandNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* bufferAddress */
    structBody << "\t" << structInfo->bufferAddress << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "," << std::endl;
/* stride */
    structBody << "\t" << structInfo->stride << "," ;
    std::string varname = consumer.AddStruct(structBody, "bindVertexBufferIndirectCommandNV");
    out << "VkBindVertexBufferIndirectCommandNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSetStateFlagsIndirectCommandNV(std::ostream &out, const VkSetStateFlagsIndirectCommandNV* structInfo, Decoded_VkSetStateFlagsIndirectCommandNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* data */
    structBody << "\t" << structInfo->data << "," ;
    std::string varname = consumer.AddStruct(structBody, "setStateFlagsIndirectCommandNV");
    out << "VkSetStateFlagsIndirectCommandNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkIndirectCommandsStreamNV(std::ostream &out, const VkIndirectCommandsStreamNV* structInfo, Decoded_VkIndirectCommandsStreamNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* buffer */
    structBody << "\t" << consumer.GetHandle(metainfo->buffer) << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "indirectCommandsStreamNV");
    out << "VkIndirectCommandsStreamNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkIndirectCommandsLayoutTokenNV(std::ostream &out, const VkIndirectCommandsLayoutTokenNV* structInfo, Decoded_VkIndirectCommandsLayoutTokenNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pIndexTypesValues;
    std::string pIndexTypesArray = "NULL";
    if (structInfo->pIndexTypes != NULL) {
        for (uint32_t idx = 0; idx < structInfo->indexTypeCount; idx++) {
            pIndexTypesValues += util::ToString<VkIndexType>(structInfo->pIndexTypes[idx]) + ", ";
        }
        pIndexTypesArray = "pIndexTypes_" + std::to_string(consumer.getNextId());
        out << "VkIndexType " << pIndexTypesArray << "[] = {" << pIndexTypesValues << "};" << std::endl;
    }
    std::string pIndexTypeValuesArray = "NULL";
    if (structInfo->pIndexTypeValues != NULL) {
        pIndexTypeValuesArray = "pIndexTypeValues_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pIndexTypeValuesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pIndexTypeValues, structInfo->indexTypeCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* tokenType */
    structBody << "\t" << "VkIndirectCommandsTokenTypeNV(" << structInfo->tokenType << ")" << "," << std::endl;
/* stream */
    structBody << "\t" << structInfo->stream << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "," << std::endl;
/* vertexBindingUnit */
    structBody << "\t" << structInfo->vertexBindingUnit << "," << std::endl;
/* vertexDynamicStride */
    structBody << "\t" << structInfo->vertexDynamicStride << "," << std::endl;
/* pushconstantPipelineLayout */
    structBody << "\t" << consumer.GetHandle(metainfo->pushconstantPipelineLayout) << "," << std::endl;
/* pushconstantShaderStageFlags */
    structBody << "\t" << "VkShaderStageFlags(" << structInfo->pushconstantShaderStageFlags << ")" << "," << std::endl;
/* pushconstantOffset */
    structBody << "\t" << structInfo->pushconstantOffset << "," << std::endl;
/* pushconstantSize */
    structBody << "\t" << structInfo->pushconstantSize << "," << std::endl;
/* indirectStateFlags */
    structBody << "\t" << "VkIndirectStateFlagsNV(" << structInfo->indirectStateFlags << ")" << "," << std::endl;
/* indexTypeCount */
    structBody << "\t" << structInfo->indexTypeCount << "," << std::endl;
/* pIndexTypes */
    structBody << "\t" << pIndexTypesArray << "," << std::endl;
/* pIndexTypeValues */
    structBody << "\t" << pIndexTypeValuesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "indirectCommandsLayoutTokenNV");
    out << "VkIndirectCommandsLayoutTokenNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkIndirectCommandsLayoutCreateInfoNV(std::ostream &out, const VkIndirectCommandsLayoutCreateInfoNV* structInfo, Decoded_VkIndirectCommandsLayoutCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pTokensArray = "NULL";
    if (structInfo->pTokens != NULL) {
        pTokensArray = "pTokens_" + std::to_string(consumer.getNextId());
        std::string pTokensNames;
        for (uint32_t idx = 0; idx < structInfo->tokenCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pTokens + idx != NULL) {
                varName = GenerateStruct_VkIndirectCommandsLayoutTokenNV(out,
                                                         structInfo->pTokens + idx,
                                                         metainfo->pTokens->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pTokensNames += varName + ", ";
        }
        out << "VkIndirectCommandsLayoutTokenNV " << pTokensArray << "[] = {" << pTokensNames << "};" << std::endl;
    }
    std::string pStreamStridesArray = "NULL";
    if (structInfo->pStreamStrides != NULL) {
        pStreamStridesArray = "pStreamStrides_" + std::to_string(consumer.getNextId());
        out << "uint32_t " << pStreamStridesArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pStreamStrides, structInfo->streamCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkIndirectCommandsLayoutUsageFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
/* pipelineBindPoint */
    structBody << "\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
/* tokenCount */
    structBody << "\t" << structInfo->tokenCount << "," << std::endl;
/* pTokens */
    structBody << "\t" << pTokensArray << "," << std::endl;
/* streamCount */
    structBody << "\t" << structInfo->streamCount << "," << std::endl;
/* pStreamStrides */
    structBody << "\t" << pStreamStridesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "indirectCommandsLayoutCreateInfoNV");
    out << "VkIndirectCommandsLayoutCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkGeneratedCommandsInfoNV(std::ostream &out, const VkGeneratedCommandsInfoNV* structInfo, Decoded_VkGeneratedCommandsInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStreamsArray = "NULL";
    if (structInfo->pStreams != NULL) {
        pStreamsArray = "pStreams_" + std::to_string(consumer.getNextId());
        std::string pStreamsNames;
        for (uint32_t idx = 0; idx < structInfo->streamCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStreams + idx != NULL) {
                varName = GenerateStruct_VkIndirectCommandsStreamNV(out,
                                                         structInfo->pStreams + idx,
                                                         metainfo->pStreams->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStreamsNames += varName + ", ";
        }
        out << "VkIndirectCommandsStreamNV " << pStreamsArray << "[] = {" << pStreamsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pipelineBindPoint */
    structBody << "\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
/* pipeline */
    structBody << "\t" << consumer.GetHandle(metainfo->pipeline) << "," << std::endl;
/* indirectCommandsLayout */
    structBody << "\t" << consumer.GetHandle(metainfo->indirectCommandsLayout) << "," << std::endl;
/* streamCount */
    structBody << "\t" << structInfo->streamCount << "," << std::endl;
/* pStreams */
    structBody << "\t" << pStreamsArray << "," << std::endl;
/* sequencesCount */
    structBody << "\t" << structInfo->sequencesCount << "," << std::endl;
/* preprocessBuffer */
    structBody << "\t" << consumer.GetHandle(metainfo->preprocessBuffer) << "," << std::endl;
/* preprocessOffset */
    structBody << "\t" << structInfo->preprocessOffset << "UL" << "," << std::endl;
/* preprocessSize */
    structBody << "\t" << structInfo->preprocessSize << "UL" << "," << std::endl;
/* sequencesCountBuffer */
    structBody << "\t" << consumer.GetHandle(metainfo->sequencesCountBuffer) << "," << std::endl;
/* sequencesCountOffset */
    structBody << "\t" << structInfo->sequencesCountOffset << "UL" << "," << std::endl;
/* sequencesIndexBuffer */
    structBody << "\t" << consumer.GetHandle(metainfo->sequencesIndexBuffer) << "," << std::endl;
/* sequencesIndexOffset */
    structBody << "\t" << structInfo->sequencesIndexOffset << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "generatedCommandsInfoNV");
    out << "VkGeneratedCommandsInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkGeneratedCommandsMemoryRequirementsInfoNV(std::ostream &out, const VkGeneratedCommandsMemoryRequirementsInfoNV* structInfo, Decoded_VkGeneratedCommandsMemoryRequirementsInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pipelineBindPoint */
    structBody << "\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
/* pipeline */
    structBody << "\t" << consumer.GetHandle(metainfo->pipeline) << "," << std::endl;
/* indirectCommandsLayout */
    structBody << "\t" << consumer.GetHandle(metainfo->indirectCommandsLayout) << "," << std::endl;
/* maxSequencesCount */
    structBody << "\t" << structInfo->maxSequencesCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "generatedCommandsMemoryRequirementsInfoNV");
    out << "VkGeneratedCommandsMemoryRequirementsInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceInheritedViewportScissorFeaturesNV(std::ostream &out, const VkPhysicalDeviceInheritedViewportScissorFeaturesNV* structInfo, Decoded_VkPhysicalDeviceInheritedViewportScissorFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* inheritedViewportScissor2D */
    structBody << "\t" << structInfo->inheritedViewportScissor2D << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceInheritedViewportScissorFeaturesNV");
    out << "VkPhysicalDeviceInheritedViewportScissorFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCommandBufferInheritanceViewportScissorInfoNV(std::ostream &out, const VkCommandBufferInheritanceViewportScissorInfoNV* structInfo, Decoded_VkCommandBufferInheritanceViewportScissorInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pViewportDepthsStruct = "NULL";
    if (structInfo->pViewportDepths != NULL) {
        pViewportDepthsStruct = GenerateStruct_VkViewport(out,
                                                               structInfo->pViewportDepths,
                                                               metainfo->pViewportDepths->GetMetaStructPointer(),
                                                               consumer);
        pViewportDepthsStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* viewportScissor2D */
    structBody << "\t" << structInfo->viewportScissor2D << "," << std::endl;
/* viewportDepthCount */
    structBody << "\t" << structInfo->viewportDepthCount << "," << std::endl;
/* pViewportDepths */
    structBody << "\t" << pViewportDepthsStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "commandBufferInheritanceViewportScissorInfoNV");
    out << "VkCommandBufferInheritanceViewportScissorInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT(std::ostream &out, const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* texelBufferAlignment */
    structBody << "\t" << structInfo->texelBufferAlignment << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceTexelBufferAlignmentFeaturesEXT");
    out << "VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderPassTransformBeginInfoQCOM(std::ostream &out, const VkRenderPassTransformBeginInfoQCOM* structInfo, Decoded_VkRenderPassTransformBeginInfoQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* transform */
    structBody << "\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->transform << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderPassTransformBeginInfoQCOM");
    out << "VkRenderPassTransformBeginInfoQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCommandBufferInheritanceRenderPassTransformInfoQCOM(std::ostream &out, const VkCommandBufferInheritanceRenderPassTransformInfoQCOM* structInfo, Decoded_VkCommandBufferInheritanceRenderPassTransformInfoQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string renderAreaInfoVar = GenerateStruct_VkRect2D(out,
                                                                   &structInfo->renderArea,
                                                                   metainfo->renderArea,
                                                                   consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* transform */
    structBody << "\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->transform << ")" << "," << std::endl;
/* renderArea */
    structBody << "\t" << renderAreaInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "commandBufferInheritanceRenderPassTransformInfoQCOM");
    out << "VkCommandBufferInheritanceRenderPassTransformInfoQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDepthBiasControlFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDepthBiasControlFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDepthBiasControlFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* depthBiasControl */
    structBody << "\t" << structInfo->depthBiasControl << "," << std::endl;
/* leastRepresentableValueForceUnormRepresentation */
    structBody << "\t" << structInfo->leastRepresentableValueForceUnormRepresentation << "," << std::endl;
/* floatRepresentation */
    structBody << "\t" << structInfo->floatRepresentation << "," << std::endl;
/* depthBiasExact */
    structBody << "\t" << structInfo->depthBiasExact << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDepthBiasControlFeaturesEXT");
    out << "VkPhysicalDeviceDepthBiasControlFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDepthBiasInfoEXT(std::ostream &out, const VkDepthBiasInfoEXT* structInfo, Decoded_VkDepthBiasInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* depthBiasConstantFactor */
    structBody << "\t" << structInfo->depthBiasConstantFactor << "," << std::endl;
/* depthBiasClamp */
    structBody << "\t" << structInfo->depthBiasClamp << "," << std::endl;
/* depthBiasSlopeFactor */
    structBody << "\t" << structInfo->depthBiasSlopeFactor << "," ;
    std::string varname = consumer.AddStruct(structBody, "depthBiasInfoEXT");
    out << "VkDepthBiasInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDepthBiasRepresentationInfoEXT(std::ostream &out, const VkDepthBiasRepresentationInfoEXT* structInfo, Decoded_VkDepthBiasRepresentationInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* depthBiasRepresentation */
    structBody << "\t" << "VkDepthBiasRepresentationEXT(" << structInfo->depthBiasRepresentation << ")" << "," << std::endl;
/* depthBiasExact */
    structBody << "\t" << structInfo->depthBiasExact << "," ;
    std::string varname = consumer.AddStruct(structBody, "depthBiasRepresentationInfoEXT");
    out << "VkDepthBiasRepresentationInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDeviceMemoryReportFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceMemoryReport */
    structBody << "\t" << structInfo->deviceMemoryReport << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDeviceMemoryReportFeaturesEXT");
    out << "VkPhysicalDeviceDeviceMemoryReportFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceMemoryReportCallbackDataEXT(std::ostream &out, const VkDeviceMemoryReportCallbackDataEXT* structInfo, Decoded_VkDeviceMemoryReportCallbackDataEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDeviceMemoryReportFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* type */
    structBody << "\t" << "VkDeviceMemoryReportEventTypeEXT(" << structInfo->type << ")" << "," << std::endl;
/* memoryObjectId */
    structBody << "\t" << structInfo->memoryObjectId << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," << std::endl;
/* objectType */
    structBody << "\t" << "VkObjectType(" << structInfo->objectType << ")" << "," << std::endl;
/* objectHandle */
    structBody << "\t" << structInfo->objectHandle << "UL" << "," << std::endl;
/* heapIndex */
    structBody << "\t" << structInfo->heapIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceMemoryReportCallbackDataEXT");
    out << "VkDeviceMemoryReportCallbackDataEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceDeviceMemoryReportCreateInfoEXT(std::ostream &out, const VkDeviceDeviceMemoryReportCreateInfoEXT* structInfo, Decoded_VkDeviceDeviceMemoryReportCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDeviceMemoryReportFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* pfnUserCallback */
    structBody << "\t" << structInfo->pfnUserCallback << "," << std::endl;
/* pUserData */
    out << "// TODO: Support pUserData (output?) argument." << std::endl;
    std::string varname = consumer.AddStruct(structBody, "deviceDeviceMemoryReportCreateInfoEXT");
    out << "VkDeviceDeviceMemoryReportCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceRobustness2FeaturesEXT(std::ostream &out, const VkPhysicalDeviceRobustness2FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceRobustness2FeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* robustBufferAccess2 */
    structBody << "\t" << structInfo->robustBufferAccess2 << "," << std::endl;
/* robustImageAccess2 */
    structBody << "\t" << structInfo->robustImageAccess2 << "," << std::endl;
/* nullDescriptor */
    structBody << "\t" << structInfo->nullDescriptor << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceRobustness2FeaturesEXT");
    out << "VkPhysicalDeviceRobustness2FeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceRobustness2PropertiesEXT(std::ostream &out, const VkPhysicalDeviceRobustness2PropertiesEXT* structInfo, Decoded_VkPhysicalDeviceRobustness2PropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* robustStorageBufferAccessSizeAlignment */
    structBody << "\t" << structInfo->robustStorageBufferAccessSizeAlignment << "UL" << "," << std::endl;
/* robustUniformBufferAccessSizeAlignment */
    structBody << "\t" << structInfo->robustUniformBufferAccessSizeAlignment << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceRobustness2PropertiesEXT");
    out << "VkPhysicalDeviceRobustness2PropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSamplerCustomBorderColorCreateInfoEXT(std::ostream &out, const VkSamplerCustomBorderColorCreateInfoEXT* structInfo, Decoded_VkSamplerCustomBorderColorCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* customBorderColor */
    structBody << "\t" << structInfo->customBorderColor.float32 << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "samplerCustomBorderColorCreateInfoEXT");
    out << "VkSamplerCustomBorderColorCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceCustomBorderColorPropertiesEXT(std::ostream &out, const VkPhysicalDeviceCustomBorderColorPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceCustomBorderColorPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxCustomBorderColorSamplers */
    structBody << "\t" << structInfo->maxCustomBorderColorSamplers << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceCustomBorderColorPropertiesEXT");
    out << "VkPhysicalDeviceCustomBorderColorPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceCustomBorderColorFeaturesEXT(std::ostream &out, const VkPhysicalDeviceCustomBorderColorFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceCustomBorderColorFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* customBorderColors */
    structBody << "\t" << structInfo->customBorderColors << "," << std::endl;
/* customBorderColorWithoutFormat */
    structBody << "\t" << structInfo->customBorderColorWithoutFormat << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceCustomBorderColorFeaturesEXT");
    out << "VkPhysicalDeviceCustomBorderColorFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePresentBarrierFeaturesNV(std::ostream &out, const VkPhysicalDevicePresentBarrierFeaturesNV* structInfo, Decoded_VkPhysicalDevicePresentBarrierFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* presentBarrier */
    structBody << "\t" << structInfo->presentBarrier << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePresentBarrierFeaturesNV");
    out << "VkPhysicalDevicePresentBarrierFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSurfaceCapabilitiesPresentBarrierNV(std::ostream &out, const VkSurfaceCapabilitiesPresentBarrierNV* structInfo, Decoded_VkSurfaceCapabilitiesPresentBarrierNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* presentBarrierSupported */
    structBody << "\t" << structInfo->presentBarrierSupported << "," ;
    std::string varname = consumer.AddStruct(structBody, "surfaceCapabilitiesPresentBarrierNV");
    out << "VkSurfaceCapabilitiesPresentBarrierNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSwapchainPresentBarrierCreateInfoNV(std::ostream &out, const VkSwapchainPresentBarrierCreateInfoNV* structInfo, Decoded_VkSwapchainPresentBarrierCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* presentBarrierEnable */
    structBody << "\t" << structInfo->presentBarrierEnable << "," ;
    std::string varname = consumer.AddStruct(structBody, "swapchainPresentBarrierCreateInfoNV");
    out << "VkSwapchainPresentBarrierCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDiagnosticsConfigFeaturesNV(std::ostream &out, const VkPhysicalDeviceDiagnosticsConfigFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDiagnosticsConfigFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* diagnosticsConfig */
    structBody << "\t" << structInfo->diagnosticsConfig << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDiagnosticsConfigFeaturesNV");
    out << "VkPhysicalDeviceDiagnosticsConfigFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceDiagnosticsConfigCreateInfoNV(std::ostream &out, const VkDeviceDiagnosticsConfigCreateInfoNV* structInfo, Decoded_VkDeviceDiagnosticsConfigCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDeviceDiagnosticsConfigFlagsNV(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceDiagnosticsConfigCreateInfoNV");
    out << "VkDeviceDiagnosticsConfigCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkQueryLowLatencySupportNV(std::ostream &out, const VkQueryLowLatencySupportNV* structInfo, Decoded_VkQueryLowLatencySupportNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pQueriedLowLatencyData */
    out << "// TODO: Support pQueriedLowLatencyData (output?) argument." << std::endl;
    std::string varname = consumer.AddStruct(structBody, "queryLowLatencySupportNV");
    out << "VkQueryLowLatencySupportNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT(std::ostream &out, const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* graphicsPipelineLibrary */
    structBody << "\t" << structInfo->graphicsPipelineLibrary << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceGraphicsPipelineLibraryFeaturesEXT");
    out << "VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT(std::ostream &out, const VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* graphicsPipelineLibraryFastLinking */
    structBody << "\t" << structInfo->graphicsPipelineLibraryFastLinking << "," << std::endl;
/* graphicsPipelineLibraryIndependentInterpolationDecoration */
    structBody << "\t" << structInfo->graphicsPipelineLibraryIndependentInterpolationDecoration << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceGraphicsPipelineLibraryPropertiesEXT");
    out << "VkPhysicalDeviceGraphicsPipelineLibraryPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkGraphicsPipelineLibraryCreateInfoEXT(std::ostream &out, const VkGraphicsPipelineLibraryCreateInfoEXT* structInfo, Decoded_VkGraphicsPipelineLibraryCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkGraphicsPipelineLibraryFlagsEXT(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "graphicsPipelineLibraryCreateInfoEXT");
    out << "VkGraphicsPipelineLibraryCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD(std::ostream &out, const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* structInfo, Decoded_VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderEarlyAndLateFragmentTests */
    structBody << "\t" << structInfo->shaderEarlyAndLateFragmentTests << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD");
    out << "VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV(std::ostream &out, const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fragmentShadingRateEnums */
    structBody << "\t" << structInfo->fragmentShadingRateEnums << "," << std::endl;
/* supersampleFragmentShadingRates */
    structBody << "\t" << structInfo->supersampleFragmentShadingRates << "," << std::endl;
/* noInvocationFragmentShadingRates */
    structBody << "\t" << structInfo->noInvocationFragmentShadingRates << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFragmentShadingRateEnumsFeaturesNV");
    out << "VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV(std::ostream &out, const VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* structInfo, Decoded_VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxFragmentShadingRateInvocationCount */
    structBody << "\t" << "VkSampleCountFlagBits(" << structInfo->maxFragmentShadingRateInvocationCount << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFragmentShadingRateEnumsPropertiesNV");
    out << "VkPhysicalDeviceFragmentShadingRateEnumsPropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineFragmentShadingRateEnumStateCreateInfoNV(std::ostream &out, const VkPipelineFragmentShadingRateEnumStateCreateInfoNV* structInfo, Decoded_VkPipelineFragmentShadingRateEnumStateCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shadingRateType */
    structBody << "\t" << "VkFragmentShadingRateTypeNV(" << structInfo->shadingRateType << ")" << "," << std::endl;
/* shadingRate */
    structBody << "\t" << "VkFragmentShadingRateNV(" << structInfo->shadingRate << ")" << "," << std::endl;
/* combinerOps */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const VkFragmentShadingRateCombinerOpKHR*>(&structInfo->combinerOps[0]), 2) << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineFragmentShadingRateEnumStateCreateInfoNV");
    out << "VkPipelineFragmentShadingRateEnumStateCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureGeometryMotionTrianglesDataNV(std::ostream &out, const VkAccelerationStructureGeometryMotionTrianglesDataNV* structInfo, Decoded_VkAccelerationStructureGeometryMotionTrianglesDataNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* vertexData */
    structBody << "\t" << structInfo->vertexData.deviceAddress << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureGeometryMotionTrianglesDataNV");
    out << "VkAccelerationStructureGeometryMotionTrianglesDataNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureMotionInfoNV(std::ostream &out, const VkAccelerationStructureMotionInfoNV* structInfo, Decoded_VkAccelerationStructureMotionInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxInstances */
    structBody << "\t" << structInfo->maxInstances << "," << std::endl;
/* flags */
    structBody << "\t" << "VkAccelerationStructureMotionInfoFlagsNV(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureMotionInfoNV");
    out << "VkAccelerationStructureMotionInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureMatrixMotionInstanceNV(std::ostream &out, const VkAccelerationStructureMatrixMotionInstanceNV* structInfo, Decoded_VkAccelerationStructureMatrixMotionInstanceNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string transformT0InfoVar = GenerateStruct_VkTransformMatrixKHR(out,
                                                                    &structInfo->transformT0,
                                                                    metainfo->transformT0,
                                                                    consumer);
    std::string transformT1InfoVar = GenerateStruct_VkTransformMatrixKHR(out,
                                                                    &structInfo->transformT1,
                                                                    metainfo->transformT1,
                                                                    consumer);
/* transformT0 */
    structBody << "\t" << transformT0InfoVar << "," << std::endl;
/* transformT1 */
    structBody << "\t" << transformT1InfoVar << "," << std::endl;
/* instanceCustomIndex */
    structBody << "\t" << structInfo->instanceCustomIndex << "," << std::endl;
/* mask */
    structBody << "\t" << structInfo->mask << "," << std::endl;
/* instanceShaderBindingTableRecordOffset */
    structBody << "\t" << structInfo->instanceShaderBindingTableRecordOffset << "," << std::endl;
/* flags */
    structBody << "\t" << "VkGeometryInstanceFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* accelerationStructureReference */
    structBody << "\t" << structInfo->accelerationStructureReference << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureMatrixMotionInstanceNV");
    out << "VkAccelerationStructureMatrixMotionInstanceNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSRTDataNV(std::ostream &out, const VkSRTDataNV* structInfo, Decoded_VkSRTDataNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* sx */
    structBody << "\t" << structInfo->sx << "," << std::endl;
/* a */
    structBody << "\t" << structInfo->a << "," << std::endl;
/* b */
    structBody << "\t" << structInfo->b << "," << std::endl;
/* pvx */
    structBody << "\t" << structInfo->pvx << "," << std::endl;
/* sy */
    structBody << "\t" << structInfo->sy << "," << std::endl;
/* c */
    structBody << "\t" << structInfo->c << "," << std::endl;
/* pvy */
    structBody << "\t" << structInfo->pvy << "," << std::endl;
/* sz */
    structBody << "\t" << structInfo->sz << "," << std::endl;
/* pvz */
    structBody << "\t" << structInfo->pvz << "," << std::endl;
/* qx */
    structBody << "\t" << structInfo->qx << "," << std::endl;
/* qy */
    structBody << "\t" << structInfo->qy << "," << std::endl;
/* qz */
    structBody << "\t" << structInfo->qz << "," << std::endl;
/* qw */
    structBody << "\t" << structInfo->qw << "," << std::endl;
/* tx */
    structBody << "\t" << structInfo->tx << "," << std::endl;
/* ty */
    structBody << "\t" << structInfo->ty << "," << std::endl;
/* tz */
    structBody << "\t" << structInfo->tz << "," ;
    std::string varname = consumer.AddStruct(structBody, "sRTDataNV");
    out << "VkSRTDataNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureSRTMotionInstanceNV(std::ostream &out, const VkAccelerationStructureSRTMotionInstanceNV* structInfo, Decoded_VkAccelerationStructureSRTMotionInstanceNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string transformT0InfoVar = GenerateStruct_VkSRTDataNV(out,
                                                                    &structInfo->transformT0,
                                                                    metainfo->transformT0,
                                                                    consumer);
    std::string transformT1InfoVar = GenerateStruct_VkSRTDataNV(out,
                                                                    &structInfo->transformT1,
                                                                    metainfo->transformT1,
                                                                    consumer);
/* transformT0 */
    structBody << "\t" << transformT0InfoVar << "," << std::endl;
/* transformT1 */
    structBody << "\t" << transformT1InfoVar << "," << std::endl;
/* instanceCustomIndex */
    structBody << "\t" << structInfo->instanceCustomIndex << "," << std::endl;
/* mask */
    structBody << "\t" << structInfo->mask << "," << std::endl;
/* instanceShaderBindingTableRecordOffset */
    structBody << "\t" << structInfo->instanceShaderBindingTableRecordOffset << "," << std::endl;
/* flags */
    structBody << "\t" << "VkGeometryInstanceFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* accelerationStructureReference */
    structBody << "\t" << structInfo->accelerationStructureReference << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureSRTMotionInstanceNV");
    out << "VkAccelerationStructureSRTMotionInstanceNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV(std::ostream &out, const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* structInfo, Decoded_VkPhysicalDeviceRayTracingMotionBlurFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* rayTracingMotionBlur */
    structBody << "\t" << structInfo->rayTracingMotionBlur << "," << std::endl;
/* rayTracingMotionBlurPipelineTraceRaysIndirect */
    structBody << "\t" << structInfo->rayTracingMotionBlurPipelineTraceRaysIndirect << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceRayTracingMotionBlurFeaturesNV");
    out << "VkPhysicalDeviceRayTracingMotionBlurFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT(std::ostream &out, const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* ycbcr2plane444Formats */
    structBody << "\t" << structInfo->ycbcr2plane444Formats << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceYcbcr2Plane444FormatsFeaturesEXT");
    out << "VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT(std::ostream &out, const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMap2FeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fragmentDensityMapDeferred */
    structBody << "\t" << structInfo->fragmentDensityMapDeferred << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFragmentDensityMap2FeaturesEXT");
    out << "VkPhysicalDeviceFragmentDensityMap2FeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT(std::ostream &out, const VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMap2PropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* subsampledLoads */
    structBody << "\t" << structInfo->subsampledLoads << "," << std::endl;
/* subsampledCoarseReconstructionEarlyAccess */
    structBody << "\t" << structInfo->subsampledCoarseReconstructionEarlyAccess << "," << std::endl;
/* maxSubsampledArrayLayers */
    structBody << "\t" << structInfo->maxSubsampledArrayLayers << "," << std::endl;
/* maxDescriptorSetSubsampledSamplers */
    structBody << "\t" << structInfo->maxDescriptorSetSubsampledSamplers << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFragmentDensityMap2PropertiesEXT");
    out << "VkPhysicalDeviceFragmentDensityMap2PropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyCommandTransformInfoQCOM(std::ostream &out, const VkCopyCommandTransformInfoQCOM* structInfo, Decoded_VkCopyCommandTransformInfoQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* transform */
    structBody << "\t" << "VkSurfaceTransformFlagBitsKHR(" << structInfo->transform << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyCommandTransformInfoQCOM");
    out << "VkCopyCommandTransformInfoQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceImageCompressionControlFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImageCompressionControlFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImageCompressionControlFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* imageCompressionControl */
    structBody << "\t" << structInfo->imageCompressionControl << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceImageCompressionControlFeaturesEXT");
    out << "VkPhysicalDeviceImageCompressionControlFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageCompressionControlEXT(std::ostream &out, const VkImageCompressionControlEXT* structInfo, Decoded_VkImageCompressionControlEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pFixedRateFlagsArray = "NULL";
    if (structInfo->pFixedRateFlags != NULL) {
        std::string pFixedRateFlagsValues;
        for (uint32_t idx = 0; idx < structInfo->compressionControlPlaneCount; idx++) {
            pFixedRateFlagsValues += util::ToString<VkImageCompressionFixedRateFlagsEXT>(structInfo->pFixedRateFlags[idx]) + ", ";
        }
        pFixedRateFlagsArray = "pFixedRateFlags_" + std::to_string(consumer.getNextId());
        out << "VkImageCompressionFixedRateFlagsEXT " << pFixedRateFlagsArray << "[] = {" << pFixedRateFlagsValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkImageCompressionFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* compressionControlPlaneCount */
    structBody << "\t" << structInfo->compressionControlPlaneCount << "," << std::endl;
/* pFixedRateFlags */
    structBody << "\t" << pFixedRateFlagsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageCompressionControlEXT");
    out << "VkImageCompressionControlEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageCompressionPropertiesEXT(std::ostream &out, const VkImageCompressionPropertiesEXT* structInfo, Decoded_VkImageCompressionPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* imageCompressionFlags */
    structBody << "\t" << "VkImageCompressionFlagsEXT(" << structInfo->imageCompressionFlags << ")" << "," << std::endl;
/* imageCompressionFixedRateFlags */
    structBody << "\t" << "VkImageCompressionFixedRateFlagsEXT(" << structInfo->imageCompressionFixedRateFlags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageCompressionPropertiesEXT");
    out << "VkImageCompressionPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT(std::ostream &out, const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* attachmentFeedbackLoopLayout */
    structBody << "\t" << structInfo->attachmentFeedbackLoopLayout << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT");
    out << "VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevice4444FormatsFeaturesEXT(std::ostream &out, const VkPhysicalDevice4444FormatsFeaturesEXT* structInfo, Decoded_VkPhysicalDevice4444FormatsFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* formatA4R4G4B4 */
    structBody << "\t" << structInfo->formatA4R4G4B4 << "," << std::endl;
/* formatA4B4G4R4 */
    structBody << "\t" << structInfo->formatA4B4G4R4 << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevice4444FormatsFeaturesEXT");
    out << "VkPhysicalDevice4444FormatsFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFaultFeaturesEXT(std::ostream &out, const VkPhysicalDeviceFaultFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFaultFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceFault */
    structBody << "\t" << structInfo->deviceFault << "," << std::endl;
/* deviceFaultVendorBinary */
    structBody << "\t" << structInfo->deviceFaultVendorBinary << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFaultFeaturesEXT");
    out << "VkPhysicalDeviceFaultFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceFaultCountsEXT(std::ostream &out, const VkDeviceFaultCountsEXT* structInfo, Decoded_VkDeviceFaultCountsEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* addressInfoCount */
    structBody << "\t" << structInfo->addressInfoCount << "," << std::endl;
/* vendorInfoCount */
    structBody << "\t" << structInfo->vendorInfoCount << "," << std::endl;
/* vendorBinarySize */
    structBody << "\t" << structInfo->vendorBinarySize << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceFaultCountsEXT");
    out << "VkDeviceFaultCountsEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceFaultAddressInfoEXT(std::ostream &out, const VkDeviceFaultAddressInfoEXT* structInfo, Decoded_VkDeviceFaultAddressInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* addressType */
    structBody << "\t" << "VkDeviceFaultAddressTypeEXT(" << structInfo->addressType << ")" << "," << std::endl;
/* reportedAddress */
    structBody << "\t" << structInfo->reportedAddress << "UL" << "," << std::endl;
/* addressPrecision */
    structBody << "\t" << structInfo->addressPrecision << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceFaultAddressInfoEXT");
    out << "VkDeviceFaultAddressInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceFaultVendorInfoEXT(std::ostream &out, const VkDeviceFaultVendorInfoEXT* structInfo, Decoded_VkDeviceFaultVendorInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* description */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->description) << "," << std::endl;
/* vendorFaultCode */
    structBody << "\t" << structInfo->vendorFaultCode << "UL" << "," << std::endl;
/* vendorFaultData */
    structBody << "\t" << structInfo->vendorFaultData << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceFaultVendorInfoEXT");
    out << "VkDeviceFaultVendorInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceFaultInfoEXT(std::ostream &out, const VkDeviceFaultInfoEXT* structInfo, Decoded_VkDeviceFaultInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* description */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->description) << "," << std::endl;
/* pAddressInfos */
    out << "// TODO: Support pAddressInfos (output?) argument." << std::endl;
/* pVendorInfos */
    out << "// TODO: Support pVendorInfos (output?) argument." << std::endl;
/* pVendorBinaryData */
    out << "// TODO: Support pVendorBinaryData (output?) argument." << std::endl;
    std::string varname = consumer.AddStruct(structBody, "deviceFaultInfoEXT");
    out << "VkDeviceFaultInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceFaultVendorBinaryHeaderVersionOneEXT(std::ostream &out, const VkDeviceFaultVendorBinaryHeaderVersionOneEXT* structInfo, Decoded_VkDeviceFaultVendorBinaryHeaderVersionOneEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* headerSize */
    structBody << "\t" << structInfo->headerSize << "," << std::endl;
/* headerVersion */
    structBody << "\t" << "VkDeviceFaultVendorBinaryHeaderVersionEXT(" << structInfo->headerVersion << ")" << "," << std::endl;
/* vendorID */
    structBody << "\t" << structInfo->vendorID << "," << std::endl;
/* deviceID */
    structBody << "\t" << structInfo->deviceID << "," << std::endl;
/* driverVersion */
    structBody << "\t" << structInfo->driverVersion << "," << std::endl;
/* pipelineCacheUUID */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->pipelineCacheUUID[0]), VK_UUID_SIZE) << "," << std::endl;
/* applicationNameOffset */
    structBody << "\t" << structInfo->applicationNameOffset << "," << std::endl;
/* applicationVersion */
    structBody << "\t" << structInfo->applicationVersion << "," << std::endl;
/* engineNameOffset */
    structBody << "\t" << structInfo->engineNameOffset << "," << std::endl;
/* engineVersion */
    structBody << "\t" << structInfo->engineVersion << "," << std::endl;
/* apiVersion */
    structBody << "\t" << structInfo->apiVersion << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceFaultVendorBinaryHeaderVersionOneEXT");
    out << "VkDeviceFaultVendorBinaryHeaderVersionOneEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT(std::ostream &out, const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* rasterizationOrderColorAttachmentAccess */
    structBody << "\t" << structInfo->rasterizationOrderColorAttachmentAccess << "," << std::endl;
/* rasterizationOrderDepthAttachmentAccess */
    structBody << "\t" << structInfo->rasterizationOrderDepthAttachmentAccess << "," << std::endl;
/* rasterizationOrderStencilAttachmentAccess */
    structBody << "\t" << structInfo->rasterizationOrderStencilAttachmentAccess << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT");
    out << "VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT(std::ostream &out, const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* formatRgba10x6WithoutYCbCrSampler */
    structBody << "\t" << structInfo->formatRgba10x6WithoutYCbCrSampler << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceRGBA10X6FormatsFeaturesEXT");
    out << "VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDirectFBSurfaceCreateInfoEXT(std::ostream &out, const VkDirectFBSurfaceCreateInfoEXT* structInfo, Decoded_VkDirectFBSurfaceCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDirectFBSurfaceCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* dfb */
    structBody << "\t" << structInfo->dfb << "," << std::endl;
/* surface */
    structBody << "\t" << structInfo->surface << "," ;
    std::string varname = consumer.AddStruct(structBody, "directFBSurfaceCreateInfoEXT");
    out << "VkDirectFBSurfaceCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* mutableDescriptorType */
    structBody << "\t" << structInfo->mutableDescriptorType << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMutableDescriptorTypeFeaturesEXT");
    out << "VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMutableDescriptorTypeListEXT(std::ostream &out, const VkMutableDescriptorTypeListEXT* structInfo, Decoded_VkMutableDescriptorTypeListEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pDescriptorTypesValues;
    std::string pDescriptorTypesArray = "NULL";
    if (structInfo->pDescriptorTypes != NULL) {
        for (uint32_t idx = 0; idx < structInfo->descriptorTypeCount; idx++) {
            pDescriptorTypesValues += util::ToString<VkDescriptorType>(structInfo->pDescriptorTypes[idx]) + ", ";
        }
        pDescriptorTypesArray = "pDescriptorTypes_" + std::to_string(consumer.getNextId());
        out << "VkDescriptorType " << pDescriptorTypesArray << "[] = {" << pDescriptorTypesValues << "};" << std::endl;
    }
/* descriptorTypeCount */
    structBody << "\t" << structInfo->descriptorTypeCount << "," << std::endl;
/* pDescriptorTypes */
    structBody << "\t" << pDescriptorTypesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "mutableDescriptorTypeListEXT");
    out << "VkMutableDescriptorTypeListEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMutableDescriptorTypeCreateInfoEXT(std::ostream &out, const VkMutableDescriptorTypeCreateInfoEXT* structInfo, Decoded_VkMutableDescriptorTypeCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pMutableDescriptorTypeListsArray = "NULL";
    if (structInfo->pMutableDescriptorTypeLists != NULL) {
        pMutableDescriptorTypeListsArray = "pMutableDescriptorTypeLists_" + std::to_string(consumer.getNextId());
        std::string pMutableDescriptorTypeListsNames;
        for (uint32_t idx = 0; idx < structInfo->mutableDescriptorTypeListCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pMutableDescriptorTypeLists + idx != NULL) {
                varName = GenerateStruct_VkMutableDescriptorTypeListEXT(out,
                                                         structInfo->pMutableDescriptorTypeLists + idx,
                                                         metainfo->pMutableDescriptorTypeLists->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pMutableDescriptorTypeListsNames += varName + ", ";
        }
        out << "VkMutableDescriptorTypeListEXT " << pMutableDescriptorTypeListsArray << "[] = {" << pMutableDescriptorTypeListsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* mutableDescriptorTypeListCount */
    structBody << "\t" << structInfo->mutableDescriptorTypeListCount << "," << std::endl;
/* pMutableDescriptorTypeLists */
    structBody << "\t" << pMutableDescriptorTypeListsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "mutableDescriptorTypeCreateInfoEXT");
    out << "VkMutableDescriptorTypeCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT(std::ostream &out, const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* vertexInputDynamicState */
    structBody << "\t" << structInfo->vertexInputDynamicState << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceVertexInputDynamicStateFeaturesEXT");
    out << "VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVertexInputBindingDescription2EXT(std::ostream &out, const VkVertexInputBindingDescription2EXT* structInfo, Decoded_VkVertexInputBindingDescription2EXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* binding */
    structBody << "\t" << structInfo->binding << "," << std::endl;
/* stride */
    structBody << "\t" << structInfo->stride << "," << std::endl;
/* inputRate */
    structBody << "\t" << "VkVertexInputRate(" << structInfo->inputRate << ")" << "," << std::endl;
/* divisor */
    structBody << "\t" << structInfo->divisor << "," ;
    std::string varname = consumer.AddStruct(structBody, "vertexInputBindingDescription2EXT");
    out << "VkVertexInputBindingDescription2EXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkVertexInputAttributeDescription2EXT(std::ostream &out, const VkVertexInputAttributeDescription2EXT* structInfo, Decoded_VkVertexInputAttributeDescription2EXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* location */
    structBody << "\t" << structInfo->location << "," << std::endl;
/* binding */
    structBody << "\t" << structInfo->binding << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "," ;
    std::string varname = consumer.AddStruct(structBody, "vertexInputAttributeDescription2EXT");
    out << "VkVertexInputAttributeDescription2EXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDrmPropertiesEXT(std::ostream &out, const VkPhysicalDeviceDrmPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceDrmPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* hasPrimary */
    structBody << "\t" << structInfo->hasPrimary << "," << std::endl;
/* hasRender */
    structBody << "\t" << structInfo->hasRender << "," << std::endl;
/* primaryMajor */
    structBody << "\t" << structInfo->primaryMajor << "," << std::endl;
/* primaryMinor */
    structBody << "\t" << structInfo->primaryMinor << "," << std::endl;
/* renderMajor */
    structBody << "\t" << structInfo->renderMajor << "," << std::endl;
/* renderMinor */
    structBody << "\t" << structInfo->renderMinor << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDrmPropertiesEXT");
    out << "VkPhysicalDeviceDrmPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceAddressBindingReportFeaturesEXT(std::ostream &out, const VkPhysicalDeviceAddressBindingReportFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceAddressBindingReportFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* reportAddressBinding */
    structBody << "\t" << structInfo->reportAddressBinding << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceAddressBindingReportFeaturesEXT");
    out << "VkPhysicalDeviceAddressBindingReportFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDeviceAddressBindingCallbackDataEXT(std::ostream &out, const VkDeviceAddressBindingCallbackDataEXT* structInfo, Decoded_VkDeviceAddressBindingCallbackDataEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDeviceAddressBindingFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* baseAddress */
    structBody << "\t" << structInfo->baseAddress << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," << std::endl;
/* bindingType */
    structBody << "\t" << "VkDeviceAddressBindingTypeEXT(" << structInfo->bindingType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "deviceAddressBindingCallbackDataEXT");
    out << "VkDeviceAddressBindingCallbackDataEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDepthClipControlFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDepthClipControlFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDepthClipControlFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* depthClipControl */
    structBody << "\t" << structInfo->depthClipControl << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDepthClipControlFeaturesEXT");
    out << "VkPhysicalDeviceDepthClipControlFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineViewportDepthClipControlCreateInfoEXT(std::ostream &out, const VkPipelineViewportDepthClipControlCreateInfoEXT* structInfo, Decoded_VkPipelineViewportDepthClipControlCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* negativeOneToOne */
    structBody << "\t" << structInfo->negativeOneToOne << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineViewportDepthClipControlCreateInfoEXT");
    out << "VkPipelineViewportDepthClipControlCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT(std::ostream &out, const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* primitiveTopologyListRestart */
    structBody << "\t" << structInfo->primitiveTopologyListRestart << "," << std::endl;
/* primitiveTopologyPatchListRestart */
    structBody << "\t" << structInfo->primitiveTopologyPatchListRestart << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePrimitiveTopologyListRestartFeaturesEXT");
    out << "VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImportMemoryZirconHandleInfoFUCHSIA(std::ostream &out, const VkImportMemoryZirconHandleInfoFUCHSIA* structInfo, Decoded_VkImportMemoryZirconHandleInfoFUCHSIA* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
/* handle */
    structBody << "\t" << structInfo->handle << "," ;
    std::string varname = consumer.AddStruct(structBody, "importMemoryZirconHandleInfoFUCHSIA");
    out << "VkImportMemoryZirconHandleInfoFUCHSIA " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryZirconHandlePropertiesFUCHSIA(std::ostream &out, const VkMemoryZirconHandlePropertiesFUCHSIA* structInfo, Decoded_VkMemoryZirconHandlePropertiesFUCHSIA* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memoryTypeBits */
    structBody << "\t" << structInfo->memoryTypeBits << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryZirconHandlePropertiesFUCHSIA");
    out << "VkMemoryZirconHandlePropertiesFUCHSIA " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryGetZirconHandleInfoFUCHSIA(std::ostream &out, const VkMemoryGetZirconHandleInfoFUCHSIA* structInfo, Decoded_VkMemoryGetZirconHandleInfoFUCHSIA* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryGetZirconHandleInfoFUCHSIA");
    out << "VkMemoryGetZirconHandleInfoFUCHSIA " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImportSemaphoreZirconHandleInfoFUCHSIA(std::ostream &out, const VkImportSemaphoreZirconHandleInfoFUCHSIA* structInfo, Decoded_VkImportSemaphoreZirconHandleInfoFUCHSIA* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* semaphore */
    structBody << "\t" << consumer.GetHandle(metainfo->semaphore) << "," << std::endl;
/* flags */
    structBody << "\t" << "VkSemaphoreImportFlags(" << structInfo->flags << ")" << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << "," << std::endl;
/* zirconHandle */
    structBody << "\t" << structInfo->zirconHandle << "," ;
    std::string varname = consumer.AddStruct(structBody, "importSemaphoreZirconHandleInfoFUCHSIA");
    out << "VkImportSemaphoreZirconHandleInfoFUCHSIA " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSemaphoreGetZirconHandleInfoFUCHSIA(std::ostream &out, const VkSemaphoreGetZirconHandleInfoFUCHSIA* structInfo, Decoded_VkSemaphoreGetZirconHandleInfoFUCHSIA* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* semaphore */
    structBody << "\t" << consumer.GetHandle(metainfo->semaphore) << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalSemaphoreHandleTypeFlagBits(" << structInfo->handleType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "semaphoreGetZirconHandleInfoFUCHSIA");
    out << "VkSemaphoreGetZirconHandleInfoFUCHSIA " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI(std::ostream &out, const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* structInfo, Decoded_VkPhysicalDeviceInvocationMaskFeaturesHUAWEI* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* invocationMask */
    structBody << "\t" << structInfo->invocationMask << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceInvocationMaskFeaturesHUAWEI");
    out << "VkPhysicalDeviceInvocationMaskFeaturesHUAWEI " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMemoryGetRemoteAddressInfoNV(std::ostream &out, const VkMemoryGetRemoteAddressInfoNV* structInfo, Decoded_VkMemoryGetRemoteAddressInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* memory */
    structBody << "\t" << consumer.GetHandle(metainfo->memory) << "," << std::endl;
/* handleType */
    structBody << "\t" << "VkExternalMemoryHandleTypeFlagBits(" << structInfo->handleType << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "memoryGetRemoteAddressInfoNV");
    out << "VkMemoryGetRemoteAddressInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV(std::ostream &out, const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* structInfo, Decoded_VkPhysicalDeviceExternalMemoryRDMAFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* externalMemoryRDMA */
    structBody << "\t" << structInfo->externalMemoryRDMA << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExternalMemoryRDMAFeaturesNV");
    out << "VkPhysicalDeviceExternalMemoryRDMAFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFrameBoundaryFeaturesEXT(std::ostream &out, const VkPhysicalDeviceFrameBoundaryFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceFrameBoundaryFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* frameBoundary */
    structBody << "\t" << structInfo->frameBoundary << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFrameBoundaryFeaturesEXT");
    out << "VkPhysicalDeviceFrameBoundaryFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkFrameBoundaryEXT(std::ostream &out, const VkFrameBoundaryEXT* structInfo, Decoded_VkFrameBoundaryEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pImagesArray = "NULL";
    if (metainfo->pImages.GetPointer() != NULL && structInfo->imageCount > 0) {
        pImagesArray = "pImagesArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_IMAGE));
        std::string pImagesValues = toStringJoin(metainfo->pImages.GetPointer(),
                                                 metainfo->pImages.GetPointer() + structInfo->imageCount,
                                                 [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                 ", ");
        if (structInfo->imageCount == 1) {
            pImagesArray = "&" + pImagesValues;
        } else if (structInfo->imageCount > 1) {
            out << "VkImage " << pImagesArray << "[] = {" << pImagesValues << "};" << std::endl;
        }
    }
    std::string pBuffersArray = "NULL";
    if (metainfo->pBuffers.GetPointer() != NULL && structInfo->bufferCount > 0) {
        pBuffersArray = "pBuffersArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_BUFFER));
        std::string pBuffersValues = toStringJoin(metainfo->pBuffers.GetPointer(),
                                                  metainfo->pBuffers.GetPointer() + structInfo->bufferCount,
                                                  [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                  ", ");
        if (structInfo->bufferCount == 1) {
            pBuffersArray = "&" + pBuffersValues;
        } else if (structInfo->bufferCount > 1) {
            out << "VkBuffer " << pBuffersArray << "[] = {" << pBuffersValues << "};" << std::endl;
        }
    }
    std::string pTagArray = "NULL";
    if (structInfo->pTag != NULL) {
        std::string pTagValues;
        for (uint32_t idx0 = 0; idx0 < structInfo->tagSize; ++idx0) {
            pTagValues += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pTag)[idx0]) + ", ";
        }
        pTagArray = "pTag_" + std::to_string(consumer.getNextId());
        out << "uint8_t " << pTagArray << "[] = {" << pTagValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkFrameBoundaryFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* frameID */
    structBody << "\t" << structInfo->frameID << "UL" << "," << std::endl;
/* imageCount */
    structBody << "\t" << structInfo->imageCount << "," << std::endl;
/* pImages */
    structBody << "\t" << pImagesArray << "," << std::endl;
/* bufferCount */
    structBody << "\t" << structInfo->bufferCount << "," << std::endl;
/* pBuffers */
    structBody << "\t" << pBuffersArray << "," << std::endl;
/* tagName */
    structBody << "\t" << structInfo->tagName << "UL" << "," << std::endl;
/* tagSize */
    structBody << "\t" << structInfo->tagSize << "," << std::endl;
/* pTag */
    structBody << "\t" << pTagArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "frameBoundaryEXT");
    out << "VkFrameBoundaryEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* multisampledRenderToSingleSampled */
    structBody << "\t" << structInfo->multisampledRenderToSingleSampled << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMultisampledRenderToSingleSampledFeaturesEXT");
    out << "VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubpassResolvePerformanceQueryEXT(std::ostream &out, const VkSubpassResolvePerformanceQueryEXT* structInfo, Decoded_VkSubpassResolvePerformanceQueryEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* optimal */
    structBody << "\t" << structInfo->optimal << "," ;
    std::string varname = consumer.AddStruct(structBody, "subpassResolvePerformanceQueryEXT");
    out << "VkSubpassResolvePerformanceQueryEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMultisampledRenderToSingleSampledInfoEXT(std::ostream &out, const VkMultisampledRenderToSingleSampledInfoEXT* structInfo, Decoded_VkMultisampledRenderToSingleSampledInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* multisampledRenderToSingleSampledEnable */
    structBody << "\t" << structInfo->multisampledRenderToSingleSampledEnable << "," << std::endl;
/* rasterizationSamples */
    structBody << "\t" << "VkSampleCountFlagBits(" << structInfo->rasterizationSamples << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "multisampledRenderToSingleSampledInfoEXT");
    out << "VkMultisampledRenderToSingleSampledInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT(std::ostream &out, const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceExtendedDynamicState2FeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* extendedDynamicState2 */
    structBody << "\t" << structInfo->extendedDynamicState2 << "," << std::endl;
/* extendedDynamicState2LogicOp */
    structBody << "\t" << structInfo->extendedDynamicState2LogicOp << "," << std::endl;
/* extendedDynamicState2PatchControlPoints */
    structBody << "\t" << structInfo->extendedDynamicState2PatchControlPoints << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExtendedDynamicState2FeaturesEXT");
    out << "VkPhysicalDeviceExtendedDynamicState2FeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkScreenSurfaceCreateInfoQNX(std::ostream &out, const VkScreenSurfaceCreateInfoQNX* structInfo, Decoded_VkScreenSurfaceCreateInfoQNX* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkScreenSurfaceCreateFlagsQNX(" << structInfo->flags << ")" << "," << std::endl;
/* context */
    structBody << "\t" << structInfo->context << "," << std::endl;
/* window */
    structBody << "\t" << structInfo->window << "," ;
    std::string varname = consumer.AddStruct(structBody, "screenSurfaceCreateInfoQNX");
    out << "VkScreenSurfaceCreateInfoQNX " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceColorWriteEnableFeaturesEXT(std::ostream &out, const VkPhysicalDeviceColorWriteEnableFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceColorWriteEnableFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* colorWriteEnable */
    structBody << "\t" << structInfo->colorWriteEnable << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceColorWriteEnableFeaturesEXT");
    out << "VkPhysicalDeviceColorWriteEnableFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineColorWriteCreateInfoEXT(std::ostream &out, const VkPipelineColorWriteCreateInfoEXT* structInfo, Decoded_VkPipelineColorWriteCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pColorWriteEnablesArray = "NULL";
    if (structInfo->pColorWriteEnables != NULL) {
        std::string pColorWriteEnablesValues;
        for (uint32_t idx0 = 0; idx0 < structInfo->attachmentCount; ++idx0) {
            pColorWriteEnablesValues += std::to_string(structInfo->pColorWriteEnables[idx0]) + ", ";
        }
        pColorWriteEnablesArray = "pColorWriteEnables_" + std::to_string(consumer.getNextId());
        out << "VkBool32 " << pColorWriteEnablesArray << "[] = {" << pColorWriteEnablesValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* attachmentCount */
    structBody << "\t" << structInfo->attachmentCount << "," << std::endl;
/* pColorWriteEnables */
    structBody << "\t" << pColorWriteEnablesArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineColorWriteCreateInfoEXT");
    out << "VkPipelineColorWriteCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT(std::ostream &out, const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* primitivesGeneratedQuery */
    structBody << "\t" << structInfo->primitivesGeneratedQuery << "," << std::endl;
/* primitivesGeneratedQueryWithRasterizerDiscard */
    structBody << "\t" << structInfo->primitivesGeneratedQueryWithRasterizerDiscard << "," << std::endl;
/* primitivesGeneratedQueryWithNonZeroStreams */
    structBody << "\t" << structInfo->primitivesGeneratedQueryWithNonZeroStreams << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePrimitivesGeneratedQueryFeaturesEXT");
    out << "VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceImageViewMinLodFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImageViewMinLodFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImageViewMinLodFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* minLod */
    structBody << "\t" << structInfo->minLod << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceImageViewMinLodFeaturesEXT");
    out << "VkPhysicalDeviceImageViewMinLodFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageViewMinLodCreateInfoEXT(std::ostream &out, const VkImageViewMinLodCreateInfoEXT* structInfo, Decoded_VkImageViewMinLodCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* minLod */
    structBody << "\t" << structInfo->minLod << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageViewMinLodCreateInfoEXT");
    out << "VkImageViewMinLodCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMultiDrawFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMultiDrawFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMultiDrawFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* multiDraw */
    structBody << "\t" << structInfo->multiDraw << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMultiDrawFeaturesEXT");
    out << "VkPhysicalDeviceMultiDrawFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMultiDrawPropertiesEXT(std::ostream &out, const VkPhysicalDeviceMultiDrawPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceMultiDrawPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxMultiDrawCount */
    structBody << "\t" << structInfo->maxMultiDrawCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMultiDrawPropertiesEXT");
    out << "VkPhysicalDeviceMultiDrawPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMultiDrawInfoEXT(std::ostream &out, const VkMultiDrawInfoEXT* structInfo, Decoded_VkMultiDrawInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* firstVertex */
    structBody << "\t" << structInfo->firstVertex << "," << std::endl;
/* vertexCount */
    structBody << "\t" << structInfo->vertexCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "multiDrawInfoEXT");
    out << "VkMultiDrawInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMultiDrawIndexedInfoEXT(std::ostream &out, const VkMultiDrawIndexedInfoEXT* structInfo, Decoded_VkMultiDrawIndexedInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* firstIndex */
    structBody << "\t" << structInfo->firstIndex << "," << std::endl;
/* indexCount */
    structBody << "\t" << structInfo->indexCount << "," << std::endl;
/* vertexOffset */
    structBody << "\t" << structInfo->vertexOffset << "," ;
    std::string varname = consumer.AddStruct(structBody, "multiDrawIndexedInfoEXT");
    out << "VkMultiDrawIndexedInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImage2DViewOf3DFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* image2DViewOf3D */
    structBody << "\t" << structInfo->image2DViewOf3D << "," << std::endl;
/* sampler2DViewOf3D */
    structBody << "\t" << structInfo->sampler2DViewOf3D << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceImage2DViewOf3DFeaturesEXT");
    out << "VkPhysicalDeviceImage2DViewOf3DFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderTileImageFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderTileImageFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderTileImageFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderTileImageColorReadAccess */
    structBody << "\t" << structInfo->shaderTileImageColorReadAccess << "," << std::endl;
/* shaderTileImageDepthReadAccess */
    structBody << "\t" << structInfo->shaderTileImageDepthReadAccess << "," << std::endl;
/* shaderTileImageStencilReadAccess */
    structBody << "\t" << structInfo->shaderTileImageStencilReadAccess << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderTileImageFeaturesEXT");
    out << "VkPhysicalDeviceShaderTileImageFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderTileImagePropertiesEXT(std::ostream &out, const VkPhysicalDeviceShaderTileImagePropertiesEXT* structInfo, Decoded_VkPhysicalDeviceShaderTileImagePropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderTileImageCoherentReadAccelerated */
    structBody << "\t" << structInfo->shaderTileImageCoherentReadAccelerated << "," << std::endl;
/* shaderTileImageReadSampleFromPixelRateInvocation */
    structBody << "\t" << structInfo->shaderTileImageReadSampleFromPixelRateInvocation << "," << std::endl;
/* shaderTileImageReadFromHelperInvocation */
    structBody << "\t" << structInfo->shaderTileImageReadFromHelperInvocation << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderTileImagePropertiesEXT");
    out << "VkPhysicalDeviceShaderTileImagePropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMicromapUsageEXT(std::ostream &out, const VkMicromapUsageEXT* structInfo, Decoded_VkMicromapUsageEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* count */
    structBody << "\t" << structInfo->count << "," << std::endl;
/* subdivisionLevel */
    structBody << "\t" << structInfo->subdivisionLevel << "," << std::endl;
/* format */
    structBody << "\t" << structInfo->format << "," ;
    std::string varname = consumer.AddStruct(structBody, "micromapUsageEXT");
    out << "VkMicromapUsageEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMicromapBuildInfoEXT(std::ostream &out, const VkMicromapBuildInfoEXT* structInfo, Decoded_VkMicromapBuildInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pUsageCountsArray = "NULL";
    if (structInfo->pUsageCounts != NULL) {
        pUsageCountsArray = "pUsageCounts_" + std::to_string(consumer.getNextId());
        std::string pUsageCountsNames;
        for (uint32_t idx = 0; idx < structInfo->usageCountsCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pUsageCounts + idx != NULL) {
                varName = GenerateStruct_VkMicromapUsageEXT(out,
                                                         structInfo->pUsageCounts + idx,
                                                         metainfo->pUsageCounts->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pUsageCountsNames += varName + ", ";
        }
        out << "VkMicromapUsageEXT " << pUsageCountsArray << "[] = {" << pUsageCountsNames << "};" << std::endl;
    }
    std::string ppUsageCountsArray = "NULL";
    if (structInfo->ppUsageCounts != NULL) {
        ppUsageCountsArray = "ppUsageCounts_" + std::to_string(consumer.getNextId());
        std::string ppUsageCountsNames;
        for (uint32_t idx0 = 0; idx0 < structInfo->usageCountsCount; ++idx0) {
            for (uint32_t idx1 = 0; idx1 < 1; ++idx1) {
                std::string varName = "NULL";
                varName = GenerateStruct_VkMicromapUsageEXT(out,
                                                         &(structInfo->ppUsageCounts[idx0][idx1]),
                                                         &(metainfo->ppUsageCounts->GetMetaStructPointer()[idx0][idx1]),
                                                         consumer);
                ppUsageCountsNames += varName + ", ";
            }
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* type */
    structBody << "\t" << "VkMicromapTypeEXT(" << structInfo->type << ")" << "," << std::endl;
/* flags */
    structBody << "\t" << "VkBuildMicromapFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* mode */
    structBody << "\t" << "VkBuildMicromapModeEXT(" << structInfo->mode << ")" << "," << std::endl;
/* dstMicromap */
    structBody << "\t" << consumer.GetHandle(metainfo->dstMicromap) << "," << std::endl;
/* usageCountsCount */
    structBody << "\t" << structInfo->usageCountsCount << "," << std::endl;
/* pUsageCounts */
    structBody << "\t" << pUsageCountsArray << "," << std::endl;
/* ppUsageCounts */
    structBody << "\t" << ppUsageCountsArray << "," << std::endl;
/* data */
    structBody << "\t" << structInfo->data.deviceAddress << "," << std::endl;
/* scratchData */
    structBody << "\t" << structInfo->scratchData.deviceAddress << "," << std::endl;
/* triangleArray */
    structBody << "\t" << structInfo->triangleArray.deviceAddress << "," << std::endl;
/* triangleArrayStride */
    structBody << "\t" << structInfo->triangleArrayStride << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "micromapBuildInfoEXT");
    out << "VkMicromapBuildInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMicromapCreateInfoEXT(std::ostream &out, const VkMicromapCreateInfoEXT* structInfo, Decoded_VkMicromapCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* createFlags */
    structBody << "\t" << "VkMicromapCreateFlagsEXT(" << structInfo->createFlags << ")" << "," << std::endl;
/* buffer */
    structBody << "\t" << consumer.GetHandle(metainfo->buffer) << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," << std::endl;
/* type */
    structBody << "\t" << "VkMicromapTypeEXT(" << structInfo->type << ")" << "," << std::endl;
/* deviceAddress */
    structBody << "\t" << structInfo->deviceAddress << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "micromapCreateInfoEXT");
    out << "VkMicromapCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceOpacityMicromapFeaturesEXT(std::ostream &out, const VkPhysicalDeviceOpacityMicromapFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceOpacityMicromapFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* micromap */
    structBody << "\t" << structInfo->micromap << "," << std::endl;
/* micromapCaptureReplay */
    structBody << "\t" << structInfo->micromapCaptureReplay << "," << std::endl;
/* micromapHostCommands */
    structBody << "\t" << structInfo->micromapHostCommands << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceOpacityMicromapFeaturesEXT");
    out << "VkPhysicalDeviceOpacityMicromapFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceOpacityMicromapPropertiesEXT(std::ostream &out, const VkPhysicalDeviceOpacityMicromapPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceOpacityMicromapPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxOpacity2StateSubdivisionLevel */
    structBody << "\t" << structInfo->maxOpacity2StateSubdivisionLevel << "," << std::endl;
/* maxOpacity4StateSubdivisionLevel */
    structBody << "\t" << structInfo->maxOpacity4StateSubdivisionLevel << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceOpacityMicromapPropertiesEXT");
    out << "VkPhysicalDeviceOpacityMicromapPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMicromapVersionInfoEXT(std::ostream &out, const VkMicromapVersionInfoEXT* structInfo, Decoded_VkMicromapVersionInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pVersionDataArray = "NULL";
    std::string pVersionDataValues;
    for (uint32_t idx0 = 0; idx0 < 2*VK_UUID_SIZE; ++idx0) {
        pVersionDataValues += std::to_string(structInfo->pVersionData[idx0]) + ", ";
    }
    pVersionDataArray = "pVersionData_" + std::to_string(consumer.getNextId());
    out << "uint8_t " << pVersionDataArray << "[] = {" << pVersionDataValues << "};" << std::endl;
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pVersionData */
    structBody << "\t" << pVersionDataArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "micromapVersionInfoEXT");
    out << "VkMicromapVersionInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyMicromapToMemoryInfoEXT(std::ostream &out, const VkCopyMicromapToMemoryInfoEXT* structInfo, Decoded_VkCopyMicromapToMemoryInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* src */
    structBody << "\t" << consumer.GetHandle(metainfo->src) << "," << std::endl;
/* dst */
    structBody << "\t" << structInfo->dst.deviceAddress << "," << std::endl;
/* mode */
    structBody << "\t" << "VkCopyMicromapModeEXT(" << structInfo->mode << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyMicromapToMemoryInfoEXT");
    out << "VkCopyMicromapToMemoryInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyMemoryToMicromapInfoEXT(std::ostream &out, const VkCopyMemoryToMicromapInfoEXT* structInfo, Decoded_VkCopyMemoryToMicromapInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* src */
    structBody << "\t" << structInfo->src.deviceAddress << "," << std::endl;
/* dst */
    structBody << "\t" << consumer.GetHandle(metainfo->dst) << "," << std::endl;
/* mode */
    structBody << "\t" << "VkCopyMicromapModeEXT(" << structInfo->mode << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyMemoryToMicromapInfoEXT");
    out << "VkCopyMemoryToMicromapInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyMicromapInfoEXT(std::ostream &out, const VkCopyMicromapInfoEXT* structInfo, Decoded_VkCopyMicromapInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* src */
    structBody << "\t" << consumer.GetHandle(metainfo->src) << "," << std::endl;
/* dst */
    structBody << "\t" << consumer.GetHandle(metainfo->dst) << "," << std::endl;
/* mode */
    structBody << "\t" << "VkCopyMicromapModeEXT(" << structInfo->mode << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyMicromapInfoEXT");
    out << "VkCopyMicromapInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMicromapBuildSizesInfoEXT(std::ostream &out, const VkMicromapBuildSizesInfoEXT* structInfo, Decoded_VkMicromapBuildSizesInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* micromapSize */
    structBody << "\t" << structInfo->micromapSize << "UL" << "," << std::endl;
/* buildScratchSize */
    structBody << "\t" << structInfo->buildScratchSize << "UL" << "," << std::endl;
/* discardable */
    structBody << "\t" << structInfo->discardable << "," ;
    std::string varname = consumer.AddStruct(structBody, "micromapBuildSizesInfoEXT");
    out << "VkMicromapBuildSizesInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureTrianglesOpacityMicromapEXT(std::ostream &out, const VkAccelerationStructureTrianglesOpacityMicromapEXT* structInfo, Decoded_VkAccelerationStructureTrianglesOpacityMicromapEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pUsageCountsArray = "NULL";
    if (structInfo->pUsageCounts != NULL) {
        pUsageCountsArray = "pUsageCounts_" + std::to_string(consumer.getNextId());
        std::string pUsageCountsNames;
        for (uint32_t idx = 0; idx < structInfo->usageCountsCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pUsageCounts + idx != NULL) {
                varName = GenerateStruct_VkMicromapUsageEXT(out,
                                                         structInfo->pUsageCounts + idx,
                                                         metainfo->pUsageCounts->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pUsageCountsNames += varName + ", ";
        }
        out << "VkMicromapUsageEXT " << pUsageCountsArray << "[] = {" << pUsageCountsNames << "};" << std::endl;
    }
    std::string ppUsageCountsArray = "NULL";
    if (structInfo->ppUsageCounts != NULL) {
        ppUsageCountsArray = "ppUsageCounts_" + std::to_string(consumer.getNextId());
        std::string ppUsageCountsNames;
        for (uint32_t idx0 = 0; idx0 < structInfo->usageCountsCount; ++idx0) {
            for (uint32_t idx1 = 0; idx1 < 1; ++idx1) {
                std::string varName = "NULL";
                varName = GenerateStruct_VkMicromapUsageEXT(out,
                                                         &(structInfo->ppUsageCounts[idx0][idx1]),
                                                         &(metainfo->ppUsageCounts->GetMetaStructPointer()[idx0][idx1]),
                                                         consumer);
                ppUsageCountsNames += varName + ", ";
            }
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* indexType */
    structBody << "\t" << "VkIndexType(" << structInfo->indexType << ")" << "," << std::endl;
/* indexBuffer */
    structBody << "\t" << structInfo->indexBuffer.deviceAddress << "," << std::endl;
/* indexStride */
    structBody << "\t" << structInfo->indexStride << "UL" << "," << std::endl;
/* baseTriangle */
    structBody << "\t" << structInfo->baseTriangle << "," << std::endl;
/* usageCountsCount */
    structBody << "\t" << structInfo->usageCountsCount << "," << std::endl;
/* pUsageCounts */
    structBody << "\t" << pUsageCountsArray << "," << std::endl;
/* ppUsageCounts */
    structBody << "\t" << ppUsageCountsArray << "," << std::endl;
/* micromap */
    structBody << "\t" << consumer.GetHandle(metainfo->micromap) << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureTrianglesOpacityMicromapEXT");
    out << "VkAccelerationStructureTrianglesOpacityMicromapEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMicromapTriangleEXT(std::ostream &out, const VkMicromapTriangleEXT* structInfo, Decoded_VkMicromapTriangleEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* dataOffset */
    structBody << "\t" << structInfo->dataOffset << "," << std::endl;
/* subdivisionLevel */
    structBody << "\t" << structInfo->subdivisionLevel << "," << std::endl;
/* format */
    structBody << "\t" << structInfo->format << "," ;
    std::string varname = consumer.AddStruct(structBody, "micromapTriangleEXT");
    out << "VkMicromapTriangleEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDisplacementMicromapFeaturesNV(std::ostream &out, const VkPhysicalDeviceDisplacementMicromapFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDisplacementMicromapFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* displacementMicromap */
    structBody << "\t" << structInfo->displacementMicromap << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDisplacementMicromapFeaturesNV");
    out << "VkPhysicalDeviceDisplacementMicromapFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDisplacementMicromapPropertiesNV(std::ostream &out, const VkPhysicalDeviceDisplacementMicromapPropertiesNV* structInfo, Decoded_VkPhysicalDeviceDisplacementMicromapPropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxDisplacementMicromapSubdivisionLevel */
    structBody << "\t" << structInfo->maxDisplacementMicromapSubdivisionLevel << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDisplacementMicromapPropertiesNV");
    out << "VkPhysicalDeviceDisplacementMicromapPropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureTrianglesDisplacementMicromapNV(std::ostream &out, const VkAccelerationStructureTrianglesDisplacementMicromapNV* structInfo, Decoded_VkAccelerationStructureTrianglesDisplacementMicromapNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pUsageCountsArray = "NULL";
    if (structInfo->pUsageCounts != NULL) {
        pUsageCountsArray = "pUsageCounts_" + std::to_string(consumer.getNextId());
        std::string pUsageCountsNames;
        for (uint32_t idx = 0; idx < structInfo->usageCountsCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pUsageCounts + idx != NULL) {
                varName = GenerateStruct_VkMicromapUsageEXT(out,
                                                         structInfo->pUsageCounts + idx,
                                                         metainfo->pUsageCounts->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pUsageCountsNames += varName + ", ";
        }
        out << "VkMicromapUsageEXT " << pUsageCountsArray << "[] = {" << pUsageCountsNames << "};" << std::endl;
    }
    std::string ppUsageCountsArray = "NULL";
    if (structInfo->ppUsageCounts != NULL) {
        ppUsageCountsArray = "ppUsageCounts_" + std::to_string(consumer.getNextId());
        std::string ppUsageCountsNames;
        for (uint32_t idx0 = 0; idx0 < structInfo->usageCountsCount; ++idx0) {
            for (uint32_t idx1 = 0; idx1 < 1; ++idx1) {
                std::string varName = "NULL";
                varName = GenerateStruct_VkMicromapUsageEXT(out,
                                                         &(structInfo->ppUsageCounts[idx0][idx1]),
                                                         &(metainfo->ppUsageCounts->GetMetaStructPointer()[idx0][idx1]),
                                                         consumer);
                ppUsageCountsNames += varName + ", ";
            }
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* displacementBiasAndScaleFormat */
    structBody << "\t" << "VkFormat(" << structInfo->displacementBiasAndScaleFormat << ")" << "," << std::endl;
/* displacementVectorFormat */
    structBody << "\t" << "VkFormat(" << structInfo->displacementVectorFormat << ")" << "," << std::endl;
/* displacementBiasAndScaleBuffer */
    structBody << "\t" << structInfo->displacementBiasAndScaleBuffer.deviceAddress << "," << std::endl;
/* displacementBiasAndScaleStride */
    structBody << "\t" << structInfo->displacementBiasAndScaleStride << "UL" << "," << std::endl;
/* displacementVectorBuffer */
    structBody << "\t" << structInfo->displacementVectorBuffer.deviceAddress << "," << std::endl;
/* displacementVectorStride */
    structBody << "\t" << structInfo->displacementVectorStride << "UL" << "," << std::endl;
/* displacedMicromapPrimitiveFlags */
    structBody << "\t" << structInfo->displacedMicromapPrimitiveFlags.deviceAddress << "," << std::endl;
/* displacedMicromapPrimitiveFlagsStride */
    structBody << "\t" << structInfo->displacedMicromapPrimitiveFlagsStride << "UL" << "," << std::endl;
/* indexType */
    structBody << "\t" << "VkIndexType(" << structInfo->indexType << ")" << "," << std::endl;
/* indexBuffer */
    structBody << "\t" << structInfo->indexBuffer.deviceAddress << "," << std::endl;
/* indexStride */
    structBody << "\t" << structInfo->indexStride << "UL" << "," << std::endl;
/* baseTriangle */
    structBody << "\t" << structInfo->baseTriangle << "," << std::endl;
/* usageCountsCount */
    structBody << "\t" << structInfo->usageCountsCount << "," << std::endl;
/* pUsageCounts */
    structBody << "\t" << pUsageCountsArray << "," << std::endl;
/* ppUsageCounts */
    structBody << "\t" << ppUsageCountsArray << "," << std::endl;
/* micromap */
    structBody << "\t" << consumer.GetHandle(metainfo->micromap) << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureTrianglesDisplacementMicromapNV");
    out << "VkAccelerationStructureTrianglesDisplacementMicromapNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI(std::ostream &out, const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* structInfo, Decoded_VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* clustercullingShader */
    structBody << "\t" << structInfo->clustercullingShader << "," << std::endl;
/* multiviewClusterCullingShader */
    structBody << "\t" << structInfo->multiviewClusterCullingShader << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceClusterCullingShaderFeaturesHUAWEI");
    out << "VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI(std::ostream &out, const VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* structInfo, Decoded_VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxWorkGroupCount */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxWorkGroupCount[0]), 3) << "," << std::endl;
/* maxWorkGroupSize */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxWorkGroupSize[0]), 3) << "," << std::endl;
/* maxOutputClusterCount */
    structBody << "\t" << structInfo->maxOutputClusterCount << "," << std::endl;
/* indirectBufferOffsetAlignment */
    structBody << "\t" << structInfo->indirectBufferOffsetAlignment << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceClusterCullingShaderPropertiesHUAWEI");
    out << "VkPhysicalDeviceClusterCullingShaderPropertiesHUAWEI " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT(std::ostream &out, const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceBorderColorSwizzleFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* borderColorSwizzle */
    structBody << "\t" << structInfo->borderColorSwizzle << "," << std::endl;
/* borderColorSwizzleFromImage */
    structBody << "\t" << structInfo->borderColorSwizzleFromImage << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceBorderColorSwizzleFeaturesEXT");
    out << "VkPhysicalDeviceBorderColorSwizzleFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSamplerBorderColorComponentMappingCreateInfoEXT(std::ostream &out, const VkSamplerBorderColorComponentMappingCreateInfoEXT* structInfo, Decoded_VkSamplerBorderColorComponentMappingCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string componentsInfoVar = GenerateStruct_VkComponentMapping(out,
                                                                   &structInfo->components,
                                                                   metainfo->components,
                                                                   consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* components */
    structBody << "\t" << componentsInfoVar << "," << std::endl;
/* srgb */
    structBody << "\t" << structInfo->srgb << "," ;
    std::string varname = consumer.AddStruct(structBody, "samplerBorderColorComponentMappingCreateInfoEXT");
    out << "VkSamplerBorderColorComponentMappingCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT(std::ostream &out, const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pageableDeviceLocalMemory */
    structBody << "\t" << structInfo->pageableDeviceLocalMemory << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePageableDeviceLocalMemoryFeaturesEXT");
    out << "VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCorePropertiesARM(std::ostream &out, const VkPhysicalDeviceShaderCorePropertiesARM* structInfo, Decoded_VkPhysicalDeviceShaderCorePropertiesARM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pixelRate */
    structBody << "\t" << structInfo->pixelRate << "," << std::endl;
/* texelRate */
    structBody << "\t" << structInfo->texelRate << "," << std::endl;
/* fmaRate */
    structBody << "\t" << structInfo->fmaRate << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderCorePropertiesARM");
    out << "VkPhysicalDeviceShaderCorePropertiesARM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* imageSlicedViewOf3D */
    structBody << "\t" << structInfo->imageSlicedViewOf3D << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceImageSlicedViewOf3DFeaturesEXT");
    out << "VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageViewSlicedCreateInfoEXT(std::ostream &out, const VkImageViewSlicedCreateInfoEXT* structInfo, Decoded_VkImageViewSlicedCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* sliceOffset */
    structBody << "\t" << structInfo->sliceOffset << "," << std::endl;
/* sliceCount */
    structBody << "\t" << structInfo->sliceCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageViewSlicedCreateInfoEXT");
    out << "VkImageViewSlicedCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE(std::ostream &out, const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* structInfo, Decoded_VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* descriptorSetHostMapping */
    structBody << "\t" << structInfo->descriptorSetHostMapping << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDescriptorSetHostMappingFeaturesVALVE");
    out << "VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDescriptorSetBindingReferenceVALVE(std::ostream &out, const VkDescriptorSetBindingReferenceVALVE* structInfo, Decoded_VkDescriptorSetBindingReferenceVALVE* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* descriptorSetLayout */
    structBody << "\t" << consumer.GetHandle(metainfo->descriptorSetLayout) << "," << std::endl;
/* binding */
    structBody << "\t" << structInfo->binding << "," ;
    std::string varname = consumer.AddStruct(structBody, "descriptorSetBindingReferenceVALVE");
    out << "VkDescriptorSetBindingReferenceVALVE " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDescriptorSetLayoutHostMappingInfoVALVE(std::ostream &out, const VkDescriptorSetLayoutHostMappingInfoVALVE* structInfo, Decoded_VkDescriptorSetLayoutHostMappingInfoVALVE* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* descriptorOffset */
    structBody << "\t" << structInfo->descriptorOffset << "," << std::endl;
/* descriptorSize */
    structBody << "\t" << structInfo->descriptorSize << "," ;
    std::string varname = consumer.AddStruct(structBody, "descriptorSetLayoutHostMappingInfoVALVE");
    out << "VkDescriptorSetLayoutHostMappingInfoVALVE " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDepthClampZeroOneFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDepthClampZeroOneFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* depthClampZeroOne */
    structBody << "\t" << structInfo->depthClampZeroOne << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDepthClampZeroOneFeaturesEXT");
    out << "VkPhysicalDeviceDepthClampZeroOneFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT(std::ostream &out, const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* nonSeamlessCubeMap */
    structBody << "\t" << structInfo->nonSeamlessCubeMap << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceNonSeamlessCubeMapFeaturesEXT");
    out << "VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fragmentDensityMapOffset */
    structBody << "\t" << structInfo->fragmentDensityMapOffset << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFragmentDensityMapOffsetFeaturesQCOM");
    out << "VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM(std::ostream &out, const VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* structInfo, Decoded_VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string fragmentDensityOffsetGranularityInfoVar = GenerateStruct_VkExtent2D(out,
                                                                                         &structInfo->fragmentDensityOffsetGranularity,
                                                                                         metainfo->fragmentDensityOffsetGranularity,
                                                                                         consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fragmentDensityOffsetGranularity */
    structBody << "\t" << fragmentDensityOffsetGranularityInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceFragmentDensityMapOffsetPropertiesQCOM");
    out << "VkPhysicalDeviceFragmentDensityMapOffsetPropertiesQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSubpassFragmentDensityMapOffsetEndInfoQCOM(std::ostream &out, const VkSubpassFragmentDensityMapOffsetEndInfoQCOM* structInfo, Decoded_VkSubpassFragmentDensityMapOffsetEndInfoQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pFragmentDensityOffsetsArray = "NULL";
    if (structInfo->pFragmentDensityOffsets != NULL) {
        pFragmentDensityOffsetsArray = "pFragmentDensityOffsets_" + std::to_string(consumer.getNextId());
        std::string pFragmentDensityOffsetsNames;
        for (uint32_t idx = 0; idx < structInfo->fragmentDensityOffsetCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pFragmentDensityOffsets + idx != NULL) {
                varName = GenerateStruct_VkOffset2D(out,
                                                         structInfo->pFragmentDensityOffsets + idx,
                                                         metainfo->pFragmentDensityOffsets->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pFragmentDensityOffsetsNames += varName + ", ";
        }
        out << "VkOffset2D " << pFragmentDensityOffsetsArray << "[] = {" << pFragmentDensityOffsetsNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* fragmentDensityOffsetCount */
    structBody << "\t" << structInfo->fragmentDensityOffsetCount << "," << std::endl;
/* pFragmentDensityOffsets */
    structBody << "\t" << pFragmentDensityOffsetsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "subpassFragmentDensityMapOffsetEndInfoQCOM");
    out << "VkSubpassFragmentDensityMapOffsetEndInfoQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV(std::ostream &out, const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceGeneratedCompute */
    structBody << "\t" << structInfo->deviceGeneratedCompute << "," << std::endl;
/* deviceGeneratedComputePipelines */
    structBody << "\t" << structInfo->deviceGeneratedComputePipelines << "," << std::endl;
/* deviceGeneratedComputeCaptureReplay */
    structBody << "\t" << structInfo->deviceGeneratedComputeCaptureReplay << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDeviceGeneratedCommandsComputeFeaturesNV");
    out << "VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkComputePipelineIndirectBufferInfoNV(std::ostream &out, const VkComputePipelineIndirectBufferInfoNV* structInfo, Decoded_VkComputePipelineIndirectBufferInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* deviceAddress */
    structBody << "\t" << structInfo->deviceAddress << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," << std::endl;
/* pipelineDeviceAddressCaptureReplay */
    structBody << "\t" << structInfo->pipelineDeviceAddressCaptureReplay << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "computePipelineIndirectBufferInfoNV");
    out << "VkComputePipelineIndirectBufferInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineIndirectDeviceAddressInfoNV(std::ostream &out, const VkPipelineIndirectDeviceAddressInfoNV* structInfo, Decoded_VkPipelineIndirectDeviceAddressInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pipelineBindPoint */
    structBody << "\t" << "VkPipelineBindPoint(" << structInfo->pipelineBindPoint << ")" << "," << std::endl;
/* pipeline */
    structBody << "\t" << consumer.GetHandle(metainfo->pipeline) << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineIndirectDeviceAddressInfoNV");
    out << "VkPipelineIndirectDeviceAddressInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBindPipelineIndirectCommandNV(std::ostream &out, const VkBindPipelineIndirectCommandNV* structInfo, Decoded_VkBindPipelineIndirectCommandNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* pipelineAddress */
    structBody << "\t" << structInfo->pipelineAddress << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "bindPipelineIndirectCommandNV");
    out << "VkBindPipelineIndirectCommandNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceLinearColorAttachmentFeaturesNV(std::ostream &out, const VkPhysicalDeviceLinearColorAttachmentFeaturesNV* structInfo, Decoded_VkPhysicalDeviceLinearColorAttachmentFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* linearColorAttachment */
    structBody << "\t" << structInfo->linearColorAttachment << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceLinearColorAttachmentFeaturesNV");
    out << "VkPhysicalDeviceLinearColorAttachmentFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT(std::ostream &out, const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* imageCompressionControlSwapchain */
    structBody << "\t" << structInfo->imageCompressionControlSwapchain << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceImageCompressionControlSwapchainFeaturesEXT");
    out << "VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkImageViewSampleWeightCreateInfoQCOM(std::ostream &out, const VkImageViewSampleWeightCreateInfoQCOM* structInfo, Decoded_VkImageViewSampleWeightCreateInfoQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string filterCenterInfoVar = GenerateStruct_VkOffset2D(out,
                                                                     &structInfo->filterCenter,
                                                                     metainfo->filterCenter,
                                                                     consumer);
    std::string filterSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                   &structInfo->filterSize,
                                                                   metainfo->filterSize,
                                                                   consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* filterCenter */
    structBody << "\t" << filterCenterInfoVar << "," << std::endl;
/* filterSize */
    structBody << "\t" << filterSizeInfoVar << "," << std::endl;
/* numPhases */
    structBody << "\t" << structInfo->numPhases << "," ;
    std::string varname = consumer.AddStruct(structBody, "imageViewSampleWeightCreateInfoQCOM");
    out << "VkImageViewSampleWeightCreateInfoQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceImageProcessingFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceImageProcessingFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceImageProcessingFeaturesQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* textureSampleWeighted */
    structBody << "\t" << structInfo->textureSampleWeighted << "," << std::endl;
/* textureBoxFilter */
    structBody << "\t" << structInfo->textureBoxFilter << "," << std::endl;
/* textureBlockMatch */
    structBody << "\t" << structInfo->textureBlockMatch << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceImageProcessingFeaturesQCOM");
    out << "VkPhysicalDeviceImageProcessingFeaturesQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceImageProcessingPropertiesQCOM(std::ostream &out, const VkPhysicalDeviceImageProcessingPropertiesQCOM* structInfo, Decoded_VkPhysicalDeviceImageProcessingPropertiesQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string maxWeightFilterDimensionInfoVar = GenerateStruct_VkExtent2D(out,
                                                                                 &structInfo->maxWeightFilterDimension,
                                                                                 metainfo->maxWeightFilterDimension,
                                                                                 consumer);
    std::string maxBlockMatchRegionInfoVar = GenerateStruct_VkExtent2D(out,
                                                                            &structInfo->maxBlockMatchRegion,
                                                                            metainfo->maxBlockMatchRegion,
                                                                            consumer);
    std::string maxBoxFilterBlockSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                              &structInfo->maxBoxFilterBlockSize,
                                                                              metainfo->maxBoxFilterBlockSize,
                                                                              consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxWeightFilterPhases */
    structBody << "\t" << structInfo->maxWeightFilterPhases << "," << std::endl;
/* maxWeightFilterDimension */
    structBody << "\t" << maxWeightFilterDimensionInfoVar << "," << std::endl;
/* maxBlockMatchRegion */
    structBody << "\t" << maxBlockMatchRegionInfoVar << "," << std::endl;
/* maxBoxFilterBlockSize */
    structBody << "\t" << maxBoxFilterBlockSizeInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceImageProcessingPropertiesQCOM");
    out << "VkPhysicalDeviceImageProcessingPropertiesQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceNestedCommandBufferFeaturesEXT(std::ostream &out, const VkPhysicalDeviceNestedCommandBufferFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceNestedCommandBufferFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* nestedCommandBuffer */
    structBody << "\t" << structInfo->nestedCommandBuffer << "," << std::endl;
/* nestedCommandBufferRendering */
    structBody << "\t" << structInfo->nestedCommandBufferRendering << "," << std::endl;
/* nestedCommandBufferSimultaneousUse */
    structBody << "\t" << structInfo->nestedCommandBufferSimultaneousUse << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceNestedCommandBufferFeaturesEXT");
    out << "VkPhysicalDeviceNestedCommandBufferFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceNestedCommandBufferPropertiesEXT(std::ostream &out, const VkPhysicalDeviceNestedCommandBufferPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceNestedCommandBufferPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxCommandBufferNestingLevel */
    structBody << "\t" << structInfo->maxCommandBufferNestingLevel << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceNestedCommandBufferPropertiesEXT");
    out << "VkPhysicalDeviceNestedCommandBufferPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkExternalMemoryAcquireUnmodifiedEXT(std::ostream &out, const VkExternalMemoryAcquireUnmodifiedEXT* structInfo, Decoded_VkExternalMemoryAcquireUnmodifiedEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* acquireUnmodifiedMemory */
    structBody << "\t" << structInfo->acquireUnmodifiedMemory << "," ;
    std::string varname = consumer.AddStruct(structBody, "externalMemoryAcquireUnmodifiedEXT");
    out << "VkExternalMemoryAcquireUnmodifiedEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT(std::ostream &out, const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* structInfo, Decoded_VkPhysicalDeviceExtendedDynamicState3FeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* extendedDynamicState3TessellationDomainOrigin */
    structBody << "\t" << structInfo->extendedDynamicState3TessellationDomainOrigin << "," << std::endl;
/* extendedDynamicState3DepthClampEnable */
    structBody << "\t" << structInfo->extendedDynamicState3DepthClampEnable << "," << std::endl;
/* extendedDynamicState3PolygonMode */
    structBody << "\t" << structInfo->extendedDynamicState3PolygonMode << "," << std::endl;
/* extendedDynamicState3RasterizationSamples */
    structBody << "\t" << structInfo->extendedDynamicState3RasterizationSamples << "," << std::endl;
/* extendedDynamicState3SampleMask */
    structBody << "\t" << structInfo->extendedDynamicState3SampleMask << "," << std::endl;
/* extendedDynamicState3AlphaToCoverageEnable */
    structBody << "\t" << structInfo->extendedDynamicState3AlphaToCoverageEnable << "," << std::endl;
/* extendedDynamicState3AlphaToOneEnable */
    structBody << "\t" << structInfo->extendedDynamicState3AlphaToOneEnable << "," << std::endl;
/* extendedDynamicState3LogicOpEnable */
    structBody << "\t" << structInfo->extendedDynamicState3LogicOpEnable << "," << std::endl;
/* extendedDynamicState3ColorBlendEnable */
    structBody << "\t" << structInfo->extendedDynamicState3ColorBlendEnable << "," << std::endl;
/* extendedDynamicState3ColorBlendEquation */
    structBody << "\t" << structInfo->extendedDynamicState3ColorBlendEquation << "," << std::endl;
/* extendedDynamicState3ColorWriteMask */
    structBody << "\t" << structInfo->extendedDynamicState3ColorWriteMask << "," << std::endl;
/* extendedDynamicState3RasterizationStream */
    structBody << "\t" << structInfo->extendedDynamicState3RasterizationStream << "," << std::endl;
/* extendedDynamicState3ConservativeRasterizationMode */
    structBody << "\t" << structInfo->extendedDynamicState3ConservativeRasterizationMode << "," << std::endl;
/* extendedDynamicState3ExtraPrimitiveOverestimationSize */
    structBody << "\t" << structInfo->extendedDynamicState3ExtraPrimitiveOverestimationSize << "," << std::endl;
/* extendedDynamicState3DepthClipEnable */
    structBody << "\t" << structInfo->extendedDynamicState3DepthClipEnable << "," << std::endl;
/* extendedDynamicState3SampleLocationsEnable */
    structBody << "\t" << structInfo->extendedDynamicState3SampleLocationsEnable << "," << std::endl;
/* extendedDynamicState3ColorBlendAdvanced */
    structBody << "\t" << structInfo->extendedDynamicState3ColorBlendAdvanced << "," << std::endl;
/* extendedDynamicState3ProvokingVertexMode */
    structBody << "\t" << structInfo->extendedDynamicState3ProvokingVertexMode << "," << std::endl;
/* extendedDynamicState3LineRasterizationMode */
    structBody << "\t" << structInfo->extendedDynamicState3LineRasterizationMode << "," << std::endl;
/* extendedDynamicState3LineStippleEnable */
    structBody << "\t" << structInfo->extendedDynamicState3LineStippleEnable << "," << std::endl;
/* extendedDynamicState3DepthClipNegativeOneToOne */
    structBody << "\t" << structInfo->extendedDynamicState3DepthClipNegativeOneToOne << "," << std::endl;
/* extendedDynamicState3ViewportWScalingEnable */
    structBody << "\t" << structInfo->extendedDynamicState3ViewportWScalingEnable << "," << std::endl;
/* extendedDynamicState3ViewportSwizzle */
    structBody << "\t" << structInfo->extendedDynamicState3ViewportSwizzle << "," << std::endl;
/* extendedDynamicState3CoverageToColorEnable */
    structBody << "\t" << structInfo->extendedDynamicState3CoverageToColorEnable << "," << std::endl;
/* extendedDynamicState3CoverageToColorLocation */
    structBody << "\t" << structInfo->extendedDynamicState3CoverageToColorLocation << "," << std::endl;
/* extendedDynamicState3CoverageModulationMode */
    structBody << "\t" << structInfo->extendedDynamicState3CoverageModulationMode << "," << std::endl;
/* extendedDynamicState3CoverageModulationTableEnable */
    structBody << "\t" << structInfo->extendedDynamicState3CoverageModulationTableEnable << "," << std::endl;
/* extendedDynamicState3CoverageModulationTable */
    structBody << "\t" << structInfo->extendedDynamicState3CoverageModulationTable << "," << std::endl;
/* extendedDynamicState3CoverageReductionMode */
    structBody << "\t" << structInfo->extendedDynamicState3CoverageReductionMode << "," << std::endl;
/* extendedDynamicState3RepresentativeFragmentTestEnable */
    structBody << "\t" << structInfo->extendedDynamicState3RepresentativeFragmentTestEnable << "," << std::endl;
/* extendedDynamicState3ShadingRateImageEnable */
    structBody << "\t" << structInfo->extendedDynamicState3ShadingRateImageEnable << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExtendedDynamicState3FeaturesEXT");
    out << "VkPhysicalDeviceExtendedDynamicState3FeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT(std::ostream &out, const VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* structInfo, Decoded_VkPhysicalDeviceExtendedDynamicState3PropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* dynamicPrimitiveTopologyUnrestricted */
    structBody << "\t" << structInfo->dynamicPrimitiveTopologyUnrestricted << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExtendedDynamicState3PropertiesEXT");
    out << "VkPhysicalDeviceExtendedDynamicState3PropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkColorBlendEquationEXT(std::ostream &out, const VkColorBlendEquationEXT* structInfo, Decoded_VkColorBlendEquationEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* srcColorBlendFactor */
    structBody << "\t" << "VkBlendFactor(" << structInfo->srcColorBlendFactor << ")" << "," << std::endl;
/* dstColorBlendFactor */
    structBody << "\t" << "VkBlendFactor(" << structInfo->dstColorBlendFactor << ")" << "," << std::endl;
/* colorBlendOp */
    structBody << "\t" << "VkBlendOp(" << structInfo->colorBlendOp << ")" << "," << std::endl;
/* srcAlphaBlendFactor */
    structBody << "\t" << "VkBlendFactor(" << structInfo->srcAlphaBlendFactor << ")" << "," << std::endl;
/* dstAlphaBlendFactor */
    structBody << "\t" << "VkBlendFactor(" << structInfo->dstAlphaBlendFactor << ")" << "," << std::endl;
/* alphaBlendOp */
    structBody << "\t" << "VkBlendOp(" << structInfo->alphaBlendOp << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "colorBlendEquationEXT");
    out << "VkColorBlendEquationEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkColorBlendAdvancedEXT(std::ostream &out, const VkColorBlendAdvancedEXT* structInfo, Decoded_VkColorBlendAdvancedEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* advancedBlendOp */
    structBody << "\t" << "VkBlendOp(" << structInfo->advancedBlendOp << ")" << "," << std::endl;
/* srcPremultiplied */
    structBody << "\t" << structInfo->srcPremultiplied << "," << std::endl;
/* dstPremultiplied */
    structBody << "\t" << structInfo->dstPremultiplied << "," << std::endl;
/* blendOverlap */
    structBody << "\t" << "VkBlendOverlapEXT(" << structInfo->blendOverlap << ")" << "," << std::endl;
/* clampResults */
    structBody << "\t" << structInfo->clampResults << "," ;
    std::string varname = consumer.AddStruct(structBody, "colorBlendAdvancedEXT");
    out << "VkColorBlendAdvancedEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT(std::ostream &out, const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* subpassMergeFeedback */
    structBody << "\t" << structInfo->subpassMergeFeedback << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceSubpassMergeFeedbackFeaturesEXT");
    out << "VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderPassCreationControlEXT(std::ostream &out, const VkRenderPassCreationControlEXT* structInfo, Decoded_VkRenderPassCreationControlEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* disallowMerging */
    structBody << "\t" << structInfo->disallowMerging << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderPassCreationControlEXT");
    out << "VkRenderPassCreationControlEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderPassCreationFeedbackInfoEXT(std::ostream &out, const VkRenderPassCreationFeedbackInfoEXT* structInfo, Decoded_VkRenderPassCreationFeedbackInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* postMergeSubpassCount */
    structBody << "\t" << structInfo->postMergeSubpassCount << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderPassCreationFeedbackInfoEXT");
    out << "VkRenderPassCreationFeedbackInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderPassCreationFeedbackCreateInfoEXT(std::ostream &out, const VkRenderPassCreationFeedbackCreateInfoEXT* structInfo, Decoded_VkRenderPassCreationFeedbackCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pRenderPassFeedback */
    out << "// TODO: Support pRenderPassFeedback (output?) argument." << std::endl;
    std::string varname = consumer.AddStruct(structBody, "renderPassCreationFeedbackCreateInfoEXT");
    out << "VkRenderPassCreationFeedbackCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderPassSubpassFeedbackInfoEXT(std::ostream &out, const VkRenderPassSubpassFeedbackInfoEXT* structInfo, Decoded_VkRenderPassSubpassFeedbackInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* subpassMergeStatus */
    structBody << "\t" << "VkSubpassMergeStatusEXT(" << structInfo->subpassMergeStatus << ")" << "," << std::endl;
/* description */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->description) << "," << std::endl;
/* postMergeIndex */
    structBody << "\t" << structInfo->postMergeIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "renderPassSubpassFeedbackInfoEXT");
    out << "VkRenderPassSubpassFeedbackInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRenderPassSubpassFeedbackCreateInfoEXT(std::ostream &out, const VkRenderPassSubpassFeedbackCreateInfoEXT* structInfo, Decoded_VkRenderPassSubpassFeedbackCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pSubpassFeedback */
    out << "// TODO: Support pSubpassFeedback (output?) argument." << std::endl;
    std::string varname = consumer.AddStruct(structBody, "renderPassSubpassFeedbackCreateInfoEXT");
    out << "VkRenderPassSubpassFeedbackCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDirectDriverLoadingInfoLUNARG(std::ostream &out, const VkDirectDriverLoadingInfoLUNARG* structInfo, Decoded_VkDirectDriverLoadingInfoLUNARG* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkDirectDriverLoadingFlagsLUNARG(" << structInfo->flags << ")" << "," << std::endl;
/* pfnGetInstanceProcAddr */
    structBody << "\t" << structInfo->pfnGetInstanceProcAddr << "," ;
    std::string varname = consumer.AddStruct(structBody, "directDriverLoadingInfoLUNARG");
    out << "VkDirectDriverLoadingInfoLUNARG " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDirectDriverLoadingListLUNARG(std::ostream &out, const VkDirectDriverLoadingListLUNARG* structInfo, Decoded_VkDirectDriverLoadingListLUNARG* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pDriversArray = "NULL";
    if (structInfo->pDrivers != NULL) {
        pDriversArray = "pDrivers_" + std::to_string(consumer.getNextId());
        std::string pDriversNames;
        for (uint32_t idx = 0; idx < structInfo->driverCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pDrivers + idx != NULL) {
                varName = GenerateStruct_VkDirectDriverLoadingInfoLUNARG(out,
                                                         structInfo->pDrivers + idx,
                                                         metainfo->pDrivers->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pDriversNames += varName + ", ";
        }
        out << "VkDirectDriverLoadingInfoLUNARG " << pDriversArray << "[] = {" << pDriversNames << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* mode */
    structBody << "\t" << "VkDirectDriverLoadingModeLUNARG(" << structInfo->mode << ")" << "," << std::endl;
/* driverCount */
    structBody << "\t" << structInfo->driverCount << "," << std::endl;
/* pDrivers */
    structBody << "\t" << pDriversArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "directDriverLoadingListLUNARG");
    out << "VkDirectDriverLoadingListLUNARG " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderModuleIdentifier */
    structBody << "\t" << structInfo->shaderModuleIdentifier << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderModuleIdentifierFeaturesEXT");
    out << "VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT(std::ostream &out, const VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderModuleIdentifierAlgorithmUUID */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->shaderModuleIdentifierAlgorithmUUID[0]), VK_UUID_SIZE) << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderModuleIdentifierPropertiesEXT");
    out << "VkPhysicalDeviceShaderModuleIdentifierPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPipelineShaderStageModuleIdentifierCreateInfoEXT(std::ostream &out, const VkPipelineShaderStageModuleIdentifierCreateInfoEXT* structInfo, Decoded_VkPipelineShaderStageModuleIdentifierCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pIdentifierArray = "NULL";
    if (structInfo->pIdentifier != NULL) {
        std::string pIdentifierValues;
        for (uint32_t idx0 = 0; idx0 < structInfo->identifierSize; ++idx0) {
            pIdentifierValues += std::to_string(structInfo->pIdentifier[idx0]) + ", ";
        }
        pIdentifierArray = "pIdentifier_" + std::to_string(consumer.getNextId());
        out << "uint8_t " << pIdentifierArray << "[] = {" << pIdentifierValues << "};" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* identifierSize */
    structBody << "\t" << structInfo->identifierSize << "," << std::endl;
/* pIdentifier */
    structBody << "\t" << pIdentifierArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "pipelineShaderStageModuleIdentifierCreateInfoEXT");
    out << "VkPipelineShaderStageModuleIdentifierCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkShaderModuleIdentifierEXT(std::ostream &out, const VkShaderModuleIdentifierEXT* structInfo, Decoded_VkShaderModuleIdentifierEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* identifierSize */
    structBody << "\t" << structInfo->identifierSize << "," << std::endl;
/* identifier */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->identifier[0]), VK_MAX_SHADER_MODULE_IDENTIFIER_SIZE_EXT) << "," ;
    std::string varname = consumer.AddStruct(structBody, "shaderModuleIdentifierEXT");
    out << "VkShaderModuleIdentifierEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceOpticalFlowFeaturesNV(std::ostream &out, const VkPhysicalDeviceOpticalFlowFeaturesNV* structInfo, Decoded_VkPhysicalDeviceOpticalFlowFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* opticalFlow */
    structBody << "\t" << structInfo->opticalFlow << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceOpticalFlowFeaturesNV");
    out << "VkPhysicalDeviceOpticalFlowFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceOpticalFlowPropertiesNV(std::ostream &out, const VkPhysicalDeviceOpticalFlowPropertiesNV* structInfo, Decoded_VkPhysicalDeviceOpticalFlowPropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* supportedOutputGridSizes */
    structBody << "\t" << "VkOpticalFlowGridSizeFlagsNV(" << structInfo->supportedOutputGridSizes << ")" << "," << std::endl;
/* supportedHintGridSizes */
    structBody << "\t" << "VkOpticalFlowGridSizeFlagsNV(" << structInfo->supportedHintGridSizes << ")" << "," << std::endl;
/* hintSupported */
    structBody << "\t" << structInfo->hintSupported << "," << std::endl;
/* costSupported */
    structBody << "\t" << structInfo->costSupported << "," << std::endl;
/* bidirectionalFlowSupported */
    structBody << "\t" << structInfo->bidirectionalFlowSupported << "," << std::endl;
/* globalFlowSupported */
    structBody << "\t" << structInfo->globalFlowSupported << "," << std::endl;
/* minWidth */
    structBody << "\t" << structInfo->minWidth << "," << std::endl;
/* minHeight */
    structBody << "\t" << structInfo->minHeight << "," << std::endl;
/* maxWidth */
    structBody << "\t" << structInfo->maxWidth << "," << std::endl;
/* maxHeight */
    structBody << "\t" << structInfo->maxHeight << "," << std::endl;
/* maxNumRegionsOfInterest */
    structBody << "\t" << structInfo->maxNumRegionsOfInterest << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceOpticalFlowPropertiesNV");
    out << "VkPhysicalDeviceOpticalFlowPropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkOpticalFlowImageFormatInfoNV(std::ostream &out, const VkOpticalFlowImageFormatInfoNV* structInfo, Decoded_VkOpticalFlowImageFormatInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* usage */
    structBody << "\t" << "VkOpticalFlowUsageFlagsNV(" << structInfo->usage << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "opticalFlowImageFormatInfoNV");
    out << "VkOpticalFlowImageFormatInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkOpticalFlowImageFormatPropertiesNV(std::ostream &out, const VkOpticalFlowImageFormatPropertiesNV* structInfo, Decoded_VkOpticalFlowImageFormatPropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* format */
    structBody << "\t" << "VkFormat(" << structInfo->format << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "opticalFlowImageFormatPropertiesNV");
    out << "VkOpticalFlowImageFormatPropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkOpticalFlowSessionCreateInfoNV(std::ostream &out, const VkOpticalFlowSessionCreateInfoNV* structInfo, Decoded_VkOpticalFlowSessionCreateInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* width */
    structBody << "\t" << structInfo->width << "," << std::endl;
/* height */
    structBody << "\t" << structInfo->height << "," << std::endl;
/* imageFormat */
    structBody << "\t" << "VkFormat(" << structInfo->imageFormat << ")" << "," << std::endl;
/* flowVectorFormat */
    structBody << "\t" << "VkFormat(" << structInfo->flowVectorFormat << ")" << "," << std::endl;
/* costFormat */
    structBody << "\t" << "VkFormat(" << structInfo->costFormat << ")" << "," << std::endl;
/* outputGridSize */
    structBody << "\t" << "VkOpticalFlowGridSizeFlagsNV(" << structInfo->outputGridSize << ")" << "," << std::endl;
/* hintGridSize */
    structBody << "\t" << "VkOpticalFlowGridSizeFlagsNV(" << structInfo->hintGridSize << ")" << "," << std::endl;
/* performanceLevel */
    structBody << "\t" << "VkOpticalFlowPerformanceLevelNV(" << structInfo->performanceLevel << ")" << "," << std::endl;
/* flags */
    structBody << "\t" << "VkOpticalFlowSessionCreateFlagsNV(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "opticalFlowSessionCreateInfoNV");
    out << "VkOpticalFlowSessionCreateInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkOpticalFlowSessionCreatePrivateDataInfoNV(std::ostream &out, const VkOpticalFlowSessionCreatePrivateDataInfoNV* structInfo, Decoded_VkOpticalFlowSessionCreatePrivateDataInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* id */
    structBody << "\t" << structInfo->id << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "," << std::endl;
/* pPrivateData */
    structBody << "\t" << structInfo->pPrivateData << "," ;
    std::string varname = consumer.AddStruct(structBody, "opticalFlowSessionCreatePrivateDataInfoNV");
    out << "VkOpticalFlowSessionCreatePrivateDataInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkOpticalFlowExecuteInfoNV(std::ostream &out, const VkOpticalFlowExecuteInfoNV* structInfo, Decoded_VkOpticalFlowExecuteInfoNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pRegionsArray = "NULL";
    if (structInfo->pRegions != NULL) {
        pRegionsArray = "pRegions_" + std::to_string(consumer.getNextId());
        out << "VkRect2D " << pRegionsArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pRegions, structInfo->regionCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkOpticalFlowExecuteFlagsNV(" << structInfo->flags << ")" << "," << std::endl;
/* regionCount */
    structBody << "\t" << structInfo->regionCount << "," << std::endl;
/* pRegions */
    structBody << "\t" << pRegionsArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "opticalFlowExecuteInfoNV");
    out << "VkOpticalFlowExecuteInfoNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceLegacyDitheringFeaturesEXT(std::ostream &out, const VkPhysicalDeviceLegacyDitheringFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceLegacyDitheringFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* legacyDithering */
    structBody << "\t" << structInfo->legacyDithering << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceLegacyDitheringFeaturesEXT");
    out << "VkPhysicalDeviceLegacyDitheringFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePipelineProtectedAccessFeaturesEXT(std::ostream &out, const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePipelineProtectedAccessFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pipelineProtectedAccess */
    structBody << "\t" << structInfo->pipelineProtectedAccess << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePipelineProtectedAccessFeaturesEXT");
    out << "VkPhysicalDevicePipelineProtectedAccessFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID(std::ostream &out, const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* structInfo, Decoded_VkPhysicalDeviceExternalFormatResolveFeaturesANDROID* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* externalFormatResolve */
    structBody << "\t" << structInfo->externalFormatResolve << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExternalFormatResolveFeaturesANDROID");
    out << "VkPhysicalDeviceExternalFormatResolveFeaturesANDROID " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID(std::ostream &out, const VkPhysicalDeviceExternalFormatResolvePropertiesANDROID* structInfo, Decoded_VkPhysicalDeviceExternalFormatResolvePropertiesANDROID* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* nullColorAttachmentWithExternalFormatResolve */
    structBody << "\t" << structInfo->nullColorAttachmentWithExternalFormatResolve << "," << std::endl;
/* externalFormatResolveChromaOffsetX */
    structBody << "\t" << "VkChromaLocation(" << structInfo->externalFormatResolveChromaOffsetX << ")" << "," << std::endl;
/* externalFormatResolveChromaOffsetY */
    structBody << "\t" << "VkChromaLocation(" << structInfo->externalFormatResolveChromaOffsetY << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExternalFormatResolvePropertiesANDROID");
    out << "VkPhysicalDeviceExternalFormatResolvePropertiesANDROID " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAndroidHardwareBufferFormatResolvePropertiesANDROID(std::ostream &out, const VkAndroidHardwareBufferFormatResolvePropertiesANDROID* structInfo, Decoded_VkAndroidHardwareBufferFormatResolvePropertiesANDROID* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* colorAttachmentFormat */
    structBody << "\t" << "VkFormat(" << structInfo->colorAttachmentFormat << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "androidHardwareBufferFormatResolvePropertiesANDROID");
    out << "VkAndroidHardwareBufferFormatResolvePropertiesANDROID " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderObjectFeaturesEXT(std::ostream &out, const VkPhysicalDeviceShaderObjectFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceShaderObjectFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderObject */
    structBody << "\t" << structInfo->shaderObject << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderObjectFeaturesEXT");
    out << "VkPhysicalDeviceShaderObjectFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderObjectPropertiesEXT(std::ostream &out, const VkPhysicalDeviceShaderObjectPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceShaderObjectPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderBinaryUUID */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint8_t*>(&structInfo->shaderBinaryUUID[0]), VK_UUID_SIZE) << "," << std::endl;
/* shaderBinaryVersion */
    structBody << "\t" << structInfo->shaderBinaryVersion << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderObjectPropertiesEXT");
    out << "VkPhysicalDeviceShaderObjectPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkShaderCreateInfoEXT(std::ostream &out, const VkShaderCreateInfoEXT* structInfo, Decoded_VkShaderCreateInfoEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pCodeArray = "NULL";
    if (structInfo->pCode != NULL) {
        std::string pCodeValues;
        for (uint32_t idx0 = 0; idx0 < structInfo->codeSize; ++idx0) {
            pCodeValues += std::to_string(reinterpret_cast<const uint8_t*>(structInfo->pCode)[idx0]) + ", ";
        }
        pCodeArray = "pCode_" + std::to_string(consumer.getNextId());
        out << "uint8_t " << pCodeArray << "[] = {" << pCodeValues << "};" << std::endl;
    }
    std::string pSetLayoutsArray = "NULL";
    if (metainfo->pSetLayouts.GetPointer() != NULL && structInfo->setLayoutCount > 0) {
        pSetLayoutsArray = "pSetLayoutsArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT));
        std::string pSetLayoutsValues = toStringJoin(metainfo->pSetLayouts.GetPointer(),
                                                     metainfo->pSetLayouts.GetPointer() + structInfo->setLayoutCount,
                                                     [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                     ", ");
        if (structInfo->setLayoutCount == 1) {
            pSetLayoutsArray = "&" + pSetLayoutsValues;
        } else if (structInfo->setLayoutCount > 1) {
            out << "VkDescriptorSetLayout " << pSetLayoutsArray << "[] = {" << pSetLayoutsValues << "};" << std::endl;
        }
    }
    std::string pPushConstantRangesArray = "NULL";
    if (structInfo->pPushConstantRanges != NULL) {
        pPushConstantRangesArray = "pPushConstantRanges_" + std::to_string(consumer.getNextId());
        std::string pPushConstantRangesNames;
        for (uint32_t idx = 0; idx < structInfo->pushConstantRangeCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pPushConstantRanges + idx != NULL) {
                varName = GenerateStruct_VkPushConstantRange(out,
                                                         structInfo->pPushConstantRanges + idx,
                                                         metainfo->pPushConstantRanges->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pPushConstantRangesNames += varName + ", ";
        }
        out << "VkPushConstantRange " << pPushConstantRangesArray << "[] = {" << pPushConstantRangesNames << "};" << std::endl;
    }
    std::string pSpecializationInfoStruct = "NULL";
    if (structInfo->pSpecializationInfo != NULL) {
        pSpecializationInfoStruct = GenerateStruct_VkSpecializationInfo(out,
                                                                   structInfo->pSpecializationInfo,
                                                                   metainfo->pSpecializationInfo->GetMetaStructPointer(),
                                                                   consumer);
        pSpecializationInfoStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkShaderCreateFlagsEXT(" << structInfo->flags << ")" << "," << std::endl;
/* stage */
    structBody << "\t" << "VkShaderStageFlagBits(" << structInfo->stage << ")" << "," << std::endl;
/* nextStage */
    structBody << "\t" << "VkShaderStageFlags(" << structInfo->nextStage << ")" << "," << std::endl;
/* codeType */
    structBody << "\t" << "VkShaderCodeTypeEXT(" << structInfo->codeType << ")" << "," << std::endl;
/* codeSize */
    structBody << "\t" << structInfo->codeSize << "," << std::endl;
/* pCode */
    structBody << "\t" << pCodeArray << "," << std::endl;
/* pName */
    structBody << "\t" << VulkanCppConsumerBase::toEscape(structInfo->pName) << "," << std::endl;
/* setLayoutCount */
    structBody << "\t" << structInfo->setLayoutCount << "," << std::endl;
/* pSetLayouts */
    structBody << "\t" << pSetLayoutsArray << "," << std::endl;
/* pushConstantRangeCount */
    structBody << "\t" << structInfo->pushConstantRangeCount << "," << std::endl;
/* pPushConstantRanges */
    structBody << "\t" << pPushConstantRangesArray << "," << std::endl;
/* pSpecializationInfo */
    structBody << "\t" << pSpecializationInfoStruct << "," ;
    std::string varname = consumer.AddStruct(structBody, "shaderCreateInfoEXT");
    out << "VkShaderCreateInfoEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceTilePropertiesFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceTilePropertiesFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceTilePropertiesFeaturesQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* tileProperties */
    structBody << "\t" << structInfo->tileProperties << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceTilePropertiesFeaturesQCOM");
    out << "VkPhysicalDeviceTilePropertiesFeaturesQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkTilePropertiesQCOM(std::ostream &out, const VkTilePropertiesQCOM* structInfo, Decoded_VkTilePropertiesQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string tileSizeInfoVar = GenerateStruct_VkExtent3D(out,
                                                                 &structInfo->tileSize,
                                                                 metainfo->tileSize,
                                                                 consumer);
    std::string apronSizeInfoVar = GenerateStruct_VkExtent2D(out,
                                                                  &structInfo->apronSize,
                                                                  metainfo->apronSize,
                                                                  consumer);
    std::string originInfoVar = GenerateStruct_VkOffset2D(out,
                                                               &structInfo->origin,
                                                               metainfo->origin,
                                                               consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* tileSize */
    structBody << "\t" << tileSizeInfoVar << "," << std::endl;
/* apronSize */
    structBody << "\t" << apronSizeInfoVar << "," << std::endl;
/* origin */
    structBody << "\t" << originInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "tilePropertiesQCOM");
    out << "VkTilePropertiesQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceAmigoProfilingFeaturesSEC(std::ostream &out, const VkPhysicalDeviceAmigoProfilingFeaturesSEC* structInfo, Decoded_VkPhysicalDeviceAmigoProfilingFeaturesSEC* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* amigoProfiling */
    structBody << "\t" << structInfo->amigoProfiling << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceAmigoProfilingFeaturesSEC");
    out << "VkPhysicalDeviceAmigoProfilingFeaturesSEC " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAmigoProfilingSubmitInfoSEC(std::ostream &out, const VkAmigoProfilingSubmitInfoSEC* structInfo, Decoded_VkAmigoProfilingSubmitInfoSEC* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* firstDrawTimestamp */
    structBody << "\t" << structInfo->firstDrawTimestamp << "UL" << "," << std::endl;
/* swapBufferTimestamp */
    structBody << "\t" << structInfo->swapBufferTimestamp << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "amigoProfilingSubmitInfoSEC");
    out << "VkAmigoProfilingSubmitInfoSEC " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* multiviewPerViewViewports */
    structBody << "\t" << structInfo->multiviewPerViewViewports << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMultiviewPerViewViewportsFeaturesQCOM");
    out << "VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV(std::ostream &out, const VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* structInfo, Decoded_VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* rayTracingInvocationReorderReorderingHint */
    structBody << "\t" << "VkRayTracingInvocationReorderModeNV(" << structInfo->rayTracingInvocationReorderReorderingHint << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceRayTracingInvocationReorderPropertiesNV");
    out << "VkPhysicalDeviceRayTracingInvocationReorderPropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV(std::ostream &out, const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* structInfo, Decoded_VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* rayTracingInvocationReorder */
    structBody << "\t" << structInfo->rayTracingInvocationReorder << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceRayTracingInvocationReorderFeaturesNV");
    out << "VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV(std::ostream &out, const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* structInfo, Decoded_VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* extendedSparseAddressSpace */
    structBody << "\t" << structInfo->extendedSparseAddressSpace << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExtendedSparseAddressSpaceFeaturesNV");
    out << "VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV(std::ostream &out, const VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* structInfo, Decoded_VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* extendedSparseAddressSpaceSize */
    structBody << "\t" << structInfo->extendedSparseAddressSpaceSize << "UL" << "," << std::endl;
/* extendedSparseImageUsageFlags */
    structBody << "\t" << "VkImageUsageFlags(" << structInfo->extendedSparseImageUsageFlags << ")" << "," << std::endl;
/* extendedSparseBufferUsageFlags */
    structBody << "\t" << "VkBufferUsageFlags(" << structInfo->extendedSparseBufferUsageFlags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceExtendedSparseAddressSpacePropertiesNV");
    out << "VkPhysicalDeviceExtendedSparseAddressSpacePropertiesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM(std::ostream &out, const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* structInfo, Decoded_VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderCoreBuiltins */
    structBody << "\t" << structInfo->shaderCoreBuiltins << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderCoreBuiltinsFeaturesARM");
    out << "VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM(std::ostream &out, const VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* structInfo, Decoded_VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderCoreMask */
    structBody << "\t" << structInfo->shaderCoreMask << "UL" << "," << std::endl;
/* shaderCoreCount */
    structBody << "\t" << structInfo->shaderCoreCount << "," << std::endl;
/* shaderWarpsPerCore */
    structBody << "\t" << structInfo->shaderWarpsPerCore << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceShaderCoreBuiltinsPropertiesARM");
    out << "VkPhysicalDeviceShaderCoreBuiltinsPropertiesARM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT(std::ostream &out, const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* structInfo, Decoded_VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pipelineLibraryGroupHandles */
    structBody << "\t" << structInfo->pipelineLibraryGroupHandles << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDevicePipelineLibraryGroupHandlesFeaturesEXT");
    out << "VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT(std::ostream &out, const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* dynamicRenderingUnusedAttachments */
    structBody << "\t" << structInfo->dynamicRenderingUnusedAttachments << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT");
    out << "VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* multiviewPerViewRenderAreas */
    structBody << "\t" << structInfo->multiviewPerViewRenderAreas << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM");
    out << "VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM(std::ostream &out, const VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* structInfo, Decoded_VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pPerViewRenderAreasArray = "NULL";
    if (structInfo->pPerViewRenderAreas != NULL) {
        pPerViewRenderAreasArray = "pPerViewRenderAreas_" + std::to_string(consumer.getNextId());
        out << "VkRect2D " << pPerViewRenderAreasArray << "[] = " << VulkanCppConsumerBase::BuildValue(structInfo->pPerViewRenderAreas, structInfo->perViewRenderAreaCount) << ";" << std::endl;
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* perViewRenderAreaCount */
    structBody << "\t" << structInfo->perViewRenderAreaCount << "," << std::endl;
/* pPerViewRenderAreas */
    structBody << "\t" << pPerViewRenderAreasArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "multiviewPerViewRenderAreasRenderPassBeginInfoQCOM");
    out << "VkMultiviewPerViewRenderAreasRenderPassBeginInfoQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceImageProcessing2FeaturesQCOM(std::ostream &out, const VkPhysicalDeviceImageProcessing2FeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceImageProcessing2FeaturesQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* textureBlockMatch2 */
    structBody << "\t" << structInfo->textureBlockMatch2 << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceImageProcessing2FeaturesQCOM");
    out << "VkPhysicalDeviceImageProcessing2FeaturesQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceImageProcessing2PropertiesQCOM(std::ostream &out, const VkPhysicalDeviceImageProcessing2PropertiesQCOM* structInfo, Decoded_VkPhysicalDeviceImageProcessing2PropertiesQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string maxBlockMatchWindowInfoVar = GenerateStruct_VkExtent2D(out,
                                                                            &structInfo->maxBlockMatchWindow,
                                                                            metainfo->maxBlockMatchWindow,
                                                                            consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxBlockMatchWindow */
    structBody << "\t" << maxBlockMatchWindowInfoVar << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceImageProcessing2PropertiesQCOM");
    out << "VkPhysicalDeviceImageProcessing2PropertiesQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSamplerBlockMatchWindowCreateInfoQCOM(std::ostream &out, const VkSamplerBlockMatchWindowCreateInfoQCOM* structInfo, Decoded_VkSamplerBlockMatchWindowCreateInfoQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string windowExtentInfoVar = GenerateStruct_VkExtent2D(out,
                                                                     &structInfo->windowExtent,
                                                                     metainfo->windowExtent,
                                                                     consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* windowExtent */
    structBody << "\t" << windowExtentInfoVar << "," << std::endl;
/* windowCompareMode */
    structBody << "\t" << "VkBlockMatchWindowCompareModeQCOM(" << structInfo->windowCompareMode << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "samplerBlockMatchWindowCreateInfoQCOM");
    out << "VkSamplerBlockMatchWindowCreateInfoQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceCubicWeightsFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceCubicWeightsFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceCubicWeightsFeaturesQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* selectableCubicWeights */
    structBody << "\t" << structInfo->selectableCubicWeights << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceCubicWeightsFeaturesQCOM");
    out << "VkPhysicalDeviceCubicWeightsFeaturesQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSamplerCubicWeightsCreateInfoQCOM(std::ostream &out, const VkSamplerCubicWeightsCreateInfoQCOM* structInfo, Decoded_VkSamplerCubicWeightsCreateInfoQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* cubicWeights */
    structBody << "\t" << "VkCubicFilterWeightsQCOM(" << structInfo->cubicWeights << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "samplerCubicWeightsCreateInfoQCOM");
    out << "VkSamplerCubicWeightsCreateInfoQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkBlitImageCubicWeightsInfoQCOM(std::ostream &out, const VkBlitImageCubicWeightsInfoQCOM* structInfo, Decoded_VkBlitImageCubicWeightsInfoQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* cubicWeights */
    structBody << "\t" << "VkCubicFilterWeightsQCOM(" << structInfo->cubicWeights << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "blitImageCubicWeightsInfoQCOM");
    out << "VkBlitImageCubicWeightsInfoQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceYcbcrDegammaFeaturesQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* ycbcrDegamma */
    structBody << "\t" << structInfo->ycbcrDegamma << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceYcbcrDegammaFeaturesQCOM");
    out << "VkPhysicalDeviceYcbcrDegammaFeaturesQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM(std::ostream &out, const VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* structInfo, Decoded_VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* enableYDegamma */
    structBody << "\t" << structInfo->enableYDegamma << "," << std::endl;
/* enableCbCrDegamma */
    structBody << "\t" << structInfo->enableCbCrDegamma << "," ;
    std::string varname = consumer.AddStruct(structBody, "samplerYcbcrConversionYcbcrDegammaCreateInfoQCOM");
    out << "VkSamplerYcbcrConversionYcbcrDegammaCreateInfoQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceCubicClampFeaturesQCOM(std::ostream &out, const VkPhysicalDeviceCubicClampFeaturesQCOM* structInfo, Decoded_VkPhysicalDeviceCubicClampFeaturesQCOM* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* cubicRangeClamp */
    structBody << "\t" << structInfo->cubicRangeClamp << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceCubicClampFeaturesQCOM");
    out << "VkPhysicalDeviceCubicClampFeaturesQCOM " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT(std::ostream &out, const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* attachmentFeedbackLoopDynamicState */
    structBody << "\t" << structInfo->attachmentFeedbackLoopDynamicState << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT");
    out << "VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceLayeredDriverPropertiesMSFT(std::ostream &out, const VkPhysicalDeviceLayeredDriverPropertiesMSFT* structInfo, Decoded_VkPhysicalDeviceLayeredDriverPropertiesMSFT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* underlyingAPI */
    structBody << "\t" << "VkLayeredDriverUnderlyingApiMSFT(" << structInfo->underlyingAPI << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceLayeredDriverPropertiesMSFT");
    out << "VkPhysicalDeviceLayeredDriverPropertiesMSFT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV(std::ostream &out, const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* structInfo, Decoded_VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* descriptorPoolOverallocation */
    structBody << "\t" << structInfo->descriptorPoolOverallocation << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceDescriptorPoolOverallocationFeaturesNV");
    out << "VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureBuildRangeInfoKHR(std::ostream &out, const VkAccelerationStructureBuildRangeInfoKHR* structInfo, Decoded_VkAccelerationStructureBuildRangeInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* primitiveCount */
    structBody << "\t" << structInfo->primitiveCount << "," << std::endl;
/* primitiveOffset */
    structBody << "\t" << structInfo->primitiveOffset << "," << std::endl;
/* firstVertex */
    structBody << "\t" << structInfo->firstVertex << "," << std::endl;
/* transformOffset */
    structBody << "\t" << structInfo->transformOffset << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureBuildRangeInfoKHR");
    out << "VkAccelerationStructureBuildRangeInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureGeometryTrianglesDataKHR(std::ostream &out, const VkAccelerationStructureGeometryTrianglesDataKHR* structInfo, Decoded_VkAccelerationStructureGeometryTrianglesDataKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* vertexFormat */
    structBody << "\t" << "VkFormat(" << structInfo->vertexFormat << ")" << "," << std::endl;
/* vertexData */
    structBody << "\t" << structInfo->vertexData.deviceAddress << "," << std::endl;
/* vertexStride */
    structBody << "\t" << structInfo->vertexStride << "UL" << "," << std::endl;
/* maxVertex */
    structBody << "\t" << structInfo->maxVertex << "," << std::endl;
/* indexType */
    structBody << "\t" << "VkIndexType(" << structInfo->indexType << ")" << "," << std::endl;
/* indexData */
    structBody << "\t" << structInfo->indexData.deviceAddress << "," << std::endl;
/* transformData */
    structBody << "\t" << structInfo->transformData.deviceAddress << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureGeometryTrianglesDataKHR");
    out << "VkAccelerationStructureGeometryTrianglesDataKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureGeometryAabbsDataKHR(std::ostream &out, const VkAccelerationStructureGeometryAabbsDataKHR* structInfo, Decoded_VkAccelerationStructureGeometryAabbsDataKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* data */
    structBody << "\t" << structInfo->data.deviceAddress << "," << std::endl;
/* stride */
    structBody << "\t" << structInfo->stride << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureGeometryAabbsDataKHR");
    out << "VkAccelerationStructureGeometryAabbsDataKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureGeometryInstancesDataKHR(std::ostream &out, const VkAccelerationStructureGeometryInstancesDataKHR* structInfo, Decoded_VkAccelerationStructureGeometryInstancesDataKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* arrayOfPointers */
    structBody << "\t" << structInfo->arrayOfPointers << "," << std::endl;
/* data */
    structBody << "\t" << structInfo->data.deviceAddress << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureGeometryInstancesDataKHR");
    out << "VkAccelerationStructureGeometryInstancesDataKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureGeometryKHR(std::ostream &out, const VkAccelerationStructureGeometryKHR* structInfo, Decoded_VkAccelerationStructureGeometryKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string trianglesInfoVar = GenerateStruct_VkAccelerationStructureGeometryTrianglesDataKHR(out,
                                                                           &structInfo->geometry.triangles,
                                                                           metainfo->geometry->triangles,
                                                                           consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* geometryType */
    structBody << "\t" << "VkGeometryTypeKHR(" << structInfo->geometryType << ")" << "," << std::endl;
/* geometry */
    structBody << "\t" << trianglesInfoVar << "," << std::endl;
/* flags */
    structBody << "\t" << "VkGeometryFlagsKHR(" << structInfo->flags << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureGeometryKHR");
    out << "VkAccelerationStructureGeometryKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureBuildGeometryInfoKHR(std::ostream &out, const VkAccelerationStructureBuildGeometryInfoKHR* structInfo, Decoded_VkAccelerationStructureBuildGeometryInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pGeometriesArray = "NULL";
    if (structInfo->pGeometries != NULL) {
        pGeometriesArray = "pGeometries_" + std::to_string(consumer.getNextId());
        std::string pGeometriesNames;
        for (uint32_t idx = 0; idx < structInfo->geometryCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pGeometries + idx != NULL) {
                varName = GenerateStruct_VkAccelerationStructureGeometryKHR(out,
                                                         structInfo->pGeometries + idx,
                                                         metainfo->pGeometries->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pGeometriesNames += varName + ", ";
        }
        out << "VkAccelerationStructureGeometryKHR " << pGeometriesArray << "[] = {" << pGeometriesNames << "};" << std::endl;
    }
    std::string ppGeometriesArray = "NULL";
    if (structInfo->ppGeometries != NULL) {
        ppGeometriesArray = "ppGeometries_" + std::to_string(consumer.getNextId());
        std::string ppGeometriesNames;
        for (uint32_t idx0 = 0; idx0 < structInfo->geometryCount; ++idx0) {
            for (uint32_t idx1 = 0; idx1 < 1; ++idx1) {
                std::string varName = "NULL";
                varName = GenerateStruct_VkAccelerationStructureGeometryKHR(out,
                                                         &(structInfo->ppGeometries[idx0][idx1]),
                                                         &(metainfo->ppGeometries->GetMetaStructPointer()[idx0][idx1]),
                                                         consumer);
                ppGeometriesNames += varName + ", ";
            }
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* type */
    structBody << "\t" << "VkAccelerationStructureTypeKHR(" << structInfo->type << ")" << "," << std::endl;
/* flags */
    structBody << "\t" << "VkBuildAccelerationStructureFlagsKHR(" << structInfo->flags << ")" << "," << std::endl;
/* mode */
    structBody << "\t" << "VkBuildAccelerationStructureModeKHR(" << structInfo->mode << ")" << "," << std::endl;
/* srcAccelerationStructure */
    structBody << "\t" << consumer.GetHandle(metainfo->srcAccelerationStructure) << "," << std::endl;
/* dstAccelerationStructure */
    structBody << "\t" << consumer.GetHandle(metainfo->dstAccelerationStructure) << "," << std::endl;
/* geometryCount */
    structBody << "\t" << structInfo->geometryCount << "," << std::endl;
/* pGeometries */
    structBody << "\t" << pGeometriesArray << "," << std::endl;
/* ppGeometries */
    structBody << "\t" << ppGeometriesArray << "," << std::endl;
/* scratchData */
    structBody << "\t" << structInfo->scratchData.deviceAddress << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureBuildGeometryInfoKHR");
    out << "VkAccelerationStructureBuildGeometryInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureCreateInfoKHR(std::ostream &out, const VkAccelerationStructureCreateInfoKHR* structInfo, Decoded_VkAccelerationStructureCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* createFlags */
    structBody << "\t" << "VkAccelerationStructureCreateFlagsKHR(" << structInfo->createFlags << ")" << "," << std::endl;
/* buffer */
    structBody << "\t" << consumer.GetHandle(metainfo->buffer) << "," << std::endl;
/* offset */
    structBody << "\t" << structInfo->offset << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," << std::endl;
/* type */
    structBody << "\t" << "VkAccelerationStructureTypeKHR(" << structInfo->type << ")" << "," << std::endl;
/* deviceAddress */
    structBody << "\t" << structInfo->deviceAddress << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureCreateInfoKHR");
    out << "VkAccelerationStructureCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkWriteDescriptorSetAccelerationStructureKHR(std::ostream &out, const VkWriteDescriptorSetAccelerationStructureKHR* structInfo, Decoded_VkWriteDescriptorSetAccelerationStructureKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pAccelerationStructuresArray = "NULL";
    if (metainfo->pAccelerationStructures.GetPointer() != NULL && structInfo->accelerationStructureCount > 0) {
        pAccelerationStructuresArray = "pAccelerationStructuresArray_" + std::to_string(consumer.getNextId(VK_OBJECT_TYPE_ACCELERATION_STRUCTURE_KHR));
        std::string pAccelerationStructuresValues = toStringJoin(metainfo->pAccelerationStructures.GetPointer(),
                                                                 metainfo->pAccelerationStructures.GetPointer() + structInfo->accelerationStructureCount,
                                                                 [&](const format::HandleId current) { return consumer.GetHandle(current); },
                                                                 ", ");
        if (structInfo->accelerationStructureCount == 1) {
            pAccelerationStructuresArray = "&" + pAccelerationStructuresValues;
        } else if (structInfo->accelerationStructureCount > 1) {
            out << "VkAccelerationStructureKHR " << pAccelerationStructuresArray << "[] = {" << pAccelerationStructuresValues << "};" << std::endl;
        }
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* accelerationStructureCount */
    structBody << "\t" << structInfo->accelerationStructureCount << "," << std::endl;
/* pAccelerationStructures */
    structBody << "\t" << pAccelerationStructuresArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "writeDescriptorSetAccelerationStructureKHR");
    out << "VkWriteDescriptorSetAccelerationStructureKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceAccelerationStructureFeaturesKHR(std::ostream &out, const VkPhysicalDeviceAccelerationStructureFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceAccelerationStructureFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* accelerationStructure */
    structBody << "\t" << structInfo->accelerationStructure << "," << std::endl;
/* accelerationStructureCaptureReplay */
    structBody << "\t" << structInfo->accelerationStructureCaptureReplay << "," << std::endl;
/* accelerationStructureIndirectBuild */
    structBody << "\t" << structInfo->accelerationStructureIndirectBuild << "," << std::endl;
/* accelerationStructureHostCommands */
    structBody << "\t" << structInfo->accelerationStructureHostCommands << "," << std::endl;
/* descriptorBindingAccelerationStructureUpdateAfterBind */
    structBody << "\t" << structInfo->descriptorBindingAccelerationStructureUpdateAfterBind << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceAccelerationStructureFeaturesKHR");
    out << "VkPhysicalDeviceAccelerationStructureFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceAccelerationStructurePropertiesKHR(std::ostream &out, const VkPhysicalDeviceAccelerationStructurePropertiesKHR* structInfo, Decoded_VkPhysicalDeviceAccelerationStructurePropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxGeometryCount */
    structBody << "\t" << structInfo->maxGeometryCount << "UL" << "," << std::endl;
/* maxInstanceCount */
    structBody << "\t" << structInfo->maxInstanceCount << "UL" << "," << std::endl;
/* maxPrimitiveCount */
    structBody << "\t" << structInfo->maxPrimitiveCount << "UL" << "," << std::endl;
/* maxPerStageDescriptorAccelerationStructures */
    structBody << "\t" << structInfo->maxPerStageDescriptorAccelerationStructures << "," << std::endl;
/* maxPerStageDescriptorUpdateAfterBindAccelerationStructures */
    structBody << "\t" << structInfo->maxPerStageDescriptorUpdateAfterBindAccelerationStructures << "," << std::endl;
/* maxDescriptorSetAccelerationStructures */
    structBody << "\t" << structInfo->maxDescriptorSetAccelerationStructures << "," << std::endl;
/* maxDescriptorSetUpdateAfterBindAccelerationStructures */
    structBody << "\t" << structInfo->maxDescriptorSetUpdateAfterBindAccelerationStructures << "," << std::endl;
/* minAccelerationStructureScratchOffsetAlignment */
    structBody << "\t" << structInfo->minAccelerationStructureScratchOffsetAlignment << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceAccelerationStructurePropertiesKHR");
    out << "VkPhysicalDeviceAccelerationStructurePropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureDeviceAddressInfoKHR(std::ostream &out, const VkAccelerationStructureDeviceAddressInfoKHR* structInfo, Decoded_VkAccelerationStructureDeviceAddressInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* accelerationStructure */
    structBody << "\t" << consumer.GetHandle(metainfo->accelerationStructure) << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureDeviceAddressInfoKHR");
    out << "VkAccelerationStructureDeviceAddressInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureVersionInfoKHR(std::ostream &out, const VkAccelerationStructureVersionInfoKHR* structInfo, Decoded_VkAccelerationStructureVersionInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pVersionDataArray = "NULL";
    std::string pVersionDataValues;
    for (uint32_t idx0 = 0; idx0 < 2*VK_UUID_SIZE; ++idx0) {
        pVersionDataValues += std::to_string(structInfo->pVersionData[idx0]) + ", ";
    }
    pVersionDataArray = "pVersionData_" + std::to_string(consumer.getNextId());
    out << "uint8_t " << pVersionDataArray << "[] = {" << pVersionDataValues << "};" << std::endl;
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* pVersionData */
    structBody << "\t" << pVersionDataArray << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureVersionInfoKHR");
    out << "VkAccelerationStructureVersionInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyAccelerationStructureToMemoryInfoKHR(std::ostream &out, const VkCopyAccelerationStructureToMemoryInfoKHR* structInfo, Decoded_VkCopyAccelerationStructureToMemoryInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* src */
    structBody << "\t" << consumer.GetHandle(metainfo->src) << "," << std::endl;
/* dst */
    structBody << "\t" << structInfo->dst.deviceAddress << "," << std::endl;
/* mode */
    structBody << "\t" << "VkCopyAccelerationStructureModeKHR(" << structInfo->mode << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyAccelerationStructureToMemoryInfoKHR");
    out << "VkCopyAccelerationStructureToMemoryInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyMemoryToAccelerationStructureInfoKHR(std::ostream &out, const VkCopyMemoryToAccelerationStructureInfoKHR* structInfo, Decoded_VkCopyMemoryToAccelerationStructureInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* src */
    structBody << "\t" << structInfo->src.deviceAddress << "," << std::endl;
/* dst */
    structBody << "\t" << consumer.GetHandle(metainfo->dst) << "," << std::endl;
/* mode */
    structBody << "\t" << "VkCopyAccelerationStructureModeKHR(" << structInfo->mode << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyMemoryToAccelerationStructureInfoKHR");
    out << "VkCopyMemoryToAccelerationStructureInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkCopyAccelerationStructureInfoKHR(std::ostream &out, const VkCopyAccelerationStructureInfoKHR* structInfo, Decoded_VkCopyAccelerationStructureInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* src */
    structBody << "\t" << consumer.GetHandle(metainfo->src) << "," << std::endl;
/* dst */
    structBody << "\t" << consumer.GetHandle(metainfo->dst) << "," << std::endl;
/* mode */
    structBody << "\t" << "VkCopyAccelerationStructureModeKHR(" << structInfo->mode << ")" << "," ;
    std::string varname = consumer.AddStruct(structBody, "copyAccelerationStructureInfoKHR");
    out << "VkCopyAccelerationStructureInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkAccelerationStructureBuildSizesInfoKHR(std::ostream &out, const VkAccelerationStructureBuildSizesInfoKHR* structInfo, Decoded_VkAccelerationStructureBuildSizesInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* accelerationStructureSize */
    structBody << "\t" << structInfo->accelerationStructureSize << "UL" << "," << std::endl;
/* updateScratchSize */
    structBody << "\t" << structInfo->updateScratchSize << "UL" << "," << std::endl;
/* buildScratchSize */
    structBody << "\t" << structInfo->buildScratchSize << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "accelerationStructureBuildSizesInfoKHR");
    out << "VkAccelerationStructureBuildSizesInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRayTracingShaderGroupCreateInfoKHR(std::ostream &out, const VkRayTracingShaderGroupCreateInfoKHR* structInfo, Decoded_VkRayTracingShaderGroupCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* type */
    structBody << "\t" << "VkRayTracingShaderGroupTypeKHR(" << structInfo->type << ")" << "," << std::endl;
/* generalShader */
    structBody << "\t" << structInfo->generalShader << "," << std::endl;
/* closestHitShader */
    structBody << "\t" << structInfo->closestHitShader << "," << std::endl;
/* anyHitShader */
    structBody << "\t" << structInfo->anyHitShader << "," << std::endl;
/* intersectionShader */
    structBody << "\t" << structInfo->intersectionShader << "," << std::endl;
/* pShaderGroupCaptureReplayHandle */
    structBody << "\t" << structInfo->pShaderGroupCaptureReplayHandle << "," ;
    std::string varname = consumer.AddStruct(structBody, "rayTracingShaderGroupCreateInfoKHR");
    out << "VkRayTracingShaderGroupCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRayTracingPipelineInterfaceCreateInfoKHR(std::ostream &out, const VkRayTracingPipelineInterfaceCreateInfoKHR* structInfo, Decoded_VkRayTracingPipelineInterfaceCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxPipelineRayPayloadSize */
    structBody << "\t" << structInfo->maxPipelineRayPayloadSize << "," << std::endl;
/* maxPipelineRayHitAttributeSize */
    structBody << "\t" << structInfo->maxPipelineRayHitAttributeSize << "," ;
    std::string varname = consumer.AddStruct(structBody, "rayTracingPipelineInterfaceCreateInfoKHR");
    out << "VkRayTracingPipelineInterfaceCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkRayTracingPipelineCreateInfoKHR(std::ostream &out, const VkRayTracingPipelineCreateInfoKHR* structInfo, Decoded_VkRayTracingPipelineCreateInfoKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
    std::string pStagesArray = "NULL";
    if (structInfo->pStages != NULL) {
        pStagesArray = "pStages_" + std::to_string(consumer.getNextId());
        std::string pStagesNames;
        for (uint32_t idx = 0; idx < structInfo->stageCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pStages + idx != NULL) {
                varName = GenerateStruct_VkPipelineShaderStageCreateInfo(out,
                                                         structInfo->pStages + idx,
                                                         metainfo->pStages->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pStagesNames += varName + ", ";
        }
        out << "VkPipelineShaderStageCreateInfo " << pStagesArray << "[] = {" << pStagesNames << "};" << std::endl;
    }
    std::string pGroupsArray = "NULL";
    if (structInfo->pGroups != NULL) {
        pGroupsArray = "pGroups_" + std::to_string(consumer.getNextId());
        std::string pGroupsNames;
        for (uint32_t idx = 0; idx < structInfo->groupCount; idx++) {
            std::string varName = "NULL";
            if (structInfo->pGroups + idx != NULL) {
                varName = GenerateStruct_VkRayTracingShaderGroupCreateInfoKHR(out,
                                                         structInfo->pGroups + idx,
                                                         metainfo->pGroups->GetMetaStructPointer() + idx,
                                                         consumer);
            }
            pGroupsNames += varName + ", ";
        }
        out << "VkRayTracingShaderGroupCreateInfoKHR " << pGroupsArray << "[] = {" << pGroupsNames << "};" << std::endl;
    }
    std::string pLibraryInfoStruct = "NULL";
    if (structInfo->pLibraryInfo != NULL) {
        pLibraryInfoStruct = GenerateStruct_VkPipelineLibraryCreateInfoKHR(out,
                                                            structInfo->pLibraryInfo,
                                                            metainfo->pLibraryInfo->GetMetaStructPointer(),
                                                            consumer);
        pLibraryInfoStruct.insert(0, "&");
    }
    std::string pLibraryInterfaceStruct = "NULL";
    if (structInfo->pLibraryInterface != NULL) {
        pLibraryInterfaceStruct = GenerateStruct_VkRayTracingPipelineInterfaceCreateInfoKHR(out,
                                                                 structInfo->pLibraryInterface,
                                                                 metainfo->pLibraryInterface->GetMetaStructPointer(),
                                                                 consumer);
        pLibraryInterfaceStruct.insert(0, "&");
    }
    std::string pDynamicStateStruct = "NULL";
    if (structInfo->pDynamicState != NULL) {
        pDynamicStateStruct = GenerateStruct_VkPipelineDynamicStateCreateInfo(out,
                                                             structInfo->pDynamicState,
                                                             metainfo->pDynamicState->GetMetaStructPointer(),
                                                             consumer);
        pDynamicStateStruct.insert(0, "&");
    }
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* flags */
    structBody << "\t" << "VkPipelineCreateFlags(" << structInfo->flags << ")" << "," << std::endl;
/* stageCount */
    structBody << "\t" << structInfo->stageCount << "," << std::endl;
/* pStages */
    structBody << "\t" << pStagesArray << "," << std::endl;
/* groupCount */
    structBody << "\t" << structInfo->groupCount << "," << std::endl;
/* pGroups */
    structBody << "\t" << pGroupsArray << "," << std::endl;
/* maxPipelineRayRecursionDepth */
    structBody << "\t" << structInfo->maxPipelineRayRecursionDepth << "," << std::endl;
/* pLibraryInfo */
    structBody << "\t" << pLibraryInfoStruct << "," << std::endl;
/* pLibraryInterface */
    structBody << "\t" << pLibraryInterfaceStruct << "," << std::endl;
/* pDynamicState */
    structBody << "\t" << pDynamicStateStruct << "," << std::endl;
/* layout */
    structBody << "\t" << consumer.GetHandle(metainfo->layout) << "," << std::endl;
/* basePipelineHandle */
    structBody << "\t" << consumer.GetHandle(metainfo->basePipelineHandle) << "," << std::endl;
/* basePipelineIndex */
    structBody << "\t" << structInfo->basePipelineIndex << "," ;
    std::string varname = consumer.AddStruct(structBody, "rayTracingPipelineCreateInfoKHR");
    out << "VkRayTracingPipelineCreateInfoKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingPipelineFeaturesKHR(std::ostream &out, const VkPhysicalDeviceRayTracingPipelineFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceRayTracingPipelineFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* rayTracingPipeline */
    structBody << "\t" << structInfo->rayTracingPipeline << "," << std::endl;
/* rayTracingPipelineShaderGroupHandleCaptureReplay */
    structBody << "\t" << structInfo->rayTracingPipelineShaderGroupHandleCaptureReplay << "," << std::endl;
/* rayTracingPipelineShaderGroupHandleCaptureReplayMixed */
    structBody << "\t" << structInfo->rayTracingPipelineShaderGroupHandleCaptureReplayMixed << "," << std::endl;
/* rayTracingPipelineTraceRaysIndirect */
    structBody << "\t" << structInfo->rayTracingPipelineTraceRaysIndirect << "," << std::endl;
/* rayTraversalPrimitiveCulling */
    structBody << "\t" << structInfo->rayTraversalPrimitiveCulling << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceRayTracingPipelineFeaturesKHR");
    out << "VkPhysicalDeviceRayTracingPipelineFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceRayTracingPipelinePropertiesKHR(std::ostream &out, const VkPhysicalDeviceRayTracingPipelinePropertiesKHR* structInfo, Decoded_VkPhysicalDeviceRayTracingPipelinePropertiesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* shaderGroupHandleSize */
    structBody << "\t" << structInfo->shaderGroupHandleSize << "," << std::endl;
/* maxRayRecursionDepth */
    structBody << "\t" << structInfo->maxRayRecursionDepth << "," << std::endl;
/* maxShaderGroupStride */
    structBody << "\t" << structInfo->maxShaderGroupStride << "," << std::endl;
/* shaderGroupBaseAlignment */
    structBody << "\t" << structInfo->shaderGroupBaseAlignment << "," << std::endl;
/* shaderGroupHandleCaptureReplaySize */
    structBody << "\t" << structInfo->shaderGroupHandleCaptureReplaySize << "," << std::endl;
/* maxRayDispatchInvocationCount */
    structBody << "\t" << structInfo->maxRayDispatchInvocationCount << "," << std::endl;
/* shaderGroupHandleAlignment */
    structBody << "\t" << structInfo->shaderGroupHandleAlignment << "," << std::endl;
/* maxRayHitAttributeSize */
    structBody << "\t" << structInfo->maxRayHitAttributeSize << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceRayTracingPipelinePropertiesKHR");
    out << "VkPhysicalDeviceRayTracingPipelinePropertiesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkStridedDeviceAddressRegionKHR(std::ostream &out, const VkStridedDeviceAddressRegionKHR* structInfo, Decoded_VkStridedDeviceAddressRegionKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* deviceAddress */
    structBody << "\t" << structInfo->deviceAddress << "UL" << "," << std::endl;
/* stride */
    structBody << "\t" << structInfo->stride << "UL" << "," << std::endl;
/* size */
    structBody << "\t" << structInfo->size << "UL" << "," ;
    std::string varname = consumer.AddStruct(structBody, "stridedDeviceAddressRegionKHR");
    out << "VkStridedDeviceAddressRegionKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkTraceRaysIndirectCommandKHR(std::ostream &out, const VkTraceRaysIndirectCommandKHR* structInfo, Decoded_VkTraceRaysIndirectCommandKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* width */
    structBody << "\t" << structInfo->width << "," << std::endl;
/* height */
    structBody << "\t" << structInfo->height << "," << std::endl;
/* depth */
    structBody << "\t" << structInfo->depth << "," ;
    std::string varname = consumer.AddStruct(structBody, "traceRaysIndirectCommandKHR");
    out << "VkTraceRaysIndirectCommandKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceRayQueryFeaturesKHR(std::ostream &out, const VkPhysicalDeviceRayQueryFeaturesKHR* structInfo, Decoded_VkPhysicalDeviceRayQueryFeaturesKHR* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* rayQuery */
    structBody << "\t" << structInfo->rayQuery << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceRayQueryFeaturesKHR");
    out << "VkPhysicalDeviceRayQueryFeaturesKHR " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMeshShaderFeaturesEXT(std::ostream &out, const VkPhysicalDeviceMeshShaderFeaturesEXT* structInfo, Decoded_VkPhysicalDeviceMeshShaderFeaturesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* taskShader */
    structBody << "\t" << structInfo->taskShader << "," << std::endl;
/* meshShader */
    structBody << "\t" << structInfo->meshShader << "," << std::endl;
/* multiviewMeshShader */
    structBody << "\t" << structInfo->multiviewMeshShader << "," << std::endl;
/* primitiveFragmentShadingRateMeshShader */
    structBody << "\t" << structInfo->primitiveFragmentShadingRateMeshShader << "," << std::endl;
/* meshShaderQueries */
    structBody << "\t" << structInfo->meshShaderQueries << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMeshShaderFeaturesEXT");
    out << "VkPhysicalDeviceMeshShaderFeaturesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkPhysicalDeviceMeshShaderPropertiesEXT(std::ostream &out, const VkPhysicalDeviceMeshShaderPropertiesEXT* structInfo, Decoded_VkPhysicalDeviceMeshShaderPropertiesEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
    std::string pNextName = GenerateExtension(out, structInfo->pNext, metainfo->pNext, consumer);
/* sType */
    structBody << "\t" << "VkStructureType(" << structInfo->sType << ")" << "," << std::endl;
/* pNext */
    structBody << "\t" << pNextName << "," << std::endl;
/* maxTaskWorkGroupTotalCount */
    structBody << "\t" << structInfo->maxTaskWorkGroupTotalCount << "," << std::endl;
/* maxTaskWorkGroupCount */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxTaskWorkGroupCount[0]), 3) << "," << std::endl;
/* maxTaskWorkGroupInvocations */
    structBody << "\t" << structInfo->maxTaskWorkGroupInvocations << "," << std::endl;
/* maxTaskWorkGroupSize */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxTaskWorkGroupSize[0]), 3) << "," << std::endl;
/* maxTaskPayloadSize */
    structBody << "\t" << structInfo->maxTaskPayloadSize << "," << std::endl;
/* maxTaskSharedMemorySize */
    structBody << "\t" << structInfo->maxTaskSharedMemorySize << "," << std::endl;
/* maxTaskPayloadAndSharedMemorySize */
    structBody << "\t" << structInfo->maxTaskPayloadAndSharedMemorySize << "," << std::endl;
/* maxMeshWorkGroupTotalCount */
    structBody << "\t" << structInfo->maxMeshWorkGroupTotalCount << "," << std::endl;
/* maxMeshWorkGroupCount */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxMeshWorkGroupCount[0]), 3) << "," << std::endl;
/* maxMeshWorkGroupInvocations */
    structBody << "\t" << structInfo->maxMeshWorkGroupInvocations << "," << std::endl;
/* maxMeshWorkGroupSize */
    structBody << "\t" << VulkanCppConsumerBase::BuildValue(reinterpret_cast<const uint32_t*>(&structInfo->maxMeshWorkGroupSize[0]), 3) << "," << std::endl;
/* maxMeshSharedMemorySize */
    structBody << "\t" << structInfo->maxMeshSharedMemorySize << "," << std::endl;
/* maxMeshPayloadAndSharedMemorySize */
    structBody << "\t" << structInfo->maxMeshPayloadAndSharedMemorySize << "," << std::endl;
/* maxMeshOutputMemorySize */
    structBody << "\t" << structInfo->maxMeshOutputMemorySize << "," << std::endl;
/* maxMeshPayloadAndOutputMemorySize */
    structBody << "\t" << structInfo->maxMeshPayloadAndOutputMemorySize << "," << std::endl;
/* maxMeshOutputComponents */
    structBody << "\t" << structInfo->maxMeshOutputComponents << "," << std::endl;
/* maxMeshOutputVertices */
    structBody << "\t" << structInfo->maxMeshOutputVertices << "," << std::endl;
/* maxMeshOutputPrimitives */
    structBody << "\t" << structInfo->maxMeshOutputPrimitives << "," << std::endl;
/* maxMeshOutputLayers */
    structBody << "\t" << structInfo->maxMeshOutputLayers << "," << std::endl;
/* maxMeshMultiviewViewCount */
    structBody << "\t" << structInfo->maxMeshMultiviewViewCount << "," << std::endl;
/* meshOutputPerVertexGranularity */
    structBody << "\t" << structInfo->meshOutputPerVertexGranularity << "," << std::endl;
/* meshOutputPerPrimitiveGranularity */
    structBody << "\t" << structInfo->meshOutputPerPrimitiveGranularity << "," << std::endl;
/* maxPreferredTaskWorkGroupInvocations */
    structBody << "\t" << structInfo->maxPreferredTaskWorkGroupInvocations << "," << std::endl;
/* maxPreferredMeshWorkGroupInvocations */
    structBody << "\t" << structInfo->maxPreferredMeshWorkGroupInvocations << "," << std::endl;
/* prefersLocalInvocationVertexOutput */
    structBody << "\t" << structInfo->prefersLocalInvocationVertexOutput << "," << std::endl;
/* prefersLocalInvocationPrimitiveOutput */
    structBody << "\t" << structInfo->prefersLocalInvocationPrimitiveOutput << "," << std::endl;
/* prefersCompactVertexOutput */
    structBody << "\t" << structInfo->prefersCompactVertexOutput << "," << std::endl;
/* prefersCompactPrimitiveOutput */
    structBody << "\t" << structInfo->prefersCompactPrimitiveOutput << "," ;
    std::string varname = consumer.AddStruct(structBody, "physicalDeviceMeshShaderPropertiesEXT");
    out << "VkPhysicalDeviceMeshShaderPropertiesEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


std::string GenerateStruct_VkDrawMeshTasksIndirectCommandEXT(std::ostream &out, const VkDrawMeshTasksIndirectCommandEXT* structInfo, Decoded_VkDrawMeshTasksIndirectCommandEXT* metainfo, VulkanCppConsumerBase &consumer){
    std::stringstream structBody;
/* groupCountX */
    structBody << "\t" << structInfo->groupCountX << "," << std::endl;
/* groupCountY */
    structBody << "\t" << structInfo->groupCountY << "," << std::endl;
/* groupCountZ */
    structBody << "\t" << structInfo->groupCountZ << "," ;
    std::string varname = consumer.AddStruct(structBody, "drawMeshTasksIndirectCommandEXT");
    out << "VkDrawMeshTasksIndirectCommandEXT " << varname << " {" << std::endl;
    out << structBody.str() << std::endl;
    out << "};" << std::endl;
    return varname;
}


GFXRECON_END_NAMESPACE(decode)
GFXRECON_END_NAMESPACE(gfxrecon)

