/*
** Copyright (c) 2026 LunarG, Inc.
** Copyright (c) 2026 Google
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following conditions:
**
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
** FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
** DEALINGS IN THE SOFTWARE.
*/

#include "vulkan_frame_warm_up.h"

#include "generated/generated_vulkan_enum_to_string.h"
#include "graphics/vulkan_device_util.h"
#include "graphics/vulkan_resources_util.h"
#include "util/logging.h"

GFXRECON_BEGIN_NAMESPACE(gfxrecon)
GFXRECON_BEGIN_NAMESPACE(graphics)

void VulkanFrameWarmUp::WarmUp(VkDevice                                device,
                               const VkPhysicalDeviceMemoryProperties& capture_memory_properties,
                               uint32_t                                queue_family_index,
                               VkQueue                                 queue,
                               const VulkanDeviceTable*                device_table)
{
    if (device_table == nullptr)
    {
        return;
    }

    VkResult result = VK_SUCCESS;

    if (command_pool_ == VK_NULL_HANDLE)
    {
        VkCommandPoolCreateInfo cmd_pool_info = { VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO };
        cmd_pool_info.queueFamilyIndex        = queue_family_index;
        cmd_pool_info.flags                   = VK_COMMAND_POOL_CREATE_TRANSIENT_BIT;
        result = device_table->CreateCommandPool(device, &cmd_pool_info, nullptr, &command_pool_);
        GFXRECON_LOG_WARNING("CreateCommandPool %s.", util::ToString<VkResult>(result).c_str());
    }

    if (result == VK_SUCCESS && shader_module_ == VK_NULL_HANDLE)
    {
        // Minimal SPIR-V compute shader:
        // #version 450

        // // Define the size of the workgroup.
        // // This means 64 invocations of this shader will run in parallel as a single group.
        // layout (local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

        // // Define a storage buffer that the application will provide.
        // // It's an array of floating-point numbers that we can both read from and write to.
        // // 'binding = 0' means it will be bound to the first descriptor slot (index 0).
        // layout(std430, binding = 0) buffer DataBuffer {
        //     float data[];
        // };

        // void main() {
        //     // Get the unique global ID for this specific shader invocation.
        //     // This gives us a unique index into our data buffer.
        //     uint index = gl_GlobalInvocationID.x;

        //     // Read the initial value from the buffer.
        //     float value = data[index];

        //     // --- DUMMY WORK ---
        //     // Perform a series of arbitrary calculations in a loop to keep the GPU busy.
        //     // This is designed to be work that the compiler can't easily optimize away.
        //     for (int i = 0; i < 1000; i++) {
        //         value = sin(value) * 0.999 + cos(float(i)) * 0.001;
        //     }

        //     // Write the final, modified value back into the same position in the buffer.
        //     data[index] = value;
        // }
        unsigned char spirv[] = {
            0x03, 0x02, 0x23, 0x07, 0x00, 0x00, 0x01, 0x00, 0x0b, 0x00, 0x0d, 0x00, 0x3b, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x11, 0x00, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00,
            0x47, 0x4c, 0x53, 0x4c, 0x2e, 0x73, 0x74, 0x64, 0x2e, 0x34, 0x35, 0x30, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x00,
            0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x06, 0x00, 0x05, 0x00, 0x00, 0x00,
            0x04, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x10, 0x00,
            0x06, 0x00, 0x04, 0x00, 0x00, 0x00, 0x11, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00, 0x03, 0x00, 0x03, 0x00, 0x02, 0x00, 0x00, 0x00, 0xc2, 0x01, 0x00, 0x00, 0x04, 0x00,
            0x0a, 0x00, 0x47, 0x4c, 0x5f, 0x47, 0x4f, 0x4f, 0x47, 0x4c, 0x45, 0x5f, 0x63, 0x70, 0x70, 0x5f, 0x73, 0x74,
            0x79, 0x6c, 0x65, 0x5f, 0x6c, 0x69, 0x6e, 0x65, 0x5f, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65,
            0x00, 0x00, 0x04, 0x00, 0x08, 0x00, 0x47, 0x4c, 0x5f, 0x47, 0x4f, 0x4f, 0x47, 0x4c, 0x45, 0x5f, 0x69, 0x6e,
            0x63, 0x6c, 0x75, 0x64, 0x65, 0x5f, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x00, 0x05, 0x00,
            0x04, 0x00, 0x04, 0x00, 0x00, 0x00, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00,
            0x08, 0x00, 0x00, 0x00, 0x69, 0x6e, 0x64, 0x65, 0x78, 0x00, 0x00, 0x00, 0x05, 0x00, 0x08, 0x00, 0x0b, 0x00,
            0x00, 0x00, 0x67, 0x6c, 0x5f, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x49, 0x6e, 0x76, 0x6f, 0x63, 0x61, 0x74,
            0x69, 0x6f, 0x6e, 0x49, 0x44, 0x00, 0x00, 0x00, 0x05, 0x00, 0x04, 0x00, 0x12, 0x00, 0x00, 0x00, 0x76, 0x61,
            0x6c, 0x75, 0x65, 0x00, 0x00, 0x00, 0x05, 0x00, 0x05, 0x00, 0x14, 0x00, 0x00, 0x00, 0x44, 0x61, 0x74, 0x61,
            0x42, 0x75, 0x66, 0x66, 0x65, 0x72, 0x00, 0x00, 0x06, 0x00, 0x05, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00, 0x16, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x03, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x69, 0x00, 0x00, 0x00, 0x47, 0x00,
            0x04, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00,
            0x13, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x47, 0x00, 0x03, 0x00, 0x14, 0x00,
            0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x48, 0x00, 0x05, 0x00, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x16, 0x00, 0x00, 0x00, 0x21, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x16, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x47, 0x00, 0x04, 0x00, 0x3a, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x19, 0x00,
            0x00, 0x00, 0x13, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00, 0x00, 0x21, 0x00, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00,
            0x02, 0x00, 0x00, 0x00, 0x15, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
            0x17, 0x00, 0x04, 0x00, 0x09, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x20, 0x00,
            0x04, 0x00, 0x0a, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00,
            0x0a, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x06, 0x00,
            0x00, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x0d, 0x00, 0x00, 0x00,
            0x01, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x16, 0x00, 0x03, 0x00, 0x10, 0x00, 0x00, 0x00, 0x20, 0x00,
            0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x11, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00,
            0x1d, 0x00, 0x03, 0x00, 0x13, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x03, 0x00, 0x14, 0x00,
            0x00, 0x00, 0x13, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00, 0x15, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
            0x14, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x15, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x02, 0x00,
            0x00, 0x00, 0x15, 0x00, 0x04, 0x00, 0x17, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
            0x2b, 0x00, 0x04, 0x00, 0x17, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00,
            0x04, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x20, 0x00, 0x04, 0x00,
            0x1d, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x17, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x17, 0x00,
            0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0xe8, 0x03, 0x00, 0x00, 0x14, 0x00, 0x02, 0x00, 0x26, 0x00, 0x00, 0x00,
            0x2b, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x77, 0xbe, 0x7f, 0x3f, 0x2b, 0x00,
            0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x6f, 0x12, 0x83, 0x3a, 0x2b, 0x00, 0x04, 0x00,
            0x17, 0x00, 0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x06, 0x00,
            0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00,
            0x39, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x2c, 0x00, 0x06, 0x00, 0x09, 0x00, 0x00, 0x00, 0x3a, 0x00,
            0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x39, 0x00, 0x00, 0x00, 0x39, 0x00, 0x00, 0x00, 0x36, 0x00, 0x05, 0x00,
            0x02, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0xf8, 0x00,
            0x02, 0x00, 0x05, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x07, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
            0x07, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x11, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x07, 0x00,
            0x00, 0x00, 0x3b, 0x00, 0x04, 0x00, 0x1d, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
            0x41, 0x00, 0x05, 0x00, 0x0d, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x0c, 0x00,
            0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x0e, 0x00, 0x00, 0x00,
            0x3e, 0x00, 0x03, 0x00, 0x08, 0x00, 0x00, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x06, 0x00,
            0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x41, 0x00, 0x06, 0x00, 0x1a, 0x00, 0x00, 0x00,
            0x1b, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x3d, 0x00,
            0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x1b, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
            0x12, 0x00, 0x00, 0x00, 0x1c, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x18, 0x00,
            0x00, 0x00, 0xf9, 0x00, 0x02, 0x00, 0x1f, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x1f, 0x00, 0x00, 0x00,
            0xf6, 0x00, 0x04, 0x00, 0x21, 0x00, 0x00, 0x00, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf9, 0x00,
            0x02, 0x00, 0x23, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x23, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
            0x17, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0xb1, 0x00, 0x05, 0x00, 0x26, 0x00,
            0x00, 0x00, 0x27, 0x00, 0x00, 0x00, 0x24, 0x00, 0x00, 0x00, 0x25, 0x00, 0x00, 0x00, 0xfa, 0x00, 0x04, 0x00,
            0x27, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x21, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x20, 0x00,
            0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00,
            0x0c, 0x00, 0x06, 0x00, 0x10, 0x00, 0x00, 0x00, 0x29, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0d, 0x00,
            0x00, 0x00, 0x28, 0x00, 0x00, 0x00, 0x85, 0x00, 0x05, 0x00, 0x10, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00,
            0x29, 0x00, 0x00, 0x00, 0x2a, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x17, 0x00, 0x00, 0x00, 0x2c, 0x00,
            0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x6f, 0x00, 0x04, 0x00, 0x10, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00,
            0x2c, 0x00, 0x00, 0x00, 0x0c, 0x00, 0x06, 0x00, 0x10, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x01, 0x00,
            0x00, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x2d, 0x00, 0x00, 0x00, 0x85, 0x00, 0x05, 0x00, 0x10, 0x00, 0x00, 0x00,
            0x30, 0x00, 0x00, 0x00, 0x2e, 0x00, 0x00, 0x00, 0x2f, 0x00, 0x00, 0x00, 0x81, 0x00, 0x05, 0x00, 0x10, 0x00,
            0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00,
            0x12, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0xf9, 0x00, 0x02, 0x00, 0x22, 0x00, 0x00, 0x00, 0xf8, 0x00,
            0x02, 0x00, 0x22, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00, 0x17, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00,
            0x1e, 0x00, 0x00, 0x00, 0x80, 0x00, 0x05, 0x00, 0x17, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00, 0x32, 0x00,
            0x00, 0x00, 0x33, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x03, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x34, 0x00, 0x00, 0x00,
            0xf9, 0x00, 0x02, 0x00, 0x1f, 0x00, 0x00, 0x00, 0xf8, 0x00, 0x02, 0x00, 0x21, 0x00, 0x00, 0x00, 0x3d, 0x00,
            0x04, 0x00, 0x06, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x3d, 0x00, 0x04, 0x00,
            0x10, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0x12, 0x00, 0x00, 0x00, 0x41, 0x00, 0x06, 0x00, 0x1a, 0x00,
            0x00, 0x00, 0x37, 0x00, 0x00, 0x00, 0x16, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x35, 0x00, 0x00, 0x00,
            0x3e, 0x00, 0x03, 0x00, 0x37, 0x00, 0x00, 0x00, 0x36, 0x00, 0x00, 0x00, 0xfd, 0x00, 0x01, 0x00, 0x38, 0x00,
            0x01, 0x00
        };

        VkShaderModuleCreateInfo sm_create_info = { VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO };
        sm_create_info.codeSize                 = sizeof(spirv);
        sm_create_info.pCode                    = (uint32_t*)spirv;
        result = device_table->CreateShaderModule(device, &sm_create_info, nullptr, &shader_module_);
        GFXRECON_LOG_WARNING("CreateShaderModule %s.", util::ToString<VkResult>(result).c_str());
    }
    const uint32_t     num_invocations = warm_up_load_ * 1000 * 64 * 1 * 1; // Dispatch(X,Y,Z) * local_size(X,Y,Z)
    const VkDeviceSize buffer_size     = sizeof(float) * num_invocations;

    if (result == VK_SUCCESS && buffer_ == VK_NULL_HANDLE)
    {
        VkBufferCreateInfo buffer_info = { VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO };
        buffer_info.size               = buffer_size;
        buffer_info.usage              = VK_BUFFER_USAGE_STORAGE_BUFFER_BIT;
        buffer_info.sharingMode        = VK_SHARING_MODE_EXCLUSIVE;
        result                         = device_table->CreateBuffer(device, &buffer_info, nullptr, &buffer_);
        GFXRECON_LOG_WARNING("CreateBuffer for warm-up %s.", util::ToString<VkResult>(result).c_str());

        if (result == VK_SUCCESS)
        {
            VkMemoryRequirements mem_requirements;
            device_table->GetBufferMemoryRequirements(device, buffer_, &mem_requirements);

            VkMemoryAllocateInfo alloc_info = { VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO };
            alloc_info.allocationSize       = mem_requirements.size;
            bool found                      = FindMemoryTypeIndex(capture_memory_properties,
                                             mem_requirements.memoryTypeBits,
                                             VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT,
                                             &alloc_info.memoryTypeIndex,
                                             nullptr);

            if (alloc_info.memoryTypeIndex != std::numeric_limits<uint32_t>::max())
            {
                result = device_table->AllocateMemory(device, &alloc_info, nullptr, &buffer_memory_);
                GFXRECON_LOG_WARNING("AllocateMemory for warm-up buffer %s.", util::ToString<VkResult>(result).c_str());
                if (result == VK_SUCCESS)
                {
                    result = device_table->BindBufferMemory(device, buffer_, buffer_memory_, 0);
                }
            }
            else
            {
                result = VK_ERROR_INITIALIZATION_FAILED;
            }
        }
    }

    if (result == VK_SUCCESS && descriptor_set_layout_ == VK_NULL_HANDLE)
    {
        VkDescriptorSetLayoutBinding layout_binding = {};
        layout_binding.binding                      = 0;
        layout_binding.descriptorType               = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
        layout_binding.descriptorCount              = 1;
        layout_binding.stageFlags                   = VK_SHADER_STAGE_COMPUTE_BIT;

        VkDescriptorSetLayoutCreateInfo layout_info = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO };
        layout_info.bindingCount                    = 1;
        layout_info.pBindings                       = &layout_binding;
        result = device_table->CreateDescriptorSetLayout(device, &layout_info, nullptr, &descriptor_set_layout_);
        GFXRECON_LOG_WARNING("CreateDescriptorSetLayout %s.", util::ToString<VkResult>(result).c_str());
    }

    if (result == VK_SUCCESS && pipeline_layout_ == VK_NULL_HANDLE)
    {
        VkPipelineLayoutCreateInfo pl_create_info = { VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO };
        pl_create_info.setLayoutCount             = 1;
        pl_create_info.pSetLayouts                = &descriptor_set_layout_; // Link the layout
        result = device_table->CreatePipelineLayout(device, &pl_create_info, nullptr, &pipeline_layout_);
        GFXRECON_LOG_WARNING("CreatePipelineLayout %s.", util::ToString<VkResult>(result).c_str());
    }

    if (result == VK_SUCCESS && descriptor_pool_ == VK_NULL_HANDLE)
    {
        VkDescriptorPoolSize pool_size = {};
        pool_size.type                 = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
        pool_size.descriptorCount      = 1;

        VkDescriptorPoolCreateInfo pool_info = { VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO };
        pool_info.poolSizeCount              = 1;
        pool_info.pPoolSizes                 = &pool_size;
        pool_info.maxSets                    = 1;
        result = device_table->CreateDescriptorPool(device, &pool_info, nullptr, &descriptor_pool_);
        GFXRECON_LOG_WARNING("CreateDescriptorPool %s.", util::ToString<VkResult>(result).c_str());
    }

    if (result == VK_SUCCESS && descriptor_set_ == VK_NULL_HANDLE)
    {
        VkDescriptorSetAllocateInfo alloc_info = { VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO };
        alloc_info.descriptorPool              = descriptor_pool_;
        alloc_info.descriptorSetCount          = 1;
        alloc_info.pSetLayouts                 = &descriptor_set_layout_;
        result = device_table->AllocateDescriptorSets(device, &alloc_info, &descriptor_set_);
        GFXRECON_LOG_WARNING("AllocateDescriptorSets %s.", util::ToString<VkResult>(result).c_str());

        // NEW: Update the descriptor set to point to our buffer
        if (result == VK_SUCCESS)
        {
            VkDescriptorBufferInfo buffer_info_for_descriptor = {};
            buffer_info_for_descriptor.buffer                 = buffer_;
            buffer_info_for_descriptor.offset                 = 0;
            buffer_info_for_descriptor.range                  = buffer_size;

            VkWriteDescriptorSet descriptor_write = { VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET };
            descriptor_write.dstSet               = descriptor_set_;
            descriptor_write.dstBinding           = 0;
            descriptor_write.dstArrayElement      = 0;
            descriptor_write.descriptorType       = VK_DESCRIPTOR_TYPE_STORAGE_BUFFER;
            descriptor_write.descriptorCount      = 1;
            descriptor_write.pBufferInfo          = &buffer_info_for_descriptor;
            device_table->UpdateDescriptorSets(device, 1, &descriptor_write, 0, nullptr);
        }
    }

    if (result == VK_SUCCESS && pipeline_ == VK_NULL_HANDLE)
    {
        VkComputePipelineCreateInfo cp_create_info = { VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO };
        cp_create_info.stage.sType                 = VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO;
        cp_create_info.stage.stage                 = VK_SHADER_STAGE_COMPUTE_BIT;
        cp_create_info.stage.module                = shader_module_;
        cp_create_info.stage.pName                 = "main";
        cp_create_info.layout                      = pipeline_layout_;
        result = device_table->CreateComputePipelines(device, VK_NULL_HANDLE, 1, &cp_create_info, nullptr, &pipeline_);
        GFXRECON_LOG_WARNING("CreateComputePipelines %s.", util::ToString<VkResult>(result).c_str());
    }

    if (result == VK_SUCCESS && semaphores_.empty())
    {
        semaphores_.resize(10);
        VkSemaphoreCreateInfo semaphore_info = { VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO };
        for (size_t i = 0; i < semaphores_.size(); ++i)
        {
            result = device_table->CreateSemaphore(device, &semaphore_info, nullptr, &semaphores_[i]);
            if (result != VK_SUCCESS)
            {
                GFXRECON_LOG_WARNING("Failed to create semaphore for warm-up. Error %s.",
                                     util::ToString<VkResult>(result).c_str());
                semaphores_.clear();
                break;
            }
        }
    }

    if (result == VK_SUCCESS && command_buffer_ == VK_NULL_HANDLE)
    {
        VkCommandBufferAllocateInfo cmd_buf_alloc_info = { VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO };
        cmd_buf_alloc_info.commandPool                 = command_pool_;
        cmd_buf_alloc_info.level                       = VK_COMMAND_BUFFER_LEVEL_PRIMARY;
        cmd_buf_alloc_info.commandBufferCount          = 1;
        result = device_table->AllocateCommandBuffers(device, &cmd_buf_alloc_info, &command_buffer_);
        GFXRECON_LOG_WARNING("AllocateCommandBuffers %s.", util::ToString<VkResult>(result).c_str());

        VkCommandBufferBeginInfo begin_info = { VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO };
        begin_info.flags                    = VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT;
        device_table->BeginCommandBuffer(command_buffer_, &begin_info);
        device_table->CmdBindPipeline(command_buffer_, VK_PIPELINE_BIND_POINT_COMPUTE, pipeline_);
        device_table->CmdBindDescriptorSets(
            command_buffer_, VK_PIPELINE_BIND_POINT_COMPUTE, pipeline_layout_, 0, 1, &descriptor_set_, 0, nullptr);
        device_table->CmdDispatch(command_buffer_, warm_up_load_ * 64, 1, 1);
        device_table->EndCommandBuffer(command_buffer_);
    }

    if (result == VK_SUCCESS)
    {
        VkSubmitInfo submit_info       = { VK_STRUCTURE_TYPE_SUBMIT_INFO };
        submit_info.commandBufferCount = 1;
        submit_info.pCommandBuffers    = &command_buffer_;
        // next_semaphore_index > 0 means we know how many of them we need from previous frame render
        submit_info.signalSemaphoreCount =
            next_semaphore_index_ > 0 ? next_semaphore_index_ : static_cast<uint32_t>(semaphores_.size());
        submit_info.pSignalSemaphores = semaphores_.data();
        device_table->QueueSubmit(queue, 1, &submit_info, VK_NULL_HANDLE);
        next_semaphore_index_ = 0;
    }

    if (result != VK_SUCCESS)
    {
        GFXRECON_LOG_WARNING("Device warm-up dispatch failed with error %s.", util::ToString<VkResult>(result).c_str());
    }
}

GFXRECON_END_NAMESPACE(graphics)
GFXRECON_END_NAMESPACE(gfxrecon)
