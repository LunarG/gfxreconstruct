# The settings in this file can be used to configure the behavior of
# layers in this repository.
#
####################################################################
# !WARNING! - This file is automatically generated from the
###########   (GFXReconstruct)/settings_options/generate_settings.py
########### - script and any changes should be made there.
####################################################################
#
# VK_LAYER_LUNARG_gfxreconstruct
#

# Allow Pipeline Compile Required
# ===================================
# <LayerIdentifier>.allow_pipeline_compile_required
# [Vulkan Only] The default behavior forces VK_PIPELINE_COMPILE_REQUIRED to be
# returned from Create*Pipelines calls which have
# VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT set, and skips
# dispatching and recording the calls. This forces applications to fallback to
# recompiling pipelines without caching, the Vulkan calls for which will be
# captured. Enabling this option causes capture to record the application's
# calls and implementation's return values unmodified, but the resulting
# captures are fragile to changes in Vulkan implementations if they use pipeline
# caching.
# Default is false
lunarg_gfxreconstruct.allow_pipeline_compile_required = false

#  Capture Dump Android Assets
# ===================================
# <LayerIdentifier>.capture_android_dump_assets
# Setting this triggers a dump of all assets into the asset file. Since Android
# options cannot be set by the layer, dumping is done whenever this option
# switches between from `false` to `true` or from `true` to `false`.
# [Deprecated, please use 'capture_dynamic_trigger_dump_assets']
# Default is false
lunarg_gfxreconstruct.capture_android_dump_assets = false

#  Capture Trigger For Android
# ===================================
# <LayerIdentifier>.capture_android_trigger
# Set during runtime to `true` to start capturing and to `false` to stop. If not
# set at all then it is disabled (non-trimmed capture). [Deprecated, please use
# 'capture_dynamic_trigger']
# Default is false
lunarg_gfxreconstruct.capture_android_trigger = false

# Capture File Compression Format
# ===================================
# <LayerIdentifier>.capture_compression_type
# Compression format to use with the capture file. Valid values are: LZ4, ZLIB,
# ZSTD, and NONE.
# Default is LZ4
lunarg_gfxreconstruct.capture_compression_type = LZ4

# Capture Environment
# ===================================
# <LayerIdentifier>.capture_environment
# Comma delimited list of environment variables to store in the capture file.
# These can optionally be restored during replay to their capture-time values
# with the `gfxrecon-replay-renamed.py` utility.
# Default is <empty>
lunarg_gfxreconstruct.capture_environment = 

# Capture File Name
# ===================================
# <LayerIdentifier>.capture_file
# Path to use when creating the capture file. Supports variable patterns for
# dynamic file paths, such as `${AppName}` (the application or executable name).
# Default is gfxrecon_capture.gfxr
lunarg_gfxreconstruct.capture_file = gfxrecon_capture.gfxr

# Capture File Flush After Write
# ===================================
# <LayerIdentifier>.capture_file_flush
# Flush output stream after each packet is written to the capture file.
# Default is false
lunarg_gfxreconstruct.capture_file_flush = false

# Capture File Name with Timestamp
# ===================================
# <LayerIdentifier>.capture_file_timestamp
# Add a timestamp (yyyymmddThhmmss) postfix to the capture file name.
# Default is true
lunarg_gfxreconstruct.capture_file_timestamp = true

# Capture Specific Frames
# ===================================
# <LayerIdentifier>.capture_frames
# Specify one or more comma-separated frame ranges to capture. Each range will
# be written to its own file. A frame range can be specified as a single value,
# to specify a single frame to capture, or as two hyphenated values, to specify
# the first and last frame to capture. Frame ranges should be specified in
# ascending order and cannot overlap. Note that frame numbering is 1-based (i.e.
# the first frame is frame 1). Example: 200,301-305 will create two capture
# files, one containing a single frame and one containing five frames. If not
# defined, all frames are captured.
# Default is <empty>
lunarg_gfxreconstruct.capture_frames = 

# Capture Process Name
# ===================================
# <LayerIdentifier>.capture_process_name
# The name of the process to capture content from, all other processes will be
# ignored.  All valid API processes are captured otherwise.
# Default is <empty>
lunarg_gfxreconstruct.capture_process_name = 

# Capture Specific GPU Queue Submits
# ===================================
# <LayerIdentifier>.capture_queue_submits
# Specify one or more comma-separated GPU queue submit call ranges to capture.
# Queue submit calls are `vkQueueSubmit` for Vulkan and
# `ID3D12CommandQueue::ExecuteCommandLists` for DX12. Queue submit ranges work
# as described for `capture_frames` but on GPU queue submit calls instead of
# frames. The index is 0-based. Default is all queue submits are captured.
# Default is <empty>
lunarg_gfxreconstruct.capture_queue_submits = 

# Hotkey Capture Trigger
# ===================================
# <LayerIdentifier>.capture_trigger
# Specify a hotkey (any one of F1-F12, TAB, CONTROL) that will be used to
# start/stop capture. Example: F3 will set the capture trigger to F3 hotkey. One
# capture file will be generated for each pair of start/stop hotkey presses.
# This, in effect, toggles `capture_dynamic_trigger`.
# Default is <empty>
lunarg_gfxreconstruct.capture_trigger = 

#  Dynamic Capture Trigger
# ===================================
# <LayerIdentifier>.capture_dynamic_trigger
# Set during runtime to `true` to start capturing and to `false` to stop. If not
# set at all then it is disabled (non-trimmed capture). [Replaces
# 'capture_android_trigger']
# Default is false
lunarg_gfxreconstruct.capture_dynamic_trigger = false

#  Dynamic Capture Trigger Dump Assets
# ===================================
# <LayerIdentifier>.capture_dynamic_trigger_dump_assets
# Setting this triggers a dump of all assets into the asset file. Dumping is
# done whenever this option switches between from `false` to `true` or from
# `true` to `false`. [Replaces 'capture_android_dump_assets']
# Default is false
lunarg_gfxreconstruct.capture_dynamic_trigger_dump_assets = false

# Hotkey Capture Frame Limit
# ===================================
# <LayerIdentifier>.capture_trigger_frames
# Specify a limit on the number of frames to be captured via hotkey. Example:
# `1` will capture exactly one frame when the trigger key is pressed. If not
# defined, then there is no limit
# Default is <empty>
lunarg_gfxreconstruct.capture_trigger_frames = 

# Use Asset File
# ===================================
# <LayerIdentifier>.capture_use_asset_file
# When set to `true` assets (images, buffers and descriptors) will be stored
# separately into an asset file instead of the capture file.
# Default is false
lunarg_gfxreconstruct.capture_use_asset_file = false

# Force Command Serialization
# ===================================
# <LayerIdentifier>.force_command_serialization
# Sets exclusive locks (unique_lock) for every ApiCall. It can avoid external
# multi-thread to cause captured issue.
# Default is false
lunarg_gfxreconstruct.force_command_serialization = false

# Force FIFO Present Mode
# ===================================
# <LayerIdentifier>.force_fifo_present_mode
# [Vulkan Only] When the `force_fifo_present_mode` is enabled, force all present
# modes in vkGetPhysicalDeviceSurfacePresentModesKHR to
# VK_PRESENT_MODE_FIFO_KHR, app present mode is set in vkCreateSwapchain to
# VK_PRESENT_MODE_FIFO_KHR. Otherwise the original present mode will be used.
# Default is true
lunarg_gfxreconstruct.force_fifo_present_mode = true

# Ignore vkFrameBoundaryANDROID
# ===================================
# <LayerIdentifier>.ignore_frame_boundary_android
# [Android Vulkan Only] Ignore any calls to vkFrameBoundaryANDROID when
# determining frame boundaries.
# Default is false
lunarg_gfxreconstruct.ignore_frame_boundary_android = false

# Log Allow Additional Indents
# ===================================
# <LayerIdentifier>.log_allow_indents
# Apply additional indentation formatting to log messages.
# Default is false
lunarg_gfxreconstruct.log_allow_indents = false

# Log Break on Error
# ===================================
# <LayerIdentifier>.log_break_on_error
# Trigger a debug break when logging an error.
# Default is false
lunarg_gfxreconstruct.log_break_on_error = false

# Log Detailed
# ===================================
# <LayerIdentifier>.log_detailed
# Include name and line number from the file responsible for the log message.
# Default is false
lunarg_gfxreconstruct.log_detailed = false

# Log Errors to StdError
# ===================================
# <LayerIdentifier>.log_errors_to_stderr
# Log any errors that occur to stderr.
# Default is true
lunarg_gfxreconstruct.log_errors_to_stderr = true

# Log File
# ===================================
# <LayerIdentifier>.log_file
# When set, log messages will be written to a file at the specified location.
# Default is <empty>
lunarg_gfxreconstruct.log_file = 

# Log File Create New
# ===================================
# <LayerIdentifier>.log_file_create_new
# Specifies that log file initialization should overwrite an existing file when
# `true`, or append to an existing file when `false`.
# Default is true
lunarg_gfxreconstruct.log_file_create_new = true

# Log File Flush After Write
# ===================================
# <LayerIdentifier>.log_file_flush_after_write
# Flush the log file to disk after each write when true.
# Default is false
lunarg_gfxreconstruct.log_file_flush_after_write = false

# Log File Keep Open
# ===================================
# <LayerIdentifier>.log_file_keep_open
# Keep the log file open between log messages when true, or close and reopen the
# log file for each message when false.
# Default is true
lunarg_gfxreconstruct.log_file_keep_open = true

# Log Level
# ===================================
# <LayerIdentifier>.log_level
# Specify the highest level message to log.  The specified level and all levels
# listed after it will be enabled for logging.  For example, choosing the
# `warning` level will also enable the `error` and `fatal` levels.
# Default is info
lunarg_gfxreconstruct.log_level = info

# Log Output to Console / stdout
# ===================================
# <LayerIdentifier>.log_output_to_console
# Log messages will be written to stdout.
# Default is true
lunarg_gfxreconstruct.log_output_to_console = true

# Log Output to Debug Console
# ===================================
# <LayerIdentifier>.log_output_to_os_debug_string
# [Windows Only] Log messages will be written to the Debug Console with
# OutputDebugStringA
# Default is false
lunarg_gfxreconstruct.log_output_to_os_debug_string = false

# Log Timestamps
# ===================================
# <LayerIdentifier>.log_timestamps
# Output a timestamp in front of each log message.
# Default is false
lunarg_gfxreconstruct.log_timestamps = false

# Memory Tracking Mode
# ===================================
# <LayerIdentifier>.memory_tracking_mode
# Specifies the memory tracking mode to use for detecting modifications to
# mapped Vulkan memory objects. Available options are: page_guard, assisted, and
# unassisted.
# Default is page_guard
lunarg_gfxreconstruct.memory_tracking_mode = page_guard

# Page Guard Align Buffer Sizes
# ===================================
# <LayerIdentifier>.page_guard_align_buffer_sizes
# [Vulkan Only] When the `page_guard` memory tracking mode is enabled, this
# option overrides the Vulkan API calls that report buffer memory properties to
# report that buffer sizes and alignments must be a multiple of the system page
# size. This option is intended to be used with applications that perform CPU
# writes and GPU writes/copies to different buffers that are bound to the same
# page of mapped memory, which may result in data being lost when copying pages
# from the page_guard shadow allocation to the real allocation. This data loss
# can result in visible corruption during capture. Forcing buffer sizes and
# alignments to a multiple of the system page size prevents multiple buffers
# from being bound to the same page, avoiding data loss from simultaneous CPU
# writes to the shadow allocation and GPU writes to the real allocation for
# different buffers bound to the same page.
# Default is true
lunarg_gfxreconstruct.page_guard_align_buffer_sizes = true

# Page Guard Copy on Map
# ===================================
# <LayerIdentifier>.page_guard_copy_on_map
# When the `page_guard` memory tracking mode is enabled, copies the content of
# the mapped memory to the shadow memory immediately after the memory is mapped.
# Default is true
lunarg_gfxreconstruct.page_guard_copy_on_map = true

# Page Guard External Memory
# ===================================
# <LayerIdentifier>.page_guard_external_memory
# [Windows Only] When the `page_guard` memory tracking mode is enabled, use the
# VK_EXT_external_memory_host extension to eliminate the need for shadow memory
# allocations. For each memory allocation from a host visible memory type, the
# capture layer will create an allocation from system memory, which it can
# monitor for write access, and provide that allocation to vkAllocateMemory as
# external memory.
# Default is false
lunarg_gfxreconstruct.page_guard_external_memory = false

# Page Guard Persistent Memory
# ===================================
# <LayerIdentifier>.page_guard_persistent_memory
# When the `page_guard` memory tracking mode is enabled, this option changes the
# way that the shadow memory used to detect modifications to mapped memory is
# allocated. The default behavior is to allocate and copy the mapped memory
# range on map and free the allocation on unmap. When this option is enabled, an
# allocation with a size equal to that of the object being mapped is made once
# on the first map and is not freed until the object is destroyed. This option
# is intended to be used with applications that frequently map and unmap large
# memory ranges, to avoid frequent allocation and copy operations that can have
# a negative impact on performance. This option is ignored when
# `page_guard_external_memory` is enabled.
# Default is false
lunarg_gfxreconstruct.page_guard_persistent_memory = false

# Page Guard Separate Read Tracking
# ===================================
# <LayerIdentifier>.page_guard_separate_read
# When the `page_guard` memory tracking mode is enabled, copies the content of
# pages accessed for read from mapped memory to shadow memory on each read. Can
# overwrite unprocessed shadow memory content when an application is reading
# from and writing to the same page.
# Default is true
lunarg_gfxreconstruct.page_guard_separate_read = true

# Page Guard Signal Handler Watcher
# ===================================
# <LayerIdentifier>.page_guard_signal_handler_watcher
# When the `page_guard` memory tracking mode is enabled, setting this to `true`
# will spawn a thread which will will periodically reinstall the `SIGSEGV`
# handler if it has been replaced by the application being traced.
# Default is false
lunarg_gfxreconstruct.page_guard_signal_handler_watcher = false

# Page Guard Signal Handler Watcher Max Restores
# ===================================
# <LayerIdentifier>.page_guard_signal_handler_watcher_max_restores
# Sets the number of times the watcher will attempt to restore the signal
# handler. Setting it to a negative will make the watcher thread run
# indefinitely.
# Default is 1
lunarg_gfxreconstruct.page_guard_signal_handler_watcher_max_restores = 1

# Page Guard Track AHB Memory
# ===================================
# <LayerIdentifier>.page_guard_track_ahb_memory
# [Android Only] When the `page_guard` memory tracking mode is enabled,
# eliminate the need for shadow memory allocations for Android Hardware Buffers.
# Default is false
lunarg_gfxreconstruct.page_guard_track_ahb_memory = false

# Page Guard Unblock SIGSEGV
# ===================================
# <LayerIdentifier>.page_guard_unblock_sigsegv
# When the `page_guard` memory tracking mode is enabled and in the case that
# SIGSEGV has been marked as blocked in thread's signal mask, setting this to
# `true` will forcibly re-enable the signal in the thread's signal mask.
# Default is false
lunarg_gfxreconstruct.page_guard_unblock_sigsegv = false

# Queue Zero Only
# ===================================
# <LayerIdentifier>.queue_zero_only
# Forces to using only QueueFamilyIndex: 0 and queueCount: 1 on capturing to
# avoid replay error for unavailable VkQueue.
# Default is false
lunarg_gfxreconstruct.queue_zero_only = false

# Quit after capturing frame ranges
# ===================================
# <LayerIdentifier>.quit_after_capture_frames
# Specify one or more comma-separated frame ranges to capture. Each range will
# be written to its own file. A frame range can be specified as a single value,
# to specify a single frame to capture, or as two hyphenated values, to specify
# the first and last frame to capture. Frame ranges should be specified in
# ascending order and cannot overlap. Note that frame numbering is 1-based (i.e.
# the first frame is frame 1). Example: 200,301-305 will create two capture
# files, one containing a single frame and one containing five frames. If not
# defined, all frames are captured.
# Default is false
lunarg_gfxreconstruct.quit_after_capture_frames = false

# Screenshot Directory
# ===================================
# <LayerIdentifier>.screenshot_dir
# Directory used where screenshots are saved to.  Default is the current working
# directory.
# Default is <empty>
lunarg_gfxreconstruct.screenshot_dir = 

# Screenshot Format
# ===================================
# <LayerIdentifier>.screenshot_format
# Image file format to use when saving screenshots.
# Default is BMP
lunarg_gfxreconstruct.screenshot_format = BMP

# Screenshot Specific Frames
# ===================================
# <LayerIdentifier>.screenshot_frames
# Specify one or more comma-separated frame ranges to screenshot. Each range
# will be written to its own file. A frame range can be specified as a single
# value, to specify a single frame to capture, or as two hyphenated values, to
# specify the first and last frame to capture. Frame ranges should be specified
# in ascending order and cannot overlap. Note that frame numbering is 1-based
# (i.e. the first frame is frame 1).
# Default is <empty>
lunarg_gfxreconstruct.screenshot_frames = 

# Screenshot Interval
# ===================================
# <LayerIdentifier>.screenshot_interval
# Sets the number between every screenshot taken.  1 means every frame is
# screenshot, 2 means every other, etc. Example: If screenshot range is 10-15
# and interval is 2, screenshot will be generated for frames 10, 12 and 14.
# Default is 1
lunarg_gfxreconstruct.screenshot_interval = 1