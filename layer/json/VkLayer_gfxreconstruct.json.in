{
    "file_format_version": "1.2.0",
    "layer": {
        "name": "VK_LAYER_LUNARG_gfxreconstruct",
        "type": "GLOBAL",
        "library_path": "@RELATIVE_LAYER_BINARY@",
        "api_version": "@VK_VERSION@",
        "implementation_version": "@GFXRECONSTRUCT_VERSION@",
        "description": "GFXReconstruct Capture Layer Version @GFXRECONSTRUCT_VERSION_STRING@",
        "introduction": "The GFXReconstruct Capture Layer intercepts Vulkan API calls and logs them to a capture file. Other tools in the GFXReconstruct suite can inspect, modify, or replay capture files generated by this component.",
        "platforms": [ "WINDOWS", "LINUX", "ANDROID", "MACOS" ],
        "url": "https://vulkan.lunarg.com/doc/sdk/latest/windows/capture_tools.html",
        "status": "STABLE",
        "device_extensions": [
            {
                "name": "VK_EXT_tooling_info",
                "spec_version": "1",
                "entrypoints": [ "vkGetPhysicalDeviceToolPropertiesEXT" ]
            }
        ],
        "disable_environment": {
            "GFXRECON_DISABLE": ""
        },
        "features": {
            "presets": [
                {
                    "label": "Initialization",
                    "description": "Capture the first two frames.",
                    "platforms": [ "WINDOWS", "LINUX", "MACOS" ],
                    "settings": [
                        {
                            "key": "capture_trigger",
                            "value": ""
                        },
                        {
                            "key": "capture_frames",
                            "value": "1-2"
                        }
                    ]
                },
                {
                    "label": "Range",
                    "description": "Capture a range of frames between presses of the F5 key.",
                    "platforms": [ "WINDOWS", "LINUX", "MACOS" ],
                    "settings": [
                        {
                            "key": "capture_trigger",
                            "value": "F5"
                        },
                        {
                            "key": "capture_frames",
                            "value": ""
                        }
                    ]
                }
            ],
            "settings": [
                {
                    "key": "allow_pipeline_compile_required",
                    "env": "GFXRECON_ALLOW_PIPELINE_COMPILE_REQUIRED",
                    "label": "Allow Application Compiled Pipeline Behavior",
                    "description": "[Vulkan Only] The default behavior forces VK_PIPELINE_COMPILE_REQUIRED to be returned from Create*Pipelines calls which have VK_PIPELINE_CREATE_FAIL_ON_PIPELINE_COMPILE_REQUIRED_BIT set, and skips dispatching and recording the calls. This forces applications to fallback to recompiling pipelines without caching, the Vulkan calls for which will be captured. Enabling this option causes capture to record the application's calls and implementation's return values unmodified, but the resulting captures are fragile to changes in Vulkan implementations if they use pipeline caching.",
                    "type": "BOOL",
                    "default": false
                },
                {
                    "key": "capture_android_dump_assets",
                    "env": "GFXRECON_CAPTURE_ANDROID_DUMP_ASSETS",
                    "label": " Capture Dump Android Assets",
                    "description": "[Android Only] Setting this triggers a dump of all assets into the asset file. Since Android options cannot be set by the layer, dumping is done whenever this option switches between from `false` to `true` or from `true` to `false`. [Deprecated, please use 'capture_dynamic_trigger_dump_assets']",
                    "platforms": [
                        "ANDROID"
                    ],
                    "type": "BOOL",
                    "default": false
                },
                {
                    "key": "capture_android_trigger",
                    "env": "GFXRECON_CAPTURE_ANDROID_TRIGGER",
                    "label": " Capture Trigger For Android",
                    "description": "[Android Only] Set during runtime to `true` to start capturing and to `false` to stop. If not set at all then it is disabled (non-trimmed capture). [Deprecated, please use 'capture_dynamic_trigger']",
                    "platforms": [
                        "ANDROID"
                    ],
                    "type": "BOOL",
                    "default": false
                },
                {
                    "key": "capture_environment",
                    "env": "GFXRECON_CAPTURE_ENVIRONMENT",
                    "label": "Capture Environment",
                    "description": "Comma delimited list of environment variables to store in the capture file. These can optionally be restored during replay to their capture-time values with the `gfxrecon-replay-renamed.py` utility.",
                    "platforms": [
                        "LINUX",
                        "MACOS",
                        "WINDOWS"
                    ],
                    "type": "LIST",
                    "default": []
                },
                {
                    "key": "capture_file",
                    "env": "GFXRECON_CAPTURE_FILE",
                    "label": "Capture File Name",
                    "description": "Path to use when creating the capture file. Supports variable patterns for dynamic file paths, such as `${AppName}` (the application or executable name).",
                    "type": "SAVE_FILE",
                    "filter": "*.gfxr",
                    "default": "gfxrecon_capture.gfxr",
                    "settings": [
                        {
                            "key": "capture_compression_type",
                            "env": "GFXRECON_CAPTURE_COMPRESSION_TYPE",
                            "label": "Capture File Compression Format",
                            "description": "Compression format to use with the capture file. Valid values are: LZ4, ZLIB, ZSTD, and NONE.",
                            "type": "ENUM",
                            "flags": [
                                {
                                    "key": "LZ4",
                                    "label": "LZ4",
                                    "description": "Fastest compression algorithm that favors performance over compression ratio."
                                },
                                {
                                    "key": "ZLIB",
                                    "label": "ZLIB",
                                    "description": "Widely used compression algorithm with better compression ratio than LZ4 but worse performance."
                                },
                                {
                                    "key": "ZSTD",
                                    "label": "ZSTD",
                                    "description": "Newer compression algorithm with better compression ratio and performance than ZLIB, though not as fast as LZ4."
                                },
                                {
                                    "key": "NONE",
                                    "label": "NONE",
                                    "description": "No compression"
                                }
                            ],
                            "default": "LZ4"
                        },
                        {
                            "key": "capture_file_flush",
                            "env": "GFXRECON_CAPTURE_FILE_FLUSH",
                            "label": "Capture File Flush After Write",
                            "description": "Flush output stream after each packet is written to the capture file.",
                            "type": "BOOL",
                            "default": false
                        },
                        {
                            "key": "capture_file_timestamp",
                            "env": "GFXRECON_CAPTURE_FILE_TIMESTAMP",
                            "label": "Capture File Name with Timestamp",
                            "description": "Add a timestamp (yyyymmddThhmmss) postfix to the capture file name.",
                            "type": "BOOL",
                            "default": true
                        }
                    ]
                },
                {
                    "key": "capture_restrictions",
                    "label": "Capture Restrictions",
                    "description": "Restrictions That Can Be Placed on Capture",
                    "type": "GROUP",
                    "settings": [
                        {
                            "key": "capture_frames",
                            "env": "GFXRECON_CAPTURE_FRAMES",
                            "label": "Capture Specific Frames",
                            "description": "Specify one or more comma-separated frame ranges to capture. Each range will be written to its own file. A frame range can be specified as a single value, to specify a single frame to capture, or as two hyphenated values, to specify the first and last frame to capture. Frame ranges should be specified in ascending order and cannot overlap. Note that frame numbering is 1-based (i.e. the first frame is frame 1). Example: 200,301-305 will create two capture files, one containing a single frame and one containing five frames. If not defined, all frames are captured.",
                            "type": "STRING",
                            "default": "",
                            "settings": [
                                {
                                    "key": "quit_after_capture_frames",
                                    "env": "GFXRECON_QUIT_AFTER_CAPTURE_FRAMES",
                                    "label": "Quit after capturing frame ranges",
                                    "description": "Specify one or more comma-separated frame ranges to capture. Each range will be written to its own file. A frame range can be specified as a single value, to specify a single frame to capture, or as two hyphenated values, to specify the first and last frame to capture. Frame ranges should be specified in ascending order and cannot overlap. Note that frame numbering is 1-based (i.e. the first frame is frame 1). Example: 200,301-305 will create two capture files, one containing a single frame and one containing five frames. If not defined, all frames are captured.",
                                    "type": "BOOL",
                                    "default": false
                                }
                            ]
                        },
                        {
                            "key": "capture_process_name",
                            "env": "GFXRECON_CAPTURE_PROCESS_NAME",
                            "label": "Capture Specific Process Name",
                            "description": "The name of the process to capture content from, all other processes will be ignored.  All valid API processes are captured otherwise.",
                            "type": "STRING",
                            "default": ""
                        },
                        {
                            "key": "capture_queue_submits",
                            "env": "GFXRECON_CAPTURE_QUEUE_SUBMITS",
                            "label": "Capture Specific GPU Queue Submits",
                            "description": "Specify one or more comma-separated GPU queue submit call ranges to capture.  Queue submit calls are `vkQueueSubmit` for Vulkan and `ID3D12CommandQueue::ExecuteCommandLists` for DX12. Queue submit ranges work as described for `capture_frames` but on GPU queue submit calls instead of frames. The index is 0-based. Default is all queue submits are captured.",
                            "type": "STRING",
                            "default": ""
                        },
                        {
                            "key": "hotkeys",
                            "label": "Hot Keys",
                            "description": "Hot Keys for Dynamic Capture",
                            "type": "GROUP",
                            "settings": [
                                {
                                    "key": "capture_trigger",
                                    "env": "GFXRECON_CAPTURE_TRIGGER",
                                    "label": "Hotkey Capture Trigger",
                                    "description": "Specify a hotkey (any one of F1-F12, TAB, CONTROL) that will be used to start/stop capture. Example: F3 will set the capture trigger to F3 hotkey. One capture file will be generated for each pair of start/stop hotkey presses.   This, in effect, toggles `capture_dynamic_trigger`.",
                                    "platforms": [
                                        "LINUX",
                                        "MACOS",
                                        "WINDOWS"
                                    ],
                                    "type": "ENUM",
                                    "flags": [
                                        {
                                            "key": "",
                                            "label": "None",
                                            "description": "None (Default)"
                                        },
                                        {
                                            "key": "F1",
                                            "label": "F1",
                                            "description": "F1 Key"
                                        },
                                        {
                                            "key": "F2",
                                            "label": "F2",
                                            "description": "F2 Key"
                                        },
                                        {
                                            "key": "F3",
                                            "label": "F3",
                                            "description": "F3 Key"
                                        },
                                        {
                                            "key": "F4",
                                            "label": "F4",
                                            "description": "F4 Key"
                                        },
                                        {
                                            "key": "F5",
                                            "label": "F5",
                                            "description": "F5 Key"
                                        },
                                        {
                                            "key": "F6",
                                            "label": "F6",
                                            "description": "F6 Key"
                                        },
                                        {
                                            "key": "F7",
                                            "label": "F7",
                                            "description": "F7 Key"
                                        },
                                        {
                                            "key": "F8",
                                            "label": "F8",
                                            "description": "F8 Key"
                                        },
                                        {
                                            "key": "F9",
                                            "label": "F9",
                                            "description": "F9 Key"
                                        },
                                        {
                                            "key": "F10",
                                            "label": "F10",
                                            "description": "F10 Key"
                                        },
                                        {
                                            "key": "F11",
                                            "label": "F11",
                                            "description": "F11 Key"
                                        },
                                        {
                                            "key": "F12",
                                            "label": "F12",
                                            "description": "F12 Key"
                                        },
                                        {
                                            "key": "TAB",
                                            "label": "TAB",
                                            "description": "TAB Key"
                                        },
                                        {
                                            "key": "CONTROL",
                                            "label": "CONTROL",
                                            "description": "CONTROL Key"
                                        }
                                    ],
                                    "default": ""
                                },
                                {
                                    "key": "capture_dynamic_trigger",
                                    "env": "GFXRECON_CAPTURE_DYNAMIC_TRIGGER",
                                    "label": " Dynamic Capture Trigger",
                                    "description": "Set during runtime to `true` to start capturing and to `false` to stop. If not set at all then it is disabled (non-trimmed capture). [Replaces 'capture_android_trigger']",
                                    "type": "BOOL",
                                    "default": false
                                },
                                {
                                    "key": "capture_dynamic_trigger_dump_assets",
                                    "env": "GFXRECON_CAPTURE_DYNAMIC_TRIGGER_DUMP_ASSETS",
                                    "label": " Dynamic Capture Trigger Dump Assets",
                                    "description": "Setting this triggers a dump of all assets into the asset file. Dumping is done whenever this option switches between from `false` to `true` or from `true` to `false`. [Replaces 'capture_android_dump_assets']",
                                    "type": "BOOL",
                                    "default": false
                                },
                                {
                                    "key": "capture_trigger_frames",
                                    "env": "GFXRECON_CAPTURE_TRIGGER_FRAMES",
                                    "label": "Hotkey Capture Frame Limit",
                                    "description": "Specify a limit on the number of frames to be captured via hotkey. Example: `1` will capture exactly one frame when the trigger key is pressed. If not defined, then there is no limit",
                                    "type": "STRING",
                                    "default": ""
                                }
                            ]
                        },
                        {
                            "key": "force_command_serialization",
                            "env": "GFXRECON_FORCE_COMMAND_SERIALIZATION",
                            "label": "Force Command Serialization",
                            "description": "Sets exclusive locks (unique_lock) for every ApiCall. It can avoid external multi-thread to cause captured issue.",
                            "type": "BOOL",
                            "default": false
                        },
                        {
                            "key": "force_fifo_present_mode",
                            "env": "GFXRECON_FORCE_FIFO_PRESENT_MODE",
                            "label": "Force FIFO Present Mode",
                            "description": "[Vulkan Only] When the `force_fifo_present_mode` is enabled, force all present modes in vkGetPhysicalDeviceSurfacePresentModesKHR to VK_PRESENT_MODE_FIFO_KHR, app present mode is set in vkCreateSwapchain to VK_PRESENT_MODE_FIFO_KHR. Otherwise the original present mode will be used.",
                            "type": "BOOL",
                            "default": true
                        },
                        {
                            "key": "queue_zero_only",
                            "env": "GFXRECON_QUEUE_ZERO_ONLY",
                            "label": "Queue Zero Only",
                            "description": "Forces to using only QueueFamilyIndex: 0 and queueCount: 1 on capturing to avoid replay error for unavailable VkQueue.",
                            "type": "BOOL",
                            "default": false
                        }
                    ]
                },
                {
                    "key": "capture_use_asset_file",
                    "env": "GFXRECON_CAPTURE_USE_ASSET_FILE",
                    "label": "Use Asset File",
                    "description": "When set to `true` assets (images, buffers and descriptors) will be stored separately into an asset file instead of the capture file.",
                    "type": "BOOL",
                    "default": false
                },
                {
                    "key": "ignore_frame_boundary_android",
                    "env": "GFXRECON_IGNORE_FRAME_BOUNDARY_ANDROID",
                    "label": "Ignore vkFrameBoundaryANDROID",
                    "description": "[Android Vulkan Only] Ignore any calls to vkFrameBoundaryANDROID when determining frame boundaries.",
                    "platforms": [
                        "ANDROID"
                    ],
                    "type": "BOOL",
                    "default": false
                },
                {
                    "key": "log",
                    "label": "Log",
                    "description": "Control log messages.",
                    "type": "GROUP",
                    "settings": [
                        {
                            "key": "log_allow_indents",
                            "env": "GFXRECON_LOG_ALLOW_INDENTS",
                            "label": "Log Apply Additional Indentation",
                            "description": "Apply additional indentation formatting to log messages.",
                            "type": "BOOL",
                            "default": false
                        },
                        {
                            "key": "log_break_on_error",
                            "env": "GFXRECON_LOG_BREAK_ON_ERROR",
                            "label": "Log Break on Error",
                            "description": "Trigger a debug break when logging an error.",
                            "type": "BOOL",
                            "default": false
                        },
                        {
                            "key": "log_detailed",
                            "env": "GFXRECON_LOG_DETAILED",
                            "label": "Log Name and Line Number",
                            "description": "Include name and line number from the file responsible for the log message.",
                            "type": "BOOL",
                            "default": false
                        },
                        {
                            "key": "log_errors_to_stderr",
                            "env": "GFXRECON_LOG_ERRORS_TO_STDERR",
                            "label": "Log Errors to StdError",
                            "description": "Log any errors that occur to stderr.",
                            "type": "BOOL",
                            "default": true
                        },
                        {
                            "key": "log_file",
                            "env": "GFXRECON_LOG_FILE",
                            "label": "Log File",
                            "description": "When set, log messages will be written to a file at the specified location.",
                            "type": "SAVE_FILE",
                            "filter": "*.txt",
                            "default": "",
                            "settings": [
                                {
                                    "key": "log_file_create_new",
                                    "env": "GFXRECON_LOG_FILE_CREATE_NEW",
                                    "label": "Log File Overwrite",
                                    "description": "Specifies that log file initialization should overwrite an existing file when `true`, or append to an existing file when `false`.",
                                    "type": "BOOL",
                                    "default": true
                                },
                                {
                                    "key": "log_file_flush_after_write",
                                    "env": "GFXRECON_LOG_FILE_FLUSH_AFTER_WRITE",
                                    "label": "Log File Flush After Write",
                                    "description": "Flush the log file to disk after each write when true.",
                                    "type": "BOOL",
                                    "default": false
                                },
                                {
                                    "key": "log_file_keep_open",
                                    "env": "GFXRECON_LOG_FILE_KEEP_OPEN",
                                    "label": "Log File Keep Open",
                                    "description": "Keep the log file open between log messages when true, or close and reopen the log file for each message when false.",
                                    "type": "BOOL",
                                    "default": true
                                }
                            ]
                        },
                        {
                            "key": "log_level",
                            "env": "GFXRECON_LOG_LEVEL",
                            "label": "Log Level",
                            "description": "Specify the highest level message to log.  The specified level and all levels listed after it will be enabled for logging.  For example, choosing the `warning` level will also enable the `error` and `fatal` levels.",
                            "type": "ENUM",
                            "flags": [
                                {
                                    "key": "debug",
                                    "label": "debug, info, warning, error, fatal",
                                    "description": "Messages with debug-severity and higher"
                                },
                                {
                                    "key": "info",
                                    "label": "info, warning, error, fatal",
                                    "description": "Messages with info-severity and higher"
                                },
                                {
                                    "key": "warning",
                                    "label": "warning, error, fatal",
                                    "description": "Messages with warning-severity and higher"
                                },
                                {
                                    "key": "error",
                                    "label": "error, fatal",
                                    "description": "Only Error/Fatal messages"
                                },
                                {
                                    "key": "fatal",
                                    "label": "fatal",
                                    "description": "Only Fatal messages"
                                }
                            ],
                            "default": "info"
                        },
                        {
                            "key": "log_output_to_console",
                            "env": "GFXRECON_LOG_OUTPUT_TO_CONSOLE",
                            "label": "Log Output to Console / stdout",
                            "description": "Log messages will be written to stdout.",
                            "type": "BOOL",
                            "default": true
                        },
                        {
                            "key": "log_output_to_os_debug_string",
                            "env": "GFXRECON_LOG_OUTPUT_TO_OS_DEBUG_STRING",
                            "label": "Log Output to Debug Console",
                            "description": "[Windows Only] Log messages will be written to the Debug Console with OutputDebugStringA",
                            "platforms": [
                                "WINDOWS"
                            ],
                            "type": "BOOL",
                            "default": false
                        },
                        {
                            "key": "log_timestamps",
                            "env": "GFXRECON_LOG_TIMESTAMPS",
                            "label": "Log Timestamps",
                            "description": "Output a timestamp in front of each log message.",
                            "type": "BOOL",
                            "default": false
                        }
                    ]
                },
                {
                    "key": "memory_tracking_mode",
                    "env": "GFXRECON_MEMORY_TRACKING_MODE",
                    "label": "Memory Tracking Mode",
                    "description": "Specifies the memory tracking mode to use for detecting modifications to mapped Vulkan memory objects. Available options are: page_guard, assisted, and unassisted.",
                    "type": "ENUM",
                    "flags": [
                        {
                            "key": "page_guard",
                            "label": "page_guard",
                            "description": "Tracks modifications to individual memory pages, which are written to the capture file on calls to vkFlushMappedMemoryRanges, vkUnmapMemory, and vkQueueSubmit. Tracking modifications requires allocating shadow memory for all mapped memory."
                        },
                        {
                            "key": "assisted",
                            "label": "assisted",
                            "description": "Expects the application to call vkFlushMappedMemoryRanges after memory is modified; the memory ranges specified to the vkFlushMappedMemoryRanges call will be written to the capture file during the call."
                        },
                        {
                            "key": "unassisted",
                            "label": "unassisted",
                            "description": "Writes the full content of mapped memory to the capture file on calls to vkUnmapMemory and vkQueueSubmit. It is very inefficient and may be unusable with real-world applications that map large amounts of memory."
                        }
                    ],
                    "default": "page_guard",
                    "settings": [
                        {
                            "key": "page_guard_align_buffer_sizes",
                            "env": "GFXRECON_PAGE_GUARD_ALIGN_BUFFER_SIZES",
                            "label": "Page Guard Align Buffer Sizes",
                            "description": "[Vulkan Only] When the `page_guard` memory tracking mode is enabled, this option overrides the Vulkan API calls that report buffer memory properties to report that buffer sizes and alignments must be a multiple of the system page size. This option is intended to be used with applications that perform CPU writes and GPU writes/copies to different buffers that are bound to the same page of mapped memory, which may result in data being lost when copying pages from the page_guard shadow allocation to the real allocation. This data loss can result in visible corruption during capture. Forcing buffer sizes and alignments to a multiple of the system page size prevents multiple buffers from being bound to the same page, avoiding data loss from simultaneous CPU writes to the shadow allocation and GPU writes to the real allocation for different buffers bound to the same page.",
                            "type": "BOOL",
                            "default": true,
                            "dependence": {
                                "mode": "ALL",
                                "settings": [
                                    {
                                        "key": "memory_tracking_mode",
                                        "value": "page_guard"
                                    },
                                    {
                                        "key": "page_guard_external_memory",
                                        "value": false
                                    }
                                ]
                            }
                        },
                        {
                            "key": "page_guard_copy_on_map",
                            "env": "GFXRECON_PAGE_GUARD_COPY_ON_MAP",
                            "label": "Page Guard Copy on Map",
                            "description": "When the `page_guard` memory tracking mode is enabled, copies the content of the mapped memory to the shadow memory immediately after the memory is mapped.",
                            "type": "BOOL",
                            "default": true,
                            "dependence": {
                                "mode": "ALL",
                                "settings": [
                                    {
                                        "key": "memory_tracking_mode",
                                        "value": "page_guard"
                                    }
                                ]
                            }
                        },
                        {
                            "key": "page_guard_external_memory",
                            "env": "GFXRECON_PAGE_GUARD_EXTERNAL_MEMORY",
                            "label": "Page Guard External Memory",
                            "description": "[Windows Only] When the `page_guard` memory tracking mode is enabled, use the VK_EXT_external_memory_host extension to eliminate the need for shadow memory allocations. For each memory allocation from a host visible memory type, the capture layer will create an allocation from system memory, which it can monitor for write access, and provide that allocation to vkAllocateMemory as external memory.",
                            "platforms": [
                                "WINDOWS"
                            ],
                            "type": "BOOL",
                            "default": false,
                            "dependence": {
                                "mode": "ALL",
                                "settings": [
                                    {
                                        "key": "memory_tracking_mode",
                                        "value": "page_guard"
                                    }
                                ]
                            }
                        },
                        {
                            "key": "page_guard_persistent_memory",
                            "env": "GFXRECON_PAGE_GUARD_PERSISTENT_MEMORY",
                            "label": "Page Guard Persistent Memory",
                            "description": "When the `page_guard` memory tracking mode is enabled, this option changes the way that the shadow memory used to detect modifications to mapped memory is allocated. The default behavior is to allocate and copy the mapped memory range on map and free the allocation on unmap. When this option is enabled, an allocation with a size equal to that of the object being mapped is made once on the first map and is not freed until the object is destroyed. This option is intended to be used with applications that frequently map and unmap large memory ranges, to avoid frequent allocation and copy operations that can have a negative impact on performance. This option is ignored when `page_guard_external_memory` is enabled.",
                            "type": "BOOL",
                            "default": false,
                            "dependence": {
                                "mode": "ALL",
                                "settings": [
                                    {
                                        "key": "memory_tracking_mode",
                                        "value": "page_guard"
                                    },
                                    {
                                        "key": "page_guard_external_memory",
                                        "value": false
                                    }
                                ]
                            }
                        },
                        {
                            "key": "page_guard_separate_read",
                            "env": "GFXRECON_PAGE_GUARD_SEPARATE_READ",
                            "label": "Page Guard Separate Read Tracking",
                            "description": "When the `page_guard` memory tracking mode is enabled, copies the content of pages accessed for read from mapped memory to shadow memory on each read. Can overwrite unprocessed shadow memory content when an application is reading from and writing to the same page.",
                            "type": "BOOL",
                            "default": true,
                            "dependence": {
                                "mode": "ALL",
                                "settings": [
                                    {
                                        "key": "memory_tracking_mode",
                                        "value": "page_guard"
                                    }
                                ]
                            }
                        },
                        {
                            "key": "page_guard_signal_handler_watcher",
                            "env": "GFXRECON_PAGE_GUARD_SIGNAL_HANDLER_WATCHER",
                            "label": "Page Guard Signal Handler Watcher",
                            "description": "When the `page_guard` memory tracking mode is enabled, setting this to `true` will spawn a thread which will will periodically reinstall the `SIGSEGV` handler if it has been replaced by the application being traced.",
                            "type": "BOOL",
                            "default": false,
                            "dependence": {
                                "mode": "ALL",
                                "settings": [
                                    {
                                        "key": "memory_tracking_mode",
                                        "value": "page_guard"
                                    }
                                ]
                            }
                        },
                        {
                            "key": "page_guard_signal_handler_watcher_max_restores",
                            "env": "GFXRECON_PAGE_GUARD_SIGNAL_HANDLER_WATCHER_MAX_RESTORES",
                            "label": "Page Guard Signal Handler Watcher Max Restores",
                            "description": "Sets the number of times the watcher will attempt to restore the signal handler. Setting it to a negative will make the watcher thread run indefinitely.",
                            "type": "INT",
                            "default": 1,
                            "dependence": {
                                "mode": "ALL",
                                "settings": [
                                    {
                                        "key": "memory_tracking_mode",
                                        "value": "page_guard"
                                    }
                                ]
                            }
                        },
                        {
                            "key": "page_guard_track_ahb_memory",
                            "env": "GFXRECON_PAGE_GUARD_TRACK_AHB_MEMORY",
                            "label": "Page Guard Track AHB Memory",
                            "description": "[Android Only] When the `page_guard` memory tracking mode is enabled, eliminate the need for shadow memory allocations for Android Hardware Buffers.",
                            "platforms": [
                                "ANDROID"
                            ],
                            "type": "BOOL",
                            "default": false,
                            "dependence": {
                                "mode": "ALL",
                                "settings": [
                                    {
                                        "key": "memory_tracking_mode",
                                        "value": "page_guard"
                                    }
                                ]
                            }
                        },
                        {
                            "key": "page_guard_unblock_sigsegv",
                            "env": "GFXRECON_PAGE_GUARD_UNBLOCK_SIGSEGV",
                            "label": "Page Guard Unblock SIGSEGV",
                            "description": "When the `page_guard` memory tracking mode is enabled and in the case that SIGSEGV has been marked as blocked in thread's signal mask, setting this to `true` will forcibly re-enable the signal in the thread's signal mask.",
                            "type": "BOOL",
                            "default": false,
                            "dependence": {
                                "mode": "ALL",
                                "settings": [
                                    {
                                        "key": "memory_tracking_mode",
                                        "value": "page_guard"
                                    },
                                    {
                                        "key": "page_guard_external_memory",
                                        "value": false
                                    }
                                ]
                            }
                        }
                    ]
                },
                {
                    "key": "screenshot",
                    "label": "Screenshot",
                    "description": "Screenshot Control",
                    "type": "GROUP",
                    "settings": [
                        {
                            "key": "screenshot_dir",
                            "env": "GFXRECON_SCREENSHOT_DIR",
                            "label": "Screenshot Directory",
                            "description": "Directory used where screenshots are saved to.  Default is the current working directory.",
                            "type": "SAVE_FOLDER",
                            "default": ""
                        },
                        {
                            "key": "screenshot_format",
                            "env": "GFXRECON_SCREENSHOT_FORMAT",
                            "label": "Screenshot Format",
                            "description": "Image file format to use when saving screenshots.",
                            "type": "ENUM",
                            "flags": [
                                {
                                    "key": "BMP",
                                    "label": "BMP",
                                    "description": "Bitmap File Format."
                                },
                                {
                                    "key": "PNG",
                                    "label": "PNG",
                                    "description": "Portable Network Graphics Format."
                                }
                            ],
                            "default": "BMP"
                        },
                        {
                            "key": "screenshot_frames",
                            "env": "GFXRECON_SCREENSHOT_FRAMES",
                            "label": "Screenshot Specific Frames",
                            "description": "Specify one or more comma-separated frame ranges to screenshot. Each range will be written to its own file. A frame range can be specified as a single value, to specify a single frame to capture, or as two hyphenated values, to specify the first and last frame to capture. Frame ranges should be specified in ascending order and cannot overlap. Note that frame numbering is 1-based (i.e. the first frame is frame 1).",
                            "type": "STRING",
                            "default": ""
                        },
                        {
                            "key": "screenshot_interval",
                            "env": "GFXRECON_SCREENSHOT_INTERVAL",
                            "label": "Screenshot Interval",
                            "description": "Sets the number between every screenshot taken.  1 means every frame is screenshot, 2 means every other, etc. Example: If screenshot range is 10-15 and interval is 2, screenshot will be generated for frames 10, 12 and 14.",
                            "type": "INT",
                            "default": 1
                        }
                    ]
                }
            ]
        }
    }
}