# Using the GFXReconstruct Layer on Android Devices

## Before Use

### Permissions
The GFXReconstruct layer can optionally read a configuration file
from or write capture files to external storage.  This requires that
the application loading the layer have external storage permissions.

The read and write external storage permission may be requested in
the application's manifest file.  When installing the application,
it may be necessary to ensure that the requested permissions are
granted through one of the following actions:

When installing the application with `adb install`:
 * Specify the -g option: `adb install -g`

When deploying from Android Studio:
 * Click on "Run" in the menu
 * Choose "Edit Configurations..."
 * In the dialog box, look for the "Install Flags:" text box
 * Enter `-g`
 * Click "Apply"

It may also be possible to grant external storage permissions to
an installed application through the device Settings.

**Failure to enable the write external storage permission** can cause
the layer to return `VK_ERROR_INITIALIZATION_FAILED` from its
`vkCreateInstance` function if it fails to create a capture file.

### Disabling Debug Breaks Triggered by the GFXReconstruct Layer
The Vulkan API allows Vulkan memory objects to be mapped by an application
for direct modification. To successfully capture an application,
the GFXReconstruct layer must be able to detect when the application
modifies the mapped memory. The layer can be configured to detect memory
modifications by marking the mapped memory as write protected, triggering
an access violation when the application writes to the memory. The
layer then uses a signal handler to intercept the signal generated by the
access violation, where it removes the write protection, marks the modified
memory page as dirty, and allows the application to continue.

When running an application in a debugger with the layer enabled, the
access violations triggered by the layer's memory tracking behavior may
cause the debugger to break. These debug breaks may be disabled for LLDB with
the following command:
```
process handle SIGSEGV -n true -p true -s false
```

This command may be entered manually through the LLDB tab on Android Studio's
Debug panel.

It may also be set as a post attach command in the project configuration:
 * Click on "Run" in the menu
 * Choose "Edit Configurations..."
 * In the dialog box, select the "Debugger" tab
 * In the "Debugger" tab, select the "LLDB Post Attach Commands" tab
 * Click the `+` to add the command to the command list
 * Enter the `process handle SIGSEGV -n true -p true -s false` command
 * Click "Apply"

## Enabling the Layer with ADB
The layer can be enabled through a system property by executing the following
ADB command:

```
adb shell "setprop debug.vulkan.layers 'VK_LAYER_LUNARG_gfxreconstruct'"
```

The following command will disable the layer:

```
adb shell "setprop debug.vulkan.layers ''"
```

## Layer Options
The GFXReconstruct layer supports the following options, which may be enabled
with Android system properties.  Each property begins with the prefix `debug.gfxrecon`,
and can be set through ADB with the following command syntax:

```
adb shell "setprop <option> '<value>'"
```

For example, to set the log_level to "warning", specify:

```
adb shell "setprop debug.gfxrecon.log_level 'warning'"
```

### Supported Options
Options with the BOOL type accept the following values:
* A case-insensitive string value 'true' or a non-zero integer value indicate true.
* A case-insensitive string value 'false' or a zero integer value indicate false.

The capture layer will generate a warning message for unrecognized or invalid
option values.

Option | Property | Type | Description
------| ------------- |------|-------------
Capture File Name | debug.gfxrecon.capture_file | STRING | Path to use when creating the capture file.  Default is: `/sdcard/gfxrecon_capture.gfxr`
Capture Specific Frames | debug.gfxrecon.capture_frames | STRING | Specify one or more comma-separated frame ranges to capture.  Each range will be written to its own file.  A frame range can be specified as a single value, to specify a single frame to capture, or as two hyphenated values, to specify the first and last frame to capture.  Frame ranges should be specified in ascending order and cannot overlap.  Example: `200,301-305` will create two capture files, one containing a single frame and one containing five frames.  Default is: Empty string (all frames are captured).
Capture File Compression Type | debug.gfxrecon.capture_compression_type | STRING | Compression format to use with the capture file.  Valid values are: `LZ4`, `ZLIB`, and `NONE`. Default is: `LZ4`
Capture File Timestamp | debug.gfxrecon.capture_file_timestamp | BOOL | Add a timestamp to the capture file as described by [Timestamps](#timestamps).  Default is: `true`
Capture File Flush After Write | debug.gfxrecon.capture_file_flush | BOOL | Flush output stream after each packet is written to the capture file.  Default is: `false`
Log Level | debug.gfxrecon.log_level | STRING | Specify the highest level message to log.  Options are: `debug`, `info`, `warning`, `error`, and `fatal`.  The specified level and all levels listed after it will be enabled for logging.  For example, choosing the `warning` level will also enable the `error` and `fatal` levels. Default is: `info`
Log Output to Console | debug.gfxrecon.log_output_to_console | BOOL | Log messages will be written to Logcat. Default is: `true`
Log File | debug.gfxrecon.log_file | STRING | When set, log messages will be written to a file at the specified path. Default is: Empty string (file logging disabled).
Log Detailed | debug.gfxrecon.log_detailed | BOOL | Include name and line number from the file responsible for the log message. Default is: `false`
Log Allow Indents | debug.gfxrecon.log_allow_indents | BOOL | Apply additional indentation formatting to log messages. Default is: `false`
Log Break on Error | debug.gfxrecon.log_break_on_error | BOOL | Trigger a debug break when logging an error. Default is: `false`
Log File Create New | debug.gfxrecon.log_file_create_new | BOOL | Specifies that log file initialization should overwrite an existing file when true, or append to an existing file when false. Default is: `true`
Log File Flush After Write | debug.gfxrecon.log_file_flush_after_write | BOOL | Flush the log file to disk after each write when true. Default is: `false`
Log File Keep Open | debug.gfxrecon.log_file_keep_open | BOOL | Keep the log file open between log messages when true, or close and reopen the log file for each message when false. Default is: `true`
Memory Tracking Mode | debug.gfxrecon.memory_tracking_mode | STRING | Specifies the memory tracking mode to use for detecting modifications to mapped Vulkan memory objects. Available options are: `page_guard`, `assisted`, and `unassisted`. Default is `page_guard` <ul><li>`page_guard` tracks modifications to individual memory pages, which are written to the capture file on calls to `vkFlushMappedMemoryRanges`, `vkUnmapMemory`, and `vkQueueSubmit`. Tracking modifications requires allocating shadow memory for all mapped memory.</li><li>`assisted` expects the application to call `vkFlushMappedMemoryRanges` after memory is modified; the memory ranges specified to the `vkFlushMappedMemoryRanges` call will be written to the capture file during the call.</li><li>`unassisted` writes the full content of mapped memory to the capture file on calls to `vkUnmapMemory` and `vkQueueSubmit`. It is very inefficient and may be unusable with real world applications that map large amounts of memory.</li></ul>
Page Guard Copy on Map | debug.gfxrecon.page_guard_copy_on_map | BOOL | When the `page_guard` memory tracking mode is enabled, copies the content of the mapped memory to the shadow memory immediately after the memory is mapped. Default is: `true`
Page Guard Lazy Copy | debug.gfxrecon.page_guard_lazy_copy | BOOL | When the `page_guard` memory tracking mode is enabled, changes the copy on map behavior such that the copy is performed for individual memory pages on first access after map. Default is: `false`
Page Guard Separate Read Tracking | debug.gfxrecon.page_guard_separate_read | BOOL | When the `page_guard` memory tracking mode is enabled, copies the content of pages accessed for read from mapped memory to shadow memory on each read. Can overwrite unprocessed shadow memory content when an application is reading from and writing to the same page. Default is: `true`

## Capture Files
Capture files are created on the first call to `vkCreateInstance`, when the
Vulkan loader loads the capture layer, and are closed on `vkDestroyInstance`,
when the last active instance is destroyed and the layer is unloaded.

If multiple instances are active concurrently, only one capture file will be
created. If multiple instances are active consecutively (i.e. an instance is
created and destroyed before the next instance is created), the creation of
each instance will generate a new file. For applications that create multiple
instances consecutively, it will be necessary to enable capture file timestamps
to prevent each new instance from overwriting the file created by the previous
instance.

If the layer fails to open the capture file, it will make the call to
`vkCreateInstance` fail, returning `VK_ERROR_INITIALIZATION_FAILED`.

### Specifying Capture File Location
The capture file's save location can be specified by setting the
`debug.gfxrecon.capture_file` system property, described above in
the [Layer Options](#layer-options) section.

### Timestamps
When capture file timestamps are enabled, a timestamp with an
[ISO 8601-based](https://en.wikipedia.org/wiki/ISO_8601)
format will be added to the name of every file created by the layer. The
timestamp is generated when the capture file is created by the layer's
`vkCreateInstance` function and is added to the base filename specified
through the `debug.gfxrecon.capture_file` system property. Timestamps have
the form:
 ```
_yyyymmddThhmmss
```
where the lower-case letters stand for: Year, Month, Day, Hour, Minute, Second.
The `T` is a designator that separates the date and time components. Time is
reported for the local timezone and is specified with the 24-hour format.

The following example shows a timestamp that was added to a file that was
originally named `gfxrecon_capture.gfxr` and was created at 2:35 PM
on November 25, 2018:
  `gfxrecon_capture_20181125T143527.gfxr`
