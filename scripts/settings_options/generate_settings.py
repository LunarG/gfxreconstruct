#!/usr/bin/python3 -i
#
# Copyright (c) 2025 LunarG, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

import json
import os
import textwrap
from jsonschema import validate
from collections import OrderedDict

script_name = os.path.basename(__file__)

# Relevant files
###################################

# Settings input files
settings_input_json_filename: str = "settings.json"
schema_filename: str = "settings_schema.json"

# Generated/Modified files
layer_json_filename: str = "../../layer/json/VkLayer_gfxreconstruct.json.in"

# Commonly used strings
settings_env_var_prefix = "GFXRECON_"
settings_android_property_prefix = "debug.gfxrecon."
settings_file_layer_prefix = "lunarg_gfxreconstruct."

generated_source_copyright = f"""
/*
 * Copyright (c) 2025 LunarG, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 ***** WARNING **** This file is automatically generated by {script_name},
 ****************** do not edit directly!
 */
"""


# Convert a string of lower_snake_case to UpperCamelCase
# Parameters:
#   in_string : the string of snake_case_content to convert to UpperCameCase
# Returns:
#   upper_camel_case : the new UpperCamelCase string
def ConvertLowerSnakeToUpperCamelCase(in_string):
    individual_words = in_string.split('_')
    upper_camel_case = ''.join(word.title() for word in individual_words)
    return upper_camel_case


# Generate the appropriate default filename based on the platform
# Parameters:
#   prefix   : the prefix including the variable name to start the
#              string with
#   filename : the name of the filename
# Returns:
#   entry : a string containing the C-code  initialization for the
#           capture filename
def GenerateDefaultCaptureFileNameString(prefix: str, filename: str):
    entry = []
    entry.append("#if defined(__ANDROID__)")
    entry.append(f"{prefix} = std::string(\"/sdcard/{filename}\");")
    entry.append("#else")
    entry.append(f"{prefix} = std::string(\"{filename}\");")
    entry.append("#endif")
    return entry


# Verify that the JSON file at least corresponds to the schema.
# Parameters:
#   json_data : the data read from the JSON file for validation
# Returns:
#   None
def ValidateJsonFile(json_data: any):
    # Load the schema from a file
    with open(schema_filename, 'r') as schema_file:
        schema = json.load(schema_file)

    try:
        validate(instance=json_data, schema=schema)
        print(
            f"The {settings_input_json_filename} is valid according to the schema."
        )
    except Exception as e:
        print(f"Validation error of {settings_input_json_filename}: {e}")


# Utility function to return the appropriate read-able API string,
# not the ALL CAPS version
# Parameters:
#   api : the all-caps API string to return a more readable version for
# Returns:
#   the human-readable API string
def GetReadableApiString(api: str):
    if "D3D" in api:
        return api
    elif api == "OPENXR":
        return "OpenXR"
    else:
        return api.lower().capitalize()


# Generate the Api Family enum value from an API
# Parameters:
#   api : the all-caps API string to return a more readable version for
# Returns:
#   string containing the C-code for the correct api-family enum
def GetApiFamilyFromApiId(api):
    platform_api = GetReadableApiString(api)
    if platform_api == "OpenXR":
        # We need to lower-case the R here:
        platform_api = "OpenXr"
    return f"format::ApiFamily_{platform_api}"


# Generate the check to determine if a given value should be called in the
# C code based on the API Id.
# Parameters:
#   apis : the list of all APIs to check for
# Returns:
#   if_string : the resulting C code if string
#   indent    : string containing any indent required
def GenerateApiIfCheck(apis):
    if_string = ""
    indent = ""
    if len(apis) > 1 or "ALL" not in apis:
        if_string = indent + "if ("
        first_time = True
        for api in apis:
            if first_time:
                first_time = False
            else:
                if_string += " || "
            api_family = GetApiFamilyFromApiId(api)
            if_string += f"std::find(enable_apis.begin(), enable_apis.end(), {api_family}) != enable_apis.end()"
        if_string += ")"
        indent += "    "
    return if_string, indent


# Generate an ifdef based on the required list of platforms passed in.
# Parameters:
#   platforms : the list of all platforms to check for
# Returns:
#   begin_platform_ifdef : the resulting C code ifdef string
#   end_platform_ifdef   : the resulting C code endif string
def GeneratePlatformIfdef(platforms):
    begin_platform_ifdef = ""
    end_platform_ifdef = ""
    if "ALL" not in platforms and len(platforms) > 0:
        begin_platform_ifdef = "#if "
        end_platform_ifdef = "#endif // "

        wrote_value = False
        for platform in platforms:
            if wrote_value:
                begin_platform_ifdef += " || "
                end_platform_ifdef += " || "
            else:
                wrote_value = True

            if platform == "ANDROID":
                begin_platform_ifdef += "defined(__ANDROID__)"
                end_platform_ifdef += "defined(__ANDROID__)"
            elif platform == "WINDOWS":
                begin_platform_ifdef += "defined(WIN32)"
                end_platform_ifdef += "defined(WIN32)"
            elif platform == "LINUX":
                begin_platform_ifdef += "defined(__linux__)"
                end_platform_ifdef += "defined(__linux__)"
            elif platform == "MACOS":
                begin_platform_ifdef += "defined(__APPLE__)"
                end_platform_ifdef += "defined(__APPLE__)"
            else:
                begin_platform_ifdef += "ERROR_INVALID_PLATFORM_GENERATION"
                end_platform_ifdef += "ERROR_INVALID_PLATFORM_GENERATION"

    return begin_platform_ifdef, end_platform_ifdef


def PadStringToColumn(input_string: str, max_column_width: int):
    ret_string = input_string
    if len(ret_string) < max_column_width:
        spaces = max_column_width - len(ret_string)
        ret_string += " " * spaces
    return ret_string


class ParsedDependency():
    """ParsedDependency - Class used to read and store dependency info.

    Members:
        key         - Name of Enum
        value       - The value the key must be for this setting to be valid
    """

    def __init__(self, dependency_json):
        self.key: str = dependency_json["key"]
        if "value" in dependency_json:
            self.value: any = dependency_json["value"]
        else:
            self.value = None


class ParsedEnumFlag():
    """ParsedEnumFlag - Class used to read and store enum flag info.

    Members:
        key         - Name of Enum
        label       - Label for flag
        description - Description of the enum flag
    """

    def __init__(self, flag_json):
        self.key: str = flag_json["key"]
        self.label: str = flag_json["label"]
        self.description: str = flag_json["description"]


class ParsedSettingType():
    """ParsedSettingType - Class to store the type information for a setting read from the JSON file.

    Members:
        primitive_type  - Type of primitive for this setting
        default_value   - Default value for this setting
        android_base    - An additional base value associate with this type for Android.
                          Usually related to SAVE_FILES and SAVE_FOLDER.
    """

    def __init__(self, setting_type_json):
        self.primitive_type: str = setting_type_json["primitive"]

        if self.primitive_type != "GROUP":
            self.default: any = setting_type_json["default"]
        else:
            self.default = None

        if self.primitive_type == "ENUM":
            self.flags: list[ParsedEnumFlag] = []
            for json_flag in setting_type_json["flags"]:
                flag = ParsedEnumFlag(json_flag)
                self.flags.append(flag)
        else:
            self.flags = None

        self.android_base = None
        if self.primitive_type == "SAVE_FILE" or self.primitive_type == "SAVE_FOLDER":
            if "android-base" in setting_type_json:
                self.android_base = setting_type_json["android-base"]

        if self.primitive_type == "SAVE_FILE":
            self.filter = setting_type_json["filter"]
        else:
            self.filter = None


class ParsedSetting():
    """ParsedSetting - Class to store the settings we read from the JSON file.

    Members:
        key             - The name of the setting option
        label           - The text label displayed on any GUIs for this option
        description     - The description of the option
        deprecated      - [Optional] This feature is not valid in the long term
                          and may be removed at some point in the future.
        dynamic         - [Optional] This option can dynamically change over the
                          course of app execution.
        tools           - List of tools this setting is valid for (if not set,
                          it is valid for all)
        apis            - List of APIs this setting is valid for (if not set,
                          it is valid for all)
        platforms       - List of Platforms this setting is valid for (if not set,
                          it is valid for all)
        type            - Type of this setting and any default value
        parent          - Owning setting to this setting.  In addition, this child
                          may only be valid if the parent has a certain value.
        dependencies    - List of dependent settings that this setting also relies on
                          in addition to their parent.
        children        - List of children settings to this setting.
    """

    def __init__(self, setting_input_json):
        self.key: str = setting_input_json["key"]
        self.label: str = setting_input_json["label"]
        self.description: str = setting_input_json["description"]
        self.deprecated: bool = False
        self.dynamic: bool = False

        if "deprecated" in setting_input_json:
            self.deprecated = setting_input_json["deprecated"]

        if "dynamic" in setting_input_json:
            self.dynamic = setting_input_json["dynamic"]

        if "tools" in setting_input_json:
            self.tools: list[str] = []
            for tool in setting_input_json["tools"]:
                self.tools.append(tool)
        else:
            self.tools = None

        self.apis: list[str] = []
        if "apis" in setting_input_json:
            for api in setting_input_json["apis"]:
                self.apis.append(api)
        else:
            self.apis.append("ALL")

        self.platforms: list[str] = []
        if "platforms" in setting_input_json:
            for platform in setting_input_json["platforms"]:
                self.platforms.append(platform)
        else:
            self.platforms.append("ALL")

        self.type = ParsedSettingType(setting_input_json["type"])

        if "parent" in setting_input_json:
            self.parent = ParsedDependency(setting_input_json["parent"])
        else:
            self.parent = None

        self.dependencies: list[ParsedDependency] = []
        if "additional_dependencies" in setting_input_json:
            for dependency in setting_input_json["additional_dependencies"]:
                self.dependencies.append(ParsedDependency(dependency))

        self.children: list[ParsedSetting] = []

    # Generate the necessary json dic for a Vulkan setting dependency
    # Parameters:
    #   dep : A dependency for this key
    # Returns:
    #   dep_setting: a dictionary containing the dependency
    def GenerateDependencyVulkanSettingJsonDict(self, dep):
        dep_setting = dict()
        dep_setting["key"] = dep.key
        if dep.value is not None:
            dep_setting["value"] = dep.value
        return dep_setting

    # Generate a displayable string for the type.  This includes
    # filtering out any JSON data-field specific types like
    # SAVE_FOLDER and SAVE_FILE.  It also lists any enum values
    # or string filters.
    # Parameters:
    #   is_env_var : indicates that this is intended for use with
    #                an environment variable definition.
    # Returns:
    #   type_string : string containing the type description
    def GetTypeString(self, is_env_var: bool):
        type_string = self.type.primitive_type
        if (self.type.primitive_type == "ENUM"
                and self.type.flags is not None):
            type_string = "STRING with possible values of: \""
            flags = []
            for incoming_flag in self.type.flags:
                if is_env_var:
                    flag_str = incoming_flag.key
                else:
                    flag_str = incoming_flag.key.lower()
                flags.append(flag_str)
            type_string += '\", \"'.join(flags)
            type_string += '\"'
        elif (self.type.primitive_type == "SAVE_FILE"
              or self.type.primitive_type == "SAVE_FOLDER"):
            type_string = "STRING"
            if self.type.filter is not None:
                type_string += " (filter = " + self.type.filter + ")"

        return type_string

    # Generate the Vulkan Layer JSON dictionary for this setting
    # Parameters:
    #   is_child : indicates that the current setting is a child
    # Returns:
    #   setting_json_dict : None or a new dictionary containing the
    #                       contents of the setting
    def GenerateVulkanSettingJsonDict(self, is_child: bool = False):
        if ("ALL" in self.apis
                or "VULKAN" in self.apis) and (self.tools is None
                                               or "CAPTURE" in self.tools):
            setting_json_dict = dict()
            setting_json_dict["key"] = self.key
            if self.type.primitive_type != "GROUP":
                setting_json_dict[
                    "env"] = settings_env_var_prefix + self.key.upper()
            setting_json_dict["label"] = self.label
            setting_json_dict["description"] = self.description

            if "ALL" not in self.platforms:
                setting_json_dict["platforms"] = self.platforms

            setting_json_dict["type"] = self.type.primitive_type
            if (self.type.primitive_type == "ENUM"
                    and self.type.flags is not None):
                flags = []
                for incoming_flag in self.type.flags:
                    flag = dict()
                    flag["key"] = incoming_flag.key
                    flag["label"] = incoming_flag.label
                    flag["description"] = incoming_flag.description
                    flags.append(flag)
                setting_json_dict["flags"] = flags
            elif (self.type.primitive_type == "SAVE_FILE"
                  and self.type.filter is not None):
                setting_json_dict["filter"] = self.type.filter

            if self.type.default is not None:
                setting_json_dict["default"] = self.type.default

            if len(self.children) > 0:
                children_settings = []
                for child in self.children:
                    child_setting = child.GenerateVulkanSettingJsonDict(True)
                    if child_setting is not None:
                        children_settings.append(child_setting)

                if (len(children_settings) > 0):
                    setting_json_dict["settings"] = children_settings

            if (is_child and self.parent is not None
                    or len(self.dependencies) > 0):
                dependent_value = False
                deps = dict()
                deps["mode"] = "ALL"
                dep_settings = []
                if self.parent is not None:
                    if self.parent.value is not None:
                        gen_dep = self.GenerateDependencyVulkanSettingJsonDict(
                            self.parent)
                        if gen_dep is not None:
                            dependent_value = True
                            dep_settings.append(gen_dep)

                for dep in self.dependencies:
                    if dep.value is not None:
                        gen_dep = self.GenerateDependencyVulkanSettingJsonDict(
                            dep)
                        if gen_dep is not None:
                            dependent_value = True
                            dep_settings.append(gen_dep)

                if dependent_value:
                    deps["settings"] = dep_settings
                    setting_json_dict["dependence"] = deps

            return setting_json_dict
        return None


# Build up the list of children in each parent setting
# Parameters:
#   parsed_settings : The dictionary of all settings parsed from the JSON file.
# Returns:
#   None
def BuildChildrenLists(parsed_settings: OrderedDict[str, ParsedSetting]):
    for key, parsed_setting in parsed_settings.items():
        if parsed_setting.parent is not None:
            if parsed_settings[parsed_setting.parent.key] is not None:
                parsed_settings[parsed_setting.parent.key].children.append(
                    parsed_setting)


# Update the Vulkan layer manifest file settings values (which VkConfig uses)
# Parameters:
#   parsed_settings : The dictionary of all settings parsed from the JSON file.
# Returns:
#   None
def UpdateVulkanLayerManifestInputFile(parsed_settings):
    print(f"Updating (GFXReconstruct)/{layer_json_filename[6:]} file")

    # Generate the dictionary for each setting
    output_settings = []
    for key, parsed_setting in parsed_settings.items():
        if parsed_setting.parent is None:
            setting_dict = parsed_setting.GenerateVulkanSettingJsonDict()
            if setting_dict is not None:
                output_settings.append(setting_dict)

    # Write out to a temporary file.  This results in a prettier output
    # than trying to save it per line
    with open("temp_output.json", "w") as outfile:
        json.dump(output_settings, outfile, indent=4, sort_keys=False)
    outfile.close()

    # Now, read the current VkLayer_gfxreconstruct.json.in file and replace the old
    # settings information with the new settings
    padded_lines = []
    with open(layer_json_filename, 'r') as current_layer_json:
        record_lines = True
        while line := current_layer_json.readline():
            stripped_line = line.rstrip()
            if record_lines and stripped_line == '            "settings": [':
                record_lines = False

                # Read back in the temporary file output and pre-pend the appropriate
                # prefix info per line
                with open("temp_output.json", 'r') as tmp_file:
                    first_line = True
                    while settings_line := tmp_file.readline():
                        stripped_settings_line = settings_line.rstrip()
                        if first_line:
                            padded_lines.append(
                                f"            \"settings\": {stripped_settings_line}"
                            )
                            first_line = False
                        else:
                            padded_lines.append("            " +
                                                stripped_settings_line)

                tmp_file.close()

            if record_lines:
                padded_lines.append(stripped_line)
            else:
                if stripped_line == "            ]":
                    record_lines = True

    current_layer_json.close()

    # Write out to the new layer json content to VkLayer_gfxreconstruct.json.in
    with open(layer_json_filename, 'w') as current_layer_json:
        current_layer_json.write('\n'.join(padded_lines))

    os.remove("temp_output.json")


if __name__ == "__main__":

    # Load the JSON data from a file
    with open(settings_input_json_filename, 'r') as data_file:
        json_data = json.load(data_file)

    ValidateJsonFile(json_data)

    # Parse the setting information
    parsed_settings: OrderedDict[str, ParsedSetting] = OrderedDict()
    for setting in json_data["settings"]:
        parsed_setting = ParsedSetting(setting)
        parsed_settings[parsed_setting.key] = parsed_setting

    # Build the children lists
    BuildChildrenLists(parsed_settings)

    # Vulkan layer manifest file and layer settings generation
    UpdateVulkanLayerManifestInputFile(parsed_settings)
