#!/usr/bin/python3 -i
#
# Copyright (c) 2025 LunarG, Inc.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
# IN THE SOFTWARE.

import json
import os
import textwrap
from jsonschema import validate
from collections import OrderedDict

script_name = os.path.basename(__file__)

# Relevant files
###################################

# Settings input files
settings_input_json_filename: str = "settings.json"
schema_filename: str = "settings_schema.json"

# Generated/Modified files
layer_json_filename: str = "../../layer/json/VkLayer_gfxreconstruct.json.in"
layer_settings_filename: str = "../../layer/vk_layer_settings.txt"

# Documents
android_usage_doc_filename: str = "../../USAGE_android.md"
desktop_d3d12_usage_doc_filename: str = "../../USAGE_desktop_D3D12.md"
desktop_vulkan_usage_doc_filename: str = "../../USAGE_desktop_Vulkan.md"

# Commonly used strings
settings_env_var_prefix = "GFXRECON_"
settings_android_property_prefix = "debug.gfxrecon."
settings_file_layer_prefix = "lunarg_gfxreconstruct."

# Strings used to identify Markdown/HTML docs sections that need to be replaced
# during the codegen phanse
capture_gen_begin_str = "<!-- CAPTURE_SETTINGS_OPTIONS TABLE CODEGEN BEGIN -->"
capture_gen_end_str = "<!-- CAPTURE_SETTINGS_OPTIONS TABLE CODEGEN END -->"

generated_source_copyright = f"""
/*
 * Copyright (c) 2025 LunarG, Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 ***** WARNING **** This file is automatically generated by {script_name},
 ****************** do not edit directly!
 */
"""


# Convert a string of lower_snake_case to UpperCamelCase
# Parameters:
#   in_string : the string of snake_case_content to convert to UpperCameCase
# Returns:
#   upper_camel_case : the new UpperCamelCase string
def ConvertLowerSnakeToUpperCamelCase(in_string):
    individual_words = in_string.split('_')
    upper_camel_case = ''.join(word.title() for word in individual_words)
    return upper_camel_case


# Generate the appropriate default filename based on the platform
# Parameters:
#   prefix   : the prefix including the variable name to start the
#              string with
#   filename : the name of the filename
# Returns:
#   entry : a string containing the C-code  initialization for the
#           capture filename
def GenerateDefaultCaptureFileNameString(prefix: str, filename: str):
    entry = []
    entry.append("#if defined(__ANDROID__)")
    entry.append(f"{prefix} = std::string(\"/sdcard/{filename}\");")
    entry.append("#else")
    entry.append(f"{prefix} = std::string(\"{filename}\");")
    entry.append("#endif")
    return entry


# Verify that the JSON file at least corresponds to the schema.
# Parameters:
#   json_data : the data read from the JSON file for validation
# Returns:
#   None
def ValidateJsonFile(json_data: any):
    # Load the schema from a file
    with open(schema_filename, 'r') as schema_file:
        schema = json.load(schema_file)

    try:
        validate(instance=json_data, schema=schema)
        print(
            f"The {settings_input_json_filename} is valid according to the schema."
        )
    except Exception as e:
        print(f"Validation error of {settings_input_json_filename}: {e}")


# Utility function to return the appropriate read-able API string,
# not the ALL CAPS version
# Parameters:
#   api : the all-caps API string to return a more readable version for
# Returns:
#   the human-readable API string
def GetReadableApiString(api: str):
    if "D3D" in api:
        return api
    elif api == "OPENXR":
        return "OpenXR"
    else:
        return api.lower().capitalize()


# Generate the Api Family enum value from an API
# Parameters:
#   api : the all-caps API string to return a more readable version for
# Returns:
#   string containing the C-code for the correct api-family enum
def GetApiFamilyFromApiId(api):
    platform_api = GetReadableApiString(api)
    if platform_api == "OpenXR":
        # We need to lower-case the R here:
        platform_api = "OpenXr"
    return f"format::ApiFamily_{platform_api}"


# Generate the check to determine if a given value should be called in the
# C code based on the API Id.
# Parameters:
#   apis : the list of all APIs to check for
# Returns:
#   if_string : the resulting C code if string
#   indent    : string containing any indent required
def GenerateApiIfCheck(apis):
    if_string = ""
    indent = ""
    if len(apis) > 1 or "ALL" not in apis:
        if_string = indent + "if ("
        first_time = True
        for api in apis:
            if first_time:
                first_time = False
            else:
                if_string += " || "
            api_family = GetApiFamilyFromApiId(api)
            if_string += f"std::find(enable_apis.begin(), enable_apis.end(), {api_family}) != enable_apis.end()"
        if_string += ")"
        indent += "    "
    return if_string, indent


# Generate an ifdef based on the required list of platforms passed in.
# Parameters:
#   platforms : the list of all platforms to check for
# Returns:
#   begin_platform_ifdef : the resulting C code ifdef string
#   end_platform_ifdef   : the resulting C code endif string
def GeneratePlatformIfdef(platforms):
    begin_platform_ifdef = ""
    end_platform_ifdef = ""
    if "ALL" not in platforms and len(platforms) > 0:
        begin_platform_ifdef = "#if "
        end_platform_ifdef = "#endif // "

        wrote_value = False
        for platform in platforms:
            if wrote_value:
                begin_platform_ifdef += " || "
                end_platform_ifdef += " || "
            else:
                wrote_value = True

            if platform == "ANDROID":
                begin_platform_ifdef += "defined(__ANDROID__)"
                end_platform_ifdef += "defined(__ANDROID__)"
            elif platform == "WINDOWS":
                begin_platform_ifdef += "defined(WIN32)"
                end_platform_ifdef += "defined(WIN32)"
            elif platform == "LINUX":
                begin_platform_ifdef += "defined(__linux__)"
                end_platform_ifdef += "defined(__linux__)"
            elif platform == "MACOS":
                begin_platform_ifdef += "defined(__APPLE__)"
                end_platform_ifdef += "defined(__APPLE__)"
            else:
                begin_platform_ifdef += "ERROR_INVALID_PLATFORM_GENERATION"
                end_platform_ifdef += "ERROR_INVALID_PLATFORM_GENERATION"

    return begin_platform_ifdef, end_platform_ifdef


def PadStringToColumn(input_string: str, max_column_width: int):
    ret_string = input_string
    if len(ret_string) < max_column_width:
        spaces = max_column_width - len(ret_string)
        ret_string += " " * spaces
    return ret_string


class ParsedDependency():
    """ParsedDependency - Class used to read and store dependency info.

    Members:
        key         - Name of Enum
        value       - The value the key must be for this setting to be valid
    """

    def __init__(self, dependency_json):
        self.key: str = dependency_json["key"]
        if "value" in dependency_json:
            self.value: any = dependency_json["value"]
        else:
            self.value = None


class ParsedEnumFlag():
    """ParsedEnumFlag - Class used to read and store enum flag info.

    Members:
        key         - Name of Enum
        label       - Label for flag
        description - Description of the enum flag
    """

    def __init__(self, flag_json):
        self.key: str = flag_json["key"]
        self.label: str = flag_json["label"]
        self.description: str = flag_json["description"]


class ParsedSettingType():
    """ParsedSettingType - Class to store the type information for a setting read from the JSON file.

    Members:
        primitive_type  - Type of primitive for this setting
        default_value   - Default value for this setting
        android_base    - An additional base value associate with this type for Android.
                          Usually related to SAVE_FILES and SAVE_FOLDER.
    """

    def __init__(self, setting_type_json):
        self.primitive_type: str = setting_type_json["primitive"]

        if self.primitive_type != "GROUP":
            self.default: any = setting_type_json["default"]
        else:
            self.default = None

        if self.primitive_type == "ENUM":
            self.flags: list[ParsedEnumFlag] = []
            for json_flag in setting_type_json["flags"]:
                flag = ParsedEnumFlag(json_flag)
                self.flags.append(flag)
        else:
            self.flags = None

        self.android_base = None
        if self.primitive_type == "SAVE_FILE" or self.primitive_type == "SAVE_FOLDER":
            if "android-base" in setting_type_json:
                self.android_base = setting_type_json["android-base"]

        if self.primitive_type == "SAVE_FILE":
            self.filter = setting_type_json["filter"]
        else:
            self.filter = None


class ParsedSetting():
    """ParsedSetting - Class to store the settings we read from the JSON file.

    Members:
        key             - The name of the setting option
        label           - The text label displayed on any GUIs for this option
        description     - The description of the option
        deprecated      - [Optional] This feature is not valid in the long term
                          and may be removed at some point in the future.
        dynamic         - [Optional] This option can dynamically change over the
                          course of app execution.
        tools           - List of tools this setting is valid for (if not set,
                          it is valid for all)
        apis            - List of APIs this setting is valid for (if not set,
                          it is valid for all)
        platforms       - List of Platforms this setting is valid for (if not set,
                          it is valid for all)
        type            - Type of this setting and any default value
        parent          - Owning setting to this setting.  In addition, this child
                          may only be valid if the parent has a certain value.
        dependencies    - List of dependent settings that this setting also relies on
                          in addition to their parent.
        children        - List of children settings to this setting.
    """

    def __init__(self, setting_input_json):
        self.key: str = setting_input_json["key"]
        self.label: str = setting_input_json["label"]
        self.description: str = setting_input_json["description"]
        self.deprecated: bool = False
        self.dynamic: bool = False

        if "deprecated" in setting_input_json:
            self.deprecated = setting_input_json["deprecated"]

        if "dynamic" in setting_input_json:
            self.dynamic = setting_input_json["dynamic"]

        if "tools" in setting_input_json:
            self.tools: list[str] = []
            for tool in setting_input_json["tools"]:
                self.tools.append(tool)
        else:
            self.tools = None

        self.apis: list[str] = []
        if "apis" in setting_input_json:
            for api in setting_input_json["apis"]:
                self.apis.append(api)
        else:
            self.apis.append("ALL")

        self.platforms: list[str] = []
        if "platforms" in setting_input_json:
            for platform in setting_input_json["platforms"]:
                self.platforms.append(platform)
        else:
            self.platforms.append("ALL")

        self.type = ParsedSettingType(setting_input_json["type"])

        if "parent" in setting_input_json:
            self.parent = ParsedDependency(setting_input_json["parent"])
        else:
            self.parent = None

        self.dependencies: list[ParsedDependency] = []
        if "additional_dependencies" in setting_input_json:
            for dependency in setting_input_json["additional_dependencies"]:
                self.dependencies.append(ParsedDependency(dependency))

        self.children: list[ParsedSetting] = []

    # Generate the necessary json dic for a Vulkan setting dependency
    # Parameters:
    #   dep : A dependency for this key
    # Returns:
    #   dep_setting: a dictionary containing the dependency
    def GenerateDependencyVulkanSettingJsonDict(self, dep):
        dep_setting = dict()
        dep_setting["key"] = dep.key
        if dep.value is not None:
            dep_setting["value"] = dep.value
        return dep_setting

    # Generate a displayable string for the type.  This includes
    # filtering out any JSON data-field specific types like
    # SAVE_FOLDER and SAVE_FILE.  It also lists any enum values
    # or string filters.
    # Parameters:
    #   is_env_var : indicates that this is intended for use with
    #                an environment variable definition.
    # Returns:
    #   type_string : string containing the type description
    def GetTypeString(self, is_env_var: bool):
        type_string = self.type.primitive_type
        if (self.type.primitive_type == "ENUM"
                and self.type.flags is not None):
            type_string = "STRING with possible values of: \""
            flags = []
            for incoming_flag in self.type.flags:
                if is_env_var:
                    flag_str = incoming_flag.key
                else:
                    flag_str = incoming_flag.key.lower()
                flags.append(flag_str)
            type_string += '\", \"'.join(flags)
            type_string += '\"'
        elif (self.type.primitive_type == "SAVE_FILE"
              or self.type.primitive_type == "SAVE_FOLDER"):
            type_string = "STRING"
            if self.type.filter is not None:
                type_string += " (filter = " + self.type.filter + ")"

        return type_string

    # Generate the Vulkan Layer JSON dictionary for this setting
    # Parameters:
    #   is_child : indicates that the current setting is a child
    # Returns:
    #   setting_json_dict : None or a new dictionary containing the
    #                       contents of the setting
    def GenerateVulkanSettingJsonDict(self, is_child: bool = False):
        if ("ALL" in self.apis
                or "VULKAN" in self.apis) and (self.tools is None
                                               or "CAPTURE" in self.tools):
            setting_json_dict = dict()
            setting_json_dict["key"] = self.key
            if self.type.primitive_type != "GROUP":
                setting_json_dict[
                    "env"] = settings_env_var_prefix + self.key.upper()
            setting_json_dict["label"] = self.label
            setting_json_dict["description"] = self.description

            if "ALL" not in self.platforms:
                setting_json_dict["platforms"] = self.platforms

            setting_json_dict["type"] = self.type.primitive_type
            if (self.type.primitive_type == "ENUM"
                    and self.type.flags is not None):
                flags = []
                for incoming_flag in self.type.flags:
                    flag = dict()
                    flag["key"] = incoming_flag.key
                    flag["label"] = incoming_flag.label
                    flag["description"] = incoming_flag.description
                    flags.append(flag)
                setting_json_dict["flags"] = flags
            elif (self.type.primitive_type == "SAVE_FILE"
                  and self.type.filter is not None):
                setting_json_dict["filter"] = self.type.filter

            if self.type.default is not None:
                setting_json_dict["default"] = self.type.default

            if len(self.children) > 0:
                children_settings = []
                for child in self.children:
                    child_setting = child.GenerateVulkanSettingJsonDict(True)
                    if child_setting is not None:
                        children_settings.append(child_setting)

                if (len(children_settings) > 0):
                    setting_json_dict["settings"] = children_settings

            if (is_child and self.parent is not None
                    or len(self.dependencies) > 0):
                dependent_value = False
                deps = dict()
                deps["mode"] = "ALL"
                dep_settings = []
                if self.parent is not None:
                    if self.parent.value is not None:
                        gen_dep = self.GenerateDependencyVulkanSettingJsonDict(
                            self.parent)
                        if gen_dep is not None:
                            dependent_value = True
                            dep_settings.append(gen_dep)

                for dep in self.dependencies:
                    if dep.value is not None:
                        gen_dep = self.GenerateDependencyVulkanSettingJsonDict(
                            dep)
                        if gen_dep is not None:
                            dependent_value = True
                            dep_settings.append(gen_dep)

                if dependent_value:
                    deps["settings"] = dep_settings
                    setting_json_dict["dependence"] = deps

            return setting_json_dict
        return None

    # Generate a clear readable string for the default label and value.
    # This is used for usage and table information for a type
    # Parameters:
    #   None
    # Returns:
    #   default_label : string containing the label for the default setting
    #   default_value : string containing what the default value should be
    def GetDefaultLabelAndValue(self, lower_case_values: bool = False):
        default_label = "<Undefined>"
        default_value = ""
        if self.type.default is not None:
            default_value = f"{self.type.default}"
            # Convert Python bool to C++ bool
            if self.type.primitive_type == "BOOL":
                if self.type.default == True:
                    default_value = "true"
                else:
                    default_value = "false"

            # If list, remove the brackets
            if self.type.primitive_type == "LIST":
                default_value = default_value.replace('[', '').replace(']', '')

            if default_value == "":
                default_label = "<empty>"
            else:
                default_label = default_value

            if lower_case_values:
                default_label = default_label.lower()

        return default_label, default_value

    # Generate the layer settings file text for this setting
    # Parameters:
    #   None
    # Returns:
    #   settings_layer_file_text : string containing the initial
    #                              Vulkan layer settings file
    #                              contents for this setting
    #                              including setting it to a
    #                              default value
    def GenerateVulkanLayerFileText(self):
        settings_layer_file_text = []
        if (("ALL" in self.apis or "VULKAN" in self.apis)
                and (self.tools is None or "CAPTURE" in self.tools)
                and (self.type.primitive_type != "GROUP")):
            settings_layer_file_text.append("")
            settings_layer_file_text.append(f"# {self.label}")
            settings_layer_file_text.append(
                "# ===================================")
            settings_layer_file_text.append(f"# <LayerIdentifier>.{self.key}")

            # Write out the description but no more than 80 characters per line
            wrapped_lines = textwrap.wrap(self.description, width=78)
            for wrapped_line in wrapped_lines:
                settings_layer_file_text.append(f"# {wrapped_line}")

            default_label, default_value = self.GetDefaultLabelAndValue()
            settings_layer_file_text.append(f"# Default is {default_label}")
            settings_layer_file_text.append(
                f"{settings_file_layer_prefix}{self.key} = {default_value}")
        return settings_layer_file_text

    # Generate the usage for this setting if it is used by the capture library.
    # This is used for tables in the Markdown documentation
    # Parameters:
    #   None
    # Returns:
    #   markdown_setting_table_entry : List of strings necessary to
    #                                  write the setting information to
    #                                  a capture usage markdown table.
    def GenerateAndroidCaptureUsageSettingsEntry(self):
        markdown_setting_table_entry = []
        if ((self.tools is None or "CAPTURE" in self.tools)
                and (self.type.primitive_type != "GROUP")
                and ("ALL" in self.platforms or "ANDROID" in self.platforms)):

            table_string = f"| {self.label} | {settings_android_property_prefix}{self.key} | {self.type.primitive_type} | "
            default_label, default_value = self.GetDefaultLabelAndValue(True)
            table_string += default_label + " | " + self.description + " |"

            markdown_setting_table_entry.append(table_string)
        return markdown_setting_table_entry

    # If the string has HTML tags in it, fix it so that it doesn't mess up the Markdown
    # output
    # Parameters:
    #   input_string : String to replace any HTML tags in
    # Returns:
    #   new_string2 : the "fixed" string
    def FixHtmlTagsInString(self, input_string: str):
        new_string = input_string.replace("<", "\<")
        new_string2 = new_string.replace(">", "\>")
        return new_string2

    # Generate a full detailed description used for a usage output.
    # The output can be written to the command-line for a standard tool
    # usage, or to a Markdown/HTML document.
    # Parameters:
    #  max_column_width : the widest to let any string get before starting a new line
    #  continue_indent  : the indent applied when starting a new line
    #  is_html_out      : indicates the output is being used by a Markdown/HTML file
    # Returns:
    #  usage_info : List of strings containing the full usage description
    def GenerateFullUsageDescription(self,
                                     max_column_width: int,
                                     continue_indent: str = " ",
                                     is_html_out: bool = False):
        usage_info = []
        continue_len = len(continue_indent)
        desc_words = self.description.split(' ')
        output_desc = ""
        for word in desc_words:
            if len(output_desc + word + " ") < max_column_width:
                if len(output_desc) > 0:
                    output_desc += " "
                output_desc += word
            else:
                usage_info.append(output_desc)
                output_desc = word

        if len(output_desc) > 0:
            usage_info.append(output_desc)

        # If this is an enum, list each parameter in the usage and it's description
        if self.type.primitive_type == "ENUM":
            usage_info.append("May be the following:")

            flag_indent = "   "
            flag_dev_cont_indent = continue_indent
            if is_html_out:
                usage_info.append("<ul>")
            for flag in self.type.flags:
                output_desc = flag_indent
                if is_html_out:
                    output_desc += "<li>"

                if len(flag.key) > 0:
                    output_desc += flag.key.lower() + " "
                else:
                    output_desc += "\"\" "

                if len(flag.description) > 0:
                    if len(output_desc) < continue_len:
                        if not is_html_out:
                            output_desc += (continue_len - len(output_desc) -
                                            1) * " "

                    if is_html_out:
                        output_desc += " - "

                    desc_words = flag.description.split(' ')
                    for word in desc_words:
                        if len(output_desc + word + " ") < max_column_width:
                            if len(output_desc) > 4:
                                output_desc += " "
                            output_desc += word
                        else:
                            usage_info.append(output_desc)
                            output_desc = flag_dev_cont_indent + word

                if len(output_desc) > continue_len:
                    usage_info.append(output_desc)

                if is_html_out:
                    usage_info.append("</li>")

            if is_html_out:
                usage_info.append("</ul>")

        return usage_info

    # Generate the capture library usage information into a Markdown format
    # for the appropriate api (specified in the "api" parameter)
    # Parameters:
    #   api : API desired to filter by
    # Returns:
    #   markdown_setting_table_entry : List of strings necessary to
    #                                  write the setting information to
    #                                  a capture usage markdown table.
    def GenerateDesktopCaptureUsageSettingsEntry(self, api: str):
        markdown_setting_table_entry = []
        if ((self.tools is None or "CAPTURE" in self.tools)
                and (self.type.primitive_type != "GROUP")
                and ("ALL" in self.apis or api in self.apis) and
            ("ALL" in self.platforms or "MACOS" in self.platforms
             or "LINUX" in self.platforms or "WINDOWS" in self.platforms)
                and ("ALL" in self.apis or api in self.apis)):

            type_string = self.GetTypeString(True)
            table_string = f"| {self.label} | {settings_env_var_prefix}{self.key.upper()} | {type_string} | "
            default_label, default_value = self.GetDefaultLabelAndValue()
            full_description = ' '.join(
                self.GenerateFullUsageDescription(30, " ", True))
            table_string += default_label + " | " + full_description + " |"

            markdown_setting_table_entry.append(table_string)
        return markdown_setting_table_entry


# Build up the list of children in each parent setting
# Parameters:
#   parsed_settings : The dictionary of all settings parsed from the JSON file.
# Returns:
#   None
def BuildChildrenLists(parsed_settings: OrderedDict[str, ParsedSetting]):
    for key, parsed_setting in parsed_settings.items():
        if parsed_setting.parent is not None:
            if parsed_settings[parsed_setting.parent.key] is not None:
                parsed_settings[parsed_setting.parent.key].children.append(
                    parsed_setting)


# Update the Vulkan layer manifest file settings values (which VkConfig uses)
# Parameters:
#   parsed_settings : The dictionary of all settings parsed from the JSON file.
# Returns:
#   None
def UpdateVulkanLayerManifestInputFile(parsed_settings):
    print(f"Updating (GFXReconstruct)/{layer_json_filename[6:]} file")

    # Generate the dictionary for each setting
    output_settings = []
    for key, parsed_setting in parsed_settings.items():
        if parsed_setting.parent is None:
            setting_dict = parsed_setting.GenerateVulkanSettingJsonDict()
            if setting_dict is not None:
                output_settings.append(setting_dict)

    # Write out to a temporary file.  This results in a prettier output
    # than trying to save it per line
    with open("temp_output.json", "w") as outfile:
        json.dump(output_settings, outfile, indent=4, sort_keys=False)
    outfile.close()

    # Now, read the current VkLayer_gfxreconstruct.json.in file and replace the old
    # settings information with the new settings
    padded_lines = []
    with open(layer_json_filename, 'r') as current_layer_json:
        record_lines = True
        while line := current_layer_json.readline():
            stripped_line = line.rstrip()
            if record_lines and stripped_line == '            "settings": [':
                record_lines = False

                # Read back in the temporary file output and pre-pend the appropriate
                # prefix info per line
                with open("temp_output.json", 'r') as tmp_file:
                    first_line = True
                    while settings_line := tmp_file.readline():
                        stripped_settings_line = settings_line.rstrip()
                        if first_line:
                            padded_lines.append(
                                f"            \"settings\": {stripped_settings_line}"
                            )
                            first_line = False
                        else:
                            padded_lines.append("            " +
                                                stripped_settings_line)

                tmp_file.close()

            if record_lines:
                padded_lines.append(stripped_line)
            else:
                if stripped_line == "            ]":
                    record_lines = True

    current_layer_json.close()

    # Write out to the new layer json content to VkLayer_gfxreconstruct.json.in
    with open(layer_json_filename, 'w') as current_layer_json:
        current_layer_json.write('\n'.join(padded_lines))

    os.remove("temp_output.json")


# Generate the Vulkan layer settings file with the current settings.
# It looks at the current layer settings file and replaces the content
# between the two identifying comments.
# Parameters:
#   parsed_settings : The dictionary of all settings parsed from the JSON file.
# Returns:
#   None
def GenerateVulkanLayerSettingsFile(parsed_settings):
    print(f"Generating (GFXReconstruct)/{layer_settings_filename[6:]} file")

    settings_file_contents = []
    settings_file_contents.append(
        "# The settings in this file can be used to configure the behavior of")
    settings_file_contents.append("# layers in this repository.")
    settings_file_contents.append("#")
    settings_file_contents.append(
        "####################################################################")
    settings_file_contents.append(
        "# !WARNING! - This file is automatically generated from the")
    settings_file_contents.append(
        f"###########   (GFXReconstruct)/settings_options/{script_name}")
    settings_file_contents.append(
        "########### - script and any changes should be made there.")
    settings_file_contents.append(
        "####################################################################")
    settings_file_contents.append("#")
    settings_file_contents.append("# VK_LAYER_LUNARG_gfxreconstruct")
    settings_file_contents.append("#")

    for key, parsed_setting in parsed_settings.items():
        settings_file_contents.extend(
            parsed_setting.GenerateVulkanLayerFileText())

    with open(layer_settings_filename, 'w') as current_layer_json:
        current_layer_json.write('\n'.join(settings_file_contents))


# Update a USAGE_android.md options/settings table for the
# capture library with the latest settings info.
#   parsed_settings : The dictionary of all settings parsed from the
#                     JSON file.
def UpdateAndroidUsageSettingsTable(parsed_settings):
    print(f"Updating (GFXReconstruct)/USAGE_android.md")

    capture_markdown_table_lines = []

    capture_markdown_table_lines.append(capture_gen_begin_str)
    capture_markdown_table_lines.append(
        "| Setting/Options | Property | Type | Default | Description |")
    capture_markdown_table_lines.append(
        "| ------- | -------- | ---- | ------- | ----------- |")

    for key, parsed_setting in parsed_settings.items():
        capture_markdown_table_lines.extend(
            parsed_setting.GenerateAndroidCaptureUsageSettingsEntry())

    capture_markdown_table_lines.append(capture_gen_end_str)

    # Now, read the current capture settings source file and replace the old
    # settings information with the new settings
    markdown_lines = []
    with open(android_usage_doc_filename, 'r') as markdown_doc:
        record_lines = True
        while line := markdown_doc.readline():
            stripped_line = line.rstrip()
            if record_lines and stripped_line == capture_gen_begin_str:
                record_lines = False

            if record_lines:
                markdown_lines.append(stripped_line)
            else:
                if stripped_line == capture_gen_end_str:
                    markdown_lines.extend(capture_markdown_table_lines)
                    record_lines = True

    markdown_doc.close()

    with open(android_usage_doc_filename, 'w') as markdown_doc:
        markdown_doc.write('\n'.join(markdown_lines))


# Update a desktop USAGE.md options/settings tables for the
# capture library with the latest settings info.
#   parsed_settings : The dictionary of all settings parsed from the
#                     JSON file.
#   api             : The current API who's info we need to output
def UpdateDesktopUsageSettingsTable(parsed_settings, api: str):
    source_file = desktop_d3d12_usage_doc_filename
    if api == "VULKAN":
        source_file = desktop_vulkan_usage_doc_filename

    print(f"Updating (GFXReconstruct)/{source_file[6:]}")

    capture_markdown_table_lines = []

    capture_markdown_table_lines.append(capture_gen_begin_str)
    capture_markdown_table_lines.append(
        "| Setting/Options | Environment Variable | Type | Default | Description |"
    )
    capture_markdown_table_lines.append(
        "| ------- | -------- | ---- | ------- | ----------- |")

    for key, parsed_setting in parsed_settings.items():
        capture_markdown_table_lines.extend(
            parsed_setting.GenerateDesktopCaptureUsageSettingsEntry(api))

    capture_markdown_table_lines.append(capture_gen_end_str)

    # Now, read the current capture settings source file and replace the old
    # settings information with the new settings
    markdown_lines = []
    with open(source_file, 'r') as markdown_doc:
        record_lines = True
        while line := markdown_doc.readline():
            stripped_line = line.rstrip()
            if record_lines and stripped_line == capture_gen_begin_str:
                record_lines = False

            if record_lines:
                markdown_lines.append(stripped_line)
            else:
                if stripped_line == capture_gen_end_str:
                    markdown_lines.extend(capture_markdown_table_lines)
                    record_lines = True

    markdown_doc.close()

    with open(source_file, 'w') as markdown_doc:
        markdown_doc.write('\n'.join(markdown_lines))


if __name__ == "__main__":

    # Load the JSON data from a file
    with open(settings_input_json_filename, 'r') as data_file:
        json_data = json.load(data_file)

    ValidateJsonFile(json_data)

    # Parse the setting information
    parsed_settings: OrderedDict[str, ParsedSetting] = OrderedDict()
    for setting in json_data["settings"]:
        parsed_setting = ParsedSetting(setting)
        parsed_settings[parsed_setting.key] = parsed_setting

    # Build the children lists
    BuildChildrenLists(parsed_settings)

    # Vulkan layer manifest file and layer settings generation
    UpdateVulkanLayerManifestInputFile(parsed_settings)
    GenerateVulkanLayerSettingsFile(parsed_settings)

    # Update documentation
    UpdateAndroidUsageSettingsTable(parsed_settings)
    UpdateDesktopUsageSettingsTable(parsed_settings, "D3D12")
    UpdateDesktopUsageSettingsTable(parsed_settings, "VULKAN")
